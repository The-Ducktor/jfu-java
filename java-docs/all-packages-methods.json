{
  "packages": [
    {
      "package": "java.lang",
      "description": "Core Java language classes",
      "classes": [
        {
          "name": "AbstractMethodError",
          "methods": [
            {
              "name": "AbstractMethodError",
              "overloads": [
                {
                  "signature": "public AbstractMethodError()",
                  "description": "Constructs an AbstractMethodError with no detail  message."
                },
                {
                  "signature": "public AbstractMethodError(String s)",
                  "description": "Constructs an AbstractMethodError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Appendable",
          "methods": [
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "Appendable append(CharSequence csq) throws IOException",
                  "description": "Appends the specified character sequence to this Appendable.\n\n  Depending on which class implements the character sequence\n csq, the entire sequence may not be appended.  For\n instance, if csq is a CharBuffer then\n the subsequence to append is defined by the buffer's position and limit."
                },
                {
                  "signature": "Appendable append(CharSequence csq, int start, int end) throws IOException",
                  "description": "Appends a subsequence of the specified character sequence to this\n Appendable.\n\n  An invocation of this method of the form out.append(csq, start, end)\n when csq is not null, behaves in\n exactly the same way as the invocation\n\n      out.append(csq.subSequence(start, end))"
                },
                {
                  "signature": "Appendable append(char c) throws IOException",
                  "description": "Appends the specified character to this Appendable."
                }
              ]
            }
          ]
        },
        {
          "name": "ArithmeticException",
          "methods": [
            {
              "name": "ArithmeticException",
              "overloads": [
                {
                  "signature": "public ArithmeticException()",
                  "description": "Constructs an ArithmeticException with no detail\n message."
                },
                {
                  "signature": "public ArithmeticException(String s)",
                  "description": "Constructs an ArithmeticException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayIndexOutOfBoundsException",
          "methods": [
            {
              "name": "ArrayIndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public ArrayIndexOutOfBoundsException()",
                  "description": "Constructs an ArrayIndexOutOfBoundsException with no detail\n message."
                },
                {
                  "signature": "public ArrayIndexOutOfBoundsException(String s)",
                  "description": "Constructs an ArrayIndexOutOfBoundsException class with the\n specified detail message."
                },
                {
                  "signature": "public ArrayIndexOutOfBoundsException(int index)",
                  "description": "Constructs a new ArrayIndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayStoreException",
          "methods": [
            {
              "name": "ArrayStoreException",
              "overloads": [
                {
                  "signature": "public ArrayStoreException()",
                  "description": "Constructs an ArrayStoreException with no detail message."
                },
                {
                  "signature": "public ArrayStoreException(String s)",
                  "description": "Constructs an ArrayStoreException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "AssertionError",
          "methods": [
            {
              "name": "AssertionError",
              "overloads": [
                {
                  "signature": "public AssertionError()",
                  "description": "Constructs an AssertionError with no detail message."
                },
                {
                  "signature": "public AssertionError(Object detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified object, which is converted to a string as\n defined in section 5.1.11 of\n The Java Language Specification.\n\n If the specified object is an instance of Throwable, it\n becomes the cause of the newly constructed assertion error."
                },
                {
                  "signature": "public AssertionError(boolean detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified boolean, which is converted to\n a string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(char detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified char, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(int detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified int, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(long detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified long, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(float detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified float, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(double detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified double, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(String message, Throwable cause)",
                  "description": "Constructs a new AssertionError with the specified\n detail message and cause.\n\n Note that the detail message associated with\n cause is not automatically incorporated in\n this error's detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "AutoCloseable",
          "methods": [
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws Exception",
                  "description": "Closes this resource, relinquishing any underlying resources.\n This method is invoked automatically on objects managed by the\n try-with-resources statement."
                }
              ]
            }
          ]
        },
        {
          "name": "Boolean",
          "methods": [
            {
              "name": "Boolean",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Boolean(boolean value)",
                  "description": "Allocates a Boolean object representing the\n value argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Boolean(String s)",
                  "description": "Allocates a Boolean object representing the value\n true if the string argument is not null\n and is equal, ignoring case, to the string \"true\".\n Otherwise, allocates a Boolean object representing the\n value false.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "parseBoolean",
              "overloads": [
                {
                  "signature": "public static boolean parseBoolean(String s)",
                  "description": "Parses the string argument as a boolean.  The boolean\n returned represents the value true if the string argument\n is not null and is equal, ignoring case, to the string\n \"true\".\n Otherwise, a false value is returned, including for a null\n argument.\n Example: Boolean.parseBoolean(\"True\") returns true.\n Example: Boolean.parseBoolean(\"yes\") returns false."
                }
              ]
            },
            {
              "name": "booleanValue",
              "overloads": [
                {
                  "signature": "public boolean booleanValue()",
                  "description": "Returns the value of this Boolean object as a boolean\n primitive."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Boolean valueOf(boolean b)",
                  "description": "Returns a Boolean instance representing the specified\n boolean value.  If the specified boolean value\n is true, this method returns Boolean.TRUE;\n if it is false, this method returns Boolean.FALSE.\n If a new Boolean instance is not required, this method\n should generally be used in preference to the constructor\n Boolean(boolean), as this method is likely to yield\n significantly better space and time performance."
                },
                {
                  "signature": "public static Boolean valueOf(String s)",
                  "description": "Returns a Boolean with a value represented by the\n specified string.  The Boolean returned represents a\n true value if the string argument is not null\n and is equal, ignoring case, to the string \"true\".\n Otherwise, a false value is returned, including for a null\n argument."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(boolean b)",
                  "description": "Returns a String object representing the specified\n boolean.  If the specified boolean is true, then\n the string \"true\" will be returned, otherwise the\n string \"false\" will be returned."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this Boolean's\n value.  If this object represents the value true,\n a string equal to \"true\" is returned. Otherwise, a\n string equal to \"false\" is returned."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Boolean object."
                },
                {
                  "signature": "public static int hashCode(boolean value)",
                  "description": "Returns a hash code for a boolean value; compatible with\n Boolean.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if and only if the argument is not\n null and is a Boolean object that\n represents the same boolean value as this object."
                }
              ]
            },
            {
              "name": "getBoolean",
              "overloads": [
                {
                  "signature": "public static boolean getBoolean(String name)",
                  "description": "Returns true if and only if the system property named\n by the argument exists and is equal to, ignoring case, the\n string \"true\".\n A system property is accessible through getProperty, a\n method defined by the System class.   If there is no\n property with the specified name, or if the specified name is\n empty or null, then false is returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Boolean b)",
                  "description": "Compares this Boolean instance with another."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(boolean x, boolean y)",
                  "description": "Compares two boolean values.\n The value returned is identical to what would be returned by:\n     Boolean.valueOf(x).compareTo(Boolean.valueOf(y))"
                }
              ]
            },
            {
              "name": "logicalAnd",
              "overloads": [
                {
                  "signature": "public static boolean logicalAnd(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical AND operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "logicalOr",
              "overloads": [
                {
                  "signature": "public static boolean logicalOr(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical OR operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "logicalXor",
              "overloads": [
                {
                  "signature": "public static boolean logicalXor(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical XOR operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Boolean>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            }
          ]
        },
        {
          "name": "BootstrapMethodError",
          "methods": [
            {
              "name": "BootstrapMethodError",
              "overloads": [
                {
                  "signature": "public BootstrapMethodError()",
                  "description": "Constructs a BootstrapMethodError with no detail message."
                },
                {
                  "signature": "public BootstrapMethodError(String s)",
                  "description": "Constructs a BootstrapMethodError with the specified\n detail message."
                },
                {
                  "signature": "public BootstrapMethodError(String s, Throwable cause)",
                  "description": "Constructs a BootstrapMethodError with the specified\n detail message and cause."
                },
                {
                  "signature": "public BootstrapMethodError(Throwable cause)",
                  "description": "Constructs a BootstrapMethodError with the specified\n cause."
                }
              ]
            }
          ]
        },
        {
          "name": "Byte",
          "methods": [
            {
              "name": "Byte",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Byte(byte value)",
                  "description": "Constructs a newly allocated Byte object that\n represents the specified byte value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Byte(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Byte object that\n represents the byte value indicated by the\n String parameter. The string is converted to a\n byte value in exactly the manner used by the\n parseByte method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(byte b)",
                  "description": "Returns a new String object representing the\n specified byte. The radix is assumed to be 10."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Byte's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the byte value were given as an argument to the\n toString(byte) method."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Byte>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Byte valueOf(byte b)",
                  "description": "Returns a Byte instance representing the specified\n byte value.\n If a new Byte instance is not required, this method\n should generally be used in preference to the constructor\n Byte(byte), as this method is likely to yield\n significantly better space and time performance since\n all byte values are cached."
                },
                {
                  "signature": "public static Byte valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Byte object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed byte in\n the radix specified by the second argument, exactly as if the\n argument were given to the parseByte(java.lang.String, int) method. The result is a Byte object that\n represents the byte value specified by the string.\n\n  In other words, this method returns a Byte object\n equal to the value of:\n\n \n new Byte(Byte.parseByte(s, radix))"
                },
                {
                  "signature": "public static Byte valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Byte object holding the value\n given by the specified String. The argument is\n interpreted as representing a signed decimal byte,\n exactly as if the argument were given to the parseByte(java.lang.String) method. The result is a\n Byte object that represents the byte\n value specified by the string.\n\n  In other words, this method returns a Byte object\n equal to the value of:\n\n \n new Byte(Byte.parseByte(s))"
                }
              ]
            },
            {
              "name": "parseByte",
              "overloads": [
                {
                  "signature": "public static byte parseByte(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed byte in the\n radix specified by the second argument. The characters in the\n string must all be digits, of the specified radix (as\n determined by whether Character.digit(char, int) returns a nonnegative value) except that the first\n character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value.  The resulting byte value is\n returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n  The first argument is null or is a string of\n length zero.\n\n  The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n  Any character of the string is not a digit of the\n specified radix, except that the first character may be a minus\n sign '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n  The value represented by the string is not a value of type\n byte."
                },
                {
                  "signature": "public static byte parseByte(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal \n byte. The characters in the string must all be decimal digits,\n except that the first character may be an ASCII minus sign\n '-' ('\\u002D') to indicate a negative\n value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting byte value is returned, exactly as if the\n argument and the radix 10 were given as arguments to the parseByte(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Byte decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Byte.\n Accepts decimal, hexadecimal, and octal numbers given by\n the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Byte.parseByte method with the indicated radix (10, 16, or 8).\n This sequence of characters must represent a positive value or\n a NumberFormatException will be thrown.  The result is\n negated if first character of the specified String is\n the minus sign.  No whitespace characters are permitted in the\n String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Byte as a\n byte."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Byte as a short after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Byte as an int after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Byte as a long after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Byte as a float after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Byte as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Byte; equal to the result\n of invoking intValue()."
                },
                {
                  "signature": "public static int hashCode(byte value)",
                  "description": "Returns a hash code for a byte value; compatible with\n Byte.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Byte object that\n contains the same byte value as this object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Byte anotherByte)",
                  "description": "Compares two Byte objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(byte x, byte y)",
                  "description": "Compares two byte values numerically.\n The value returned is identical to what would be returned by:\n     Byte.valueOf(x).compareTo(Byte.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(byte x, byte y)",
                  "description": "Compares two byte values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "toUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int toUnsignedInt(byte x)",
                  "description": "Converts the argument to an int by an unsigned\n conversion.  In an unsigned conversion to an int, the\n high-order 24 bits of the int are zero and the\n low-order 8 bits are equal to the bits of the byte argument.\n\n Consequently, zero and positive byte values are mapped\n to a numerically equal int value and negative \n byte values are mapped to an int value equal to the\n input plus 28."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(byte x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 56 bits of the long are zero and the\n low-order 8 bits are equal to the bits of the byte argument.\n\n Consequently, zero and positive byte values are mapped\n to a numerically equal long value and negative \n byte values are mapped to a long value equal to the\n input plus 28."
                }
              ]
            }
          ]
        },
        {
          "name": "Character",
          "methods": [
            {
              "name": "Character",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Character(char value)",
                  "description": "Constructs a newly allocated Character object that\n represents the specified char value.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Character>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Character valueOf(char c)",
                  "description": "Returns a Character instance representing the specified\n char value.\n If a new Character instance is not required, this method\n should generally be used in preference to the constructor\n Character(char), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range \n '\\u0000' to '\\u007F', inclusive, and may\n cache other values outside of this range."
                }
              ]
            },
            {
              "name": "charValue",
              "overloads": [
                {
                  "signature": "public char charValue()",
                  "description": "Returns the value of this Character object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Character; equal to the result\n of invoking charValue()."
                },
                {
                  "signature": "public static int hashCode(char value)",
                  "description": "Returns a hash code for a char value; compatible with\n Character.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is not\n null and is a Character object that\n represents the same char value as this object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Character's value.  The result is a string of\n length 1 whose sole component is the primitive\n char value represented by this\n Character object."
                },
                {
                  "signature": "public static String toString(char c)",
                  "description": "Returns a String object representing the\n specified char.  The result is a string of length\n 1 consisting solely of the specified char."
                },
                {
                  "signature": "public static String toString(int codePoint)",
                  "description": "Returns a String object representing the\n specified character (Unicode code point).  The result is a string of\n length 1 or 2, consisting solely of the specified codePoint."
                }
              ]
            },
            {
              "name": "isValidCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isValidCodePoint(int codePoint)",
                  "description": "Determines whether the specified code point is a valid\n \n Unicode code point value."
                }
              ]
            },
            {
              "name": "isBmpCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isBmpCodePoint(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is in the Basic Multilingual Plane (BMP).\n Such code points can be represented using a single char."
                }
              ]
            },
            {
              "name": "isSupplementaryCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isSupplementaryCodePoint(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is in the supplementary character range."
                }
              ]
            },
            {
              "name": "isHighSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isHighSurrogate(char ch)",
                  "description": "Determines if the given char value is a\n \n Unicode high-surrogate code unit\n (also known as leading-surrogate code unit).\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding."
                }
              ]
            },
            {
              "name": "isLowSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isLowSurrogate(char ch)",
                  "description": "Determines if the given char value is a\n \n Unicode low-surrogate code unit\n (also known as trailing-surrogate code unit).\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding."
                }
              ]
            },
            {
              "name": "isSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isSurrogate(char ch)",
                  "description": "Determines if the given char value is a Unicode\n surrogate code unit.\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding.\n\n A char value is a surrogate code unit if and only if it is either\n a low-surrogate code unit or\n a high-surrogate code unit."
                }
              ]
            },
            {
              "name": "isSurrogatePair",
              "overloads": [
                {
                  "signature": "public static boolean isSurrogatePair(char high, char low)",
                  "description": "Determines whether the specified pair of char\n values is a valid\n \n Unicode surrogate pair.\n\n This method is equivalent to the expression:\n \n isHighSurrogate(high) && isLowSurrogate(low)"
                }
              ]
            },
            {
              "name": "charCount",
              "overloads": [
                {
                  "signature": "public static int charCount(int codePoint)",
                  "description": "Determines the number of char values needed to\n represent the specified character (Unicode code point). If the\n specified character is equal to or greater than 0x10000, then\n the method returns 2. Otherwise, the method returns 1.\n\n This method doesn't validate the specified character to be a\n valid Unicode code point. The caller must validate the\n character value using isValidCodePoint\n if necessary."
                }
              ]
            },
            {
              "name": "toCodePoint",
              "overloads": [
                {
                  "signature": "public static int toCodePoint(char high, char low)",
                  "description": "Converts the specified surrogate pair to its supplementary code\n point value. This method does not validate the specified\n surrogate pair. The caller must validate it using isSurrogatePair if necessary."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public static int codePointAt(CharSequence seq, int index)",
                  "description": "Returns the code point at the given index of the\n CharSequence. If the char value at\n the given index in the CharSequence is in the\n high-surrogate range, the following index is less than the\n length of the CharSequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                },
                {
                  "signature": "public static int codePointAt(char[] a, int index)",
                  "description": "Returns the code point at the given index of the\n char array. If the char value at\n the given index in the char array is in the\n high-surrogate range, the following index is less than the\n length of the char array, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                },
                {
                  "signature": "public static int codePointAt(char[] a, int index, int limit)",
                  "description": "Returns the code point at the given index of the\n char array, where only array elements with\n index less than limit can be used. If\n the char value at the given index in the\n char array is in the high-surrogate range, the\n following index is less than the limit, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public static int codePointBefore(CharSequence seq, int index)",
                  "description": "Returns the code point preceding the given index of the\n CharSequence. If the char value at\n (index - 1) in the CharSequence is in\n the low-surrogate range, (index - 2) is not\n negative, and the char value at (index - 2)\n in the CharSequence is in the\n high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                },
                {
                  "signature": "public static int codePointBefore(char[] a, int index)",
                  "description": "Returns the code point preceding the given index of the\n char array. If the char value at\n (index - 1) in the char array is in\n the low-surrogate range, (index - 2) is not\n negative, and the char value at (index - 2)\n in the char array is in the\n high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                },
                {
                  "signature": "public static int codePointBefore(char[] a, int index, int start)",
                  "description": "Returns the code point preceding the given index of the\n char array, where only array elements with\n index greater than or equal to start\n can be used. If the char value at (index - 1)\n in the char array is in the\n low-surrogate range, (index - 2) is not less than\n start, and the char value at\n (index - 2) in the char array is in\n the high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                }
              ]
            },
            {
              "name": "highSurrogate",
              "overloads": [
                {
                  "signature": "public static char highSurrogate(int codePoint)",
                  "description": "Returns the leading surrogate (a\n \n high surrogate code unit) of the\n \n surrogate pair\n representing the specified supplementary character (Unicode\n code point) in the UTF-16 encoding.  If the specified character\n is not a\n supplementary character,\n an unspecified char is returned.\n\n If\n isSupplementaryCodePoint(x)\n is true, then\n isHighSurrogate(highSurrogate(x)) and\n toCodePoint(highSurrogate(x), lowSurrogate(x)) == x\n are also always true."
                }
              ]
            },
            {
              "name": "lowSurrogate",
              "overloads": [
                {
                  "signature": "public static char lowSurrogate(int codePoint)",
                  "description": "Returns the trailing surrogate (a\n \n low surrogate code unit) of the\n \n surrogate pair\n representing the specified supplementary character (Unicode\n code point) in the UTF-16 encoding.  If the specified character\n is not a\n supplementary character,\n an unspecified char is returned.\n\n If\n isSupplementaryCodePoint(x)\n is true, then\n isLowSurrogate(lowSurrogate(x)) and\n toCodePoint(highSurrogate(x), lowSurrogate(x)) == x\n are also always true."
                }
              ]
            },
            {
              "name": "toChars",
              "overloads": [
                {
                  "signature": "public static int toChars(int codePoint, char[] dst, int dstIndex)",
                  "description": "Converts the specified character (Unicode code point) to its\n UTF-16 representation. If the specified code point is a BMP\n (Basic Multilingual Plane or Plane 0) value, the same value is\n stored in dst[dstIndex], and 1 is returned. If the\n specified code point is a supplementary character, its\n surrogate values are stored in dst[dstIndex]\n (high-surrogate) and dst[dstIndex+1]\n (low-surrogate), and 2 is returned."
                },
                {
                  "signature": "public static char[] toChars(int codePoint)",
                  "description": "Converts the specified character (Unicode code point) to its\n UTF-16 representation stored in a char array. If\n the specified code point is a BMP (Basic Multilingual Plane or\n Plane 0) value, the resulting char array has\n the same value as codePoint. If the specified code\n point is a supplementary code point, the resulting\n char array has the corresponding surrogate pair."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the text range of\n the specified char sequence. The text range begins at the\n specified beginIndex and extends to the\n char at index endIndex - 1. Thus the\n length (in chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n the text range count as one code point each."
                },
                {
                  "signature": "public static int codePointCount(char[] a, int offset, int count)",
                  "description": "Returns the number of Unicode code points in a subarray of the\n char array argument. The offset\n argument is the index of the first char of the\n subarray and the count argument specifies the\n length of the subarray in chars. Unpaired\n surrogates within the subarray count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)",
                  "description": "Returns the index within the given char sequence that is offset\n from the given index by codePointOffset\n code points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                },
                {
                  "signature": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)",
                  "description": "Returns the index within the given char subarray\n that is offset from the given index by\n codePointOffset code points. The\n start and count arguments specify a\n subarray of the char array. Unpaired surrogates\n within the text range given by index and\n codePointOffset count as one code point each."
                }
              ]
            },
            {
              "name": "isLowerCase",
              "overloads": [
                {
                  "signature": "public static boolean isLowerCase(char ch)",
                  "description": "Determines if the specified character is a lowercase character.\n \n A character is lowercase if its general category type, provided\n by Character.getType(ch), is\n LOWERCASE_LETTER, or it has contributory property\n Other_Lowercase as defined by the Unicode Standard.\n \n The following are examples of lowercase characters:\n  a b c d e f g h i j k l m n o p q r s t u v w x y z\n '\\u00DF' '\\u00E0' '\\u00E1' '\\u00E2' '\\u00E3' '\\u00E4' '\\u00E5' '\\u00E6'\n '\\u00E7' '\\u00E8' '\\u00E9' '\\u00EA' '\\u00EB' '\\u00EC' '\\u00ED' '\\u00EE'\n '\\u00EF' '\\u00F0' '\\u00F1' '\\u00F2' '\\u00F3' '\\u00F4' '\\u00F5' '\\u00F6'\n '\\u00F8' '\\u00F9' '\\u00FA' '\\u00FB' '\\u00FC' '\\u00FD' '\\u00FE' '\\u00FF'\n \n  Many other Unicode characters are lowercase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLowerCase(int) method."
                },
                {
                  "signature": "public static boolean isLowerCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a\n lowercase character.\n \n A character is lowercase if its general category type, provided\n by getType(codePoint), is\n LOWERCASE_LETTER, or it has contributory property\n Other_Lowercase as defined by the Unicode Standard.\n \n The following are examples of lowercase characters:\n  a b c d e f g h i j k l m n o p q r s t u v w x y z\n '\\u00DF' '\\u00E0' '\\u00E1' '\\u00E2' '\\u00E3' '\\u00E4' '\\u00E5' '\\u00E6'\n '\\u00E7' '\\u00E8' '\\u00E9' '\\u00EA' '\\u00EB' '\\u00EC' '\\u00ED' '\\u00EE'\n '\\u00EF' '\\u00F0' '\\u00F1' '\\u00F2' '\\u00F3' '\\u00F4' '\\u00F5' '\\u00F6'\n '\\u00F8' '\\u00F9' '\\u00FA' '\\u00FB' '\\u00FC' '\\u00FD' '\\u00FE' '\\u00FF'\n \n  Many other Unicode characters are lowercase too."
                }
              ]
            },
            {
              "name": "isUpperCase",
              "overloads": [
                {
                  "signature": "public static boolean isUpperCase(char ch)",
                  "description": "Determines if the specified character is an uppercase character.\n \n A character is uppercase if its general category type, provided by\n Character.getType(ch), is UPPERCASE_LETTER.\n or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n \n The following are examples of uppercase characters:\n  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n '\\u00C0' '\\u00C1' '\\u00C2' '\\u00C3' '\\u00C4' '\\u00C5' '\\u00C6' '\\u00C7'\n '\\u00C8' '\\u00C9' '\\u00CA' '\\u00CB' '\\u00CC' '\\u00CD' '\\u00CE' '\\u00CF'\n '\\u00D0' '\\u00D1' '\\u00D2' '\\u00D3' '\\u00D4' '\\u00D5' '\\u00D6' '\\u00D8'\n '\\u00D9' '\\u00DA' '\\u00DB' '\\u00DC' '\\u00DD' '\\u00DE'\n \n  Many other Unicode characters are uppercase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUpperCase(int) method."
                },
                {
                  "signature": "public static boolean isUpperCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is an uppercase character.\n \n A character is uppercase if its general category type, provided by\n getType(codePoint), is UPPERCASE_LETTER,\n or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n \n The following are examples of uppercase characters:\n  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n '\\u00C0' '\\u00C1' '\\u00C2' '\\u00C3' '\\u00C4' '\\u00C5' '\\u00C6' '\\u00C7'\n '\\u00C8' '\\u00C9' '\\u00CA' '\\u00CB' '\\u00CC' '\\u00CD' '\\u00CE' '\\u00CF'\n '\\u00D0' '\\u00D1' '\\u00D2' '\\u00D3' '\\u00D4' '\\u00D5' '\\u00D6' '\\u00D8'\n '\\u00D9' '\\u00DA' '\\u00DB' '\\u00DC' '\\u00DD' '\\u00DE'\n \n  Many other Unicode characters are uppercase too."
                }
              ]
            },
            {
              "name": "isTitleCase",
              "overloads": [
                {
                  "signature": "public static boolean isTitleCase(char ch)",
                  "description": "Determines if the specified character is a titlecase character.\n \n A character is a titlecase character if its general\n category type, provided by Character.getType(ch),\n is TITLECASE_LETTER.\n \n Some characters look like pairs of Latin letters. For example, there\n is an uppercase letter that looks like \"LJ\" and has a corresponding\n lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\n is the appropriate form to use when rendering a word in lowercase\n with initial capitals, as for a book title.\n \n These are some of the Unicode characters for which this method returns\n true:\n \n LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON\n LATIN CAPITAL LETTER L WITH SMALL LETTER J\n LATIN CAPITAL LETTER N WITH SMALL LETTER J\n LATIN CAPITAL LETTER D WITH SMALL LETTER Z\n \n  Many other Unicode characters are titlecase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isTitleCase(int) method."
                },
                {
                  "signature": "public static boolean isTitleCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a titlecase character.\n \n A character is a titlecase character if its general\n category type, provided by getType(codePoint),\n is TITLECASE_LETTER.\n \n Some characters look like pairs of Latin letters. For example, there\n is an uppercase letter that looks like \"LJ\" and has a corresponding\n lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\n is the appropriate form to use when rendering a word in lowercase\n with initial capitals, as for a book title.\n \n These are some of the Unicode characters for which this method returns\n true:\n \n LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON\n LATIN CAPITAL LETTER L WITH SMALL LETTER J\n LATIN CAPITAL LETTER N WITH SMALL LETTER J\n LATIN CAPITAL LETTER D WITH SMALL LETTER Z\n \n  Many other Unicode characters are titlecase too."
                }
              ]
            },
            {
              "name": "isDigit",
              "overloads": [
                {
                  "signature": "public static boolean isDigit(char ch)",
                  "description": "Determines if the specified character is a digit.\n \n A character is a digit if its general category type, provided\n by Character.getType(ch), is\n DECIMAL_DIGIT_NUMBER.\n \n Some Unicode character ranges that contain digits:\n \n '\\u0030' through '\\u0039',\n     ISO-LATIN-1 digits ('0' through '9')\n '\\u0660' through '\\u0669',\n     Arabic-Indic digits\n '\\u06F0' through '\\u06F9',\n     Extended Arabic-Indic digits\n '\\u0966' through '\\u096F',\n     Devanagari digits\n '\\uFF10' through '\\uFF19',\n     Fullwidth digits\n \n\n Many other character ranges contain digits as well.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isDigit(int) method."
                },
                {
                  "signature": "public static boolean isDigit(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a digit.\n \n A character is a digit if its general category type, provided\n by getType(codePoint), is\n DECIMAL_DIGIT_NUMBER.\n \n Some Unicode character ranges that contain digits:\n \n '\\u0030' through '\\u0039',\n     ISO-LATIN-1 digits ('0' through '9')\n '\\u0660' through '\\u0669',\n     Arabic-Indic digits\n '\\u06F0' through '\\u06F9',\n     Extended Arabic-Indic digits\n '\\u0966' through '\\u096F',\n     Devanagari digits\n '\\uFF10' through '\\uFF19',\n     Fullwidth digits\n \n\n Many other character ranges contain digits as well."
                }
              ]
            },
            {
              "name": "isDefined",
              "overloads": [
                {
                  "signature": "public static boolean isDefined(char ch)",
                  "description": "Determines if a character is defined in Unicode.\n \n A character is defined if at least one of the following is true:\n \n It has an entry in the UnicodeData file.\n It has a value in a range defined by the UnicodeData file.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isDefined(int) method."
                },
                {
                  "signature": "public static boolean isDefined(int codePoint)",
                  "description": "Determines if a character (Unicode code point) is defined in Unicode.\n \n A character is defined if at least one of the following is true:\n \n It has an entry in the UnicodeData file.\n It has a value in a range defined by the UnicodeData file."
                }
              ]
            },
            {
              "name": "isLetter",
              "overloads": [
                {
                  "signature": "public static boolean isLetter(char ch)",
                  "description": "Determines if the specified character is a letter.\n \n A character is considered to be a letter if its general\n category type, provided by Character.getType(ch),\n is any of the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n \n\n Not all letters have case. Many characters are\n letters but are neither uppercase nor lowercase nor titlecase.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLetter(int) method."
                },
                {
                  "signature": "public static boolean isLetter(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a letter.\n \n A character is considered to be a letter if its general\n category type, provided by getType(codePoint),\n is any of the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n \n\n Not all letters have case. Many characters are\n letters but are neither uppercase nor lowercase nor titlecase."
                }
              ]
            },
            {
              "name": "isLetterOrDigit",
              "overloads": [
                {
                  "signature": "public static boolean isLetterOrDigit(char ch)",
                  "description": "Determines if the specified character is a letter or digit.\n \n A character is considered to be a letter or digit if either\n Character.isLetter(char ch) or\n Character.isDigit(char ch) returns\n true for the character.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLetterOrDigit(int) method."
                },
                {
                  "signature": "public static boolean isLetterOrDigit(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a letter or digit.\n \n A character is considered to be a letter or digit if either\n isLetter(codePoint) or\n isDigit(codePoint) returns\n true for the character."
                }
              ]
            },
            {
              "name": "isJavaLetter",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isJavaLetter(char ch)",
                  "description": "Determines if the specified character is permissible as the first\n character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns LETTER_NUMBER\n  ch is a currency symbol (such as '$')\n  ch is a connecting punctuation character (such as '_').",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isJavaLetterOrDigit",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isJavaLetterOrDigit(char ch)",
                  "description": "Determines if the specified character may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if and only if one\n of the following conditions is true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for the character.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isAlphabetic",
              "overloads": [
                {
                  "signature": "public static boolean isAlphabetic(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is alphabetic.\n \n A character is considered to be alphabetic if its general category type,\n provided by getType(codePoint), is any of\n the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n  LETTER_NUMBER\n \n or it has contributory property Other_Alphabetic as defined by the\n Unicode Standard."
                }
              ]
            },
            {
              "name": "isIdeographic",
              "overloads": [
                {
                  "signature": "public static boolean isIdeographic(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a CJKV\n (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by\n the Unicode Standard."
                }
              ]
            },
            {
              "name": "isJavaIdentifierStart",
              "overloads": [
                {
                  "signature": "public static boolean isJavaIdentifierStart(char ch)",
                  "description": "Determines if the specified character is\n permissible as the first character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns LETTER_NUMBER\n  ch is a currency symbol (such as '$')\n  ch is a connecting punctuation character (such as '_').\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isJavaIdentifierStart(int) method."
                },
                {
                  "signature": "public static boolean isJavaIdentifierStart(int codePoint)",
                  "description": "Determines if the character (Unicode code point) is\n permissible as the first character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(codePoint)\n      returns true\n  getType(codePoint)\n      returns LETTER_NUMBER\n  the referenced character is a currency symbol (such as '$')\n  the referenced character is a connecting punctuation character\n      (such as '_')."
                }
              ]
            },
            {
              "name": "isJavaIdentifierPart",
              "overloads": [
                {
                  "signature": "public static boolean isJavaIdentifierPart(char ch)",
                  "description": "Determines if the specified character may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if any of the following\n conditions are true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for the character\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isJavaIdentifierPart(int) method."
                },
                {
                  "signature": "public static boolean isJavaIdentifierPart(int codePoint)",
                  "description": "Determines if the character (Unicode code point) may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if any of the following\n conditions are true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable(codePoint) returns true for\n the code point"
                }
              ]
            },
            {
              "name": "isUnicodeIdentifierStart",
              "overloads": [
                {
                  "signature": "public static boolean isUnicodeIdentifierStart(char ch)",
                  "description": "Determines if the specified character is permissible as the\n first character in a Unicode identifier.\n \n A character may start a Unicode identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns\n      LETTER_NUMBER.\n  it is an \n      Other_ID_Start character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Start := ID_Start + 'VERTICAL TILDE' (U+2E2F)\n \n 'VERTICAL TILDE' is added to Start for backward\n compatibility.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUnicodeIdentifierStart(int) method."
                },
                {
                  "signature": "public static boolean isUnicodeIdentifierStart(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is permissible as the\n first character in a Unicode identifier.\n \n A character may start a Unicode identifier if and only if\n one of the following conditions is true:\n \n  isLetter(codePoint)\n      returns true\n  getType(codePoint)\n      returns LETTER_NUMBER.\n  it is an \n      Other_ID_Start character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Start := ID_Start + 'VERTICAL TILDE' (U+2E2F)\n \n 'VERTICAL TILDE' is added to Start for backward\n compatibility."
                }
              ]
            },
            {
              "name": "isUnicodeIdentifierPart",
              "overloads": [
                {
                  "signature": "public static boolean isUnicodeIdentifierPart(char ch)",
                  "description": "Determines if the specified character may be part of a Unicode\n identifier as other than the first character.\n \n A character may be part of a Unicode identifier if and only if\n one of the following statements is true:\n \n   it is a letter\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for this character.\n  it is an \n      Other_ID_Start character.\n  it is an \n      Other_ID_Continue character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Continue := Start + ID_Continue + ignorable\n Medial := empty\n ignorable := isIdentifierIgnorable(char) returns true for the character\n \n ignorable is added to Continue for backward\n compatibility.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUnicodeIdentifierPart(int) method."
                },
                {
                  "signature": "public static boolean isUnicodeIdentifierPart(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) may be part of a Unicode\n identifier as other than the first character.\n \n A character may be part of a Unicode identifier if and only if\n one of the following statements is true:\n \n   it is a letter\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for this character.\n  it is an \n      Other_ID_Start character.\n  it is an \n      Other_ID_Continue character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Continue := Start + ID_Continue + ignorable\n Medial := empty\n ignorable := isIdentifierIgnorable(int) returns true for the character\n \n ignorable is added to Continue for backward\n compatibility."
                }
              ]
            },
            {
              "name": "isIdentifierIgnorable",
              "overloads": [
                {
                  "signature": "public static boolean isIdentifierIgnorable(char ch)",
                  "description": "Determines if the specified character should be regarded as\n an ignorable character in a Java identifier or a Unicode identifier.\n \n The following Unicode characters are ignorable in a Java identifier\n or a Unicode identifier:\n \n ISO control characters that are not whitespace\n \n '\\u0000' through '\\u0008'\n '\\u000E' through '\\u001B'\n '\\u007F' through '\\u009F'\n \n\n all characters that have the FORMAT general\n category value\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isIdentifierIgnorable(int) method."
                },
                {
                  "signature": "public static boolean isIdentifierIgnorable(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) should be regarded as\n an ignorable character in a Java identifier or a Unicode identifier.\n \n The following Unicode characters are ignorable in a Java identifier\n or a Unicode identifier:\n \n ISO control characters that are not whitespace\n \n '\\u0000' through '\\u0008'\n '\\u000E' through '\\u001B'\n '\\u007F' through '\\u009F'\n \n\n all characters that have the FORMAT general\n category value"
                }
              ]
            },
            {
              "name": "toLowerCase",
              "overloads": [
                {
                  "signature": "public static char toLowerCase(char ch)",
                  "description": "Converts the character argument to lowercase using case\n mapping information from the UnicodeData file.\n \n Note that\n Character.isLowerCase(Character.toLowerCase(ch))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toLowerCase() should be used to map\n characters to lowercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toLowerCase(int) method."
                },
                {
                  "signature": "public static int toLowerCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to\n lowercase using case mapping information from the UnicodeData\n file.\n\n  Note that\n Character.isLowerCase(Character.toLowerCase(codePoint))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toLowerCase() should be used to map\n characters to lowercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot."
                }
              ]
            },
            {
              "name": "toUpperCase",
              "overloads": [
                {
                  "signature": "public static char toUpperCase(char ch)",
                  "description": "Converts the character argument to uppercase using case mapping\n information from the UnicodeData file.\n \n Note that\n Character.isUpperCase(Character.toUpperCase(ch))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toUpperCase() should be used to map\n characters to uppercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toUpperCase(int) method."
                },
                {
                  "signature": "public static int toUpperCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to\n uppercase using case mapping information from the UnicodeData\n file.\n\n Note that\n Character.isUpperCase(Character.toUpperCase(codePoint))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toUpperCase() should be used to map\n characters to uppercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot."
                }
              ]
            },
            {
              "name": "toTitleCase",
              "overloads": [
                {
                  "signature": "public static char toTitleCase(char ch)",
                  "description": "Converts the character argument to titlecase using case mapping\n information from the UnicodeData file. If a character has no\n explicit titlecase mapping and is not itself a titlecase char\n according to UnicodeData, then the uppercase mapping is\n returned as an equivalent titlecase mapping. If the\n char argument is already a titlecase\n char, the same char value will be\n returned.\n \n Note that\n Character.isTitleCase(Character.toTitleCase(ch))\n does not always return true for some ranges of\n characters.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toTitleCase(int) method."
                },
                {
                  "signature": "public static int toTitleCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to titlecase using case mapping\n information from the UnicodeData file. If a character has no\n explicit titlecase mapping and is not itself a titlecase char\n according to UnicodeData, then the uppercase mapping is\n returned as an equivalent titlecase mapping. If the\n character argument is already a titlecase\n character, the same character value will be\n returned.\n\n Note that\n Character.isTitleCase(Character.toTitleCase(codePoint))\n does not always return true for some ranges of\n characters."
                }
              ]
            },
            {
              "name": "digit",
              "overloads": [
                {
                  "signature": "public static int digit(char ch, int radix)",
                  "description": "Returns the numeric value of the character ch in the\n specified radix.\n \n If the radix is not in the range MIN_RADIX \n radix  MAX_RADIX or if the\n value of ch is not a valid digit in the specified\n radix, -1 is returned. A character is a valid digit\n if at least one of the following is true:\n \n The method isDigit is true of the character\n     and the Unicode decimal digit value of the character (or its\n     single-character decomposition) is less than the specified radix.\n     In this case the decimal digit value is returned.\n The character is one of the uppercase Latin letters\n     'A' through 'Z' and its code is less than\n     radix + 'A' - 10.\n     In this case, ch - 'A' + 10\n     is returned.\n The character is one of the lowercase Latin letters\n     'a' through 'z' and its code is less than\n     radix + 'a' - 10.\n     In this case, ch - 'a' + 10\n     is returned.\n The character is one of the fullwidth uppercase Latin letters A\n     ('\\uFF21') through Z ('\\uFF3A')\n     and its code is less than\n     radix + '\\uFF21' - 10.\n     In this case, ch - '\\uFF21' + 10\n     is returned.\n The character is one of the fullwidth lowercase Latin letters a\n     ('\\uFF41') through z ('\\uFF5A')\n     and its code is less than\n     radix + '\\uFF41' - 10.\n     In this case, ch - '\\uFF41' + 10\n     is returned.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the digit(int, int) method."
                },
                {
                  "signature": "public static int digit(int codePoint, int radix)",
                  "description": "Returns the numeric value of the specified character (Unicode\n code point) in the specified radix.\n\n If the radix is not in the range MIN_RADIX \n radix  MAX_RADIX or if the\n character is not a valid digit in the specified\n radix, -1 is returned. A character is a valid digit\n if at least one of the following is true:\n \n The method isDigit(codePoint) is true of the character\n     and the Unicode decimal digit value of the character (or its\n     single-character decomposition) is less than the specified radix.\n     In this case the decimal digit value is returned.\n The character is one of the uppercase Latin letters\n     'A' through 'Z' and its code is less than\n     radix + 'A' - 10.\n     In this case, codePoint - 'A' + 10\n     is returned.\n The character is one of the lowercase Latin letters\n     'a' through 'z' and its code is less than\n     radix + 'a' - 10.\n     In this case, codePoint - 'a' + 10\n     is returned.\n The character is one of the fullwidth uppercase Latin letters A\n     ('\\uFF21') through Z ('\\uFF3A')\n     and its code is less than\n     radix + '\\uFF21' - 10.\n     In this case,\n     codePoint - '\\uFF21' + 10\n     is returned.\n The character is one of the fullwidth lowercase Latin letters a\n     ('\\uFF41') through z ('\\uFF5A')\n     and its code is less than\n     radix + '\\uFF41'- 10.\n     In this case,\n     codePoint - '\\uFF41' + 10\n     is returned."
                }
              ]
            },
            {
              "name": "getNumericValue",
              "overloads": [
                {
                  "signature": "public static int getNumericValue(char ch)",
                  "description": "Returns the int value that the specified Unicode\n character represents. For example, the character\n '\\u216C' (the roman numeral fifty) will return\n an int with a value of 50.\n \n The letters A-Z in their uppercase ('\\u0041' through\n '\\u005A'), lowercase\n ('\\u0061' through '\\u007A'), and\n full width variant ('\\uFF21' through\n '\\uFF3A' and '\\uFF41' through\n '\\uFF5A') forms have numeric values from 10\n through 35. This is independent of the Unicode specification,\n which does not assign numeric values to these char\n values.\n \n If the character does not have a numeric value, then -1 is returned.\n If the character has a numeric value that cannot be represented as a\n nonnegative integer (for example, a fractional value), then -2\n is returned.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getNumericValue(int) method."
                },
                {
                  "signature": "public static int getNumericValue(int codePoint)",
                  "description": "Returns the int value that the specified\n character (Unicode code point) represents. For example, the character\n '\\u216C' (the Roman numeral fifty) will return\n an int with a value of 50.\n \n The letters A-Z in their uppercase ('\\u0041' through\n '\\u005A'), lowercase\n ('\\u0061' through '\\u007A'), and\n full width variant ('\\uFF21' through\n '\\uFF3A' and '\\uFF41' through\n '\\uFF5A') forms have numeric values from 10\n through 35. This is independent of the Unicode specification,\n which does not assign numeric values to these char\n values.\n \n If the character does not have a numeric value, then -1 is returned.\n If the character has a numeric value that cannot be represented as a\n nonnegative integer (for example, a fractional value), then -2\n is returned."
                }
              ]
            },
            {
              "name": "isSpace",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isSpace(char ch)",
                  "description": "Determines if the specified character is ISO-LATIN-1 white space.\n This method returns true for the following five\n characters only:\n \n truechars\n \n Character\n     Code\n     Name\n \n \n '\\t'            U+0009\n     HORIZONTAL TABULATION\n '\\n'            U+000A\n     NEW LINE\n '\\f'            U+000C\n     FORM FEED\n '\\r'            U+000D\n     CARRIAGE RETURN\n ' '  U+0020\n     SPACE",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isSpaceChar",
              "overloads": [
                {
                  "signature": "public static boolean isSpaceChar(char ch)",
                  "description": "Determines if the specified character is a Unicode space character.\n A character is considered to be a space character if and only if\n it is specified to be a space character by the Unicode Standard. This\n method returns true if the character's general category type is any of\n the following:\n \n  SPACE_SEPARATOR\n  LINE_SEPARATOR\n  PARAGRAPH_SEPARATOR\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isSpaceChar(int) method."
                },
                {
                  "signature": "public static boolean isSpaceChar(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a\n Unicode space character.  A character is considered to be a\n space character if and only if it is specified to be a space\n character by the Unicode Standard. This method returns true if\n the character's general category type is any of the following:\n\n \n  SPACE_SEPARATOR\n  LINE_SEPARATOR\n  PARAGRAPH_SEPARATOR"
                }
              ]
            },
            {
              "name": "isWhitespace",
              "overloads": [
                {
                  "signature": "public static boolean isWhitespace(char ch)",
                  "description": "Determines if the specified character is white space according to Java.\n A character is a Java whitespace character if and only if it satisfies\n one of the following criteria:\n \n  It is a Unicode space character (SPACE_SEPARATOR,\n      LINE_SEPARATOR, or PARAGRAPH_SEPARATOR)\n      but is not also a non-breaking space ('\\u00A0',\n      '\\u2007', '\\u202F').\n  It is '\\t', U+0009 HORIZONTAL TABULATION.\n  It is '\\n', U+000A LINE FEED.\n  It is '\\u000B', U+000B VERTICAL TABULATION.\n  It is '\\f', U+000C FORM FEED.\n  It is '\\r', U+000D CARRIAGE RETURN.\n  It is '\\u001C', U+001C FILE SEPARATOR.\n  It is '\\u001D', U+001D GROUP SEPARATOR.\n  It is '\\u001E', U+001E RECORD SEPARATOR.\n  It is '\\u001F', U+001F UNIT SEPARATOR.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isWhitespace(int) method."
                },
                {
                  "signature": "public static boolean isWhitespace(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is\n white space according to Java.  A character is a Java\n whitespace character if and only if it satisfies one of the\n following criteria:\n \n  It is a Unicode space character (SPACE_SEPARATOR,\n      LINE_SEPARATOR, or PARAGRAPH_SEPARATOR)\n      but is not also a non-breaking space ('\\u00A0',\n      '\\u2007', '\\u202F').\n  It is '\\t', U+0009 HORIZONTAL TABULATION.\n  It is '\\n', U+000A LINE FEED.\n  It is '\\u000B', U+000B VERTICAL TABULATION.\n  It is '\\f', U+000C FORM FEED.\n  It is '\\r', U+000D CARRIAGE RETURN.\n  It is '\\u001C', U+001C FILE SEPARATOR.\n  It is '\\u001D', U+001D GROUP SEPARATOR.\n  It is '\\u001E', U+001E RECORD SEPARATOR.\n  It is '\\u001F', U+001F UNIT SEPARATOR."
                }
              ]
            },
            {
              "name": "isISOControl",
              "overloads": [
                {
                  "signature": "public static boolean isISOControl(char ch)",
                  "description": "Determines if the specified character is an ISO control\n character.  A character is considered to be an ISO control\n character if its code is in the range '\\u0000'\n through '\\u001F' or in the range\n '\\u007F' through '\\u009F'.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isISOControl(int) method."
                },
                {
                  "signature": "public static boolean isISOControl(int codePoint)",
                  "description": "Determines if the referenced character (Unicode code point) is an ISO control\n character.  A character is considered to be an ISO control\n character if its code is in the range '\\u0000'\n through '\\u001F' or in the range\n '\\u007F' through '\\u009F'."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public static int getType(char ch)",
                  "description": "Returns a value indicating a character's general category.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getType(int) method."
                },
                {
                  "signature": "public static int getType(int codePoint)",
                  "description": "Returns a value indicating a character's general category."
                }
              ]
            },
            {
              "name": "forDigit",
              "overloads": [
                {
                  "signature": "public static char forDigit(int digit, int radix)",
                  "description": "Determines the character representation for a specific digit in\n the specified radix. If the value of radix is not a\n valid radix, or the value of digit is not a valid\n digit in the specified radix, the null character\n ('\\u0000') is returned.\n \n The radix argument is valid if it is greater than or\n equal to MIN_RADIX and less than or equal to\n MAX_RADIX. The digit argument is valid if\n 0 <= digit < radix.\n \n If the digit is less than 10, then\n '0' + digit is returned. Otherwise, the value\n 'a' + digit - 10 is returned."
                }
              ]
            },
            {
              "name": "getDirectionality",
              "overloads": [
                {
                  "signature": "public static byte getDirectionality(char ch)",
                  "description": "Returns the Unicode directionality property for the given\n character.  Character directionality is used to calculate the\n visual ordering of text. The directionality value of undefined\n char values is DIRECTIONALITY_UNDEFINED.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getDirectionality(int) method."
                },
                {
                  "signature": "public static byte getDirectionality(int codePoint)",
                  "description": "Returns the Unicode directionality property for the given\n character (Unicode code point).  Character directionality is\n used to calculate the visual ordering of text. The\n directionality value of undefined character is DIRECTIONALITY_UNDEFINED."
                }
              ]
            },
            {
              "name": "isMirrored",
              "overloads": [
                {
                  "signature": "public static boolean isMirrored(char ch)",
                  "description": "Determines whether the character is mirrored according to the\n Unicode specification.  Mirrored characters should have their\n glyphs horizontally mirrored when displayed in text that is\n right-to-left.  For example, '\\u0028' LEFT\n PARENTHESIS is semantically defined to be an opening\n parenthesis.  This will appear as a \"(\" in text that is\n left-to-right but as a \")\" in text that is right-to-left.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isMirrored(int) method."
                },
                {
                  "signature": "public static boolean isMirrored(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is mirrored according to the Unicode specification.  Mirrored\n characters should have their glyphs horizontally mirrored when\n displayed in text that is right-to-left.  For example,\n '\\u0028' LEFT PARENTHESIS is semantically\n defined to be an opening parenthesis.  This will appear\n as a \"(\" in text that is left-to-right but as a \")\" in text\n that is right-to-left."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Character anotherCharacter)",
                  "description": "Compares two Character objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(char x, char y)",
                  "description": "Compares two char values numerically.\n The value returned is identical to what would be returned by:\n     Character.valueOf(x).compareTo(Character.valueOf(y))"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static char reverseBytes(char ch)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n specified char value."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public static String getName(int codePoint)",
                  "description": "Returns the Unicode name of the specified character\n codePoint, or null if the code point is\n unassigned.\n \n Note: if the specified character is not assigned a name by\n the UnicodeData file (part of the Unicode Character\n Database maintained by the Unicode Consortium), the returned\n name is the same as the result of expression:\n\n \n     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     + \" \"\n     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);"
                }
              ]
            },
            {
              "name": "codePointOf",
              "overloads": [
                {
                  "signature": "public static int codePointOf(String name)",
                  "description": "Returns the code point value of the Unicode character specified by\n the given Unicode character name.\n \n Note: if a character is not assigned a name by the UnicodeData\n file (part of the Unicode Character Database maintained by the Unicode\n Consortium), its name is defined as the result of expression:\n\n \n     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     + \" \"\n     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\n\n \n \n The name matching is case insensitive, with any leading and\n trailing whitespace character removed."
                }
              ]
            }
          ]
        },
        {
          "name": "Character.Subset",
          "methods": [
            {
              "name": "Subset",
              "overloads": [
                {
                  "signature": "protected Subset(String name)",
                  "description": "Constructs a new Subset instance."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares two Subset objects for equality.\n This method returns true if and only if\n this and the argument refer to the same\n object; since this method is final, this\n guarantee holds for all subclasses."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns the standard hash code as defined by the\n Object.hashCode() method.  This method\n is final in order to ensure that the\n equals and hashCode methods will\n be consistent in all subclasses."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns the name of this subset."
                }
              ]
            }
          ]
        },
        {
          "name": "Character.UnicodeBlock",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeBlock of(char c)",
                  "description": "Returns the object representing the Unicode block containing the\n given character, or null if the character is not a\n member of a defined block.\n\n Note: This method cannot handle\n  supplementary\n characters.  To support all Unicode characters, including\n supplementary characters, use the of(int) method."
                },
                {
                  "signature": "public static Character.UnicodeBlock of(int codePoint)",
                  "description": "Returns the object representing the Unicode block\n containing the given character (Unicode code point), or\n null if the character is not a member of a\n defined block."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static final Character.UnicodeBlock forName(String blockName)",
                  "description": "Returns the UnicodeBlock with the given name. Block\n names are determined by The Unicode Standard. The file\n Blocks-<version>.txt defines blocks for a particular\n version of the standard. The Character class specifies\n the version of the standard that it supports.\n \n This method accepts block names in the following forms:\n \n  Canonical block names as defined by the Unicode Standard.\n For example, the standard defines a \"Basic Latin\" block. Therefore, this\n method accepts \"Basic Latin\" as a valid block name. The documentation of\n each UnicodeBlock provides the canonical name.\n Canonical block names with all spaces removed. For example, \"BasicLatin\"\n is a valid block name for the \"Basic Latin\" block.\n The text representation of each constant UnicodeBlock identifier.\n For example, this method will return the BASIC_LATIN block if\n provided with the \"BASIC_LATIN\" name. This form replaces all spaces and\n hyphens in the canonical name with underscores.\n \n Finally, character case is ignored for all of the valid block name forms.\n For example, \"BASIC_LATIN\" and \"basic_latin\" are both valid block names.\n The en_US locale's case mapping rules are used to provide case-insensitive\n string comparisons for block name validation.\n \n If the Unicode Standard changes block names, both the previous and\n current names will be accepted."
                }
              ]
            }
          ]
        },
        {
          "name": "CharSequence",
          "methods": [
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "int length()",
                  "description": "Returns the length of this character sequence.  The length is the number\n of 16-bit chars in the sequence."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "char charAt(int index)",
                  "description": "Returns the char value at the specified index.  An index ranges from zero\n to length() - 1.  The first char value of the sequence is at\n index zero, the next at index one, and so on, as for array\n indexing.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "default boolean isEmpty()",
                  "description": "Returns true if this character sequence is empty."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "CharSequence subSequence(int start, int end)",
                  "description": "Returns a CharSequence that is a subsequence of this sequence.\n The subsequence starts with the char value at the specified index and\n ends with the char value at index end - 1.  The length\n (in chars) of the\n returned sequence is end - start, so if start == end\n then an empty sequence is returned."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "String toString()",
                  "description": "Returns a string containing the characters in this sequence in the same\n order as this sequence.  The length of the string will be the length of\n this sequence."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "default IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "default IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "static int compare(CharSequence cs1, CharSequence cs2)",
                  "description": "Compares two CharSequence instances lexicographically. Returns a\n negative value, zero, or a positive value if the first sequence is lexicographically\n less than, equal to, or greater than the second, respectively.\n\n \n The lexicographical ordering of CharSequence is defined as follows.\n Consider a CharSequence cs of length len to be a\n sequence of char values, cs[0] to cs[len-1]. Suppose k\n is the lowest index at which the corresponding char values from each sequence\n differ. The lexicographic ordering of the sequences is determined by a numeric\n comparison of the char values cs1[k] with cs2[k]. If there is\n no such index k, the shorter sequence is considered lexicographically\n less than the other. If the sequences have the same length, the sequences are\n considered lexicographically equal."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static StackWalker.Option[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static StackWalker.Option valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript of(int codePoint)",
                  "description": "Returns the enum constant representing the Unicode script of which\n the given character (Unicode code point) is assigned to."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static final Character.UnicodeScript forName(String scriptName)",
                  "description": "Returns the UnicodeScript constant with the given Unicode script\n name or the script name alias. Script names and their aliases are\n determined by The Unicode Standard. The files Scripts<version>.txt\n and PropertyValueAliases<version>.txt define script names\n and the script name aliases for a particular version of the\n standard. The Character class specifies the version of\n the standard that it supports.\n \n Character case is ignored for all of the valid script names.\n The en_US locale's case mapping rules are used to provide\n case-insensitive string comparisons for script name validation."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect.Type[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect.Type valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Thread.State[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Thread.State valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static System.Logger.Level[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static System.Logger.Level valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns the name of this level."
                }
              ]
            },
            {
              "name": "getSeverity",
              "overloads": [
                {
                  "signature": "public final int getSeverity()",
                  "description": "Returns the severity of this level.\n A higher severity means a more severe condition."
                }
              ]
            }
          ]
        },
        {
          "name": "Class<T>",
          "methods": [
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts the object to a string. The string representation is the\n string \"class\" or \"interface\", followed by a space, and then by the\n name of the class in the format returned by getName.\n If this Class object represents a primitive type,\n this method returns the name of the primitive type.  If\n this Class object represents void this method returns\n \"void\". If this Class object represents an array type,\n this method returns \"class \" followed by getName."
                }
              ]
            },
            {
              "name": "toGenericString",
              "overloads": [
                {
                  "signature": "public String toGenericString()",
                  "description": "Returns a string describing this Class, including\n information about modifiers and type parameters.\n\n The string is formatted as a list of type modifiers, if any,\n followed by the kind of type (empty string for primitive types\n and class, enum, interface,\n @interface, or record as appropriate), followed\n by the type's name, followed by an angle-bracketed\n comma-separated list of the type's type parameters, if any,\n including informative bounds on the type parameters, if any.\n\n A space is used to separate modifiers from one another and to\n separate any modifiers from the kind of type. The modifiers\n occur in canonical order. If there are no type parameters, the\n type parameter list is elided.\n\n For an array type, the string starts with the type name,\n followed by an angle-bracketed comma-separated list of the\n type's type parameters, if any, followed by a sequence of\n [] characters, one set of brackets per dimension of\n the array.\n\n Note that since information about the runtime representation\n of a type is being generated, modifiers not present on the\n originating source code or illegal on the originating source\n code may be present."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static Class<?> forName(String className) throws ClassNotFoundException",
                  "description": "Returns the Class object associated with the class or\n interface with the given string name.  Invoking this method is\n equivalent to:\n\n \n  Class.forName(className, true, currentLoader)\n \n\n where currentLoader denotes the defining class loader of\n the current class.\n\n  For example, the following code fragment returns the\n runtime Class descriptor for the class named\n java.lang.Thread:\n\n \n   Class t = Class.forName(\"java.lang.Thread\")\n \n \n A call to forName(\"X\") causes the class named\n X to be initialized."
                },
                {
                  "signature": "public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
                  "description": "Returns the Class object associated with the class or\n interface with the given string name, using the given class loader.\n Given the fully qualified name for a class or interface (in the same\n format returned by getName) this method attempts to\n locate and load the class or interface.  The specified class\n loader is used to load the class or interface.  If the parameter\n loader is null, the class is loaded through the bootstrap\n class loader.  The class is initialized only if the\n initialize parameter is true and if it has\n not been initialized earlier.\n\n  If name denotes a primitive type or void, an attempt\n will be made to locate a user-defined class in the unnamed package whose\n name is name. Therefore, this method cannot be used to\n obtain any of the Class objects representing primitive\n types or void.\n\n  If name denotes an array class, the component type of\n the array class is loaded but not initialized.\n\n  For example, in an instance method the expression:\n\n \n  Class.forName(\"Foo\")\n \n\n is equivalent to:\n\n \n  Class.forName(\"Foo\", true, this.getClass().getClassLoader())\n \n\n Note that this method throws errors related to loading, linking\n or initializing as specified in Sections 12.2, 12.3, and 12.4 of The Java Language\n Specification.\n Note that this method does not check whether the requested class\n is accessible to its caller."
                },
                {
                  "signature": "public static Class<?> forName(Module module, String name)",
                  "description": "Returns the Class with the given \n binary name in the given module.\n\n  This method attempts to locate and load the class or interface.\n It does not link the class, and does not run the class initializer.\n If the class is not found, this method returns null. \n\n  If the class loader of the given module defines other modules and\n the given name is a class defined in a different module, this method\n returns null after the class is loaded. \n\n  This method does not check whether the requested class is\n accessible to its caller."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public T newInstance() throws InstantiationException, IllegalAccessException",
                  "description": "Creates a new instance of the class represented by this Class\n object.  The class is instantiated as if by a new\n expression with an empty argument list.  The class is initialized if it\n has not already been initialized.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isInstance",
              "overloads": [
                {
                  "signature": "public boolean isInstance(Object obj)",
                  "description": "Determines if the specified Object is assignment-compatible\n with the object represented by this Class.  This method is\n the dynamic equivalent of the Java language instanceof\n operator. The method returns true if the specified\n Object argument is non-null and can be cast to the\n reference type represented by this Class object without\n raising a ClassCastException. It returns false\n otherwise.\n\n  Specifically, if this Class object represents a\n declared class, this method returns true if the specified\n Object argument is an instance of the represented class (or\n of any of its subclasses); it returns false otherwise. If\n this Class object represents an array class, this method\n returns true if the specified Object argument\n can be converted to an object of the array class by an identity\n conversion or by a widening reference conversion; it returns\n false otherwise. If this Class object\n represents an interface, this method returns true if the\n class or any superclass of the specified Object argument\n implements this interface; it returns false otherwise. If\n this Class object represents a primitive type, this method\n returns false."
                }
              ]
            },
            {
              "name": "isAssignableFrom",
              "overloads": [
                {
                  "signature": "public boolean isAssignableFrom(Class<?> cls)",
                  "description": "Determines if the class or interface represented by this\n Class object is either the same as, or is a superclass or\n superinterface of, the class or interface represented by the specified\n Class parameter. It returns true if so;\n otherwise it returns false. If this Class\n object represents a primitive type, this method returns\n true if the specified Class parameter is\n exactly this Class object; otherwise it returns\n false.\n\n  Specifically, this method tests whether the type represented by the\n specified Class parameter can be converted to the type\n represented by this Class object via an identity conversion\n or via a widening reference conversion. See The Java Language\n Specification, sections 5.1.1 and 5.1.4,\n for details."
                }
              ]
            },
            {
              "name": "isInterface",
              "overloads": [
                {
                  "signature": "public boolean isInterface()",
                  "description": "Determines if this Class object represents an\n interface type."
                }
              ]
            },
            {
              "name": "isArray",
              "overloads": [
                {
                  "signature": "public boolean isArray()",
                  "description": "Determines if this Class object represents an array class."
                }
              ]
            },
            {
              "name": "isPrimitive",
              "overloads": [
                {
                  "signature": "public boolean isPrimitive()",
                  "description": "Determines if the specified Class object represents a\n primitive type.\n\n  There are nine predefined Class objects to represent\n the eight primitive types and void.  These are created by the Java\n Virtual Machine, and have the same names as the primitive types that\n they represent, namely boolean, byte,\n char, short, int,\n long, float, and double.\n\n  These objects may only be accessed via the following public static\n final variables, and are the only Class objects for which\n this method returns true."
                }
              ]
            },
            {
              "name": "isAnnotation",
              "overloads": [
                {
                  "signature": "public boolean isAnnotation()",
                  "description": "Returns true if this Class object represents an annotation\n interface.  Note that if this method returns true, isInterface()\n would also return true, as all annotation interfaces are also interfaces."
                }
              ]
            },
            {
              "name": "isSynthetic",
              "overloads": [
                {
                  "signature": "public boolean isSynthetic()",
                  "description": "Returns true if and only if this class has the synthetic modifier\n bit set."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the  name of the entity (class, interface, array class,\n primitive type, or void) represented by this Class object.\n\n  If this Class object represents a class or interface,\n not an array class, then:\n \n  If the class or interface is not hidden,\n      then the binary name\n      of the class or interface is returned.\n  If the class or interface is hidden, then the result is a string\n      of the form: N + '/' + <suffix>\n      where N is the binary name\n      indicated by the class file passed to\n      Lookup::defineHiddenClass, and <suffix> is an unqualified name.\n \n\n  If this Class object represents an array class, then\n the result is a string consisting of one or more '[' characters\n representing the depth of the array nesting, followed by the element\n type as encoded using the following table:\n\n \n Element types and encodings\n \n  Element Type  Encoding\n \n \n  boolean  Z\n  byte     B\n  char     C\n  class or interface with binary name N\n                                       LN;\n  double   D\n  float    F\n  int      I\n  long     J\n  short    S\n \n \n\n  If this Class object represents a primitive type or void,\n then the result is a string with the same spelling as the Java language\n keyword which corresponds to the primitive type or void.\n\n  Examples:\n  String.class.getName()\n     returns \"java.lang.String\"\n byte.class.getName()\n     returns \"byte\"\n (new Object[3]).getClass().getName()\n     returns \"[Ljava.lang.Object;\"\n (new int[3][4][5][6][7][8][9]).getClass().getName()\n     returns \"[[[[[[[I\""
                }
              ]
            },
            {
              "name": "getClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getClassLoader()",
                  "description": "Returns the class loader for the class.  Some implementations may use\n null to represent the bootstrap class loader. This method will return\n null in such implementations if this class was loaded by the bootstrap\n class loader.\n\n If this Class object\n represents a primitive type or void, null is returned."
                }
              ]
            },
            {
              "name": "getModule",
              "overloads": [
                {
                  "signature": "public Module getModule()",
                  "description": "Returns the module that this class or interface is a member of.\n\n If this class represents an array type then this method returns the\n Module for the element type. If this class represents a\n primitive type or void, then the Module object for the\n java.base module is returned.\n\n If this class is in an unnamed module then the unnamed Module of the class\n loader for this class is returned."
                }
              ]
            },
            {
              "name": "getTypeParameters",
              "overloads": [
                {
                  "signature": "public TypeVariable<Class<T>>[] getTypeParameters()",
                  "description": "Returns an array of TypeVariable objects that represent the\n type variables declared by the generic declaration represented by this\n GenericDeclaration object, in declaration order.  Returns an\n array of length 0 if the underlying generic declaration declares no type\n variables."
                }
              ]
            },
            {
              "name": "getSuperclass",
              "overloads": [
                {
                  "signature": "public Class<? super T> getSuperclass()",
                  "description": "Returns the Class representing the direct superclass of the\n entity (class, interface, primitive type or void) represented by\n this Class.  If this Class represents either the\n Object class, an interface, a primitive type, or void, then\n null is returned.  If this Class object represents an array class\n then the Class object representing the Object class is\n returned."
                }
              ]
            },
            {
              "name": "getGenericSuperclass",
              "overloads": [
                {
                  "signature": "public Type getGenericSuperclass()",
                  "description": "Returns the Type representing the direct superclass of\n the entity (class, interface, primitive type or void) represented by\n this Class object.\n\n If the superclass is a parameterized type, the Type\n object returned must accurately reflect the actual type\n arguments used in the source code. The parameterized type\n representing the superclass is created if it had not been\n created before. See the declaration of ParameterizedType for the\n semantics of the creation process for parameterized types.  If\n this Class object represents either the Object\n class, an interface, a primitive type, or void, then null is\n returned.  If this Class object represents an array class\n then the Class object representing the Object class is\n returned."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "public Package getPackage()",
                  "description": "Gets the package of this class.\n\n If this class represents an array type, a primitive type or void,\n this method returns null."
                }
              ]
            },
            {
              "name": "getPackageName",
              "overloads": [
                {
                  "signature": "public String getPackageName()",
                  "description": "Returns the fully qualified package name.\n\n  If this class is a top level class, then this method returns the fully\n qualified name of the package that the class is a member of, or the\n empty string if the class is in an unnamed package.\n\n  If this class is a member class, then this method is equivalent to\n invoking getPackageName() on the enclosing class.\n\n  If this class is a local class or an anonymous class, then this method is equivalent to\n invoking getPackageName() on the declaring class of the enclosing method or\n enclosing constructor.\n\n  If this class represents an array type then this method returns the\n package name of the element type. If this class represents a primitive\n type or void then the package name \"java.lang\" is returned."
                }
              ]
            },
            {
              "name": "getInterfaces",
              "overloads": [
                {
                  "signature": "public Class<?>[] getInterfaces()",
                  "description": "Returns the interfaces directly implemented by the class or interface\n represented by this Class object.\n\n If this Class object represents a class, the return value is an array\n containing objects representing all interfaces directly implemented by\n the class.  The order of the interface objects in the array corresponds\n to the order of the interface names in the implements clause of\n the declaration of the class represented by this Class object.  For example,\n given the declaration:\n \n class Shimmer implements FloorWax, DessertTopping { ... }\n \n suppose the value of s is an instance of\n Shimmer; the value of the expression:\n \n s.getClass().getInterfaces()[0]\n \n is the Class object that represents interface\n FloorWax; and the value of:\n \n s.getClass().getInterfaces()[1]\n \n is the Class object that represents interface\n DessertTopping.\n\n If this Class object represents an interface, the array contains objects\n representing all interfaces directly extended by the interface.  The\n order of the interface objects in the array corresponds to the order of\n the interface names in the extends clause of the declaration of\n the interface represented by this Class object.\n\n If this Class object represents a class or interface that implements no\n interfaces, the method returns an array of length 0.\n\n If this Class object represents a primitive type or void, the method\n returns an array of length 0.\n\n If this Class object represents an array type, the\n interfaces Cloneable and java.io.Serializable are\n returned in that order."
                }
              ]
            },
            {
              "name": "getGenericInterfaces",
              "overloads": [
                {
                  "signature": "public Type[] getGenericInterfaces()",
                  "description": "Returns the Types representing the interfaces\n directly implemented by the class or interface represented by\n this Class object.\n\n If a superinterface is a parameterized type, the\n Type object returned for it must accurately reflect\n the actual type arguments used in the source code. The\n parameterized type representing each superinterface is created\n if it had not been created before. See the declaration of\n ParameterizedType\n for the semantics of the creation process for parameterized\n types.\n\n If this Class object represents a class, the return value is an array\n containing objects representing all interfaces directly implemented by\n the class.  The order of the interface objects in the array corresponds\n to the order of the interface names in the implements clause of\n the declaration of the class represented by this Class object.\n\n If this Class object represents an interface, the array contains objects\n representing all interfaces directly extended by the interface.  The\n order of the interface objects in the array corresponds to the order of\n the interface names in the extends clause of the declaration of\n the interface represented by this Class object.\n\n If this Class object represents a class or interface that implements no\n interfaces, the method returns an array of length 0.\n\n If this Class object represents a primitive type or void, the method\n returns an array of length 0.\n\n If this Class object represents an array type, the\n interfaces Cloneable and java.io.Serializable are\n returned in that order."
                }
              ]
            },
            {
              "name": "getComponentType",
              "overloads": [
                {
                  "signature": "public Class<?> getComponentType()",
                  "description": "Returns the Class representing the component type of an\n array.  If this class does not represent an array class this method\n returns null."
                }
              ]
            },
            {
              "name": "getModifiers",
              "overloads": [
                {
                  "signature": "public int getModifiers()",
                  "description": "Returns the Java language modifiers for this class or interface, encoded\n in an integer. The modifiers consist of the Java Virtual Machine's\n constants for public, protected,\n private, final, static,\n abstract and interface; they should be decoded\n using the methods of class Modifier.\n\n  If the underlying class is an array class, then its\n public, private and protected\n modifiers are the same as those of its component type.  If this\n Class object represents a primitive type or void, its\n public modifier is always true, and its\n protected and private modifiers are always\n false. If this Class object represents an array class, a\n primitive type or void, then its final modifier is always\n true and its interface modifier is always\n false. The values of its other modifiers are not determined\n by this specification.\n\n  The modifier encodings are defined in section 4.1\n of The Java Virtual Machine Specification."
                }
              ]
            },
            {
              "name": "getSigners",
              "overloads": [
                {
                  "signature": "public Object[] getSigners()",
                  "description": "Gets the signers of this class."
                }
              ]
            },
            {
              "name": "getEnclosingMethod",
              "overloads": [
                {
                  "signature": "public Method getEnclosingMethod() throws SecurityException",
                  "description": "If this Class object represents a local or anonymous\n class within a method, returns a Method object representing the\n immediately enclosing method of the underlying class. Returns\n null otherwise.\n\n In particular, this method returns null if the underlying\n class is a local or anonymous class immediately enclosed by a class or\n interface declaration, instance initializer or static initializer."
                }
              ]
            },
            {
              "name": "getEnclosingConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<?> getEnclosingConstructor() throws SecurityException",
                  "description": "If this Class object represents a local or anonymous\n class within a constructor, returns a Constructor object representing\n the immediately enclosing constructor of the underlying\n class. Returns null otherwise.  In particular, this\n method returns null if the underlying class is a local\n or anonymous class immediately enclosed by a class or\n interface declaration, instance initializer or static initializer."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "public Class<?> getDeclaringClass() throws SecurityException",
                  "description": "If the class or interface represented by this Class object\n is a member of another class, returns the Class object\n representing the class in which it was declared.  This method returns\n null if this class or interface is not a member of any other class.  If\n this Class object represents an array class, a primitive\n type, or void,then this method returns null."
                }
              ]
            },
            {
              "name": "getEnclosingClass",
              "overloads": [
                {
                  "signature": "public Class<?> getEnclosingClass() throws SecurityException",
                  "description": "Returns the immediately enclosing class of the underlying\n class.  If the underlying class is a top level class this\n method returns null."
                }
              ]
            },
            {
              "name": "getSimpleName",
              "overloads": [
                {
                  "signature": "public String getSimpleName()",
                  "description": "Returns the simple name of the underlying class as given in the\n source code. An empty string is returned if the underlying class is\n anonymous.\n A synthetic class, one not present\n in source code, can have a non-empty name including special\n characters, such as \"$\".\n\n The simple name of an array class is the simple name of the\n component type with \"[]\" appended.  In particular the simple\n name of an array class whose component type is anonymous is \"[]\"."
                }
              ]
            },
            {
              "name": "getTypeName",
              "overloads": [
                {
                  "signature": "public String getTypeName()",
                  "description": "Return an informative string for the name of this class or interface."
                }
              ]
            },
            {
              "name": "getCanonicalName",
              "overloads": [
                {
                  "signature": "public String getCanonicalName()",
                  "description": "Returns the canonical name of the underlying class as\n defined by The Java Language Specification.\n Returns null if the underlying class does not have a canonical\n name. Classes without canonical names include:\n \n a local class\n a anonymous class\n a hidden class\n an array whose component type does not have a canonical name"
                }
              ]
            },
            {
              "name": "isAnonymousClass",
              "overloads": [
                {
                  "signature": "public boolean isAnonymousClass()",
                  "description": "Returns true if and only if the underlying class\n is an anonymous class."
                }
              ]
            },
            {
              "name": "isLocalClass",
              "overloads": [
                {
                  "signature": "public boolean isLocalClass()",
                  "description": "Returns true if and only if the underlying class\n is a local class."
                }
              ]
            },
            {
              "name": "isMemberClass",
              "overloads": [
                {
                  "signature": "public boolean isMemberClass()",
                  "description": "Returns true if and only if the underlying class\n is a member class."
                }
              ]
            },
            {
              "name": "getClasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getClasses()",
                  "description": "Returns an array containing Class objects representing all\n the public classes and interfaces that are members of the class\n represented by this Class object.  This includes public\n class and interface members inherited from superclasses and public class\n and interface members declared by the class.  This method returns an\n array of length 0 if this Class object has no public member\n classes or interfaces.  This method also returns an array of length 0 if\n this Class object represents a primitive type, an array\n class, or void."
                }
              ]
            },
            {
              "name": "getFields",
              "overloads": [
                {
                  "signature": "public Field[] getFields() throws SecurityException",
                  "description": "Returns an array containing Field objects reflecting all\n the accessible public fields of the class or interface represented by\n this Class object.\n\n  If this Class object represents a class or interface with\n no accessible public fields, then this method returns an array of length\n 0.\n\n  If this Class object represents a class, then this method\n returns the public fields of the class and of all its superclasses and\n superinterfaces.\n\n  If this Class object represents an interface, then this\n method returns the fields of the interface and of all its\n superinterfaces.\n\n  If this Class object represents an array type, a primitive\n type, or void, then this method returns an array of length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getMethods",
              "overloads": [
                {
                  "signature": "public Method[] getMethods() throws SecurityException",
                  "description": "Returns an array containing Method objects reflecting all the\n public methods of the class or interface represented by this \n Class object, including those declared by the class or interface and\n those inherited from superclasses and superinterfaces.\n\n  If this Class object represents an array type, then the\n returned array has a Method object for each of the public\n methods inherited by the array type from Object. It does not\n contain a Method object for clone().\n\n  If this Class object represents an interface then the\n returned array does not contain any implicitly declared methods from\n Object. Therefore, if no methods are explicitly declared in\n this interface or any of its superinterfaces then the returned array\n has length 0. (Note that a Class object which represents a class\n always has public methods, inherited from Object.)\n\n  The returned array never contains methods with names \"<init>\"\n or \"<clinit>\".\n\n  The elements in the returned array are not sorted and are not in any\n particular order.\n\n  Generally, the result is computed as with the following 4 step algorithm.\n Let C be the class or interface represented by this Class object:\n \n  A union of methods is composed of:\n   \n    C's declared public instance and static methods as returned by\n        getDeclaredMethods() and filtered to include only public\n        methods.\n    If C is a class other than Object, then include the result\n        of invoking this algorithm recursively on the superclass of C.\n    Include the results of invoking this algorithm recursively on all\n        direct superinterfaces of C, but include only instance methods.\n   \n  Union from step 1 is partitioned into subsets of methods with same\n      signature (name, parameter types) and return type.\n  Within each such subset only the most specific methods are selected.\n      Let method M be a method from a set of methods with same signature\n      and return type. M is most specific if there is no such method\n      N != M from the same set, such that N is more specific than M.\n      N is more specific than M if:\n   \n    N is declared by a class and M is declared by an interface; or\n    N and M are both declared by classes or both by interfaces and\n        N's declaring type is the same as or a subtype of M's declaring type\n        (clearly, if M's and N's declaring types are the same type, then\n        M and N are the same method).\n   \n  The result of this algorithm is the union of all selected methods from\n      step 3."
                }
              ]
            },
            {
              "name": "getConstructors",
              "overloads": [
                {
                  "signature": "public Constructor<?>[] getConstructors() throws SecurityException",
                  "description": "Returns an array containing Constructor objects reflecting\n all the public constructors of the class represented by this\n Class object.  An array of length 0 is returned if the\n class has no public constructors, or if the class is an array class, or\n if the class reflects a primitive type or void."
                }
              ]
            },
            {
              "name": "getField",
              "overloads": [
                {
                  "signature": "public Field getField(String name) throws NoSuchFieldException, SecurityException",
                  "description": "Returns a Field object that reflects the specified public member\n field of the class or interface represented by this Class\n object. The name parameter is a String specifying the\n simple name of the desired field.\n\n  The field to be reflected is determined by the algorithm that\n follows.  Let C be the class or interface represented by this Class object:\n\n \n  If C declares a public field with the name specified, that is the\n      field to be reflected.\n  If no field was found in step 1 above, this algorithm is applied\n      recursively to each direct superinterface of C. The direct\n      superinterfaces are searched in the order they were declared.\n  If no field was found in steps 1 and 2 above, and C has a\n      superclass S, then this algorithm is invoked recursively upon S.\n      If C has no superclass, then a NoSuchFieldException\n      is thrown.\n \n\n  If this Class object represents an array type, then this\n method does not find the length field of the array type."
                }
              ]
            },
            {
              "name": "getMethod",
              "overloads": [
                {
                  "signature": "public Method getMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Method object that reflects the specified public\n member method of the class or interface represented by this\n Class object. The name parameter is a\n String specifying the simple name of the desired method. The\n parameterTypes parameter is an array of Class\n objects that identify the method's formal parameter types, in declared\n order. If parameterTypes is null, it is\n treated as if it were an empty array.\n\n  If this Class object represents an array type, then this\n method finds any public method inherited by the array type from\n Object except method clone().\n\n  If this Class object represents an interface then this\n method does not find any implicitly declared method from\n Object. Therefore, if no methods are explicitly declared in\n this interface or any of its superinterfaces, then this method does not\n find any method.\n\n  This method does not find any method with name \"<init>\" or\n \"<clinit>\".\n\n  Generally, the method to be reflected is determined by the 4 step\n algorithm that follows.\n Let C be the class or interface represented by this Class object:\n \n  A union of methods is composed of:\n   \n    C's declared public instance and static methods as returned by\n        getDeclaredMethods() and filtered to include only public\n        methods that match given name and parameterTypes\n    If C is a class other than Object, then include the result\n        of invoking this algorithm recursively on the superclass of C.\n    Include the results of invoking this algorithm recursively on all\n        direct superinterfaces of C, but include only instance methods.\n   \n  This union is partitioned into subsets of methods with same\n      return type (the selection of methods from step 1 also guarantees that\n      they have the same method name and parameter types).\n  Within each such subset only the most specific methods are selected.\n      Let method M be a method from a set of methods with same VM\n      signature (return type, name, parameter types).\n      M is most specific if there is no such method N != M from the same\n      set, such that N is more specific than M. N is more specific than M\n      if:\n   \n    N is declared by a class and M is declared by an interface; or\n    N and M are both declared by classes or both by interfaces and\n        N's declaring type is the same as or a subtype of M's declaring type\n        (clearly, if M's and N's declaring types are the same type, then\n        M and N are the same method).\n   \n  The result of this algorithm is chosen arbitrarily from the methods\n      with most specific return type among all selected methods from step 3.\n      Let R be a return type of a method M from the set of all selected methods\n      from step 3. M is a method with most specific return type if there is\n      no such method N != M from the same set, having return type S != R,\n      such that S is a subtype of R as determined by\n      R.class.isAssignableFrom(java.lang.Class<?>)(S.class)."
                }
              ]
            },
            {
              "name": "getConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Constructor object that reflects the specified\n public constructor of the class represented by this Class\n object. The parameterTypes parameter is an array of\n Class objects that identify the constructor's formal\n parameter types, in declared order.\n\n If this Class object represents an inner class\n declared in a non-static context, the formal parameter types\n include the explicit enclosing instance as the first parameter.\n\n  The constructor to reflect is the public constructor of the class\n represented by this Class object whose formal parameter\n types match those specified by parameterTypes."
                }
              ]
            },
            {
              "name": "getDeclaredClasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getDeclaredClasses() throws SecurityException",
                  "description": "Returns an array of Class objects reflecting all the\n classes and interfaces declared as members of the class represented by\n this Class object. This includes public, protected, default\n (package) access, and private classes and interfaces declared by the\n class, but excludes inherited classes and interfaces.  This method\n returns an array of length 0 if the class declares no classes or\n interfaces as members, or if this Class object represents a\n primitive type, an array class, or void."
                }
              ]
            },
            {
              "name": "getDeclaredFields",
              "overloads": [
                {
                  "signature": "public Field[] getDeclaredFields() throws SecurityException",
                  "description": "Returns an array of Field objects reflecting all the fields\n declared by the class or interface represented by this\n Class object. This includes public, protected, default\n (package) access, and private fields, but excludes inherited fields.\n\n  If this Class object represents a class or interface with no\n declared fields, then this method returns an array of length 0.\n\n  If this Class object represents an array type, a primitive\n type, or void, then this method returns an array of length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getRecordComponents",
              "overloads": [
                {
                  "signature": "public RecordComponent[] getRecordComponents()",
                  "description": "Returns an array of RecordComponent objects representing all the\n record components of this record class, or null if this class is\n not a record class.\n\n  The components are returned in the same order that they are declared\n in the record header. The array is empty if this record class has no\n components. If the class is not a record class, that is isRecord() returns false, then this method returns null.\n Conversely, if isRecord() returns true, then this method\n returns a non-null value."
                }
              ]
            },
            {
              "name": "getDeclaredMethods",
              "overloads": [
                {
                  "signature": "public Method[] getDeclaredMethods() throws SecurityException",
                  "description": "Returns an array containing Method objects reflecting all the\n declared methods of the class or interface represented by this \n Class object, including public, protected, default (package)\n access, and private methods, but excluding inherited methods.\n The declared methods may include methods not in the\n source of the class or interface, including bridge methods and other synthetic methods added by compilers.\n\n  If this Class object represents a class or interface that\n has multiple declared methods with the same name and parameter types,\n but different return types, then the returned array has a Method\n object for each such method.\n\n  If this Class object represents a class or interface that\n has a class initialization method <clinit>, then the returned\n array does not have a corresponding Method object.\n\n  If this Class object represents a class or interface with no\n declared methods, then the returned array has length 0.\n\n  If this Class object represents an array type, a primitive\n type, or void, then the returned array has length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getDeclaredConstructors",
              "overloads": [
                {
                  "signature": "public Constructor<?>[] getDeclaredConstructors() throws SecurityException",
                  "description": "Returns an array of Constructor objects reflecting all the\n constructors declared by the class represented by this\n Class object. These are public, protected, default\n (package) access, and private constructors.  The elements in the array\n returned are not sorted and are not in any particular order.  If the\n class has a default constructor, it is included in the returned array.\n This method returns an array of length 0 if this Class\n object represents an interface, a primitive type, an array class, or\n void.\n\n  See The Java Language Specification,\n section 8.2."
                }
              ]
            },
            {
              "name": "getDeclaredField",
              "overloads": [
                {
                  "signature": "public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException",
                  "description": "Returns a Field object that reflects the specified declared\n field of the class or interface represented by this Class\n object. The name parameter is a String that specifies\n the simple name of the desired field.\n\n  If this Class object represents an array type, then this\n method does not find the length field of the array type."
                }
              ]
            },
            {
              "name": "getDeclaredMethod",
              "overloads": [
                {
                  "signature": "public Method getDeclaredMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Method object that reflects the specified\n declared method of the class or interface represented by this\n Class object. The name parameter is a\n String that specifies the simple name of the desired\n method, and the parameterTypes parameter is an array of\n Class objects that identify the method's formal parameter\n types, in declared order.  If more than one method with the same\n parameter types is declared in a class, and one of these methods has a\n return type that is more specific than any of the others, that method is\n returned; otherwise one of the methods is chosen arbitrarily.  If the\n name is \"<init>\"or \"<clinit>\" a NoSuchMethodException\n is raised.\n\n  If this Class object represents an array type, then this\n method does not find the clone() method."
                }
              ]
            },
            {
              "name": "getDeclaredConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Constructor object that reflects the specified\n constructor of the class or interface represented by this\n Class object.  The parameterTypes parameter is\n an array of Class objects that identify the constructor's\n formal parameter types, in declared order.\n\n If this Class object represents an inner class\n declared in a non-static context, the formal parameter types\n include the explicit enclosing instance as the first parameter."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Finds a resource with a given name.\n\n  If this class is in a named Module then this method\n will attempt to find the resource in the module. This is done by\n delegating to the module's class loader findResource(String,String)\n method, invoking it with the module name and the absolute name of the\n resource. Resources in named modules are subject to the rules for\n encapsulation specified in the Module getResourceAsStream method and so this\n method returns null when the resource is a\n non-\".class\" resource in a package that is not open to the\n caller's module.\n\n  Otherwise, if this class is not in a named module then the rules for\n searching resources associated with a given class are implemented by the\n defining class loader of the class.  This method\n delegates to this Class object's class loader.\n If this Class object was loaded by the bootstrap class loader,\n the method delegates to ClassLoader.getSystemResourceAsStream(java.lang.String).\n\n  Before delegation, an absolute resource name is constructed from the\n given resource name using this algorithm:\n\n \n\n  If the name begins with a '/'\n ('\\u002f'), then the absolute name of the resource is the\n portion of the name following the '/'.\n\n  Otherwise, the absolute name is of the following form:\n\n \n   modified_package_name/name\n \n\n  Where the modified_package_name is the package name of this\n object with '/' substituted for '.'\n ('\\u002e')."
                }
              ]
            },
            {
              "name": "getResource",
              "overloads": [
                {
                  "signature": "public URL getResource(String name)",
                  "description": "Finds a resource with a given name.\n\n  If this class is in a named Module then this method\n will attempt to find the resource in the module. This is done by\n delegating to the module's class loader findResource(String,String)\n method, invoking it with the module name and the absolute name of the\n resource. Resources in named modules are subject to the rules for\n encapsulation specified in the Module getResourceAsStream method and so this\n method returns null when the resource is a\n non-\".class\" resource in a package that is not open to the\n caller's module.\n\n  Otherwise, if this class is not in a named module then the rules for\n searching resources associated with a given class are implemented by the\n defining class loader of the class.  This method\n delegates to this Class object's class loader.\n If this Class object was loaded by the bootstrap class loader,\n the method delegates to ClassLoader.getSystemResource(java.lang.String).\n\n  Before delegation, an absolute resource name is constructed from the\n given resource name using this algorithm:\n\n \n\n  If the name begins with a '/'\n ('\\u002f'), then the absolute name of the resource is the\n portion of the name following the '/'.\n\n  Otherwise, the absolute name is of the following form:\n\n \n   modified_package_name/name\n \n\n  Where the modified_package_name is the package name of this\n object with '/' substituted for '.'\n ('\\u002e')."
                }
              ]
            },
            {
              "name": "getProtectionDomain",
              "overloads": [
                {
                  "signature": "public ProtectionDomain getProtectionDomain()",
                  "description": "Returns the ProtectionDomain of this class.  If there is a\n security manager installed, this method first calls the security\n manager's checkPermission method with a\n RuntimePermission(\"getProtectionDomain\") permission to\n ensure it's ok to get the\n ProtectionDomain."
                }
              ]
            },
            {
              "name": "desiredAssertionStatus",
              "overloads": [
                {
                  "signature": "public boolean desiredAssertionStatus()",
                  "description": "Returns the assertion status that would be assigned to this\n class if it were to be initialized at the time this method is invoked.\n If this class has had its assertion status set, the most recent\n setting will be returned; otherwise, if any package default assertion\n status pertains to this class, the most recent setting for the most\n specific pertinent package default assertion status is returned;\n otherwise, if this class is not a system class (i.e., it has a\n class loader) its class loader's default assertion status is returned;\n otherwise, the system class default assertion status is returned."
                }
              ]
            },
            {
              "name": "isEnum",
              "overloads": [
                {
                  "signature": "public boolean isEnum()",
                  "description": "Returns true if and only if this class was declared as an enum in the\n source code.\n\n Note that Enum is not itself an enum class.\n\n Also note that if an enum constant is declared with a class body,\n the class of that enum constant object is an anonymous class\n and not the class of the declaring enum class. The\n Enum.getDeclaringClass() method of an enum constant can\n be used to get the class of the enum class declaring the\n constant."
                }
              ]
            },
            {
              "name": "isRecord",
              "overloads": [
                {
                  "signature": "public boolean isRecord()",
                  "description": "Returns true if and only if this class is a record class.\n\n  The direct superclass of a record\n class is java.lang.Record. A record class is final. A record class has (possibly zero) record\n components; getRecordComponents() returns a non-null but\n possibly empty value for a record.\n\n  Note that class Record is not a record class and thus\n invoking this method on class Record returns false."
                }
              ]
            },
            {
              "name": "getEnumConstants",
              "overloads": [
                {
                  "signature": "public T[] getEnumConstants()",
                  "description": "Returns the elements of this enum class or null if this\n Class object does not represent an enum class."
                }
              ]
            },
            {
              "name": "cast",
              "overloads": [
                {
                  "signature": "public T cast(Object obj)",
                  "description": "Casts an object to the class or interface represented\n by this Class object."
                }
              ]
            },
            {
              "name": "asSubclass",
              "overloads": [
                {
                  "signature": "public <U> Class<? extends U> asSubclass(Class<U> clazz)",
                  "description": "Casts this Class object to represent a subclass of the class\n represented by the specified class object.  Checks that the cast\n is valid, and throws a ClassCastException if it is not.  If\n this method succeeds, it always returns a reference to this Class object.\n\n This method is useful when a client needs to \"narrow\" the type of\n a Class object to pass it to an API that restricts the\n Class objects that it is willing to accept.  A cast would\n generate a compile-time warning, as the correctness of the cast\n could not be checked at runtime (because generic types are implemented\n by erasure)."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "isAnnotationPresent",
              "overloads": [
                {
                  "signature": "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
                  "description": "Returns true if an annotation for the specified type\n is present on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n The truth value returned by this method is equivalent to:\n getAnnotation(annotationClass) != null"
                }
              ]
            },
            {
              "name": "getAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns annotations that are associated with this element.\n\n If there are no annotations associated with this element, the return\n value is an array of length 0.\n\n The difference between this method and AnnotatedElement.getAnnotation(Class)\n is that this method detects if its argument is a repeatable\n annotation type (JLS 9.6), and if so, attempts to find one or\n more annotations of that type by \"looking through\" a container\n annotation.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.\n\n This method ignores inherited annotations. (Returns null if no\n annotations are directly present on this element.)\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns this element's annotation(s) for the specified type if\n such annotations are either directly present or\n indirectly present. This method ignores inherited\n annotations.\n\n If there are no specified annotations directly or indirectly\n present on this element, the return value is an array of length\n 0.\n\n The difference between this method and AnnotatedElement.getDeclaredAnnotation(Class) is that this method detects if its\n argument is a repeatable annotation type (JLS 9.6), and if so,\n attempts to find one or more annotations of that type by \"looking\n through\" a container annotation if one is present.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotatedSuperclass",
              "overloads": [
                {
                  "signature": "public AnnotatedType getAnnotatedSuperclass()",
                  "description": "Returns an AnnotatedType object that represents the use of a\n type to specify the superclass of the entity represented by this \n Class object. (The use of type Foo to specify the superclass\n in '...  extends Foo' is distinct from the declaration of class\n Foo.)\n\n  If this Class object represents a class whose declaration\n does not explicitly indicate an annotated superclass, then the return\n value is an AnnotatedType object representing an element with no\n annotations.\n\n  If this Class represents either the Object class, an\n interface type, an array type, a primitive type, or void, the return\n value is null."
                }
              ]
            },
            {
              "name": "getAnnotatedInterfaces",
              "overloads": [
                {
                  "signature": "public AnnotatedType[] getAnnotatedInterfaces()",
                  "description": "Returns an array of AnnotatedType objects that represent the use\n of types to specify superinterfaces of the entity represented by this\n Class object. (The use of type Foo to specify a\n superinterface in '... implements Foo' is distinct from the\n declaration of interface Foo.)\n\n  If this Class object represents a class, the return value is\n an array containing objects representing the uses of interface types to\n specify interfaces implemented by the class. The order of the objects in\n the array corresponds to the order of the interface types used in the\n 'implements' clause of the declaration of this Class object.\n\n  If this Class object represents an interface, the return\n value is an array containing objects representing the uses of interface\n types to specify interfaces directly extended by the interface. The\n order of the objects in the array corresponds to the order of the\n interface types used in the 'extends' clause of the declaration of this\n Class object.\n\n  If this Class object represents a class or interface whose\n declaration does not explicitly indicate any annotated superinterfaces,\n the return value is an array of length 0.\n\n  If this Class object represents either the Object\n class, an array type, a primitive type, or void, the return value is an\n array of length 0."
                }
              ]
            },
            {
              "name": "getNestHost",
              "overloads": [
                {
                  "signature": "public Class<?> getNestHost()",
                  "description": "Returns the nest host of the nest to which the class\n or interface represented by this Class object belongs.\n Every class and interface belongs to exactly one nest.\n\n If the nest host of this class or interface has previously\n been determined, then this method returns the nest host.\n If the nest host of this class or interface has\n not previously been determined, then this method determines the nest\n host using the algorithm of JVMS 5.4.4, and returns it.\n\n Often, a class or interface belongs to a nest consisting only of itself,\n in which case this method returns this to indicate that the class\n or interface is the nest host.\n\n If this Class object represents a primitive type, an array type,\n or void, then this method returns this,\n indicating that the represented entity belongs to the nest consisting only of\n itself, and is the nest host."
                }
              ]
            },
            {
              "name": "isNestmateOf",
              "overloads": [
                {
                  "signature": "public boolean isNestmateOf(Class<?> c)",
                  "description": "Determines if the given Class is a nestmate of the\n class or interface represented by this Class object.\n Two classes or interfaces are nestmates\n if they have the same nest host."
                }
              ]
            },
            {
              "name": "getNestMembers",
              "overloads": [
                {
                  "signature": "public Class<?>[] getNestMembers()",
                  "description": "Returns an array containing Class objects representing all the\n classes and interfaces that are members of the nest to which the class\n or interface represented by this Class object belongs.\n\n First, this method obtains the nest host,\n H, of the nest to which the class or interface represented by\n this Class object belongs. The zeroth element of the returned\n array is H.\n\n Then, for each class or interface C which is recorded by H\n as being a member of its nest, this method attempts to obtain the Class\n object for C (using the defining class\n loader of the current Class object), and then obtains the\n nest host of the nest to which C belongs.\n The classes and interfaces which are recorded by H as being members\n of its nest, and for which H can be determined as their nest host,\n are indicated by subsequent elements of the returned array. The order of\n such elements is unspecified. Duplicates are permitted.\n\n If this Class object represents a primitive type, an array type,\n or void, then this method returns a single-element array containing\n this."
                }
              ]
            },
            {
              "name": "descriptorString",
              "overloads": [
                {
                  "signature": "public String descriptorString()",
                  "description": "Returns the descriptor string of the entity (class, interface, array class,\n primitive type, or void) represented by this Class object.\n\n  If this Class object represents a class or interface,\n not an array class, then:\n \n  If the class or interface is not hidden,\n      then the result is a field descriptor (JVMS 4.3.2)\n      for the class or interface. Calling\n      ClassDesc::ofDescriptor\n      with the result descriptor string produces a ClassDesc\n      describing this class or interface.\n  If the class or interface is hidden,\n      then the result is a string of the form:\n      \n      \"L\" + N + \".\" + <suffix> + \";\"\n      \n      where N is the binary name\n      encoded in internal form indicated by the class file passed to\n      Lookup::defineHiddenClass, and <suffix> is an unqualified name.\n      A hidden class or interface has no nominal descriptor.\n      The result string is not a type descriptor.\n \n\n  If this Class object represents an array class, then\n the result is a string consisting of one or more '[' characters\n representing the depth of the array nesting, followed by the\n descriptor string of the element type.\n \n  If the element type is not a hidden class\n or interface, then this array class can be described nominally.\n Calling ClassDesc::ofDescriptor\n with the result descriptor string produces a ClassDesc\n describing this array class.\n  If the element type is a hidden class or\n interface, then this array class cannot be described nominally.\n The result string is not a type descriptor.\n \n\n  If this Class object represents a primitive type or\n void, then the result is a field descriptor string which\n is a one-letter code corresponding to a primitive type or void\n (\"B\", \"C\", \"D\", \"F\", \"I\", \"J\", \"S\", \"Z\", \"V\") (JVMS 4.3.2)."
                }
              ]
            },
            {
              "name": "componentType",
              "overloads": [
                {
                  "signature": "public Class<?> componentType()",
                  "description": "Returns the component type of this Class, if it describes\n an array type, or null otherwise."
                }
              ]
            },
            {
              "name": "arrayType",
              "overloads": [
                {
                  "signature": "public Class<?> arrayType()",
                  "description": "Returns a Class for an array type whose component type\n is described by this Class."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<ClassDesc> describeConstable()",
                  "description": "Returns a nominal descriptor for this instance, if one can be\n constructed, or an empty Optional if one cannot be."
                }
              ]
            },
            {
              "name": "isHidden",
              "overloads": [
                {
                  "signature": "public boolean isHidden()",
                  "description": "Returns true if and only if the underlying class is a hidden class."
                }
              ]
            },
            {
              "name": "getPermittedSubclasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getPermittedSubclasses()",
                  "description": "Returns an array containing Class objects representing the\n direct subinterfaces or subclasses permitted to extend or\n implement this class or interface if it is sealed.  The order of such elements\n is unspecified. The array is empty if this sealed class or interface has no\n permitted subclass. If this Class object represents a primitive type,\n void, an array type, or a class or interface that is not sealed,\n that is isSealed() returns false, then this method returns null.\n Conversely, if isSealed() returns true, then this method\n returns a non-null value.\n\n For each class or interface C which is recorded as a permitted\n direct subinterface or subclass of this class or interface,\n this method attempts to obtain the Class\n object for C (using the defining class\n loader of the current Class object).\n The Class objects which can be obtained and which are direct\n subinterfaces or subclasses of this class or interface,\n are indicated by elements of the returned array. If a Class object\n cannot be obtained, it is silently ignored, and not included in the result\n array."
                }
              ]
            },
            {
              "name": "isSealed",
              "overloads": [
                {
                  "signature": "public boolean isSealed()",
                  "description": "Returns true if and only if this Class object represents\n a sealed class or interface. If this Class object represents a\n primitive type, void, or an array type, this method returns\n false. A sealed class or interface has (possibly zero) permitted\n subclasses; getPermittedSubclasses() returns a non-null but\n possibly empty value for a sealed class or interface."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassCastException",
          "methods": [
            {
              "name": "ClassCastException",
              "overloads": [
                {
                  "signature": "public ClassCastException()",
                  "description": "Constructs a ClassCastException with no detail message."
                },
                {
                  "signature": "public ClassCastException(String s)",
                  "description": "Constructs a ClassCastException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassCircularityError",
          "methods": [
            {
              "name": "ClassCircularityError",
              "overloads": [
                {
                  "signature": "public ClassCircularityError()",
                  "description": "Constructs a ClassCircularityError with no detail message."
                },
                {
                  "signature": "public ClassCircularityError(String s)",
                  "description": "Constructs a ClassCircularityError with the specified detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassFormatError",
          "methods": [
            {
              "name": "ClassFormatError",
              "overloads": [
                {
                  "signature": "public ClassFormatError()",
                  "description": "Constructs a ClassFormatError with no detail message."
                },
                {
                  "signature": "public ClassFormatError(String s)",
                  "description": "Constructs a ClassFormatError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassLoader",
          "methods": [
            {
              "name": "ClassLoader",
              "overloads": [
                {
                  "signature": "protected ClassLoader(String name, ClassLoader parent)",
                  "description": "Creates a new class loader of the specified name and using the\n specified parent class loader for delegation."
                },
                {
                  "signature": "protected ClassLoader(ClassLoader parent)",
                  "description": "Creates a new class loader using the specified parent class loader for\n delegation.\n\n  If there is a security manager, its checkCreateClassLoader method\n is invoked.  This may result in a security exception."
                },
                {
                  "signature": "protected ClassLoader()",
                  "description": "Creates a new class loader using the ClassLoader returned by\n the method getSystemClassLoader() as the parent class loader.\n\n  If there is a security manager, its checkCreateClassLoader method is invoked.  This may result in\n a security exception."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of this class loader or null if\n this class loader is not named."
                }
              ]
            },
            {
              "name": "loadClass",
              "overloads": [
                {
                  "signature": "public Class<?> loadClass(String name) throws ClassNotFoundException",
                  "description": "Loads the class with the specified binary name.\n This method searches for classes in the same manner as the loadClass(String, boolean) method.  It is invoked by the Java virtual\n machine to resolve class references.  Invoking this method is equivalent\n to invoking loadClass(name,\n false)."
                },
                {
                  "signature": "protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException",
                  "description": "Loads the class with the specified binary name.  The\n default implementation of this method searches for classes in the\n following order:\n\n \n\n    Invoke findLoadedClass(String) to check if the class\n   has already been loaded.  \n\n    Invoke the loadClass method\n   on the parent class loader.  If the parent is null the class\n   loader built into the virtual machine is used, instead.  \n\n    Invoke the findClass(String) method to find the\n   class.  \n\n \n\n  If the class was found using the above steps, and the\n resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object.\n\n  Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method.  \n\n  Unless overridden, this method synchronizes on the result of\n getClassLoadingLock method\n during the entire class loading process."
                }
              ]
            },
            {
              "name": "getClassLoadingLock",
              "overloads": [
                {
                  "signature": "protected Object getClassLoadingLock(String className)",
                  "description": "Returns the lock object for class loading operations.\n For backward compatibility, the default implementation of this method\n behaves as follows. If this ClassLoader object is registered as\n parallel capable, the method returns a dedicated object associated\n with the specified class name. Otherwise, the method returns this\n ClassLoader object."
                }
              ]
            },
            {
              "name": "findClass",
              "overloads": [
                {
                  "signature": "protected Class<?> findClass(String name) throws ClassNotFoundException",
                  "description": "Finds the class with the specified binary name.\n This method should be overridden by class loader implementations that\n follow the delegation model for loading classes, and will be invoked by\n the loadClass method after checking the\n parent class loader for the requested class."
                },
                {
                  "signature": "protected Class<?> findClass(String moduleName, String name)",
                  "description": "Finds the class with the given binary name\n in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."
                }
              ]
            },
            {
              "name": "defineClass",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.  This method\n is deprecated in favor of the version that takes a binary name as its first argument, and is more secure.",
                  "deprecated": true
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.\n\n  This method assigns a default ProtectionDomain to the newly defined class.  The\n ProtectionDomain is effectively granted the same set of\n permissions returned when Policy.getPolicy().getPermissions(new CodeSource(null, null))\n is invoked.  The default protection domain is created on the first invocation\n of defineClass,\n and re-used on subsequent invocations.\n\n  To assign a specific ProtectionDomain to the class, use\n the defineClass method that takes a\n ProtectionDomain as one of its arguments.  \n\n \n This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class,\n with a given ProtectionDomain.\n\n  If the given ProtectionDomain is null,\n then a default protection domain will be assigned to the class as specified\n in the documentation for defineClass(String, byte[], int, int).\n Before the class can be used it must be resolved.\n\n  The first class defined in a package determines the exact set of\n certificates that all subsequent classes defined in that package must\n contain.  The set of certificates for a class is obtained from the\n CodeSource within the\n ProtectionDomain of the class.  Any classes added to that\n package must contain the same set of certificates or a\n SecurityException will be thrown.  Note that if\n name is null, this check is not performed.\n You should always pass in the binary name of the\n class you are defining as well as the bytes.  This ensures that the\n class you are defining is indeed the class you think it is.\n\n  If the specified name begins with \"java.\", it can\n only be defined by the platform class loader or its ancestors; otherwise SecurityException\n will be thrown.  If name is not null, it must be equal to\n the binary name of the class\n specified by the byte array b, otherwise a NoClassDefFoundError will be thrown.\n\n  This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) throws ClassFormatError",
                  "description": "Converts a ByteBuffer into an instance\n of class Class, with the given ProtectionDomain.\n If the given ProtectionDomain is null, then a default\n protection domain will be assigned to the class as\n specified in the documentation for defineClass(String, byte[], int, int).  Before the class can be used it must be resolved.\n\n The rules about the first class defined in a package determining the\n set of certificates for the package, the restrictions on class names,\n and the defined package of the class\n are identical to those specified in the documentation for defineClass(String, byte[], int, int, ProtectionDomain).\n\n  An invocation of this method of the form\n cl.defineClass(name,\n bBuffer, pd) yields exactly the same\n result as the statements\n\n \n ...\n byte[] temp = new byte[bBuffer.remaining()];\n     bBuffer.get(temp);\n     return cl.defineClass(name, temp, 0,\n temp.length, pd);"
                }
              ]
            },
            {
              "name": "resolveClass",
              "overloads": [
                {
                  "signature": "protected final void resolveClass(Class<?> c)",
                  "description": "Links the specified class.  This (misleadingly named) method may be\n used by a class loader to link a class.  If the class c has\n already been linked, then this method simply returns. Otherwise, the\n class is linked as described in the \"Execution\" chapter of\n The Java Language Specification."
                }
              ]
            },
            {
              "name": "findSystemClass",
              "overloads": [
                {
                  "signature": "protected final Class<?> findSystemClass(String name) throws ClassNotFoundException",
                  "description": "Finds a class with the specified binary name,\n loading it if necessary.\n\n  This method loads the class through the system class loader (see\n getSystemClassLoader()).  The Class object returned\n might have more than one ClassLoader associated with it.\n Subclasses of ClassLoader need not usually invoke this method,\n because most class loaders need to override just findClass(String)."
                }
              ]
            },
            {
              "name": "findLoadedClass",
              "overloads": [
                {
                  "signature": "protected final Class<?> findLoadedClass(String name)",
                  "description": "Returns the class with the given binary name if this\n loader has been recorded by the Java virtual machine as an initiating\n loader of a class with that binary name.  Otherwise\n null is returned."
                }
              ]
            },
            {
              "name": "setSigners",
              "overloads": [
                {
                  "signature": "protected final void setSigners(Class<?> c, Object[] signers)",
                  "description": "Sets the signers of a class.  This should be invoked after defining a\n class."
                }
              ]
            },
            {
              "name": "findResource",
              "overloads": [
                {
                  "signature": "protected URL findResource(String moduleName, String name) throws IOException",
                  "description": "Returns a URL to a resource in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."
                },
                {
                  "signature": "protected URL findResource(String name)",
                  "description": "Finds the resource with the given name. Class loader implementations\n should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally."
                }
              ]
            },
            {
              "name": "getResource",
              "overloads": [
                {
                  "signature": "public URL getResource(String name)",
                  "description": "Finds the resource with the given name.  A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a '/'-separated path name that\n identifies the resource. \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "getResources",
              "overloads": [
                {
                  "signature": "public Enumeration<URL> getResources(String name) throws IOException",
                  "description": "Finds all the resources with the given name. A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource. \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "resources",
              "overloads": [
                {
                  "signature": "public Stream<URL> resources(String name)",
                  "description": "Returns a stream whose elements are the URLs of all the resources with\n the given name. A resource is some data (images, audio, text, etc) that\n can be accessed by class code in a way that is independent of the\n location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource.\n\n  The resources will be located when the returned stream is evaluated.\n If the evaluation results in an IOException then the I/O\n exception is wrapped in an UncheckedIOException that is then\n thrown.\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "findResources",
              "overloads": [
                {
                  "signature": "protected Enumeration<URL> findResources(String name) throws IOException",
                  "description": "Returns an enumeration of URL objects\n representing all the resources with the given name. Class loader\n implementations should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally."
                }
              ]
            },
            {
              "name": "registerAsParallelCapable",
              "overloads": [
                {
                  "signature": "protected static boolean registerAsParallelCapable()",
                  "description": "Registers the caller as\n parallel capable.\n The registration succeeds if and only if all of the following\n conditions are met:\n \n  no instance of the caller has been created\n  all of the super classes (except class Object) of the caller are\n registered as parallel capable\n \n Note that once a class loader is registered as parallel capable, there\n is no way to change it back."
                }
              ]
            },
            {
              "name": "isRegisteredAsParallelCapable",
              "overloads": [
                {
                  "signature": "public final boolean isRegisteredAsParallelCapable()",
                  "description": "Returns true if this class loader is registered as\n parallel capable, otherwise\n false."
                }
              ]
            },
            {
              "name": "getSystemResource",
              "overloads": [
                {
                  "signature": "public static URL getSystemResource(String name)",
                  "description": "Find a resource of the specified name from the search path used to load\n classes.  This method locates the resource through the system class\n loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getSystemResources",
              "overloads": [
                {
                  "signature": "public static Enumeration<URL> getSystemResources(String name) throws IOException",
                  "description": "Finds all resources of the specified name from the search path used to\n load classes.  The resources thus found are returned as an\n Enumeration of URL objects.\n\n  The search order is described in the documentation for getSystemResource(String).  \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Returns an input stream for reading the specified resource.\n\n  The search order is described in the documentation for getResource(String).  \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getSystemResourceAsStream",
              "overloads": [
                {
                  "signature": "public static InputStream getSystemResourceAsStream(String name)",
                  "description": "Open for reading, a resource of the specified name from the search path\n used to load classes.  This method locates the resource through the\n system class loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public final ClassLoader getParent()",
                  "description": "Returns the parent class loader for delegation. Some implementations may\n use null to represent the bootstrap class loader. This method\n will return null in such implementations if this class loader's\n parent is the bootstrap class loader."
                }
              ]
            },
            {
              "name": "getUnnamedModule",
              "overloads": [
                {
                  "signature": "public final Module getUnnamedModule()",
                  "description": "Returns the unnamed Module for this class loader."
                }
              ]
            },
            {
              "name": "getPlatformClassLoader",
              "overloads": [
                {
                  "signature": "public static ClassLoader getPlatformClassLoader()",
                  "description": "Returns the platform class loader.  All\n platform classes are visible to\n the platform class loader."
                }
              ]
            },
            {
              "name": "getSystemClassLoader",
              "overloads": [
                {
                  "signature": "public static ClassLoader getSystemClassLoader()",
                  "description": "Returns the system class loader.  This is the default\n delegation parent for new ClassLoader instances, and is\n typically the class loader used to start the application.\n\n  This method is first invoked early in the runtime's startup\n sequence, at which point it creates the system class loader. This\n class loader will be the context class loader for the main application\n thread (for example, the thread that invokes the main method of\n the main class).\n\n  The default system class loader is an implementation-dependent\n instance of this class.\n\n  If the system property \"java.system.class.loader\"\n is defined when this method is first invoked then the value of that\n property is taken to be the name of a class that will be returned as the\n system class loader. The class is loaded using the default system class\n loader and must define a public constructor that takes a single parameter\n of type ClassLoader which is used as the delegation parent. An\n instance is then created using this constructor with the default system\n class loader as the parameter.  The resulting class loader is defined\n to be the system class loader. During construction, the class loader\n should take great care to avoid calling getSystemClassLoader().\n If circular initialization of the system class loader is detected then\n an IllegalStateException is thrown."
                }
              ]
            },
            {
              "name": "definePackage",
              "overloads": [
                {
                  "signature": "protected Package definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)",
                  "description": "Defines a package by name in this ClassLoader.\n \n Package names must be unique within a class loader and\n cannot be redefined or changed once created.\n \n If a class loader wishes to define a package with specific properties,\n such as version information, then the class loader should call this\n definePackage method before calling defineClass.\n Otherwise, the\n defineClass\n method will define a package in this class loader corresponding to the package\n of the newly defined class; the properties of this defined package are\n specified by Package."
                }
              ]
            },
            {
              "name": "getDefinedPackage",
              "overloads": [
                {
                  "signature": "public final Package getDefinedPackage(String name)",
                  "description": "Returns a Package of the given name that\n has been defined by this class loader."
                }
              ]
            },
            {
              "name": "getDefinedPackages",
              "overloads": [
                {
                  "signature": "public final Package[] getDefinedPackages()",
                  "description": "Returns all of the Packages that have been defined by\n this class loader.  The returned array has no duplicated Packages\n of the same name."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected Package getPackage(String name)",
                  "description": "Finds a package by name in this class loader and its ancestors.\n \n If this class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of\n this class loader are searched recursively (parent by parent)\n for a Package of the given name.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "protected Package[] getPackages()",
                  "description": "Returns all of the Packages that have been defined by\n this class loader and its ancestors.  The returned array may contain\n more than one Package object of the same package name, each\n defined by a different class loader in the class loader hierarchy."
                }
              ]
            },
            {
              "name": "findLibrary",
              "overloads": [
                {
                  "signature": "protected String findLibrary(String libname)",
                  "description": "Returns the absolute path name of a native library.  The VM invokes this\n method to locate the native libraries that belong to classes loaded with\n this class loader. If this method returns null, the VM\n searches the library along the path specified as the\n \"java.library.path\" property."
                }
              ]
            },
            {
              "name": "setDefaultAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setDefaultAssertionStatus(boolean enabled)",
                  "description": "Sets the default assertion status for this class loader.  This setting\n determines whether classes loaded by this class loader and initialized\n in the future will have assertions enabled or disabled by default.\n This setting may be overridden on a per-package or per-class basis by\n invoking setPackageAssertionStatus(String, boolean) or setClassAssertionStatus(String, boolean)."
                }
              ]
            },
            {
              "name": "setPackageAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setPackageAssertionStatus(String packageName, boolean enabled)",
                  "description": "Sets the package default assertion status for the named package.  The\n package default assertion status determines the assertion status for\n classes initialized in the future that belong to the named package or\n any of its \"subpackages\".\n\n  A subpackage of a package named p is any package whose name begins\n with \"p.\".  For example, javax.swing.text is a\n subpackage of javax.swing, and both java.util and\n java.lang.reflect are subpackages of java.\n\n  In the event that multiple package defaults apply to a given class,\n the package default pertaining to the most specific package takes\n precedence over the others.  For example, if javax.lang and\n javax.lang.reflect both have package defaults associated with\n them, the latter package default applies to classes in\n javax.lang.reflect.\n\n  Package defaults take precedence over the class loader's default\n assertion status, and may be overridden on a per-class basis by invoking\n setClassAssertionStatus(String, boolean)."
                }
              ]
            },
            {
              "name": "setClassAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setClassAssertionStatus(String className, boolean enabled)",
                  "description": "Sets the desired assertion status for the named top-level class in this\n class loader and any nested classes contained therein.  This setting\n takes precedence over the class loader's default assertion status, and\n over any applicable per-package default.  This method has no effect if\n the named class has already been initialized.  (Once a class is\n initialized, its assertion status cannot change.)\n\n  If the named class is not a top-level class, this invocation will\n have no effect on the actual assertion status of any class."
                }
              ]
            },
            {
              "name": "clearAssertionStatus",
              "overloads": [
                {
                  "signature": "public void clearAssertionStatus()",
                  "description": "Sets the default assertion status for this class loader to\n false and discards any package defaults or class assertion\n status settings associated with the class loader.  This method is\n provided so that class loaders can be made to ignore any command line or\n persistent assertion status settings and \"start with a clean slate.\""
                }
              ]
            }
          ]
        },
        {
          "name": "ClassNotFoundException",
          "methods": [
            {
              "name": "ClassNotFoundException",
              "overloads": [
                {
                  "signature": "public ClassNotFoundException()",
                  "description": "Constructs a ClassNotFoundException with no detail message."
                },
                {
                  "signature": "public ClassNotFoundException(String s)",
                  "description": "Constructs a ClassNotFoundException with the\n specified detail message."
                },
                {
                  "signature": "public ClassNotFoundException(String s, Throwable ex)",
                  "description": "Constructs a ClassNotFoundException with the\n specified detail message and optional exception that was\n raised while loading the class."
                }
              ]
            },
            {
              "name": "getException",
              "overloads": [
                {
                  "signature": "public Throwable getException()",
                  "description": "Returns the exception that was raised if an error occurred while\n attempting to load the class. Otherwise, returns null."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassValue<T>",
          "methods": [
            {
              "name": "ClassValue",
              "overloads": [
                {
                  "signature": "protected ClassValue()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "computeValue",
              "overloads": [
                {
                  "signature": "protected abstract T computeValue(Class<?> type)",
                  "description": "Computes the given class's derived value for this ClassValue.\n \n This method will be invoked within the first thread that accesses\n the value with the get method.\n \n Normally, this method is invoked at most once per class,\n but it may be invoked again if there has been a call to\n remove.\n \n If this method throws an exception, the corresponding call to get\n will terminate abnormally with that exception, and no class value will be recorded."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public T get(Class<?> type)",
                  "description": "Returns the value for the given class.\n If no value has yet been computed, it is obtained by\n an invocation of the computeValue method.\n \n The actual installation of the value on the class\n is performed atomically.\n At that point, if several racing threads have\n computed values, one is chosen, and returned to\n all the racing threads.\n \n The type parameter is typically a class, but it may be any type,\n such as an interface, a primitive type (like int.class), or void.class.\n \n In the absence of remove calls, a class value has a simple\n state diagram:  uninitialized and initialized.\n When remove calls are made,\n the rules for value observation are more complex.\n See the documentation for remove for more information."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public void remove(Class<?> type)",
                  "description": "Removes the associated value for the given class.\n If this value is subsequently read for the same class,\n its value will be reinitialized by invoking its computeValue method.\n This may result in an additional invocation of the\n computeValue method for the given class.\n \n In order to explain the interaction between get and remove calls,\n we must model the state transitions of a class value to take into account\n the alternation between uninitialized and initialized states.\n To do this, number these states sequentially from zero, and note that\n uninitialized (or removed) states are numbered with even numbers,\n while initialized (or re-initialized) states have odd numbers.\n \n When a thread T removes a class value in state 2N,\n nothing happens, since the class value is already uninitialized.\n Otherwise, the state is advanced atomically to 2N+1.\n \n When a thread T queries a class value in state 2N,\n the thread first attempts to initialize the class value to state 2N+1\n by invoking computeValue and installing the resulting value.\n \n When T attempts to install the newly computed value,\n if the state is still at 2N, the class value will be initialized\n with the computed value, advancing it to state 2N+1.\n \n Otherwise, whether the new state is even or odd,\n T will discard the newly computed value\n and retry the get operation.\n \n Discarding and retrying is an important proviso,\n since otherwise T could potentially install\n a disastrously stale value.  For example:\n \n T calls CV.get(C) and sees state 2N\n T quickly computes a time-dependent value V0 and gets ready to install it\n T is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\n ...meanwhile, T2 also calls CV.get(C) and sees state 2N\n T2 quickly computes a similar time-dependent value V1 and installs it on CV.get(C)\n T2 (or a third thread) then calls CV.remove(C), undoing T2's work\n  the previous actions of T2 are repeated several times\n  also, the relevant computed values change over time: V1, V2, ...\n ...meanwhile, T wakes up and attempts to install V0; this must fail\n \n We can assume in the above scenario that CV.computeValue uses locks to properly\n observe the time-dependent states as it computes V1, etc.\n This does not remove the threat of a stale value, since there is a window of time\n between the return of computeValue in T and the installation\n of the new value.  No user synchronization is possible during this time."
                }
              ]
            }
          ]
        },
        {
          "name": "Cloneable",
          "methods": []
        },
        {
          "name": "CloneNotSupportedException",
          "methods": [
            {
              "name": "CloneNotSupportedException",
              "overloads": [
                {
                  "signature": "public CloneNotSupportedException()",
                  "description": "Constructs a CloneNotSupportedException with no\n detail message."
                },
                {
                  "signature": "public CloneNotSupportedException(String s)",
                  "description": "Constructs a CloneNotSupportedException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Comparable<T>",
          "methods": [
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "int compareTo(T o)",
                  "description": "Compares this object with the specified object for order.  Returns a\n negative integer, zero, or a positive integer as this object is less\n than, equal to, or greater than the specified object.\n\n The implementor must ensure signum(x.compareTo(y)) == -signum(y.compareTo(x)) for\n all x and y.  (This implies that \n x.compareTo(y) must throw an exception if and only if \n y.compareTo(x) throws an exception.)\n\n The implementor must also ensure that the relation is transitive:\n (x.compareTo(y) > 0 && y.compareTo(z) > 0) implies\n x.compareTo(z) > 0.\n\n Finally, the implementor must ensure that \n x.compareTo(y)==0 implies that signum(x.compareTo(z))\n == signum(y.compareTo(z)), for all z."
                }
              ]
            }
          ]
        },
        {
          "name": "Compiler",
          "methods": [
            {
              "name": "compileClass",
              "overloads": [
                {
                  "signature": "public static boolean compileClass(Class<?> clazz)",
                  "description": "Compiles the specified class.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "compileClasses",
              "overloads": [
                {
                  "signature": "public static boolean compileClasses(String string)",
                  "description": "Compiles all classes whose name matches the specified string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "public static Object command(Object any)",
                  "description": "Examines the argument type and its fields and perform some documented\n operation.  No specific operations are required.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "enable",
              "overloads": [
                {
                  "signature": "public static void enable()",
                  "description": "Cause the Compiler to resume operation.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "disable",
              "overloads": [
                {
                  "signature": "public static void disable()",
                  "description": "Cause the Compiler to cease operation.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Double",
          "methods": [
            {
              "name": "Double",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Double(double value)",
                  "description": "Constructs a newly allocated Double object that\n represents the primitive double argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Double(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Double object that\n represents the floating-point value of type double\n represented by the string. The string is converted to a\n double value as if by the valueOf method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(double d)",
                  "description": "Returns a string representation of the double\n argument. All characters mentioned below are ASCII characters.\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign character\n appears in the result. As for the magnitude m:\n \n If m is infinity, it is represented by the characters\n \"Infinity\"; thus, positive infinity produces the result\n \"Infinity\" and negative infinity produces the result\n \"-Infinity\".\n\n If m is zero, it is represented by the characters\n \"0.0\"; thus, negative zero produces the result\n \"-0.0\" and positive zero produces the result\n \"0.0\".\n\n If m is greater than or equal to 10-3 but less\n than 107, then it is represented as the integer part of\n m, in decimal form with no leading zeroes, followed by\n '.' ('\\u002E'), followed by one or\n more decimal digits representing the fractional part of m.\n\n If m is less than 10-3 or greater than or\n equal to 107, then it is represented in so-called\n \"computerized scientific notation.\" Let n be the unique\n integer such that 10n  m <\n 10n+1; then let a be the\n mathematically exact quotient of m and\n 10n so that 1  a < 10. The\n magnitude is then represented as the integer part of a,\n as a single decimal digit, followed by '.'\n ('\\u002E'), followed by decimal digits\n representing the fractional part of a, followed by the\n letter 'E' ('\\u0045'), followed\n by a representation of n as a decimal integer, as\n produced by the method Integer.toString(int).\n \n \n How many digits must be printed for the fractional part of\n m or a? There must be at least one digit to represent\n the fractional part, and beyond that as many, but only as many, more\n digits as are needed to uniquely distinguish the argument value from\n adjacent values of type double. That is, suppose that\n x is the exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero argument\n d. Then d must be the double value nearest\n to x; or if two double values are equally close\n to x, then d must be one of them and the least\n significant bit of the significand of d must be 0.\n\n To create localized string representations of a floating-point\n value, use subclasses of NumberFormat."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Double object.\n The primitive double value represented by this\n object is converted to a string exactly as if by the method\n toString of one argument."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(double d)",
                  "description": "Returns a hexadecimal string representation of the\n double argument. All characters mentioned below\n are ASCII characters.\n\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign\n and magnitude of the argument. If the sign is negative, the\n first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign\n character appears in the result. As for the magnitude m:\n\n \n If m is infinity, it is represented by the string\n \"Infinity\"; thus, positive infinity produces the\n result \"Infinity\" and negative infinity produces\n the result \"-Infinity\".\n\n If m is zero, it is represented by the string\n \"0x0.0p0\"; thus, negative zero produces the result\n \"-0x0.0p0\" and positive zero produces the result\n \"0x0.0p0\".\n\n If m is a double value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters \"0x1.\"\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by \"p\" followed\n by a decimal string of the unbiased exponent as if produced by\n a call to Integer.toString on the\n exponent value.\n\n If m is a double value with a subnormal\n representation, the significand is represented by the\n characters \"0x0.\" followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n \"p-1022\".  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \n\n \n\n \n Examples\n \n Floating-point ValueHexadecimal String\n \n \n 1.0 0x1.0p0\n -1.0        -0x1.0p0\n 2.0 0x1.0p1\n 3.0 0x1.8p1\n 0.5 0x1.0p-1\n 0.25        0x1.0p-2\n Double.MAX_VALUE\n     0x1.fffffffffffffp1023\n Minimum Normal Value\n     0x1.0p-1022\n Maximum Subnormal Value\n     0x0.fffffffffffffp-1022\n Double.MIN_VALUE\n     0x0.0000000000001p-1022"
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Double valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Double object holding the\n double value represented by the argument string\n s.\n\n If s is null, then a\n NullPointerException is thrown.\n\n Leading and trailing whitespace characters in s\n are ignored.  Whitespace is removed as if by the String.trim() method; that is, both ASCII space and control\n characters are removed. The rest of s should\n constitute a FloatValue as described by the lexical\n syntax rules:\n\n \n \n FloatValue:\n Signopt NaN\n Signopt Infinity\n Signopt FloatingPointLiteral\n Signopt HexFloatingPointLiteral\n SignedInteger\n \n\n \n HexFloatingPointLiteral:\n  HexSignificand BinaryExponent FloatTypeSuffixopt\n \n\n \n HexSignificand:\n HexNumeral\n HexNumeral .\n 0x HexDigitsopt\n     . HexDigits\n 0X HexDigitsopt\n     . HexDigits\n \n\n \n BinaryExponent:\n BinaryExponentIndicator SignedInteger\n \n\n \n BinaryExponentIndicator:\n p\n P\n \n\n \n\n where Sign, FloatingPointLiteral,\n HexNumeral, HexDigits, SignedInteger and\n FloatTypeSuffix are as defined in the lexical structure\n sections of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n If s does not have the form of\n a FloatValue, then a NumberFormatException\n is thrown. Otherwise, s is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type double\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of s is large\n enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2),\n rounding to double will result in an infinity and if the\n exact value of s is small enough in magnitude (less\n than or equal to MIN_VALUE/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a Double object representing\n this double value is returned.\n\n  To interpret localized string representations of a\n floating-point value, use subclasses of NumberFormat.\n\n Note that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n (1.0f is a float value;\n 1.0d is a double value), do\n not influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  The two-step\n sequence of conversions, string to float followed\n by float to double, is not\n equivalent to converting a string directly to\n double. For example, the float\n literal 0.1f is equal to the double\n value 0.10000000149011612; the float\n literal 0.1f represents a different numerical\n value than the double literal\n 0.1. (The numerical value 0.1 cannot be exactly\n represented in a binary floating-point number.)\n\n To avoid calling this method on an invalid string and having\n a NumberFormatException be thrown, the regular\n expression below can be used to screen the input string:\n\n \n  final String Digits     = \"(\\\\p{Digit}+)\";\n  final String HexDigits  = \"(\\\\p{XDigit}+)\";\n  // an exponent is 'e' or 'E' followed by an optionally\n  // signed decimal integer.\n  final String Exp        = \"[eE][+-]?\"+Digits;\n  final String fpRegex    =\n      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n       \"[+-]?(\" + // Optional sign character\n       \"NaN|\" +           // \"NaN\" string\n       \"Infinity|\" +      // \"Infinity\" string\n\n       // A decimal floating-point string representing a finite positive\n       // number without a leading sign has at most five basic pieces:\n       // Digits . Digits ExponentPart FloatTypeSuffix\n       //\n       // Since this method allows integer-only strings as input\n       // in addition to strings of floating-point literals, the\n       // two sub-patterns below are simplifications of the grammar\n       // productions from section 3.10.2 of\n       // The Java Language Specification.\n\n       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n\n       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n\n       // Hexadecimal strings\n       \"((\" +\n        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n\n        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n\n        \")[pP][+-]?\" + Digits + \"))\" +\n       \"[fFdD]?))\" +\n       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n\n  if (Pattern.matches(fpRegex, myString))\n      Double.valueOf(myString); // Will not throw NumberFormatException\n  else {\n      // Perform suitable alternative action\n  }"
                },
                {
                  "signature": "public static Double valueOf(double d)",
                  "description": "Returns a Double instance representing the specified\n double value.\n If a new Double instance is not required, this method\n should generally be used in preference to the constructor\n Double(double), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values."
                }
              ]
            },
            {
              "name": "parseDouble",
              "overloads": [
                {
                  "signature": "public static double parseDouble(String s) throws NumberFormatException",
                  "description": "Returns a new double initialized to the value\n represented by the specified String, as performed\n by the valueOf method of class\n Double."
                }
              ]
            },
            {
              "name": "isNaN",
              "overloads": [
                {
                  "signature": "public static boolean isNaN(double v)",
                  "description": "Returns true if the specified number is a\n Not-a-Number (NaN) value, false otherwise."
                },
                {
                  "signature": "public boolean isNaN()",
                  "description": "Returns true if this Double value is\n a Not-a-Number (NaN), false otherwise."
                }
              ]
            },
            {
              "name": "isInfinite",
              "overloads": [
                {
                  "signature": "public static boolean isInfinite(double v)",
                  "description": "Returns true if the specified number is infinitely\n large in magnitude, false otherwise."
                },
                {
                  "signature": "public boolean isInfinite()",
                  "description": "Returns true if this Double value is\n infinitely large in magnitude, false otherwise."
                }
              ]
            },
            {
              "name": "isFinite",
              "overloads": [
                {
                  "signature": "public static boolean isFinite(double d)",
                  "description": "Returns true if the argument is a finite floating-point\n value; returns false otherwise (for NaN and infinity\n arguments)."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Double as a byte\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Double as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Double as an int\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Double as a long\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Double as a float\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the double value of this Double object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Double object. The\n result is the exclusive OR of the two halves of the\n long integer bit representation, exactly as\n produced by the method doubleToLongBits(double), of\n the primitive double value represented by this\n Double object. That is, the hash code is the value\n of the expression:\n\n \n  (int)(v^(v>>>32))\n \n\n where v is defined by:\n\n \n  long v = Double.doubleToLongBits(this.doubleValue());"
                },
                {
                  "signature": "public static int hashCode(double value)",
                  "description": "Returns a hash code for a double value; compatible with\n Double.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.  The result\n is true if and only if the argument is not\n null and is a Double object that\n represents a double that has the same value as the\n double represented by this object. For this\n purpose, two double values are considered to be\n the same if and only if the method doubleToLongBits(double) returns the identical\n long value when applied to each."
                }
              ]
            },
            {
              "name": "doubleToLongBits",
              "overloads": [
                {
                  "signature": "public static long doubleToLongBits(double value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout.\n\n Bit 63 (the bit that is selected by the mask\n 0x8000000000000000L) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n 0x7ff0000000000000L) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n 0x000fffffffffffffL) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7ff0000000000000L.\n\n If the argument is negative infinity, the result is\n 0xfff0000000000000L.\n\n If the argument is NaN, the result is\n 0x7ff8000000000000L.\n\n In all cases, the result is a long integer that, when\n given to the longBitsToDouble(long) method, will produce a\n floating-point value the same as the argument to\n doubleToLongBits (except all NaN values are\n collapsed to a single \"canonical\" NaN value)."
                }
              ]
            },
            {
              "name": "doubleToRawLongBits",
              "overloads": [
                {
                  "signature": "public static long doubleToRawLongBits(double value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout, preserving Not-a-Number (NaN) values.\n\n Bit 63 (the bit that is selected by the mask\n 0x8000000000000000L) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n 0x7ff0000000000000L) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n 0x000fffffffffffffL) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7ff0000000000000L.\n\n If the argument is negative infinity, the result is\n 0xfff0000000000000L.\n\n If the argument is NaN, the result is the long\n integer representing the actual NaN value.  Unlike the\n doubleToLongBits method,\n doubleToRawLongBits does not collapse all the bit\n patterns encoding a NaN to a single \"canonical\" NaN\n value.\n\n In all cases, the result is a long integer that,\n when given to the longBitsToDouble(long) method, will\n produce a floating-point value the same as the argument to\n doubleToRawLongBits."
                }
              ]
            },
            {
              "name": "longBitsToDouble",
              "overloads": [
                {
                  "signature": "public static double longBitsToDouble(long bits)",
                  "description": "Returns the double value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"double format\" bit layout.\n\n If the argument is 0x7ff0000000000000L, the result\n is positive infinity.\n\n If the argument is 0xfff0000000000000L, the result\n is negative infinity.\n\n If the argument is any value in the range\n 0x7ff0000000000001L through\n 0x7fffffffffffffffL or in the range\n 0xfff0000000000001L through\n 0xffffffffffffffffL, the result is a NaN.  No IEEE\n 754 floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the Double.doubleToRawLongBits method.\n\n In all other cases, let s, e, and m be three\n values that can be computed from the argument:\n\n \n int s = ((bits >> 63) == 0) ? 1 : -1;\n int e = (int)((bits >> 52) & 0x7ffL);\n long m = (e == 0) ?\n                 (bits & 0xfffffffffffffL) << 1 :\n                 (bits & 0xfffffffffffffL) | 0x10000000000000L;\n \n\n Then the floating-point result equals the value of the mathematical\n expression sm2e-1075.\n\n Note that this method may not be able to return a\n double NaN with exactly same bit pattern as the\n long argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and signaling NaNs.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method\n may perform this conversion.  So longBitsToDouble\n may not be able to return a double with a\n signaling NaN bit pattern.  Consequently, for some\n long values,\n doubleToRawLongBits(longBitsToDouble(start)) may\n not equal start.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Double anotherDouble)",
                  "description": "Compares two Double objects numerically.\n\n This method imposes a total order on Double objects\n with two differences compared to the incomplete order defined by\n the Java language numerical comparison operators (<, <=,\n ==, >=, >) on double values.\n\n  A NaN is unordered with respect to other\n          values and unequal to itself under the comparison\n          operators.  This method chooses to define \n          Double.NaN to be equal to itself and greater than all\n          other double values (including \n          Double.POSITIVE_INFINITY).\n\n       Positive zero and negative zero compare equal\n      numerically, but are distinct and distinguishable values.\n      This method chooses to define positive zero (+0.0d),\n      to be greater than negative zero (-0.0d).\n \n\n This ensures that the natural ordering of Double\n objects imposed by this method is consistent with\n equals; see this\n discussion for details of floating-point comparison and\n ordering."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(double d1, double d2)",
                  "description": "Compares the two specified double values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n     new Double(d1).compareTo(new Double(d2))"
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static double sum(double a, double b)",
                  "description": "Adds two double values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Double> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Double resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Enum.EnumDesc<E",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> Enum.EnumDesc<E> of(ClassDesc enumClass, String constantName)",
                  "description": "Returns a nominal descriptor for the specified enum class and name"
                }
              ]
            }
          ]
        },
        {
          "name": "Enum<E",
          "methods": [
            {
              "name": "Enum",
              "overloads": [
                {
                  "signature": "protected Enum(String name, int ordinal)",
                  "description": "Sole constructor.  Programmers cannot invoke this constructor.\n It is for use by code emitted by the compiler in response to\n enum class declarations."
                }
              ]
            },
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "public final String name()",
                  "description": "Returns the name of this enum constant, exactly as declared in its\n enum declaration.\n\n Most programmers should use the toString() method in\n preference to this one, as the toString method may return\n a more user-friendly name.  This method is designed primarily for\n use in specialized situations where correctness depends on getting the\n exact name, which will not vary from release to release."
                }
              ]
            },
            {
              "name": "ordinal",
              "overloads": [
                {
                  "signature": "public final int ordinal()",
                  "description": "Returns the ordinal of this enumeration constant (its position\n in its enum declaration, where the initial constant is assigned\n an ordinal of zero).\n\n Most programmers will have no use for this method.  It is\n designed for use by sophisticated enum-based data structures, such\n as EnumSet and EnumMap."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the name of this enum constant, as contained in the\n declaration.  This method may be overridden, though it typically\n isn't necessary or desirable.  An enum class should override this\n method when a more \"programmer-friendly\" string form exists."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object other)",
                  "description": "Returns true if the specified object is equal to this\n enum constant."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hash code for this enum constant."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected final Object clone() throws CloneNotSupportedException",
                  "description": "Throws CloneNotSupportedException.  This guarantees that enums\n are never cloned, which is necessary to preserve their \"singleton\"\n status."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public final int compareTo(E o)",
                  "description": "Compares this enum with the specified object for order.  Returns a\n negative integer, zero, or a positive integer as this object is less\n than, equal to, or greater than the specified object.\n\n Enum constants are only comparable to other enum constants of the\n same enum type.  The natural order implemented by this\n method is the order in which the constants are declared."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "public final Class<E> getDeclaringClass()",
                  "description": "Returns the Class object corresponding to this enum constant's\n enum type.  Two enum constants e1 and  e2 are of the\n same enum type if and only if\n   e1.getDeclaringClass() == e2.getDeclaringClass().\n (The value returned by this method may differ from the one returned\n by the Object.getClass() method for enum constants with\n constant-specific class bodies.)"
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public final Optional<Enum.EnumDesc<E>> describeConstable()",
                  "description": "Returns an enum descriptor EnumDesc for this instance, if one can be\n constructed, or an empty Optional if one cannot be."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static <T extends Enum<T>> T valueOf(Class<T> enumClass, String name)",
                  "description": "Returns the enum constant of the specified enum class with the\n specified name.  The name must match exactly an identifier used\n to declare an enum constant in this class.  (Extraneous whitespace\n characters are not permitted.)\n\n Note that for a particular enum class T, the\n implicitly declared public static T valueOf(String)\n method on that enum may be used instead of this method to map\n from a name to the corresponding enum constant.  All the\n constants of an enum class can be obtained by calling the\n implicit public static T[] values() method of that\n class."
                }
              ]
            },
            {
              "name": "finalize",
              "overloads": [
                {
                  "signature": "protected final void finalize()",
                  "description": "enum classes cannot have finalize methods."
                }
              ]
            }
          ]
        },
        {
          "name": "EnumConstantNotPresentException",
          "methods": [
            {
              "name": "EnumConstantNotPresentException",
              "overloads": [
                {
                  "signature": "public EnumConstantNotPresentException(Class<? extends Enum> enumType, String constantName)",
                  "description": "Constructs an EnumConstantNotPresentException for the\n specified constant."
                }
              ]
            },
            {
              "name": "enumType",
              "overloads": [
                {
                  "signature": "public Class<? extends Enum> enumType()",
                  "description": "Returns the type of the missing enum constant."
                }
              ]
            },
            {
              "name": "constantName",
              "overloads": [
                {
                  "signature": "public String constantName()",
                  "description": "Returns the name of the missing enum constant."
                }
              ]
            }
          ]
        },
        {
          "name": "Error",
          "methods": [
            {
              "name": "Error",
              "overloads": [
                {
                  "signature": "public Error()",
                  "description": "Constructs a new error with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Error(String message)",
                  "description": "Constructs a new error with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Error(String message, Throwable cause)",
                  "description": "Constructs a new error with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this error's detail message."
                },
                {
                  "signature": "public Error(Throwable cause)",
                  "description": "Constructs a new error with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for errors that are little more than\n wrappers for other throwables."
                },
                {
                  "signature": "protected Error(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new error with the specified detail message,\n cause, suppression enabled or disabled, and writable stack\n trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "Exception",
          "methods": [
            {
              "name": "Exception",
              "overloads": [
                {
                  "signature": "public Exception()",
                  "description": "Constructs a new exception with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Exception(String message)",
                  "description": "Constructs a new exception with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Exception(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this exception's detail message."
                },
                {
                  "signature": "public Exception(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                },
                {
                  "signature": "protected Exception(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new exception with the specified detail message,\n cause, suppression enabled or disabled, and writable stack\n trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "ExceptionInInitializerError",
          "methods": [
            {
              "name": "ExceptionInInitializerError",
              "overloads": [
                {
                  "signature": "public ExceptionInInitializerError()",
                  "description": "Constructs an ExceptionInInitializerError with\n null as its detail message string and with no saved\n throwable object.\n A detail message is a String that describes this particular exception."
                },
                {
                  "signature": "public ExceptionInInitializerError(Throwable thrown)",
                  "description": "Constructs a new ExceptionInInitializerError class by\n saving a reference to the Throwable object thrown for\n later retrieval by the getException() method. The detail\n message string is set to null."
                },
                {
                  "signature": "public ExceptionInInitializerError(String s)",
                  "description": "Constructs an ExceptionInInitializerError with the specified detail\n message string.  A detail message is a String that describes this\n particular exception. The detail message string is saved for later\n retrieval by the Throwable.getMessage() method. There is no\n saved throwable object."
                }
              ]
            },
            {
              "name": "getException",
              "overloads": [
                {
                  "signature": "public Throwable getException()",
                  "description": "Returns the exception that occurred during a static initialization that\n caused this error to be created."
                }
              ]
            }
          ]
        },
        {
          "name": "Float",
          "methods": [
            {
              "name": "Float",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(float value)",
                  "description": "Constructs a newly allocated Float object that\n represents the primitive float argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(double value)",
                  "description": "Constructs a newly allocated Float object that\n represents the argument converted to type float.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Float object that\n represents the floating-point value of type float\n represented by the string. The string is converted to a\n float value as if by the valueOf method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(float f)",
                  "description": "Returns a string representation of the float\n argument. All characters mentioned below are ASCII characters.\n \n If the argument is NaN, the result is the string\n \"NaN\".\n Otherwise, the result is a string that represents the sign and\n     magnitude (absolute value) of the argument. If the sign is\n     negative, the first character of the result is\n     '-' ('\\u002D'); if the sign is\n     positive, no sign character appears in the result. As for\n     the magnitude m:\n \n If m is infinity, it is represented by the characters\n     \"Infinity\"; thus, positive infinity produces\n     the result \"Infinity\" and negative infinity\n     produces the result \"-Infinity\".\n If m is zero, it is represented by the characters\n     \"0.0\"; thus, negative zero produces the result\n     \"-0.0\" and positive zero produces the result\n     \"0.0\".\n  If m is greater than or equal to 10-3 but\n      less than 107, then it is represented as the\n      integer part of m, in decimal form with no leading\n      zeroes, followed by '.'\n      ('\\u002E'), followed by one or more\n      decimal digits representing the fractional part of\n      m.\n  If m is less than 10-3 or greater than or\n      equal to 107, then it is represented in\n      so-called \"computerized scientific notation.\" Let n\n      be the unique integer such that 10n \n      m < 10n+1; then let a\n      be the mathematically exact quotient of m and\n      10n so that 1  a < 10.\n      The magnitude is then represented as the integer part of\n      a, as a single decimal digit, followed by\n      '.' ('\\u002E'), followed by\n      decimal digits representing the fractional part of\n      a, followed by the letter 'E'\n      ('\\u0045'), followed by a representation\n      of n as a decimal integer, as produced by the\n      method Integer.toString(int).\n\n \n \n How many digits must be printed for the fractional part of\n m or a? There must be at least one digit\n to represent the fractional part, and beyond that as many, but\n only as many, more digits as are needed to uniquely distinguish\n the argument value from adjacent values of type\n float. That is, suppose that x is the\n exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero\n argument f. Then f must be the float\n value nearest to x; or, if two float values are\n equally close to x, then f must be one of\n them and the least significant bit of the significand of\n f must be 0.\n\n To create localized string representations of a floating-point\n value, use subclasses of NumberFormat."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Float object.\n The primitive float value represented by this object\n is converted to a String exactly as if by the method\n toString of one argument."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(float f)",
                  "description": "Returns a hexadecimal string representation of the\n float argument. All characters mentioned below are\n ASCII characters.\n\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign character\n appears in the result. As for the magnitude m:\n\n \n If m is infinity, it is represented by the string\n \"Infinity\"; thus, positive infinity produces the\n result \"Infinity\" and negative infinity produces\n the result \"-Infinity\".\n\n If m is zero, it is represented by the string\n \"0x0.0p0\"; thus, negative zero produces the result\n \"-0x0.0p0\" and positive zero produces the result\n \"0x0.0p0\".\n\n If m is a float value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters \"0x1.\"\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by \"p\" followed\n by a decimal string of the unbiased exponent as if produced by\n a call to Integer.toString on the\n exponent value.\n\n If m is a float value with a subnormal\n representation, the significand is represented by the\n characters \"0x0.\" followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n \"p-126\".  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \n\n \n\n \n Examples\n \n Floating-point ValueHexadecimal String\n \n \n 1.0 0x1.0p0\n -1.0        -0x1.0p0\n 2.0 0x1.0p1\n 3.0 0x1.8p1\n 0.5 0x1.0p-1\n 0.25        0x1.0p-2\n Float.MAX_VALUE\n     0x1.fffffep127\n Minimum Normal Value\n     0x1.0p-126\n Maximum Subnormal Value\n     0x0.fffffep-126\n Float.MIN_VALUE\n     0x0.000002p-126"
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Float valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Float object holding the\n float value represented by the argument string\n s.\n\n If s is null, then a\n NullPointerException is thrown.\n\n Leading and trailing whitespace characters in s\n are ignored.  Whitespace is removed as if by the String.trim() method; that is, both ASCII space and control\n characters are removed. The rest of s should\n constitute a FloatValue as described by the lexical\n syntax rules:\n\n \n \n FloatValue:\n Signopt NaN\n Signopt Infinity\n Signopt FloatingPointLiteral\n Signopt HexFloatingPointLiteral\n SignedInteger\n \n\n \n HexFloatingPointLiteral:\n  HexSignificand BinaryExponent FloatTypeSuffixopt\n \n\n \n HexSignificand:\n HexNumeral\n HexNumeral .\n 0x HexDigitsopt\n     . HexDigits\n 0X HexDigitsopt\n     . HexDigits\n \n\n \n BinaryExponent:\n BinaryExponentIndicator SignedInteger\n \n\n \n BinaryExponentIndicator:\n p\n P\n \n\n \n\n where Sign, FloatingPointLiteral,\n HexNumeral, HexDigits, SignedInteger and\n FloatTypeSuffix are as defined in the lexical structure\n sections of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n If s does not have the form of\n a FloatValue, then a NumberFormatException\n is thrown. Otherwise, s is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type float\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of s is large\n enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2),\n rounding to float will result in an infinity and if the\n exact value of s is small enough in magnitude (less\n than or equal to MIN_VALUE/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a Float object representing\n this float value is returned.\n\n To interpret localized string representations of a\n floating-point value, use subclasses of NumberFormat.\n\n Note that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n (1.0f is a float value;\n 1.0d is a double value), do\n not influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  In general, the\n two-step sequence of conversions, string to double\n followed by double to float, is\n not equivalent to converting a string directly to\n float.  For example, if first converted to an\n intermediate double and then to\n float, the string\n \"1.00000017881393421514957253748434595763683319091796875001d\"\n results in the float value\n 1.0000002f; if the string is converted directly to\n float, 1.0000001f results.\n\n To avoid calling this method on an invalid string and having\n a NumberFormatException be thrown, the documentation\n for Double.valueOf lists a regular\n expression which can be used to screen the input."
                },
                {
                  "signature": "public static Float valueOf(float f)",
                  "description": "Returns a Float instance representing the specified\n float value.\n If a new Float instance is not required, this method\n should generally be used in preference to the constructor\n Float(float), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values."
                }
              ]
            },
            {
              "name": "parseFloat",
              "overloads": [
                {
                  "signature": "public static float parseFloat(String s) throws NumberFormatException",
                  "description": "Returns a new float initialized to the value\n represented by the specified String, as performed\n by the valueOf method of class Float."
                }
              ]
            },
            {
              "name": "isNaN",
              "overloads": [
                {
                  "signature": "public static boolean isNaN(float v)",
                  "description": "Returns true if the specified number is a\n Not-a-Number (NaN) value, false otherwise."
                },
                {
                  "signature": "public boolean isNaN()",
                  "description": "Returns true if this Float value is a\n Not-a-Number (NaN), false otherwise."
                }
              ]
            },
            {
              "name": "isInfinite",
              "overloads": [
                {
                  "signature": "public static boolean isInfinite(float v)",
                  "description": "Returns true if the specified number is infinitely\n large in magnitude, false otherwise."
                },
                {
                  "signature": "public boolean isInfinite()",
                  "description": "Returns true if this Float value is\n infinitely large in magnitude, false otherwise."
                }
              ]
            },
            {
              "name": "isFinite",
              "overloads": [
                {
                  "signature": "public static boolean isFinite(float f)",
                  "description": "Returns true if the argument is a finite floating-point\n value; returns false otherwise (for NaN and infinity\n arguments)."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Float as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Float as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Float as an int after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns value of this Float as a long after a\n narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the float value of this Float object."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Float as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Float object. The\n result is the integer bit representation, exactly as produced\n by the method floatToIntBits(float), of the primitive\n float value represented by this Float\n object."
                },
                {
                  "signature": "public static int hashCode(float value)",
                  "description": "Returns a hash code for a float value; compatible with\n Float.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.  The result\n is true if and only if the argument is not\n null and is a Float object that\n represents a float with the same value as the\n float represented by this object. For this\n purpose, two float values are considered to be the\n same if and only if the method floatToIntBits(float)\n returns the identical int value when applied to\n each."
                }
              ]
            },
            {
              "name": "floatToIntBits",
              "overloads": [
                {
                  "signature": "public static int floatToIntBits(float value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout.\n\n Bit 31 (the bit that is selected by the mask\n 0x80000000) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n 0x7f800000) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n 0x007fffff) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7f800000.\n\n If the argument is negative infinity, the result is\n 0xff800000.\n\n If the argument is NaN, the result is 0x7fc00000.\n\n In all cases, the result is an integer that, when given to the\n intBitsToFloat(int) method, will produce a floating-point\n value the same as the argument to floatToIntBits\n (except all NaN values are collapsed to a single\n \"canonical\" NaN value)."
                }
              ]
            },
            {
              "name": "floatToRawIntBits",
              "overloads": [
                {
                  "signature": "public static int floatToRawIntBits(float value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout, preserving Not-a-Number (NaN) values.\n\n Bit 31 (the bit that is selected by the mask\n 0x80000000) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n 0x7f800000) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n 0x007fffff) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7f800000.\n\n If the argument is negative infinity, the result is\n 0xff800000.\n\n If the argument is NaN, the result is the integer representing\n the actual NaN value.  Unlike the floatToIntBits\n method, floatToRawIntBits does not collapse all the\n bit patterns encoding a NaN to a single \"canonical\"\n NaN value.\n\n In all cases, the result is an integer that, when given to the\n intBitsToFloat(int) method, will produce a\n floating-point value the same as the argument to\n floatToRawIntBits."
                }
              ]
            },
            {
              "name": "intBitsToFloat",
              "overloads": [
                {
                  "signature": "public static float intBitsToFloat(int bits)",
                  "description": "Returns the float value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"single format\" bit layout.\n\n If the argument is 0x7f800000, the result is positive\n infinity.\n\n If the argument is 0xff800000, the result is negative\n infinity.\n\n If the argument is any value in the range\n 0x7f800001 through 0x7fffffff or in\n the range 0xff800001 through\n 0xffffffff, the result is a NaN.  No IEEE 754\n floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the Float.floatToRawIntBits method.\n\n In all other cases, let s, e, and m be three\n values that can be computed from the argument:\n\n \n int s = ((bits >> 31) == 0) ? 1 : -1;\n int e = ((bits >> 23) & 0xff);\n int m = (e == 0) ?\n                 (bits & 0x7fffff) << 1 :\n                 (bits & 0x7fffff) | 0x800000;\n \n\n Then the floating-point result equals the value of the mathematical\n expression sm2e-150.\n\n Note that this method may not be able to return a\n float NaN with exactly same bit pattern as the\n int argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and signaling NaNs.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method may\n perform this conversion.  So intBitsToFloat may\n not be able to return a float with a signaling NaN\n bit pattern.  Consequently, for some int values,\n floatToRawIntBits(intBitsToFloat(start)) may\n not equal start.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Float anotherFloat)",
                  "description": "Compares two Float objects numerically.\n\n This method imposes a total order on Float objects\n with two differences compared to the incomplete order defined by\n the Java language numerical comparison operators (<, <=,\n ==, >=, >) on float values.\n\n  A NaN is unordered with respect to other\n          values and unequal to itself under the comparison\n          operators.  This method chooses to define \n          Float.NaN to be equal to itself and greater than all\n          other double values (including \n          Float.POSITIVE_INFINITY).\n\n       Positive zero and negative zero compare equal\n      numerically, but are distinct and distinguishable values.\n      This method chooses to define positive zero (+0.0f),\n      to be greater than negative zero (-0.0f).\n \n\n This ensures that the natural ordering of Float\n objects imposed by this method is consistent with\n equals; see this\n discussion for details of floating-point comparison and\n ordering."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(float f1, float f2)",
                  "description": "Compares the two specified float values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n     new Float(f1).compareTo(new Float(f2))"
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static float sum(float a, float b)",
                  "description": "Adds two float values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Float> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Float resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalAccessError",
          "methods": [
            {
              "name": "IllegalAccessError",
              "overloads": [
                {
                  "signature": "public IllegalAccessError()",
                  "description": "Constructs an IllegalAccessError with no detail message."
                },
                {
                  "signature": "public IllegalAccessError(String s)",
                  "description": "Constructs an IllegalAccessError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalAccessException",
          "methods": [
            {
              "name": "IllegalAccessException",
              "overloads": [
                {
                  "signature": "public IllegalAccessException()",
                  "description": "Constructs an IllegalAccessException without a\n detail message."
                },
                {
                  "signature": "public IllegalAccessException(String s)",
                  "description": "Constructs an IllegalAccessException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalArgumentException",
          "methods": [
            {
              "name": "IllegalArgumentException",
              "overloads": [
                {
                  "signature": "public IllegalArgumentException()",
                  "description": "Constructs an IllegalArgumentException with no\n detail message."
                },
                {
                  "signature": "public IllegalArgumentException(String s)",
                  "description": "Constructs an IllegalArgumentException with the\n specified detail message."
                },
                {
                  "signature": "public IllegalArgumentException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public IllegalArgumentException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalCallerException",
          "methods": [
            {
              "name": "IllegalCallerException",
              "overloads": [
                {
                  "signature": "public IllegalCallerException()",
                  "description": "Constructs an IllegalCallerException with no detail message."
                },
                {
                  "signature": "public IllegalCallerException(String s)",
                  "description": "Constructs an IllegalCallerException with the specified detail\n message."
                },
                {
                  "signature": "public IllegalCallerException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause."
                },
                {
                  "signature": "public IllegalCallerException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalMonitorStateException",
          "methods": [
            {
              "name": "IllegalMonitorStateException",
              "overloads": [
                {
                  "signature": "public IllegalMonitorStateException()",
                  "description": "Constructs an IllegalMonitorStateException with no\n detail message."
                },
                {
                  "signature": "public IllegalMonitorStateException(String s)",
                  "description": "Constructs an IllegalMonitorStateException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalStateException",
          "methods": [
            {
              "name": "IllegalStateException",
              "overloads": [
                {
                  "signature": "public IllegalStateException()",
                  "description": "Constructs an IllegalStateException with no detail message.\n A detail message is a String that describes this particular exception."
                },
                {
                  "signature": "public IllegalStateException(String s)",
                  "description": "Constructs an IllegalStateException with the specified detail\n message.  A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public IllegalStateException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public IllegalStateException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalThreadStateException",
          "methods": [
            {
              "name": "IllegalThreadStateException",
              "overloads": [
                {
                  "signature": "public IllegalThreadStateException()",
                  "description": "Constructs an IllegalThreadStateException with no\n detail message."
                },
                {
                  "signature": "public IllegalThreadStateException(String s)",
                  "description": "Constructs an IllegalThreadStateException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IncompatibleClassChangeError",
          "methods": [
            {
              "name": "IncompatibleClassChangeError",
              "overloads": [
                {
                  "signature": "public IncompatibleClassChangeError()",
                  "description": "Constructs an IncompatibleClassChangeError with no\n detail message."
                },
                {
                  "signature": "public IncompatibleClassChangeError(String s)",
                  "description": "Constructs an IncompatibleClassChangeError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IndexOutOfBoundsException",
          "methods": [
            {
              "name": "IndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public IndexOutOfBoundsException()",
                  "description": "Constructs an IndexOutOfBoundsException with no detail message."
                },
                {
                  "signature": "public IndexOutOfBoundsException(String s)",
                  "description": "Constructs an IndexOutOfBoundsException with the specified detail\n message."
                },
                {
                  "signature": "public IndexOutOfBoundsException(int index)",
                  "description": "Constructs a new IndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                },
                {
                  "signature": "public IndexOutOfBoundsException(long index)",
                  "description": "Constructs a new IndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "InheritableThreadLocal<T>",
          "methods": [
            {
              "name": "InheritableThreadLocal",
              "overloads": [
                {
                  "signature": "public InheritableThreadLocal()",
                  "description": "Creates an inheritable thread local variable."
                }
              ]
            },
            {
              "name": "childValue",
              "overloads": [
                {
                  "signature": "protected T childValue(T parentValue)",
                  "description": "Computes the child's initial value for this inheritable thread-local\n variable as a function of the parent's value at the time the child\n thread is created.  This method is called from within the parent\n thread before the child is started.\n \n This method merely returns its input argument, and should be overridden\n if a different behavior is desired."
                }
              ]
            }
          ]
        },
        {
          "name": "InstantiationError",
          "methods": [
            {
              "name": "InstantiationError",
              "overloads": [
                {
                  "signature": "public InstantiationError()",
                  "description": "Constructs an InstantiationError with no detail  message."
                },
                {
                  "signature": "public InstantiationError(String s)",
                  "description": "Constructs an InstantiationError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "InstantiationException",
          "methods": [
            {
              "name": "InstantiationException",
              "overloads": [
                {
                  "signature": "public InstantiationException()",
                  "description": "Constructs an InstantiationException with no detail message."
                },
                {
                  "signature": "public InstantiationException(String s)",
                  "description": "Constructs an InstantiationException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Integer",
          "methods": [
            {
              "name": "Integer",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Integer(int value)",
                  "description": "Constructs a newly allocated Integer object that\n represents the specified int value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Integer(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Integer object that\n represents the int value indicated by the\n String parameter. The string is converted to an\n int value in exactly the manner used by the\n parseInt method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(int i, int radix)",
                  "description": "Returns a string representation of the first argument in the\n radix specified by the second argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n If the first argument is negative, the first element of the\n result is the ASCII minus character '-'\n ('\\u002D'). If the first argument is not\n negative, no sign character appears in the result.\n\n The remaining characters of the result represent the magnitude\n of the first argument. If the magnitude is zero, it is\n represented by a single zero character '0'\n ('\\u0030'); otherwise, the first character of\n the representation of the magnitude will not be the zero\n character.  The following ASCII characters are used as digits:\n\n \n   0123456789abcdefghijklmnopqrstuvwxyz\n \n\n These are '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u007A'. If radix is\n N, then the first N of these characters\n are used as radix-N digits in the order shown. Thus,\n the digits for hexadecimal (radix 16) are\n 0123456789abcdef. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Integer.toString(n, 16).toUpperCase()"
                },
                {
                  "signature": "public static String toString(int i)",
                  "description": "Returns a String object representing the\n specified integer. The argument is converted to signed decimal\n representation and returned as a string, exactly as if the\n argument and radix 10 were given as arguments to the toString(int, int) method."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Integer's value. The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the integer value were given as an argument to the toString(int) method."
                }
              ]
            },
            {
              "name": "toUnsignedString",
              "overloads": [
                {
                  "signature": "public static String toUnsignedString(int i, int radix)",
                  "description": "Returns a string representation of the first argument as an\n unsigned integer value in the radix specified by the second\n argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n Note that since the first argument is treated as an unsigned\n value, no leading sign character is printed.\n\n If the magnitude is zero, it is represented by a single zero\n character '0' ('\\u0030'); otherwise,\n the first character of the representation of the magnitude will\n not be the zero character.\n\n The behavior of radixes and the characters used as digits\n are the same as toString."
                },
                {
                  "signature": "public static String toUnsignedString(int i)",
                  "description": "Returns a string representation of the argument as an unsigned\n decimal value.\n\n The argument is converted to unsigned decimal representation\n and returned as a string exactly as if the argument and radix\n 10 were given as arguments to the toUnsignedString(int, int) method."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base16.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise, it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in hexadecimal (base16) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 16).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as hexadecimal digits:\n\n \n  0123456789abcdef\n \n\n These are the characters '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u0066'. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Integer.toHexString(n).toUpperCase()"
                }
              ]
            },
            {
              "name": "toOctalString",
              "overloads": [
                {
                  "signature": "public static String toOctalString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base8.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise, it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in octal (base8) with no extra leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 8).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as octal digits:\n\n \n 01234567\n \n\n These are the characters '\\u0030' through\n '\\u0037'."
                }
              ]
            },
            {
              "name": "toBinaryString",
              "overloads": [
                {
                  "signature": "public static String toBinaryString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base2.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in binary (base2) with no extra leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 2).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n characters '0' ('\\u0030') and \n '1' ('\\u0031') are used as binary digits."
                }
              ]
            },
            {
              "name": "parseInt",
              "overloads": [
                {
                  "signature": "public static int parseInt(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed integer in the radix\n specified by the second argument. The characters in the string\n must all be digits of the specified radix (as determined by\n whether Character.digit(char, int) returns a\n nonnegative value), except that the first character may be an\n ASCII minus sign '-' ('\\u002D') to\n indicate a negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a minus sign\n '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is not a value of type\n int.\n \n\n Examples:\n  parseInt(\"0\", 10) returns 0\n parseInt(\"473\", 10) returns 473\n parseInt(\"+42\", 10) returns 42\n parseInt(\"-0\", 10) returns 0\n parseInt(\"-FF\", 16) returns -255\n parseInt(\"1100110\", 2) returns 102\n parseInt(\"2147483647\", 10) returns 2147483647\n parseInt(\"-2147483648\", 10) returns -2147483648\n parseInt(\"2147483648\", 10) throws a NumberFormatException\n parseInt(\"99\", 8) throws a NumberFormatException\n parseInt(\"Kona\", 10) throws a NumberFormatException\n parseInt(\"Kona\", 27) returns 411787"
                },
                {
                  "signature": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as a signed int in the\n specified radix, beginning at the specified beginIndex\n and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static int parseInt(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal integer. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value. The resulting integer value is\n returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseInt(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "parseUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned integer in the radix\n specified by the second argument.  An unsigned integer maps the\n values usually associated with negative numbers to positive\n numbers larger than MAX_VALUE.\n\n The characters in the string must all be digits of the\n specified radix (as determined by whether Character.digit(char, int) returns a nonnegative\n value), except that the first character may be an ASCII plus\n sign '+' ('\\u002B'). The resulting\n integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is larger than the\n largest unsigned int, 232-1."
                },
                {
                  "signature": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as an unsigned int in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static int parseUnsignedInt(String s) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned decimal integer. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII plus sign \n '+' ('\\u002B'). The resulting integer value\n is returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseUnsignedInt(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Integer valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns an Integer object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed integer in the radix\n specified by the second argument, exactly as if the arguments\n were given to the parseInt(java.lang.String, int)\n method. The result is an Integer object that\n represents the integer value specified by the string.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  new Integer(Integer.parseInt(s, radix))"
                },
                {
                  "signature": "public static Integer valueOf(String s) throws NumberFormatException",
                  "description": "Returns an Integer object holding the\n value of the specified String. The argument is\n interpreted as representing a signed decimal integer, exactly\n as if the argument were given to the parseInt(java.lang.String) method. The result is an\n Integer object that represents the integer value\n specified by the string.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  new Integer(Integer.parseInt(s))"
                },
                {
                  "signature": "public static Integer valueOf(int i)",
                  "description": "Returns an Integer instance representing the specified\n int value.  If a new Integer instance is not\n required, this method should generally be used in preference to\n the constructor Integer(int), as this method is likely\n to yield significantly better space and time performance by\n caching frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Integer as a byte\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Integer as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Integer as an\n int."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Integer as a long\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Integer as a float\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Integer as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Integer."
                },
                {
                  "signature": "public static int hashCode(int value)",
                  "description": "Returns a hash code for an int value; compatible with\n Integer.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is an Integer object that\n contains the same int value as this object."
                }
              ]
            },
            {
              "name": "getInteger",
              "overloads": [
                {
                  "signature": "public static Integer getInteger(String nm)",
                  "description": "Determines the integer value of the system property with the\n specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as an integer\n value using the grammar supported by decode and\n an Integer object representing this value is returned.\n\n If there is no property with the specified name, if the\n specified name is empty or null, or if the property\n does not have the correct numeric format, then null is\n returned.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  getInteger(nm, null)"
                },
                {
                  "signature": "public static Integer getInteger(String nm, int val)",
                  "description": "Determines the integer value of the system property with the\n specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as an integer\n value using the grammar supported by decode and\n an Integer object representing this value is returned.\n\n The second argument is the default value. An Integer object\n that represents the value of the second argument is returned if there\n is no property of the specified name, if the property does not have\n the correct numeric format, or if the specified name is empty or\n null.\n\n In other words, this method returns an Integer object\n equal to the value of:\n\n \n  getInteger(nm, new Integer(val))\n \n\n but in practice it may be implemented in a manner such as:\n\n  Integer result = getInteger(nm, null);\n return (result == null) ? new Integer(val) : result;\n \n\n to avoid the unnecessary allocation of an Integer\n object when the default value is not needed."
                },
                {
                  "signature": "public static Integer getInteger(String nm, Integer val)",
                  "description": "Returns the integer value of the system property with the\n specified name.  The first argument is treated as the name of a\n system property.  System properties are accessible through the\n System.getProperty(java.lang.String) method.\n The string value of this property is then interpreted as an\n integer value, as per the decode method,\n and an Integer object representing this value is\n returned; in summary:\n\n If the property value begins with the two ASCII characters\n         0x or the ASCII character #, not\n      followed by a minus sign, then the rest of it is parsed as a\n      hexadecimal integer exactly as by the method\n      valueOf(java.lang.String, int) with radix 16.\n If the property value begins with the ASCII character\n     0 followed by another character, it is parsed as an\n     octal integer exactly as by the method\n     valueOf(java.lang.String, int) with radix 8.\n Otherwise, the property value is parsed as a decimal integer\n exactly as by the method valueOf(java.lang.String, int)\n with radix 10.\n \n\n The second argument is the default value. The default value is\n returned if there is no property of the specified name, if the\n property does not have the correct numeric format, or if the\n specified name is empty or null."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Integer decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into an Integer.\n Accepts decimal, hexadecimal, and octal numbers given\n by the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Integer.parseInt method with the indicated radix (10, 16, or\n 8).  This sequence of characters must represent a positive\n value or a NumberFormatException will be thrown.  The\n result is negated if first character of the specified \n String is the minus sign.  No whitespace characters are\n permitted in the String."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Integer anotherInteger)",
                  "description": "Compares two Integer objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(int x, int y)",
                  "description": "Compares two int values numerically.\n The value returned is identical to what would be returned by:\n     Integer.valueOf(x).compareTo(Integer.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(int x, int y)",
                  "description": "Compares two int values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(int x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 32 bits of the long are zero and the\n low-order 32 bits are equal to the bits of the integer\n argument.\n\n Consequently, zero and positive int values are mapped\n to a numerically equal long value and negative \n int values are mapped to a long value equal to the\n input plus 232."
                }
              ]
            },
            {
              "name": "divideUnsigned",
              "overloads": [
                {
                  "signature": "public static int divideUnsigned(int dividend, int divisor)",
                  "description": "Returns the unsigned quotient of dividing the first argument by\n the second where each argument and the result is interpreted as\n an unsigned value.\n\n Note that in two's complement arithmetic, the three other\n basic arithmetic operations of add, subtract, and multiply are\n bit-wise identical if the two operands are regarded as both\n being signed or both being unsigned.  Therefore separate \n addUnsigned, etc. methods are not provided."
                }
              ]
            },
            {
              "name": "remainderUnsigned",
              "overloads": [
                {
                  "signature": "public static int remainderUnsigned(int dividend, int divisor)",
                  "description": "Returns the unsigned remainder from dividing the first argument\n by the second where each argument and the result is interpreted\n as an unsigned value."
                }
              ]
            },
            {
              "name": "highestOneBit",
              "overloads": [
                {
                  "signature": "public static int highestOneBit(int i)",
                  "description": "Returns an int value with at most a single one-bit, in the\n position of the highest-order (\"leftmost\") one-bit in the specified\n int value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "lowestOneBit",
              "overloads": [
                {
                  "signature": "public static int lowestOneBit(int i)",
                  "description": "Returns an int value with at most a single one-bit, in the\n position of the lowest-order (\"rightmost\") one-bit in the specified\n int value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "numberOfLeadingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfLeadingZeros(int i)",
                  "description": "Returns the number of zero bits preceding the highest-order\n (\"leftmost\") one-bit in the two's complement binary representation\n of the specified int value.  Returns 32 if the\n specified value has no one-bits in its two's complement representation,\n in other words if it is equal to zero.\n\n Note that this method is closely related to the logarithm base 2.\n For all positive int values x:\n \n floor(log2(x)) = 31 - numberOfLeadingZeros(x)\n ceil(log2(x)) = 32 - numberOfLeadingZeros(x - 1)"
                }
              ]
            },
            {
              "name": "numberOfTrailingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfTrailingZeros(int i)",
                  "description": "Returns the number of zero bits following the lowest-order (\"rightmost\")\n one-bit in the two's complement binary representation of the specified\n int value.  Returns 32 if the specified value has no\n one-bits in its two's complement representation, in other words if it is\n equal to zero."
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public static int bitCount(int i)",
                  "description": "Returns the number of one-bits in the two's complement binary\n representation of the specified int value.  This function is\n sometimes referred to as the population count."
                }
              ]
            },
            {
              "name": "rotateLeft",
              "overloads": [
                {
                  "signature": "public static int rotateLeft(int i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified int value left by the\n specified number of bits.  (Bits shifted out of the left hand, or\n high-order, side reenter on the right, or low-order.)\n\n Note that left rotation with a negative distance is equivalent to\n right rotation: rotateLeft(val, -distance) == rotateRight(val,\n distance).  Note also that rotation by any multiple of 32 is a\n no-op, so all but the last five bits of the rotation distance can be\n ignored, even if the distance is negative: rotateLeft(val,\n distance) == rotateLeft(val, distance & 0x1F)."
                }
              ]
            },
            {
              "name": "rotateRight",
              "overloads": [
                {
                  "signature": "public static int rotateRight(int i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified int value right by the\n specified number of bits.  (Bits shifted out of the right hand, or\n low-order, side reenter on the left, or high-order.)\n\n Note that right rotation with a negative distance is equivalent to\n left rotation: rotateRight(val, -distance) == rotateLeft(val,\n distance).  Note also that rotation by any multiple of 32 is a\n no-op, so all but the last five bits of the rotation distance can be\n ignored, even if the distance is negative: rotateRight(val,\n distance) == rotateRight(val, distance & 0x1F)."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public static int reverse(int i)",
                  "description": "Returns the value obtained by reversing the order of the bits in the\n two's complement binary representation of the specified int\n value."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static int signum(int i)",
                  "description": "Returns the signum function of the specified int value.  (The\n return value is -1 if the specified value is negative; 0 if the\n specified value is zero; and 1 if the specified value is positive.)"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static int reverseBytes(int i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified int value."
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static int sum(int a, int b)",
                  "description": "Adds two integers together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Integer> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Integer resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "InternalError",
          "methods": [
            {
              "name": "InternalError",
              "overloads": [
                {
                  "signature": "public InternalError()",
                  "description": "Constructs an InternalError with no detail message."
                },
                {
                  "signature": "public InternalError(String message)",
                  "description": "Constructs an InternalError with the specified\n detail message."
                },
                {
                  "signature": "public InternalError(String message, Throwable cause)",
                  "description": "Constructs an InternalError with the specified detail\n message and cause.  Note that the detail message associated\n with cause is not automatically incorporated in\n this error's detail message."
                },
                {
                  "signature": "public InternalError(Throwable cause)",
                  "description": "Constructs an InternalError with the specified cause\n and a detail message of (cause==null ? null :\n cause.toString()) (which typically contains the class and\n detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "InterruptedException",
          "methods": [
            {
              "name": "InterruptedException",
              "overloads": [
                {
                  "signature": "public InterruptedException()",
                  "description": "Constructs an InterruptedException with no detail  message."
                },
                {
                  "signature": "public InterruptedException(String s)",
                  "description": "Constructs an InterruptedException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Iterable<T>",
          "methods": [
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<T> iterator()",
                  "description": "Returns an iterator over elements of type T."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "default void forEach(Consumer<? super T> action)",
                  "description": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.  Actions are performed in the order of iteration, if that\n order is specified.  Exceptions thrown by the action are relayed to the\n caller.\n \n The behavior of this method is unspecified if the action performs\n side-effects that modify the underlying source of elements, unless an\n overriding class has specified a concurrent modification policy."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<T> spliterator()",
                  "description": "Creates a Spliterator over the elements described by this\n Iterable."
                }
              ]
            }
          ]
        },
        {
          "name": "LayerInstantiationException",
          "methods": [
            {
              "name": "LayerInstantiationException",
              "overloads": [
                {
                  "signature": "public LayerInstantiationException()",
                  "description": "Constructs a LayerInstantiationException with no detail message."
                },
                {
                  "signature": "public LayerInstantiationException(String msg)",
                  "description": "Constructs a LayerInstantiationException with the given detail\n message."
                },
                {
                  "signature": "public LayerInstantiationException(Throwable cause)",
                  "description": "Constructs a LayerInstantiationException with the given cause."
                },
                {
                  "signature": "public LayerInstantiationException(String msg, Throwable cause)",
                  "description": "Constructs a LayerInstantiationException with the given detail\n message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "LinkageError",
          "methods": [
            {
              "name": "LinkageError",
              "overloads": [
                {
                  "signature": "public LinkageError()",
                  "description": "Constructs a LinkageError with no detail message."
                },
                {
                  "signature": "public LinkageError(String s)",
                  "description": "Constructs a LinkageError with the specified detail\n message."
                },
                {
                  "signature": "public LinkageError(String s, Throwable cause)",
                  "description": "Constructs a LinkageError with the specified detail\n message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "Long",
          "methods": [
            {
              "name": "Long",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Long(long value)",
                  "description": "Constructs a newly allocated Long object that\n represents the specified long argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Long(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Long object that\n represents the long value indicated by the\n String parameter. The string is converted to a\n long value in exactly the manner used by the\n parseLong method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(long i, int radix)",
                  "description": "Returns a string representation of the first argument in the\n radix specified by the second argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n If the first argument is negative, the first element of the\n result is the ASCII minus sign '-'\n ('\\u002d'). If the first argument is not\n negative, no sign character appears in the result.\n\n The remaining characters of the result represent the magnitude\n of the first argument. If the magnitude is zero, it is\n represented by a single zero character '0'\n ('\\u0030'); otherwise, the first character of\n the representation of the magnitude will not be the zero\n character.  The following ASCII characters are used as digits:\n\n \n   0123456789abcdefghijklmnopqrstuvwxyz\n \n\n These are '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u007a'. If radix is\n N, then the first N of these characters\n are used as radix-N digits in the order shown. Thus,\n the digits for hexadecimal (radix 16) are\n 0123456789abcdef. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Long.toString(n, 16).toUpperCase()"
                },
                {
                  "signature": "public static String toString(long i)",
                  "description": "Returns a String object representing the specified\n long.  The argument is converted to signed decimal\n representation and returned as a string, exactly as if the\n argument and the radix 10 were given as arguments to the toString(long, int) method."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Long's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the long value were given as an argument to the\n toString(long) method."
                }
              ]
            },
            {
              "name": "toUnsignedString",
              "overloads": [
                {
                  "signature": "public static String toUnsignedString(long i, int radix)",
                  "description": "Returns a string representation of the first argument as an\n unsigned integer value in the radix specified by the second\n argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n Note that since the first argument is treated as an unsigned\n value, no leading sign character is printed.\n\n If the magnitude is zero, it is represented by a single zero\n character '0' ('\\u0030'); otherwise,\n the first character of the representation of the magnitude will\n not be the zero character.\n\n The behavior of radixes and the characters used as digits\n are the same as toString."
                },
                {
                  "signature": "public static String toUnsignedString(long i)",
                  "description": "Returns a string representation of the argument as an unsigned\n decimal value.\n\n The argument is converted to unsigned decimal representation\n and returned as a string exactly as if the argument and radix\n 10 were given as arguments to the toUnsignedString(long, int) method."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base16.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in hexadecimal (base16) with no extra\n leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 16).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as hexadecimal digits:\n\n \n  0123456789abcdef\n \n\n These are the characters '\\u0030' through\n '\\u0039' and  '\\u0061' through\n '\\u0066'.  If uppercase letters are desired,\n the String.toUpperCase() method may be called\n on the result:\n\n \n  Long.toHexString(n).toUpperCase()"
                }
              ]
            },
            {
              "name": "toOctalString",
              "overloads": [
                {
                  "signature": "public static String toOctalString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base8.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in octal (base8) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 8).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as octal digits:\n\n \n  01234567\n \n\n These are the characters '\\u0030' through\n '\\u0037'."
                }
              ]
            },
            {
              "name": "toBinaryString",
              "overloads": [
                {
                  "signature": "public static String toBinaryString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base2.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in binary (base2) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 2).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n characters '0' ('\\u0030') and \n '1' ('\\u0031') are used as binary digits."
                }
              ]
            },
            {
              "name": "parseLong",
              "overloads": [
                {
                  "signature": "public static long parseLong(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed long in the\n radix specified by the second argument. The characters in the\n string must all be digits of the specified radix (as determined\n by whether Character.digit(char, int) returns\n a nonnegative value), except that the first character may be an\n ASCII minus sign '-' ('\\u002D') to\n indicate a negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting long value is returned.\n\n Note that neither the character L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the string as a type indicator, as would be permitted in\n Java programming language source code - except that either\n L or l may appear as a digit for a\n radix greater than or equal to 22.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n\n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a minus sign\n '-' ('\\u002d') or plus sign \n '+' ('\\u002B') provided that the string is\n longer than length 1.\n\n The value represented by the string is not a value of type\n      long.\n \n\n Examples:\n  parseLong(\"0\", 10) returns 0L\n parseLong(\"473\", 10) returns 473L\n parseLong(\"+42\", 10) returns 42L\n parseLong(\"-0\", 10) returns 0L\n parseLong(\"-FF\", 16) returns -255L\n parseLong(\"1100110\", 2) returns 102L\n parseLong(\"99\", 8) throws a NumberFormatException\n parseLong(\"Hazelnut\", 10) throws a NumberFormatException\n parseLong(\"Hazelnut\", 36) returns 1356099454469L"
                },
                {
                  "signature": "public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as a signed long in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static long parseLong(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal long.\n The characters in the string must all be decimal digits, except\n that the first character may be an ASCII minus sign '-'\n (\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value. The resulting long value is\n returned, exactly as if the argument and the radix 10\n were given as arguments to the parseLong(java.lang.String, int) method.\n\n Note that neither the character L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the string as a type indicator, as would be permitted in\n Java programming language source code."
                }
              ]
            },
            {
              "name": "parseUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long parseUnsignedLong(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned long in the\n radix specified by the second argument.  An unsigned integer\n maps the values usually associated with negative numbers to\n positive numbers larger than MAX_VALUE.\n\n The characters in the string must all be digits of the\n specified radix (as determined by whether Character.digit(char, int) returns a nonnegative\n value), except that the first character may be an ASCII plus\n sign '+' ('\\u002B'). The resulting\n integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is larger than the\n largest unsigned long, 264-1."
                },
                {
                  "signature": "public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as an unsigned long in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static long parseUnsignedLong(String s) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned decimal long. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII plus sign \n '+' ('\\u002B'). The resulting integer value\n is returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseUnsignedLong(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Long valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Long object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument.  The first\n argument is interpreted as representing a signed\n long in the radix specified by the second\n argument, exactly as if the arguments were given to the parseLong(java.lang.String, int) method. The result is a\n Long object that represents the long\n value specified by the string.\n\n In other words, this method returns a Long object equal\n to the value of:\n\n \n  new Long(Long.parseLong(s, radix))"
                },
                {
                  "signature": "public static Long valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Long object holding the value\n of the specified String. The argument is\n interpreted as representing a signed decimal long,\n exactly as if the argument were given to the parseLong(java.lang.String) method. The result is a\n Long object that represents the integer value\n specified by the string.\n\n In other words, this method returns a Long object\n equal to the value of:\n\n \n  new Long(Long.parseLong(s))"
                },
                {
                  "signature": "public static Long valueOf(long l)",
                  "description": "Returns a Long instance representing the specified\n long value.\n If a new Long instance is not required, this method\n should generally be used in preference to the constructor\n Long(long), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Long decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Long.\n Accepts decimal, hexadecimal, and octal numbers given by the\n following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Long.parseLong method with the indicated radix (10, 16, or 8).\n This sequence of characters must represent a positive value or\n a NumberFormatException will be thrown.  The result is\n negated if first character of the specified String is\n the minus sign.  No whitespace characters are permitted in the\n String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Long as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Long as a short after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Long as an int after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Long as a\n long value."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Long as a float after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Long as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Long. The result is\n the exclusive OR of the two halves of the primitive\n long value held by this Long\n object. That is, the hashcode is the value of the expression:\n\n \n  (int)(this.longValue()^(this.longValue()>>>32))"
                },
                {
                  "signature": "public static int hashCode(long value)",
                  "description": "Returns a hash code for a long value; compatible with\n Long.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Long object that\n contains the same long value as this object."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public static Long getLong(String nm)",
                  "description": "Determines the long value of the system property\n with the specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as a \n long value using the grammar supported by decode\n and a Long object representing this value is returned.\n\n If there is no property with the specified name, if the\n specified name is empty or null, or if the property\n does not have the correct numeric format, then null is\n returned.\n\n In other words, this method returns a Long object\n equal to the value of:\n\n \n  getLong(nm, null)"
                },
                {
                  "signature": "public static Long getLong(String nm, long val)",
                  "description": "Determines the long value of the system property\n with the specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as a \n long value using the grammar supported by decode\n and a Long object representing this value is returned.\n\n The second argument is the default value. A Long object\n that represents the value of the second argument is returned if there\n is no property of the specified name, if the property does not have\n the correct numeric format, or if the specified name is empty or null.\n\n In other words, this method returns a Long object equal\n to the value of:\n\n \n  getLong(nm, new Long(val))\n \n\n but in practice it may be implemented in a manner such as:\n\n  Long result = getLong(nm, null);\n return (result == null) ? new Long(val) : result;\n \n\n to avoid the unnecessary allocation of a Long object when\n the default value is not needed."
                },
                {
                  "signature": "public static Long getLong(String nm, Long val)",
                  "description": "Returns the long value of the system property with\n the specified name.  The first argument is treated as the name\n of a system property.  System properties are accessible through\n the System.getProperty(java.lang.String)\n method. The string value of this property is then interpreted\n as a long value, as per the\n decode method, and a Long object\n representing this value is returned; in summary:\n\n \n If the property value begins with the two ASCII characters\n 0x or the ASCII character #, not followed by\n a minus sign, then the rest of it is parsed as a hexadecimal integer\n exactly as for the method valueOf(java.lang.String, int)\n with radix 16.\n If the property value begins with the ASCII character\n 0 followed by another character, it is parsed as\n an octal integer exactly as by the method valueOf(java.lang.String, int) with radix 8.\n Otherwise the property value is parsed as a decimal\n integer exactly as by the method\n valueOf(java.lang.String, int) with radix 10.\n \n\n Note that, in every case, neither L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the property value as a type indicator, as would be\n permitted in Java programming language source code.\n\n The second argument is the default value. The default value is\n returned if there is no property of the specified name, if the\n property does not have the correct numeric format, or if the\n specified name is empty or null."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Long anotherLong)",
                  "description": "Compares two Long objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(long x, long y)",
                  "description": "Compares two long values numerically.\n The value returned is identical to what would be returned by:\n     Long.valueOf(x).compareTo(Long.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(long x, long y)",
                  "description": "Compares two long values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "divideUnsigned",
              "overloads": [
                {
                  "signature": "public static long divideUnsigned(long dividend, long divisor)",
                  "description": "Returns the unsigned quotient of dividing the first argument by\n the second where each argument and the result is interpreted as\n an unsigned value.\n\n Note that in two's complement arithmetic, the three other\n basic arithmetic operations of add, subtract, and multiply are\n bit-wise identical if the two operands are regarded as both\n being signed or both being unsigned.  Therefore separate \n addUnsigned, etc. methods are not provided."
                }
              ]
            },
            {
              "name": "remainderUnsigned",
              "overloads": [
                {
                  "signature": "public static long remainderUnsigned(long dividend, long divisor)",
                  "description": "Returns the unsigned remainder from dividing the first argument\n by the second where each argument and the result is interpreted\n as an unsigned value."
                }
              ]
            },
            {
              "name": "highestOneBit",
              "overloads": [
                {
                  "signature": "public static long highestOneBit(long i)",
                  "description": "Returns a long value with at most a single one-bit, in the\n position of the highest-order (\"leftmost\") one-bit in the specified\n long value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "lowestOneBit",
              "overloads": [
                {
                  "signature": "public static long lowestOneBit(long i)",
                  "description": "Returns a long value with at most a single one-bit, in the\n position of the lowest-order (\"rightmost\") one-bit in the specified\n long value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "numberOfLeadingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfLeadingZeros(long i)",
                  "description": "Returns the number of zero bits preceding the highest-order\n (\"leftmost\") one-bit in the two's complement binary representation\n of the specified long value.  Returns 64 if the\n specified value has no one-bits in its two's complement representation,\n in other words if it is equal to zero.\n\n Note that this method is closely related to the logarithm base 2.\n For all positive long values x:\n \n floor(log2(x)) = 63 - numberOfLeadingZeros(x)\n ceil(log2(x)) = 64 - numberOfLeadingZeros(x - 1)"
                }
              ]
            },
            {
              "name": "numberOfTrailingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfTrailingZeros(long i)",
                  "description": "Returns the number of zero bits following the lowest-order (\"rightmost\")\n one-bit in the two's complement binary representation of the specified\n long value.  Returns 64 if the specified value has no\n one-bits in its two's complement representation, in other words if it is\n equal to zero."
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public static int bitCount(long i)",
                  "description": "Returns the number of one-bits in the two's complement binary\n representation of the specified long value.  This function is\n sometimes referred to as the population count."
                }
              ]
            },
            {
              "name": "rotateLeft",
              "overloads": [
                {
                  "signature": "public static long rotateLeft(long i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified long value left by the\n specified number of bits.  (Bits shifted out of the left hand, or\n high-order, side reenter on the right, or low-order.)\n\n Note that left rotation with a negative distance is equivalent to\n right rotation: rotateLeft(val, -distance) == rotateRight(val,\n distance).  Note also that rotation by any multiple of 64 is a\n no-op, so all but the last six bits of the rotation distance can be\n ignored, even if the distance is negative: rotateLeft(val,\n distance) == rotateLeft(val, distance & 0x3F)."
                }
              ]
            },
            {
              "name": "rotateRight",
              "overloads": [
                {
                  "signature": "public static long rotateRight(long i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified long value right by the\n specified number of bits.  (Bits shifted out of the right hand, or\n low-order, side reenter on the left, or high-order.)\n\n Note that right rotation with a negative distance is equivalent to\n left rotation: rotateRight(val, -distance) == rotateLeft(val,\n distance).  Note also that rotation by any multiple of 64 is a\n no-op, so all but the last six bits of the rotation distance can be\n ignored, even if the distance is negative: rotateRight(val,\n distance) == rotateRight(val, distance & 0x3F)."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public static long reverse(long i)",
                  "description": "Returns the value obtained by reversing the order of the bits in the\n two's complement binary representation of the specified long\n value."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static int signum(long i)",
                  "description": "Returns the signum function of the specified long value.  (The\n return value is -1 if the specified value is negative; 0 if the\n specified value is zero; and 1 if the specified value is positive.)"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static long reverseBytes(long i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified long value."
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static long sum(long a, long b)",
                  "description": "Adds two long values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Long> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Long resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Math",
          "methods": [
            {
              "name": "sin",
              "overloads": [
                {
                  "signature": "public static double sin(double a)",
                  "description": "Returns the trigonometric sine of an angle.  Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "cos",
              "overloads": [
                {
                  "signature": "public static double cos(double a)",
                  "description": "Returns the trigonometric cosine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is 1.0.\n\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "tan",
              "overloads": [
                {
                  "signature": "public static double tan(double a)",
                  "description": "Returns the trigonometric tangent of an angle.  Special cases:\n If the argument is NaN or an infinity, then the result\n is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "asin",
              "overloads": [
                {
                  "signature": "public static double asin(double a)",
                  "description": "Returns the arc sine of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "acos",
              "overloads": [
                {
                  "signature": "public static double acos(double a)",
                  "description": "Returns the arc cosine of a value; the returned angle is in the\n range 0.0 through pi.  Special case:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is 1.0, the result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "atan",
              "overloads": [
                {
                  "signature": "public static double atan(double a)",
                  "description": "Returns the arc tangent of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n If the argument is infinite,\n then the result is the closest value to pi/2 with the\n same sign as the input.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "toRadians",
              "overloads": [
                {
                  "signature": "public static double toRadians(double angdeg)",
                  "description": "Converts an angle measured in degrees to an approximately\n equivalent angle measured in radians.  The conversion from\n degrees to radians is generally inexact."
                }
              ]
            },
            {
              "name": "toDegrees",
              "overloads": [
                {
                  "signature": "public static double toDegrees(double angrad)",
                  "description": "Converts an angle measured in radians to an approximately\n equivalent angle measured in degrees.  The conversion from\n radians to degrees is generally inexact; users should\n not expect cos(toRadians(90.0)) to exactly\n equal 0.0."
                }
              ]
            },
            {
              "name": "exp",
              "overloads": [
                {
                  "signature": "public static double exp(double a)",
                  "description": "Returns Euler's number e raised to the power of a\n double value.  Special cases:\n If the argument is NaN, the result is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is negative infinity, then the result is\n positive zero.\n If the argument is zero, then the result is 1.0.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "public static double log(double a)",
                  "description": "Returns the natural logarithm (base e) of a double\n value.  Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is 1.0, then the result is positive\n zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "log10",
              "overloads": [
                {
                  "signature": "public static double log10(double a)",
                  "description": "Returns the base 10 logarithm of a double value.\n Special cases:\n\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is equal to 10n for\n integer n, then the result is n. In particular,\n if the argument is 1.0 (100), then the\n result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public static double sqrt(double a)",
                  "description": "Returns the correctly rounded positive square root of a\n double value.\n Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is positive\n infinity.\n If the argument is positive zero or negative zero, then the\n result is the same as the argument.\n Otherwise, the result is the double value closest to\n the true mathematical square root of the argument value."
                }
              ]
            },
            {
              "name": "cbrt",
              "overloads": [
                {
                  "signature": "public static double cbrt(double a)",
                  "description": "Returns the cube root of a double value.  For\n positive finite x, cbrt(-x) ==\n -cbrt(x); that is, the cube root of a negative value is\n the negative of the cube root of that value's magnitude.\n\n Special cases:\n\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result."
                }
              ]
            },
            {
              "name": "IEEEremainder",
              "overloads": [
                {
                  "signature": "public static double IEEEremainder(double f1, double f2)",
                  "description": "Computes the remainder operation on two arguments as prescribed\n by the IEEE 754 standard.\n The remainder value is mathematically equal to\n f1-f2n,\n where n is the mathematical integer closest to the exact\n mathematical value of the quotient f1/f2, and if two\n mathematical integers are equally close to f1/f2,\n then n is the integer that is even. If the remainder is\n zero, its sign is the same as the sign of the first argument.\n Special cases:\n If either argument is NaN, or the first argument is infinite,\n or the second argument is positive zero or negative zero, then the\n result is NaN.\n If the first argument is finite and the second argument is\n infinite, then the result is the same as the first argument."
                }
              ]
            },
            {
              "name": "ceil",
              "overloads": [
                {
                  "signature": "public static double ceil(double a)",
                  "description": "Returns the smallest (closest to negative infinity)\n double value that is greater than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument.  If the argument value is less than zero but\n greater than -1.0, then the result is negative zero. Note\n that the value of Math.ceil(x) is exactly the\n value of -Math.floor(-x)."
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "public static double floor(double a)",
                  "description": "Returns the largest (closest to positive infinity)\n double value that is less than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument."
                }
              ]
            },
            {
              "name": "rint",
              "overloads": [
                {
                  "signature": "public static double rint(double a)",
                  "description": "Returns the double value that is closest in value\n to the argument and is equal to a mathematical integer. If two\n double values that are mathematical integers are\n equally close, the result is the integer value that is\n even. Special cases:\n If the argument value is already equal to a mathematical\n integer, then the result is the same as the argument.\n If the argument is NaN or an infinity or positive zero or negative\n zero, then the result is the same as the argument."
                }
              ]
            },
            {
              "name": "atan2",
              "overloads": [
                {
                  "signature": "public static double atan2(double y, double x)",
                  "description": "Returns the angle theta from the conversion of rectangular\n coordinates (x,y) to polar\n coordinates (r,theta).\n This method computes the phase theta by computing an arc tangent\n of y/x in the range of -pi to pi. Special\n cases:\n If either argument is NaN, then the result is NaN.\n If the first argument is positive zero and the second argument\n is positive, or the first argument is positive and finite and the\n second argument is positive infinity, then the result is positive\n zero.\n If the first argument is negative zero and the second argument\n is positive, or the first argument is negative and finite and the\n second argument is positive infinity, then the result is negative zero.\n If the first argument is positive zero and the second argument\n is negative, or the first argument is positive and finite and the\n second argument is negative infinity, then the result is the\n double value closest to pi.\n If the first argument is negative zero and the second argument\n is negative, or the first argument is negative and finite and the\n second argument is negative infinity, then the result is the\n double value closest to -pi.\n If the first argument is positive and the second argument is\n positive zero or negative zero, or the first argument is positive\n infinity and the second argument is finite, then the result is the\n double value closest to pi/2.\n If the first argument is negative and the second argument is\n positive zero or negative zero, or the first argument is negative\n infinity and the second argument is finite, then the result is the\n double value closest to -pi/2.\n If both arguments are positive infinity, then the result is the\n double value closest to pi/4.\n If the first argument is positive infinity and the second argument\n is negative infinity, then the result is the double\n value closest to 3*pi/4.\n If the first argument is negative infinity and the second argument\n is positive infinity, then the result is the double value\n closest to -pi/4.\n If both arguments are negative infinity, then the result is the\n double value closest to -3*pi/4.\n\n The computed result must be within 2 ulps of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public static double pow(double a, double b)",
                  "description": "Returns the value of the first argument raised to the power of the\n second argument. Special cases:\n\n If the second argument is positive or negative zero, then the\n result is 1.0.\n If the second argument is 1.0, then the result is the same as the\n first argument.\n If the second argument is NaN, then the result is NaN.\n If the first argument is NaN and the second argument is nonzero,\n then the result is NaN.\n\n If\n \n the absolute value of the first argument is greater than 1\n and the second argument is positive infinity, or\n the absolute value of the first argument is less than 1 and\n the second argument is negative infinity,\n \n then the result is positive infinity.\n\n If\n \n the absolute value of the first argument is greater than 1 and\n the second argument is negative infinity, or\n the absolute value of the\n first argument is less than 1 and the second argument is positive\n infinity,\n \n then the result is positive zero.\n\n If the absolute value of the first argument equals 1 and the\n second argument is infinite, then the result is NaN.\n\n If\n \n the first argument is positive zero and the second argument\n is greater than zero, or\n the first argument is positive infinity and the second\n argument is less than zero,\n \n then the result is positive zero.\n\n If\n \n the first argument is positive zero and the second argument\n is less than zero, or\n the first argument is positive infinity and the second\n argument is greater than zero,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is greater than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is less than zero but not a finite odd integer,\n \n then the result is positive zero.\n\n If\n \n the first argument is negative zero and the second argument\n is a positive finite odd integer, or\n the first argument is negative infinity and the second\n argument is a negative finite odd integer,\n \n then the result is negative zero.\n\n If\n \n the first argument is negative zero and the second argument\n is less than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is greater than zero but not a finite odd integer,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is a negative finite odd integer, or\n the first argument is negative infinity and the second\n argument is a positive finite odd integer,\n \n then the result is negative infinity.\n\n If the first argument is finite and less than zero\n \n  if the second argument is a finite even integer, the\n result is equal to the result of raising the absolute value of\n the first argument to the power of the second argument\n\n if the second argument is a finite odd integer, the result\n is equal to the negative of the result of raising the absolute\n value of the first argument to the power of the second\n argument\n\n if the second argument is finite and not an integer, then\n the result is NaN.\n \n\n If both arguments are integers, then the result is exactly equal\n to the mathematical result of raising the first argument to the power\n of the second argument if that result can in fact be represented\n exactly as a double value.\n\n (In the foregoing descriptions, a floating-point value is\n considered to be an integer if and only if it is finite and a\n fixed point of the method ceil or,\n equivalently, a fixed point of the method floor. A value is a fixed point of a one-argument\n method if and only if the result of applying the method to the\n value is equal to the value.)\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public static int round(float a)",
                  "description": "Returns the closest int to the argument, with ties\n rounding to positive infinity.\n\n \n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Integer.MIN_VALUE, the result is\n equal to the value of Integer.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Integer.MAX_VALUE, the result is\n equal to the value of Integer.MAX_VALUE."
                },
                {
                  "signature": "public static long round(double a)",
                  "description": "Returns the closest long to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Long.MIN_VALUE, the result is\n equal to the value of Long.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Long.MAX_VALUE, the result is\n equal to the value of Long.MAX_VALUE."
                }
              ]
            },
            {
              "name": "random",
              "overloads": [
                {
                  "signature": "public static double random()",
                  "description": "Returns a double value with a positive sign, greater\n than or equal to 0.0 and less than 1.0.\n Returned values are chosen pseudorandomly with (approximately)\n uniform distribution from that range.\n\n When this method is first called, it creates a single new\n pseudorandom-number generator, exactly as if by the expression\n\n new java.util.Random()\n\n This new pseudorandom-number generator is used thereafter for\n all calls to this method and is used nowhere else.\n\n This method is properly synchronized to allow correct use by\n more than one thread. However, if many threads need to generate\n pseudorandom numbers at a great rate, it may reduce contention\n for each thread to have its own pseudorandom-number generator."
                }
              ]
            },
            {
              "name": "addExact",
              "overloads": [
                {
                  "signature": "public static int addExact(int x, int y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long addExact(long x, long y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "subtractExact",
              "overloads": [
                {
                  "signature": "public static int subtractExact(int x, int y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long subtractExact(long x, long y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "multiplyExact",
              "overloads": [
                {
                  "signature": "public static int multiplyExact(int x, int y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long multiplyExact(long x, int y)",
                  "description": "Returns the product of the arguments, throwing an exception if the result\n overflows a long."
                },
                {
                  "signature": "public static long multiplyExact(long x, long y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "incrementExact",
              "overloads": [
                {
                  "signature": "public static int incrementExact(int a)",
                  "description": "Returns the argument incremented by one, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the maximum value."
                },
                {
                  "signature": "public static long incrementExact(long a)",
                  "description": "Returns the argument incremented by one, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the maximum value."
                }
              ]
            },
            {
              "name": "decrementExact",
              "overloads": [
                {
                  "signature": "public static int decrementExact(int a)",
                  "description": "Returns the argument decremented by one, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long decrementExact(long a)",
                  "description": "Returns the argument decremented by one, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "negateExact",
              "overloads": [
                {
                  "signature": "public static int negateExact(int a)",
                  "description": "Returns the negation of the argument, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long negateExact(long a)",
                  "description": "Returns the negation of the argument, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "toIntExact",
              "overloads": [
                {
                  "signature": "public static int toIntExact(long value)",
                  "description": "Returns the value of the long argument,\n throwing an exception if the value overflows an int."
                }
              ]
            },
            {
              "name": "multiplyFull",
              "overloads": [
                {
                  "signature": "public static long multiplyFull(int x, int y)",
                  "description": "Returns the exact mathematical product of the arguments."
                }
              ]
            },
            {
              "name": "multiplyHigh",
              "overloads": [
                {
                  "signature": "public static long multiplyHigh(long x, long y)",
                  "description": "Returns as a long the most significant 64 bits of the 128-bit\n product of two 64-bit factors."
                }
              ]
            },
            {
              "name": "floorDiv",
              "overloads": [
                {
                  "signature": "public static int floorDiv(int x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n int value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Integer.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Integer.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n   If the signs of the arguments are the same, the results of\n       floorDiv and the / operator are the same.  \n       For example, floorDiv(4, 3) == 1 and (4 / 3) == 1.\n   If the signs of the arguments are different,  the quotient is negative and\n       floorDiv returns the integer less than or equal to the quotient\n       and the / operator returns the integer closest to zero.\n       For example, floorDiv(-4, 3) == -2,\n       whereas (-4 / 3) == -1."
                },
                {
                  "signature": "public static long floorDiv(long x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n For examples, see floorDiv(int, int)."
                },
                {
                  "signature": "public static long floorDiv(long x, long y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n For examples, see floorDiv(int, int)."
                }
              ]
            },
            {
              "name": "floorMod",
              "overloads": [
                {
                  "signature": "public static int floorMod(int x, int y)",
                  "description": "Returns the floor modulus of the int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n The difference in values between floorMod and\n the % operator is due to the difference between\n floorDiv that returns the integer less than or equal to the quotient\n and the / operator that returns the integer closest to zero.\n \n Examples:\n \n   If the signs of the arguments are the same, the results\n       of floorMod and the % operator are the same.\n       \n       floorMod(+4, +3) == +1;  and (+4 % +3) == +1\n       floorMod(-4, -3) == -1;  and (-4 % -3) == -1\n       \n   If the signs of the arguments are different, the results\n       differ from the % operator.\n       \n       floorMod(+4, -3) == -2;  and (+4 % -3) == +1\n       floorMod(-4, +3) == +2;  and (-4 % +3) == -1\n       \n   \n \n \n If the signs of arguments are unknown and a positive modulus\n is needed it can be computed as (floorMod(x, y) + abs(y)) % abs(y)."
                },
                {
                  "signature": "public static int floorMod(long x, int y)",
                  "description": "Returns the floor modulus of the long and int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n For examples, see floorMod(int, int)."
                },
                {
                  "signature": "public static long floorMod(long x, long y)",
                  "description": "Returns the floor modulus of the long arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n For examples, see floorMod(int, int)."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public static int abs(int a)",
                  "description": "Returns the absolute value of an int value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int\n value, the result is that same value, which is negative. In\n contrast, the absExact(int) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static long abs(long a)",
                  "description": "Returns the absolute value of a long value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Long.MIN_VALUE, the most negative representable long\n value, the result is that same value, which is negative. In\n contrast, the absExact(long) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static float abs(float a)",
                  "description": "Returns the absolute value of a float value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the\n result is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                },
                {
                  "signature": "public static double abs(double a)",
                  "description": "Returns the absolute value of a double value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the result\n is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                }
              ]
            },
            {
              "name": "absExact",
              "overloads": [
                {
                  "signature": "public static int absExact(int a)",
                  "description": "Returns the mathematical absolute value of an int value\n if it is exactly representable as an int, throwing\n ArithmeticException if the result overflows the\n positive int range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Integer.MIN_VALUE\n overflows the positive int range, so an exception is\n thrown for that argument."
                },
                {
                  "signature": "public static long absExact(long a)",
                  "description": "Returns the mathematical absolute value of an long value\n if it is exactly representable as an long, throwing\n ArithmeticException if the result overflows the\n positive long range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Long.MIN_VALUE overflows\n the positive long range, so an exception is thrown for\n that argument."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values. That is, the\n result is the argument closer to the value of\n Integer.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values. That is, the\n result is the argument closer to the value of\n Long.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values.  That is,\n the result is the argument closer to positive infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                },
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values.  That\n is, the result is the argument closer to positive infinity. If\n the arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values. That is,\n the result the argument closer to the value of\n Integer.MIN_VALUE.  If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values. That is,\n the result is the argument closer to the value of\n Long.MIN_VALUE. If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values.  That is,\n the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero.  If\n one argument is positive zero and the other is negative zero,\n the result is negative zero."
                },
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values.  That\n is, the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other is negative zero, the\n result is negative zero."
                }
              ]
            },
            {
              "name": "fma",
              "overloads": [
                {
                  "signature": "public static double fma(double a, double b, double c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n double.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0) does not always return the\n same result as (a * b) since\n fma(-0.0, +0.0, +0.0) is +0.0 while\n (-0.0 * +0.0) is -0.0; fma(a, b, -0.0) is\n equivalent to (a * b) however."
                },
                {
                  "signature": "public static float fma(float a, float b, float c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n float.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0f, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0f) does not always return the\n same result as (a * b) since\n fma(-0.0f, +0.0f, +0.0f) is +0.0f while\n (-0.0f * +0.0f) is -0.0f; fma(a, b, -0.0f) is\n equivalent to (a * b) however."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public static double ulp(double d)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a double value is the positive\n distance between this floating-point value and the \n double value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Double.MIN_VALUE.\n  If the argument is Double.MAX_VALUE, then\n the result is equal to 2971."
                },
                {
                  "signature": "public static float ulp(float f)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a float value is the positive\n distance between this floating-point value and the \n float value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Float.MIN_VALUE.\n  If the argument is Float.MAX_VALUE, then\n the result is equal to 2104."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static double signum(double d)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0 if the argument is greater than zero, -1.0 if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                },
                {
                  "signature": "public static float signum(float f)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0f if the argument is greater than zero, -1.0f if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                }
              ]
            },
            {
              "name": "sinh",
              "overloads": [
                {
                  "signature": "public static double sinh(double x)",
                  "description": "Returns the hyperbolic sine of a double value.\n The hyperbolic sine of x is defined to be\n (ex-e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 2.5 ulps of the exact result."
                }
              ]
            },
            {
              "name": "cosh",
              "overloads": [
                {
                  "signature": "public static double cosh(double x)",
                  "description": "Returns the hyperbolic cosine of a double value.\n The hyperbolic cosine of x is defined to be\n (ex+e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is positive\n infinity.\n\n If the argument is zero, then the result is 1.0.\n\n \n\n The computed result must be within 2.5 ulps of the exact result."
                }
              ]
            },
            {
              "name": "tanh",
              "overloads": [
                {
                  "signature": "public static double tanh(double x)",
                  "description": "Returns the hyperbolic tangent of a double value.\n The hyperbolic tangent of x is defined to be\n (ex-e-x)/(ex+e-x),\n in other words, sinh(x)/cosh(x).  Note\n that the absolute value of the exact tanh is always less than\n 1.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n If the argument is positive infinity, then the result is\n +1.0.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n \n\n The computed result must be within 2.5 ulps of the exact result.\n The result of tanh for any finite input must have\n an absolute value less than or equal to 1.  Note that once the\n exact result of tanh is within 1/2 of an ulp of the limit value\n of 1, correctly signed 1.0 should\n be returned."
                }
              ]
            },
            {
              "name": "hypot",
              "overloads": [
                {
                  "signature": "public static double hypot(double x, double y)",
                  "description": "Returns sqrt(x2+y2)\n without intermediate overflow or underflow.\n\n Special cases:\n \n\n  If either argument is infinite, then the result\n is positive infinity.\n\n  If either argument is NaN and neither argument is infinite,\n then the result is NaN.\n\n  If both arguments are zero, the result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact\n result.  If one parameter is held constant, the results must be\n semi-monotonic in the other parameter."
                }
              ]
            },
            {
              "name": "expm1",
              "overloads": [
                {
                  "signature": "public static double expm1(double x)",
                  "description": "Returns ex-1.  Note that for values of\n x near 0, the exact sum of\n expm1(x)+1 is much closer to the true\n result of ex than exp(x).\n\n Special cases:\n \n If the argument is NaN, the result is NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic.  The result of\n expm1 for any finite input must be greater than or\n equal to -1.0.  Note that once the exact result of\n ex-1 is within 1/2\n ulp of the limit value -1, -1.0 should be\n returned."
                }
              ]
            },
            {
              "name": "log1p",
              "overloads": [
                {
                  "signature": "public static double log1p(double x)",
                  "description": "Returns the natural logarithm of the sum of the argument and 1.\n Note that for small values x, the result of\n log1p(x) is much closer to the true result of ln(1\n + x) than the floating-point evaluation of\n log(1.0+x).\n\n Special cases:\n\n \n\n If the argument is NaN or less than -1, then the result is\n NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative one, then the result is\n negative infinity.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "copySign",
              "overloads": [
                {
                  "signature": "public static double copySign(double magnitude, double sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  Note that unlike the StrictMath.copySign\n method, this method does not require NaN sign\n arguments to be treated as positive values; implementations are\n permitted to treat some NaN arguments as positive and other NaN\n arguments as negative to allow greater performance."
                },
                {
                  "signature": "public static float copySign(float magnitude, float sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  Note that unlike the StrictMath.copySign\n method, this method does not require NaN sign\n arguments to be treated as positive values; implementations are\n permitted to treat some NaN arguments as positive and other NaN\n arguments as negative to allow greater performance."
                }
              ]
            },
            {
              "name": "getExponent",
              "overloads": [
                {
                  "signature": "public static int getExponent(float f)",
                  "description": "Returns the unbiased exponent used in the representation of a\n float.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Float.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Float.MIN_EXPONENT -1."
                },
                {
                  "signature": "public static int getExponent(double d)",
                  "description": "Returns the unbiased exponent used in the representation of a\n double.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Double.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Double.MIN_EXPONENT -1."
                }
              ]
            },
            {
              "name": "nextAfter",
              "overloads": [
                {
                  "signature": "public static double nextAfter(double start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal the second argument is returned.\n\n \n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, direction\n is returned unchanged (as implied by the requirement of\n returning the second argument if the arguments compare as\n equal).\n\n  If start is\n Double.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Double.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Double.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                },
                {
                  "signature": "public static float nextAfter(float start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal a value equivalent to the second argument\n is returned.\n\n \n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, a value equivalent\n to direction is returned.\n\n  If start is\n Float.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Float.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Float.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                }
              ]
            },
            {
              "name": "nextUp",
              "overloads": [
                {
                  "signature": "public static double nextUp(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextUp(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "nextDown",
              "overloads": [
                {
                  "signature": "public static double nextDown(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextDown(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "scalb",
              "overloads": [
                {
                  "signature": "public static double scalb(double d, int scaleFactor)",
                  "description": "Returns d  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Double.MIN_EXPONENT and Double.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Double.MAX_EXPONENT, an infinity is returned.  Note that if\n the result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as d.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                },
                {
                  "signature": "public static float scalb(float f, int scaleFactor)",
                  "description": "Returns f  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Float.MIN_EXPONENT and Float.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Float.MAX_EXPONENT, an infinity is returned.  Note that if the\n result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as f.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Module",
          "methods": [
            {
              "name": "isNamed",
              "overloads": [
                {
                  "signature": "public boolean isNamed()",
                  "description": "Returns true if this module is a named module."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the module name or null if this module is an unnamed\n module."
                }
              ]
            },
            {
              "name": "getClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getClassLoader()",
                  "description": "Returns the ClassLoader for this module.\n\n  If there is a security manager then its checkPermission\n method if first called with a RuntimePermission(\"getClassLoader\")\n permission to check that the caller is allowed to get access to the\n class loader."
                }
              ]
            },
            {
              "name": "getDescriptor",
              "overloads": [
                {
                  "signature": "public ModuleDescriptor getDescriptor()",
                  "description": "Returns the module descriptor for this module or null if this\n module is an unnamed module."
                }
              ]
            },
            {
              "name": "getLayer",
              "overloads": [
                {
                  "signature": "public ModuleLayer getLayer()",
                  "description": "Returns the module layer that contains this module or null if\n this module is not in a module layer.\n\n A module layer contains named modules and therefore this method always\n returns null when invoked on an unnamed module.\n\n  Dynamic modules are\n named modules that are generated at runtime. A dynamic module may or may\n not be in a module layer."
                }
              ]
            },
            {
              "name": "canRead",
              "overloads": [
                {
                  "signature": "public boolean canRead(Module other)",
                  "description": "Indicates if this module reads the given module. This method returns\n true if invoked to test if this module reads itself. It also\n returns true if invoked on an unnamed module (as unnamed\n modules read all modules)."
                }
              ]
            },
            {
              "name": "addReads",
              "overloads": [
                {
                  "signature": "public Module addReads(Module other)",
                  "description": "If the caller's module is this module then update this module to read\n the given module.\n\n This method is a no-op if other is this module (all modules read\n themselves), this module is an unnamed module (as unnamed modules read\n all modules), or this module already reads other."
                }
              ]
            },
            {
              "name": "isExported",
              "overloads": [
                {
                  "signature": "public boolean isExported(String pn, Module other)",
                  "description": "Returns true if this module exports the given package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is exported to itself. It always returns true when\n invoked on an unnamed module. A package that is open to\n the given module is considered exported to that module at run-time and\n so this method returns true if the package is open to the given\n module. \n\n  This method does not check if the given module reads this module."
                },
                {
                  "signature": "public boolean isExported(String pn)",
                  "description": "Returns true if this module exports the given package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. A package that is opened unconditionally\n is considered exported unconditionally at run-time and so this method\n returns true if the package is opened unconditionally. \n\n  This method does not check if the given module reads this module."
                }
              ]
            },
            {
              "name": "isOpen",
              "overloads": [
                {
                  "signature": "public boolean isOpen(String pn, Module other)",
                  "description": "Returns true if this module has opened a package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is open to itself. It returns true when invoked on an\n open module with a package in the module.\n It always returns true when invoked on an unnamed module. \n\n  This method does not check if the given module reads this module."
                },
                {
                  "signature": "public boolean isOpen(String pn)",
                  "description": "Returns true if this module has opened a package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. Additionally, it always returns true when invoked on an\n open module with a package in the\n module. \n\n  This method does not check if the given module reads this module."
                }
              ]
            },
            {
              "name": "addExports",
              "overloads": [
                {
                  "signature": "public Module addExports(String pn, Module other)",
                  "description": "If the caller's module is this module then update this module to export\n the given package to the given module.\n\n  This method has no effect if the package is already exported (or\n open) to the given module."
                }
              ]
            },
            {
              "name": "addOpens",
              "overloads": [
                {
                  "signature": "public Module addOpens(String pn, Module other)",
                  "description": "If this module has opened a package to at least the caller\n module then update this module to open the package to the given module.\n Opening a package with this method allows all types in the package,\n and all their members, not just public types and their public members,\n to be reflected on by the given module when using APIs that support\n private access or a way to bypass or suppress default Java language\n access control checks.\n\n  This method has no effect if the package is already open\n to the given module."
                }
              ]
            },
            {
              "name": "addUses",
              "overloads": [
                {
                  "signature": "public Module addUses(Class<?> service)",
                  "description": "If the caller's module is this module then update this module to add a\n service dependence on the given service type. This method is intended\n for use by frameworks that invoke ServiceLoader on behalf of other modules or where the framework is\n passed a reference to the service type by other code. This method is\n a no-op when invoked on an unnamed module or an automatic module.\n\n  This method does not cause resolveAndBind to be re-run."
                }
              ]
            },
            {
              "name": "canUse",
              "overloads": [
                {
                  "signature": "public boolean canUse(Class<?> service)",
                  "description": "Indicates if this module has a service dependence on the given service\n type. This method always returns true when invoked on an unnamed\n module or an automatic module."
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "public Set<String> getPackages()",
                  "description": "Returns the set of package names for the packages in this module.\n\n  For named modules, the returned set contains an element for each\n package in the module. \n\n  For unnamed modules, the returned set contains an element for\n each package that has been defined\n in the unnamed module."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <T extends Annotation> T getAnnotation(Class<T> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n This method returns null when invoked on an unnamed module.\n\n  Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module.\n\n  Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module.\n\n  Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name) throws IOException",
                  "description": "Returns an input stream for reading a resource in this module.\n The name parameter is a '/'-separated path name that\n identifies the resource. As with Class.getResourceAsStream, this method delegates to the module's class\n loader findResource(String,String) method, invoking it with the module name\n (or null when the module is unnamed) and the name of the\n resource. If the resource name has a leading slash then it is dropped\n before delegation.\n\n  A resource in a named module may be encapsulated so that\n it cannot be located by code in other modules. Whether a resource can be\n located or not is determined as follows: \n\n \n      If the resource name ends with  \".class\" then it is not\n     encapsulated. \n\n      A package name is derived from the resource name. If\n     the package name is a package in the\n     module then the resource can only be located by the caller of this\n     method when the package is open\n     to at least the caller's module. If the resource is not in a\n     package in the module then the resource is not encapsulated. \n \n\n  In the above, the package name for a resource is derived\n from the subsequence of characters that precedes the last '/' in\n the name and then replacing each '/' character in the subsequence\n with '.'. A leading slash is ignored when deriving the package\n name. As an example, the package name derived for a resource named\n \"a/b/c/foo.properties\" is \"a.b.c\". A resource name\n with the name \"META-INF/MANIFEST.MF\" is never encapsulated\n because \"META-INF\" is not a legal package name. \n\n  This method returns null if the resource is not in this\n module, the resource is encapsulated and cannot be located by the caller,\n or access to the resource is denied by the security manager."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this module. For a named module,\n the representation is the string \"module\", followed by a space,\n and then the module name. For an unnamed module, the representation is\n the string \"unnamed module\", followed by a space, and then an\n implementation specific string that identifies the unnamed module."
                }
              ]
            }
          ]
        },
        {
          "name": "ModuleLayer",
          "methods": [
            {
              "name": "defineModulesWithOneLoader",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModulesWithOneLoader(Configuration cf, ClassLoader parentLoader)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n This method creates one class loader and defines all modules to that\n class loader. The parent of each class\n loader is the given parent class loader. This method works exactly as\n specified by the static defineModulesWithOneLoader method when invoked with this layer as the\n parent. In other words, if this layer is thisLayer then this\n method is equivalent to invoking:\n  \n     ModuleLayer.defineModulesWithOneLoader(cf, List.of(thisLayer), parentLoader).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModulesWithOneLoader(Configuration cf, List<ModuleLayer> parentLayers, ClassLoader parentLoader)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. This method creates one\n class loader and defines all modules to that class loader.\n\n  The class loader created by this method implements direct\n delegation when loading classes from modules. If the loadClass method is invoked to\n load a class then it uses the package name of the class to map it to a\n module. This may be a module in this layer and hence defined to the same\n class loader. It may be a package in a module in a parent layer that is\n exported to one or more of the modules in this layer. The class\n loader delegates to the class loader of the module, throwing \n ClassNotFoundException if not found by that class loader.\n When loadClass is invoked to load classes that do not map to a\n module then it delegates to the parent class loader. \n\n  The class loader created by this method locates resources\n (getResource, getResources, and other resource\n methods) in all modules in the layer before searching the parent class\n loader. \n\n  Attempting to create a layer with all modules defined to the same\n class loader can fail for the following reasons:\n\n \n\n      Overlapping packages: Two or more modules in the\n     configuration have the same package. \n\n      Split delegation: The resulting class loader would\n     need to delegate to more than one class loader in order to load\n     classes in a specific package. \n\n \n\n  In addition, a layer cannot be created if the configuration contains\n a module named \"java.base\", or a module contains a package named\n \"java\" or a package with a name starting with \"java.\". \n\n  If there is a security manager then the class loader created by\n this method will load classes and resources with privileges that are\n restricted by the calling context of this method."
                }
              ]
            },
            {
              "name": "defineModulesWithManyLoaders",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModulesWithManyLoaders(Configuration cf, ClassLoader parentLoader)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n Each module is defined to its own ClassLoader created by this\n method. The parent of each class loader\n is the given parent class loader. This method works exactly as specified\n by the static defineModulesWithManyLoaders method when invoked with this layer as the\n parent. In other words, if this layer is thisLayer then this\n method is equivalent to invoking:\n  \n     ModuleLayer.defineModulesWithManyLoaders(cf, List.of(thisLayer), parentLoader).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModulesWithManyLoaders(Configuration cf, List<ModuleLayer> parentLayers, ClassLoader parentLoader)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. Each module is defined to\n its own ClassLoader created by this method. The parent of each class loader is the given parent\n class loader.\n\n  The class loaders created by this method implement direct\n delegation when loading classes from modules. If the loadClass method is invoked to\n load a class then it uses the package name of the class to map it to a\n module. The package may be in the module defined to the class loader.\n The package may be exported by another module in this layer to the\n module defined to the class loader. It may be in a package exported by a\n module in a parent layer. The class loader delegates to the class loader\n of the module, throwing ClassNotFoundException if not found by\n that class loader. When loadClass is invoked to load a class\n that does not map to a module then it delegates to the parent class\n loader. \n\n  The class loaders created by this method locate resources\n (getResource, getResources, and other resource\n methods) in the module defined to the class loader before searching\n the parent class loader. \n\n  If there is a security manager then the class loaders created by\n this method will load classes and resources with privileges that are\n restricted by the calling context of this method."
                }
              ]
            },
            {
              "name": "defineModules",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModules(Configuration cf, Function<String,ClassLoader> clf)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n Each module is mapped, by name, to its class loader by means of the\n given function. This method works exactly as specified by the static\n defineModules\n method when invoked with this layer as the parent. In other words, if\n this layer is thisLayer then this method is equivalent to\n invoking:\n  \n     ModuleLayer.defineModules(cf, List.of(thisLayer), clf).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModules(Configuration cf, List<ModuleLayer> parentLayers, Function<String,ClassLoader> clf)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. The given function maps each\n module in the configuration, by name, to a class loader. Creating the\n layer informs the Java virtual machine about the classes that may be\n loaded so that the Java virtual machine knows which module that each\n class is a member of.\n\n  The class loader delegation implemented by the class loaders must\n respect module readability. The class loaders should be\n parallel-capable so as to\n avoid deadlocks during class loading. In addition, the entity creating\n a new layer with this method should arrange that the class loaders be\n ready to load from these modules before there are any attempts to load\n classes or resources. \n\n  Creating a layer can fail for the following reasons: \n\n \n\n      Two or more modules with the same package are mapped to the\n     same class loader. \n\n      A module is mapped to a class loader that already has a\n     module of the same name defined to it. \n\n      A module is mapped to a class loader that has already\n     defined types in any of the packages in the module. \n\n \n\n  In addition, a layer cannot be created if the configuration contains\n a module named \"java.base\", a configuration contains a module\n with a package named \"java\" or a package name starting with\n \"java.\", or the function to map a module name to a class loader\n returns null or the platform class loader. \n\n  If the function to map a module name to class loader throws an error\n or runtime exception then it is propagated to the caller of this method."
                }
              ]
            },
            {
              "name": "configuration",
              "overloads": [
                {
                  "signature": "public Configuration configuration()",
                  "description": "Returns the configuration for this layer."
                }
              ]
            },
            {
              "name": "parents",
              "overloads": [
                {
                  "signature": "public List<ModuleLayer> parents()",
                  "description": "Returns an unmodifiable list of this layer's parents, in search\n order. If this is the empty layer then an\n empty list is returned."
                }
              ]
            },
            {
              "name": "modules",
              "overloads": [
                {
                  "signature": "public Set<Module> modules()",
                  "description": "Returns an unmodifiable set of the modules in this layer."
                }
              ]
            },
            {
              "name": "findModule",
              "overloads": [
                {
                  "signature": "public Optional<Module> findModule(String name)",
                  "description": "Returns the module with the given name in this layer, or if not in this\n layer, the parent layers. Finding a module in\n parent layers is equivalent to invoking findModule on each\n parent, in search order, until the module is found or all parents have\n been searched. In a tree of layers  then this is equivalent to\n a depth-first search."
                }
              ]
            },
            {
              "name": "findLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader findLoader(String name)",
                  "description": "Returns the ClassLoader for the module with the given name. If\n a module of the given name is not in this layer then the parent layers are searched in the manner specified by findModule.\n\n  If there is a security manager then its checkPermission\n method is called with a RuntimePermission(\"getClassLoader\")\n permission to check that the caller is allowed to get access to the\n class loader."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this module layer."
                }
              ]
            },
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static ModuleLayer empty()",
                  "description": "Returns the empty layer. There are no modules in the empty\n layer. It has no parents."
                }
              ]
            },
            {
              "name": "boot",
              "overloads": [
                {
                  "signature": "public static ModuleLayer boot()",
                  "description": "Returns the boot layer. The boot layer contains at least one module,\n java.base. Its parent is the empty layer."
                }
              ]
            }
          ]
        },
        {
          "name": "ModuleLayer.Controller",
          "methods": [
            {
              "name": "layer",
              "overloads": [
                {
                  "signature": "public ModuleLayer layer()",
                  "description": "Returns the layer that this object controls."
                }
              ]
            },
            {
              "name": "addReads",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addReads(Module source, Module target)",
                  "description": "Updates module source in the layer to read module\n target. This method is a no-op if source already\n reads target."
                }
              ]
            },
            {
              "name": "addExports",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addExports(Module source, String pn, Module target)",
                  "description": "Updates module source in the layer to export a package to\n module target. This method is a no-op if source\n already exports the package to at least target."
                }
              ]
            },
            {
              "name": "addOpens",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addOpens(Module source, String pn, Module target)",
                  "description": "Updates module source in the layer to open a package to\n module target. This method is a no-op if source\n already opens the package to at least target."
                }
              ]
            }
          ]
        },
        {
          "name": "NegativeArraySizeException",
          "methods": [
            {
              "name": "NegativeArraySizeException",
              "overloads": [
                {
                  "signature": "public NegativeArraySizeException()",
                  "description": "Constructs a NegativeArraySizeException with no\n detail message."
                },
                {
                  "signature": "public NegativeArraySizeException(String s)",
                  "description": "Constructs a NegativeArraySizeException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoClassDefFoundError",
          "methods": [
            {
              "name": "NoClassDefFoundError",
              "overloads": [
                {
                  "signature": "public NoClassDefFoundError()",
                  "description": "Constructs a NoClassDefFoundError with no detail message."
                },
                {
                  "signature": "public NoClassDefFoundError(String s)",
                  "description": "Constructs a NoClassDefFoundError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchFieldError",
          "methods": [
            {
              "name": "NoSuchFieldError",
              "overloads": [
                {
                  "signature": "public NoSuchFieldError()",
                  "description": "Constructs a NoSuchFieldError with no detail message."
                },
                {
                  "signature": "public NoSuchFieldError(String s)",
                  "description": "Constructs a NoSuchFieldError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchFieldException",
          "methods": [
            {
              "name": "NoSuchFieldException",
              "overloads": [
                {
                  "signature": "public NoSuchFieldException()",
                  "description": "Constructor."
                },
                {
                  "signature": "public NoSuchFieldException(String s)",
                  "description": "Constructor with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchMethodError",
          "methods": [
            {
              "name": "NoSuchMethodError",
              "overloads": [
                {
                  "signature": "public NoSuchMethodError()",
                  "description": "Constructs a NoSuchMethodError with no detail message."
                },
                {
                  "signature": "public NoSuchMethodError(String s)",
                  "description": "Constructs a NoSuchMethodError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchMethodException",
          "methods": [
            {
              "name": "NoSuchMethodException",
              "overloads": [
                {
                  "signature": "public NoSuchMethodException()",
                  "description": "Constructs a NoSuchMethodException without a detail message."
                },
                {
                  "signature": "public NoSuchMethodException(String s)",
                  "description": "Constructs a NoSuchMethodException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NullPointerException",
          "methods": [
            {
              "name": "NullPointerException",
              "overloads": [
                {
                  "signature": "public NullPointerException()",
                  "description": "Constructs a NullPointerException with no detail message."
                },
                {
                  "signature": "public NullPointerException(String s)",
                  "description": "Constructs a NullPointerException with the specified\n detail message."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns the detail message string of this throwable.\n\n  If a non-null message was supplied in a constructor it is\n returned. Otherwise, an implementation specific message or\n null is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Number",
          "methods": [
            {
              "name": "Number",
              "overloads": [
                {
                  "signature": "public Number()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public abstract int intValue()",
                  "description": "Returns the value of the specified number as an int."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public abstract long longValue()",
                  "description": "Returns the value of the specified number as a long."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public abstract float floatValue()",
                  "description": "Returns the value of the specified number as a float."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public abstract double doubleValue()",
                  "description": "Returns the value of the specified number as a double."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of the specified number as a byte."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of the specified number as a short."
                }
              ]
            }
          ]
        },
        {
          "name": "NumberFormatException",
          "methods": [
            {
              "name": "NumberFormatException",
              "overloads": [
                {
                  "signature": "public NumberFormatException()",
                  "description": "Constructs a NumberFormatException with no detail message."
                },
                {
                  "signature": "public NumberFormatException(String s)",
                  "description": "Constructs a NumberFormatException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Object",
          "methods": [
            {
              "name": "Object",
              "overloads": [
                {
                  "signature": "public Object()",
                  "description": "Constructs a new object."
                }
              ]
            },
            {
              "name": "getClass",
              "overloads": [
                {
                  "signature": "public final Class<?> getClass()",
                  "description": "Returns the runtime class of this Object. The returned\n Class object is the object that is locked by \n static synchronized methods of the represented class.\n\n The actual result type is Class<? extends |X|>\n where |X| is the erasure of the static type of the\n expression on which getClass is called. For\n example, no cast is required in this code fragment:\n\n \n Number n = 0;                             \n Class<? extends Number> c = n.getClass();"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for the object. This method is\n supported for the benefit of hash tables such as those provided by\n HashMap.\n \n The general contract of hashCode is:\n \n Whenever it is invoked on the same object more than once during\n     an execution of a Java application, the hashCode method\n     must consistently return the same integer, provided no information\n     used in equals comparisons on the object is modified.\n     This integer need not remain consistent from one execution of an\n     application to another execution of the same application.\n If two objects are equal according to the equals method, then calling the \n     hashCode method on each of the two objects must produce the\n     same integer result.\n It is not required that if two objects are unequal\n     according to the equals method, then\n     calling the hashCode method on each of the two objects\n     must produce distinct integer results.  However, the programmer\n     should be aware that producing distinct integer results for\n     unequal objects may improve the performance of hash tables."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this one.\n \n The equals method implements an equivalence relation\n on non-null object references:\n \n It is reflexive: for any non-null reference value\n     x, x.equals(x) should return\n     true.\n It is symmetric: for any non-null reference values\n     x and y, x.equals(y)\n     should return true if and only if\n     y.equals(x) returns true.\n It is transitive: for any non-null reference values\n     x, y, and z, if\n     x.equals(y) returns true and\n     y.equals(z) returns true, then\n     x.equals(z) should return true.\n It is consistent: for any non-null reference values\n     x and y, multiple invocations of\n     x.equals(y) consistently return true\n     or consistently return false, provided no\n     information used in equals comparisons on the\n     objects is modified.\n For any non-null reference value x,\n     x.equals(null) should return false.\n \n\n \n An equivalence relation partitions the elements it operates on\n into equivalence classes; all the members of an\n equivalence class are equal to each other. Members of an\n equivalence class are substitutable for each other, at least\n for some purposes."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected Object clone() throws CloneNotSupportedException",
                  "description": "Creates and returns a copy of this object.  The precise meaning\n of \"copy\" may depend on the class of the object. The general\n intent is that, for any object x, the expression:\n \n  x.clone() != x\n will be true, and that the expression:\n \n  x.clone().getClass() == x.getClass()\n will be true, but these are not absolute requirements.\n While it is typically the case that:\n \n  x.clone().equals(x)\n will be true, this is not an absolute requirement.\n \n By convention, the returned object should be obtained by calling\n super.clone.  If a class and all of its superclasses (except\n Object) obey this convention, it will be the case that\n x.clone().getClass() == x.getClass().\n \n By convention, the object returned by this method should be independent\n of this object (which is being cloned).  To achieve this independence,\n it may be necessary to modify one or more fields of the object returned\n by super.clone before returning it.  Typically, this means\n copying any mutable objects that comprise the internal \"deep structure\"\n of the object being cloned and replacing the references to these\n objects with references to the copies.  If a class contains only\n primitive fields or references to immutable objects, then it is usually\n the case that no fields in the object returned by super.clone\n need to be modified."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of the object."
                }
              ]
            },
            {
              "name": "notify",
              "overloads": [
                {
                  "signature": "public final void notify()",
                  "description": "Wakes up a single thread that is waiting on this object's\n monitor. If any threads are waiting on this object, one of them\n is chosen to be awakened. The choice is arbitrary and occurs at\n the discretion of the implementation. A thread waits on an object's\n monitor by calling one of the wait methods.\n \n The awakened thread will not be able to proceed until the current\n thread relinquishes the lock on this object. The awakened thread will\n compete in the usual manner with any other threads that might be\n actively competing to synchronize on this object; for example, the\n awakened thread enjoys no reliable privilege or disadvantage in being\n the next thread to lock this object.\n \n This method should only be called by a thread that is the owner\n of this object's monitor. A thread becomes the owner of the\n object's monitor in one of three ways:\n \n By executing a synchronized instance method of that object.\n By executing the body of a synchronized statement\n     that synchronizes on the object.\n For objects of type Class, by executing a\n     synchronized static method of that class.\n \n \n Only one thread at a time can own an object's monitor."
                }
              ]
            },
            {
              "name": "notifyAll",
              "overloads": [
                {
                  "signature": "public final void notifyAll()",
                  "description": "Wakes up all threads that are waiting on this object's monitor. A\n thread waits on an object's monitor by calling one of the\n wait methods.\n \n The awakened threads will not be able to proceed until the current\n thread relinquishes the lock on this object. The awakened threads\n will compete in the usual manner with any other threads that might\n be actively competing to synchronize on this object; for example,\n the awakened threads enjoy no reliable privilege or disadvantage in\n being the next thread to lock this object.\n \n This method should only be called by a thread that is the owner\n of this object's monitor. See the notify method for a\n description of the ways in which a thread can become the owner of\n a monitor."
                }
              ]
            },
            {
              "name": "wait",
              "overloads": [
                {
                  "signature": "public final void wait() throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted.\n \n In all respects, this method behaves as if wait(0L, 0)\n had been called. See the specification of the wait(long, int) method\n for details."
                },
                {
                  "signature": "public final void wait(long timeoutMillis) throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted, or until a\n certain amount of real time has elapsed.\n \n In all respects, this method behaves as if wait(timeoutMillis, 0)\n had been called. See the specification of the wait(long, int) method\n for details."
                },
                {
                  "signature": "public final void wait(long timeoutMillis, int nanos) throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted, or until a\n certain amount of real time has elapsed.\n \n The current thread must own this object's monitor lock. See the\n notify method for a description of the ways in which\n a thread can become the owner of a monitor lock.\n \n This method causes the current thread (referred to here as T) to\n place itself in the wait set for this object and then to relinquish any\n and all synchronization claims on this object. Note that only the locks\n on this object are relinquished; any other objects on which the current\n thread may be synchronized remain locked while the thread waits.\n \n Thread T then becomes disabled for thread scheduling purposes\n and lies dormant until one of the following occurs:\n \n Some other thread invokes the notify method for this\n object and thread T happens to be arbitrarily chosen as\n the thread to be awakened.\n Some other thread invokes the notifyAll method for this\n object.\n Some other thread interrupts\n thread T.\n The specified amount of real time has elapsed, more or less.\n The amount of real time, in nanoseconds, is given by the expression\n 1000000 * timeoutMillis + nanos. If timeoutMillis and nanos\n are both zero, then real time is not taken into consideration and the\n thread waits until awakened by one of the other causes.\n Thread T is awakened spuriously. (See below.)\n \n \n The thread T is then removed from the wait set for this\n object and re-enabled for thread scheduling. It competes in the\n usual manner with other threads for the right to synchronize on the\n object; once it has regained control of the object, all its\n synchronization claims on the object are restored to the status quo\n ante - that is, to the situation as of the time that the wait\n method was invoked. Thread T then returns from the\n invocation of the wait method. Thus, on return from the\n wait method, the synchronization state of the object and of\n thread T is exactly as it was when the wait method\n was invoked.\n \n A thread can wake up without being notified, interrupted, or timing out, a\n so-called spurious wakeup.  While this will rarely occur in practice,\n applications must guard against it by testing for the condition that should\n have caused the thread to be awakened, and continuing to wait if the condition\n is not satisfied. See the example below.\n \n For more information on this topic, see section 14.2,\n \"Condition Queues,\" in Brian Goetz and others' Java Concurrency\n in Practice (Addison-Wesley, 2006) or Item 69 in Joshua\n Bloch's Effective Java, Second Edition (Addison-Wesley,\n 2008).\n \n If the current thread is interrupted\n by any thread before or while it is waiting, then an InterruptedException\n is thrown.  The interrupted status of the current thread is cleared when\n this exception is thrown. This exception is not thrown until the lock status of\n this object has been restored as described above."
                }
              ]
            },
            {
              "name": "finalize",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected void finalize() throws Throwable",
                  "description": "Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.\n A subclass overrides the finalize method to dispose of\n system resources or to perform other cleanup.\n \n The general contract of finalize is that it is invoked\n if and when the Java virtual\n machine has determined that there is no longer any\n means by which this object can be accessed by any thread that has\n not yet died, except as a result of an action taken by the\n finalization of some other object or class which is ready to be\n finalized. The finalize method may take any action, including\n making this object available again to other threads; the usual purpose\n of finalize, however, is to perform cleanup actions before\n the object is irrevocably discarded. For example, the finalize method\n for an object that represents an input/output connection might perform\n explicit I/O transactions to break the connection before the object is\n permanently discarded.\n \n The finalize method of class Object performs no\n special action; it simply returns normally. Subclasses of\n Object may override this definition.\n \n The Java programming language does not guarantee which thread will\n invoke the finalize method for any given object. It is\n guaranteed, however, that the thread that invokes finalize will not\n be holding any user-visible synchronization locks when finalize is\n invoked. If an uncaught exception is thrown by the finalize method,\n the exception is ignored and finalization of that object terminates.\n \n After the finalize method has been invoked for an object, no\n further action is taken until the Java virtual machine has again\n determined that there is no longer any means by which this object can\n be accessed by any thread that has not yet died, including possible\n actions by other objects or classes which are ready to be finalized,\n at which point the object may be discarded.\n \n The finalize method is never invoked more than once by a Java\n virtual machine for any given object.\n \n Any exception thrown by the finalize method causes\n the finalization of this object to be halted, but is otherwise\n ignored.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "OutOfMemoryError",
          "methods": [
            {
              "name": "OutOfMemoryError",
              "overloads": [
                {
                  "signature": "public OutOfMemoryError()",
                  "description": "Constructs an OutOfMemoryError with no detail message."
                },
                {
                  "signature": "public OutOfMemoryError(String s)",
                  "description": "Constructs an OutOfMemoryError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Package",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Return the name of this package."
                }
              ]
            },
            {
              "name": "getSpecificationTitle",
              "overloads": [
                {
                  "signature": "public String getSpecificationTitle()",
                  "description": "Return the title of the specification that this package implements."
                }
              ]
            },
            {
              "name": "getSpecificationVersion",
              "overloads": [
                {
                  "signature": "public String getSpecificationVersion()",
                  "description": "Returns the version number of the specification\n that this package implements.\n This version string must be a sequence of non-negative decimal\n integers separated by \".\"'s and may have leading zeros.\n When version strings are compared the most significant\n numbers are compared.\n\n\n Specification version numbers use a syntax that consists of non-negative\n decimal integers separated by periods \".\", for example \"2.0\" or\n \"1.2.3.4.5.6.7\".  This allows an extensible number to be used to represent\n major, minor, micro, etc. versions.  The version specification is described\n by the following formal grammar:\n \n \n SpecificationVersion:\n Digits RefinedVersionopt\n\n RefinedVersion:\n . Digits\n . Digits RefinedVersion\n\n Digits:\n Digit\n Digits\n\n Digit:\n any character for which Character.isDigit(char) returns true,\n e.g. 0, 1, 2, ..."
                }
              ]
            },
            {
              "name": "getSpecificationVendor",
              "overloads": [
                {
                  "signature": "public String getSpecificationVendor()",
                  "description": "Return the name of the organization, vendor,\n or company that owns and maintains the specification\n of the classes that implement this package."
                }
              ]
            },
            {
              "name": "getImplementationTitle",
              "overloads": [
                {
                  "signature": "public String getImplementationTitle()",
                  "description": "Return the title of this package."
                }
              ]
            },
            {
              "name": "getImplementationVersion",
              "overloads": [
                {
                  "signature": "public String getImplementationVersion()",
                  "description": "Return the version of this implementation. It consists of any string\n assigned by the vendor of this implementation and does\n not have any particular syntax specified or expected by the Java\n runtime. It may be compared for equality with other\n package version strings used for this implementation\n by this vendor for this package."
                }
              ]
            },
            {
              "name": "getImplementationVendor",
              "overloads": [
                {
                  "signature": "public String getImplementationVendor()",
                  "description": "Returns the vendor that implemented this package, null\n is returned if it is not known."
                }
              ]
            },
            {
              "name": "isSealed",
              "overloads": [
                {
                  "signature": "public boolean isSealed()",
                  "description": "Returns true if this package is sealed."
                },
                {
                  "signature": "public boolean isSealed(URL url)",
                  "description": "Returns true if this package is sealed with respect to the specified\n code source url."
                }
              ]
            },
            {
              "name": "isCompatibleWith",
              "overloads": [
                {
                  "signature": "public boolean isCompatibleWith(String desired) throws NumberFormatException",
                  "description": "Compare this package's specification version with a\n desired version. It returns true if\n this packages specification version number is greater than or equal\n to the desired version number. \n\n Version numbers are compared by sequentially comparing corresponding\n components of the desired and specification strings.\n Each component is converted as a decimal integer and the values\n compared.\n If the specification value is greater than the desired\n value true is returned. If the value is less false is returned.\n If the values are equal the period is skipped and the next pair of\n components is compared."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public static Package getPackage(String name)",
                  "description": "Finds a package by name in the caller's class loader and its\n ancestors.\n \n If the caller's class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of the\n caller's class loader are searched recursively (parent by parent)\n for a Package of the given name.\n \n Calling this method is equivalent to calling ClassLoader.getPackage(java.lang.String)\n on a ClassLoader instance which is the caller's class loader.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "public static Package[] getPackages()",
                  "description": "Returns all of the Packages defined by the caller's class loader\n and its ancestors.  The returned array may contain more than one\n Package object of the same package name, each defined by\n a different class loader in the class loader hierarchy.\n \n Calling this method is equivalent to calling ClassLoader.getPackages()\n on a ClassLoader instance which is the caller's class loader."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Return the hash code computed from the package name."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this Package.\n Its value is the string \"package \" and the package name.\n If the package title is defined it is appended.\n If the package version is defined it is appended."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "isAnnotationPresent",
              "overloads": [
                {
                  "signature": "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
                  "description": "Returns true if an annotation for the specified type\n is present on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n The truth value returned by this method is equivalent to:\n getAnnotation(annotationClass) != null"
                }
              ]
            },
            {
              "name": "getAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns annotations that are associated with this element.\n\n If there are no annotations associated with this element, the return\n value is an array of length 0.\n\n The difference between this method and AnnotatedElement.getAnnotation(Class)\n is that this method detects if its argument is a repeatable\n annotation type (JLS 9.6), and if so, attempts to find one or\n more annotations of that type by \"looking through\" a container\n annotation.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.\n\n This method ignores inherited annotations. (Returns null if no\n annotations are directly present on this element.)\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass)",
                  "description": "Description copied from interface:AnnotatedElement"
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            }
          ]
        },
        {
          "name": "Process",
          "methods": [
            {
              "name": "Process",
              "overloads": [
                {
                  "signature": "public Process()",
                  "description": "Default constructor for Process."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public abstract OutputStream getOutputStream()",
                  "description": "Returns the output stream connected to the normal input of the\n process.  Output to the stream is piped into the standard\n input of the process represented by this Process object.\n\n If the standard input of the process has been redirected using\n ProcessBuilder.redirectInput\n then this method will return a\n null output stream."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public abstract InputStream getInputStream()",
                  "description": "Returns the input stream connected to the normal output of the\n process.  The stream obtains data piped from the standard\n output of the process represented by this Process object.\n\n If the standard output of the process has been redirected using\n ProcessBuilder.redirectOutput\n then this method will return a\n null input stream.\n\n Otherwise, if the standard error of the process has been\n redirected using\n ProcessBuilder.redirectErrorStream\n then the input stream returned by this method will receive the\n merged standard output and the standard error of the process."
                }
              ]
            },
            {
              "name": "getErrorStream",
              "overloads": [
                {
                  "signature": "public abstract InputStream getErrorStream()",
                  "description": "Returns the input stream connected to the error output of the\n process.  The stream obtains data piped from the error output\n of the process represented by this Process object.\n\n If the standard error of the process has been redirected using\n ProcessBuilder.redirectError or\n ProcessBuilder.redirectErrorStream\n then this method will return a\n null input stream."
                }
              ]
            },
            {
              "name": "inputReader",
              "overloads": [
                {
                  "signature": "public final BufferedReader inputReader()",
                  "description": "Returns a BufferedReader connected to the standard\n output of the process. The Charset for the native encoding is used\n to read characters, lines, or stream lines from standard output.\n\n This method delegates to inputReader(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedReader inputReader(Charset charset)",
                  "description": "Returns a BufferedReader connected to the\n standard output of this process using a Charset.\n The BufferedReader can be used to read characters, lines,\n or stream lines of the standard output.\n\n Characters are read by an InputStreamReader that reads and decodes bytes\n from this process getInputStream(). Bytes are decoded to characters\n using the charset; malformed-input and unmappable-character\n sequences are replaced with the charset's default replacement.\n The BufferedReader reads and buffers characters from the InputStreamReader.\n\n The first call to this method creates the BufferedReader,\n if called again with the same charset the same BufferedReader is returned.\n It is an error to call this method again with a different charset.\n\n If the standard output of the process has been redirected using\n ProcessBuilder.redirectOutput\n then the InputStreamReader will be reading from a\n null input stream.\n\n Otherwise, if the standard error of the process has been redirected using\n ProcessBuilder.redirectErrorStream then the input reader returned by\n this method will receive the merged standard output and the standard error\n of the process."
                }
              ]
            },
            {
              "name": "errorReader",
              "overloads": [
                {
                  "signature": "public final BufferedReader errorReader()",
                  "description": "Returns a BufferedReader connected to the standard\n error of the process. The Charset for the native encoding is used\n to read characters, lines, or stream lines from standard error.\n\n This method delegates to errorReader(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedReader errorReader(Charset charset)",
                  "description": "Returns a BufferedReader connected to the\n standard error of this process using a Charset.\n The BufferedReader can be used to read characters, lines,\n or stream lines of the standard error.\n\n Characters are read by an InputStreamReader that reads and decodes bytes\n from this process getErrorStream(). Bytes are decoded to characters\n using the charset; malformed-input and unmappable-character\n sequences are replaced with the charset's default replacement.\n The BufferedReader reads and buffers characters from the InputStreamReader.\n\n The first call to this method creates the BufferedReader,\n if called again with the same charset the same BufferedReader is returned.\n It is an error to call this method again with a different charset.\n\n If the standard error of the process has been redirected using\n ProcessBuilder.redirectError or\n ProcessBuilder.redirectErrorStream\n then the InputStreamReader will be reading from a\n null input stream."
                }
              ]
            },
            {
              "name": "outputWriter",
              "overloads": [
                {
                  "signature": "public final BufferedWriter outputWriter()",
                  "description": "Returns a BufferedWriter connected to the normal input of the process\n using the native encoding.\n Writes text to a character-output stream, buffering characters so as to provide\n for the efficient writing of single characters, arrays, and strings.\n\n This method delegates to outputWriter(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedWriter outputWriter(Charset charset)",
                  "description": "Returns a BufferedWriter connected to the normal input of the process\n using a Charset.\n Writes text to a character-output stream, buffering characters so as to provide\n for the efficient writing of single characters, arrays, and strings.\n\n Characters written by the writer are encoded to bytes using OutputStreamWriter\n and the Charset are written to the standard input of the process represented\n by this Process.\n Malformed-input and unmappable-character sequences are replaced with the charset's\n default replacement.\n\n The first call to this method creates the BufferedWriter,\n if called again with the same charset the same BufferedWriter is returned.\n It is an error to call this method again with a different charset.\n\n If the standard input of the process has been redirected using\n ProcessBuilder.redirectInput then the OutputStreamWriter writes to a\n null output stream."
                }
              ]
            },
            {
              "name": "waitFor",
              "overloads": [
                {
                  "signature": "public abstract int waitFor() throws InterruptedException",
                  "description": "Causes the current thread to wait, if necessary, until the\n process represented by this Process object has\n terminated.  This method returns immediately if the process\n has already terminated.  If the process has not yet\n terminated, the calling thread will be blocked until the\n process exits."
                },
                {
                  "signature": "public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException",
                  "description": "Causes the current thread to wait, if necessary, until the\n process represented by this Process object has\n terminated, or the specified waiting time elapses.\n\n If the process has already terminated then this method returns\n immediately with the value true.  If the process has not\n terminated and the timeout value is less than, or equal to, zero, then\n this method returns immediately with the value false.\n\n The default implementation of this methods polls the exitValue\n to check if the process has terminated. Concrete implementations of this\n class are strongly encouraged to override this method with a more\n efficient implementation."
                }
              ]
            },
            {
              "name": "exitValue",
              "overloads": [
                {
                  "signature": "public abstract int exitValue()",
                  "description": "Returns the exit value for the process."
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "public abstract void destroy()",
                  "description": "Kills the process.\n Whether the process represented by this Process object is\n normally terminated or not is\n implementation dependent.\n Forcible process destruction is defined as the immediate termination of a\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated."
                }
              ]
            },
            {
              "name": "destroyForcibly",
              "overloads": [
                {
                  "signature": "public Process destroyForcibly()",
                  "description": "Kills the process forcibly. The process represented by this\n Process object is forcibly terminated.\n Forcible process destruction is defined as the immediate termination of a\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Invoking this method on Process objects returned by\n ProcessBuilder.start() and Runtime.exec(java.lang.String) forcibly terminate\n the process."
                }
              ]
            },
            {
              "name": "supportsNormalTermination",
              "overloads": [
                {
                  "signature": "public boolean supportsNormalTermination()",
                  "description": "Returns true if the implementation of destroy() is to\n normally terminate the process,\n Returns false if the implementation of destroy\n forcibly and immediately terminates the process.\n \n Invoking this method on Process objects returned by\n ProcessBuilder.start() and Runtime.exec(java.lang.String) return\n true or false depending on the platform implementation."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "public boolean isAlive()",
                  "description": "Tests whether the process represented by this Process is\n alive."
                }
              ]
            },
            {
              "name": "pid",
              "overloads": [
                {
                  "signature": "public long pid()",
                  "description": "Returns the native process ID of the process.\n The native process ID is an identification number that the operating\n system assigns to the process."
                }
              ]
            },
            {
              "name": "onExit",
              "overloads": [
                {
                  "signature": "public CompletableFuture<Process> onExit()",
                  "description": "Returns a CompletableFuture<Process> for the termination of the Process.\n The CompletableFuture provides the ability\n to trigger dependent functions or actions that may be run synchronously\n or asynchronously upon process termination.\n When the process has terminated the CompletableFuture is\n completed regardless\n of the exit status of the process.\n \n Calling onExit().get() waits for the process to terminate and returns\n the Process. The future can be used to check if the process is\n done or to\n wait for it to terminate.\n Cancelling\n the CompletableFuture does not affect the Process.\n \n Processes returned from ProcessBuilder.start() override the\n default implementation to provide an efficient mechanism to wait\n for process exit."
                }
              ]
            },
            {
              "name": "toHandle",
              "overloads": [
                {
                  "signature": "public ProcessHandle toHandle()",
                  "description": "Returns a ProcessHandle for the Process.\n\n Process objects returned by ProcessBuilder.start() and\n Runtime.exec(java.lang.String) implement toHandle as the equivalent of\n ProcessHandle.of(pid) including the\n check for a SecurityManager and RuntimePermission(\"manageProcess\")."
                }
              ]
            },
            {
              "name": "info",
              "overloads": [
                {
                  "signature": "public ProcessHandle.Info info()",
                  "description": "Returns a snapshot of information about the process.\n\n  A ProcessHandle.Info instance has accessor methods\n that return information about the process if it is available."
                }
              ]
            },
            {
              "name": "children",
              "overloads": [
                {
                  "signature": "public Stream<ProcessHandle> children()",
                  "description": "Returns a snapshot of the direct children of the process.\n The parent of a direct child process is the process.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "descendants",
              "overloads": [
                {
                  "signature": "public Stream<ProcessHandle> descendants()",
                  "description": "Returns a snapshot of the descendants of the process.\n The descendants of a process are the children of the process\n plus the descendants of those children, recursively.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessBuilder",
          "methods": [
            {
              "name": "ProcessBuilder",
              "overloads": [
                {
                  "signature": "public ProcessBuilder(List<String> command)",
                  "description": "Constructs a process builder with the specified operating\n system program and arguments.  This constructor does not\n make a copy of the command list.  Subsequent\n updates to the list will be reflected in the state of the\n process builder.  It is not checked whether\n command corresponds to a valid operating system\n command."
                },
                {
                  "signature": "public ProcessBuilder(String... command)",
                  "description": "Constructs a process builder with the specified operating\n system program and arguments.  This is a convenience\n constructor that sets the process builder's command to a string\n list containing the same strings as the command\n array, in the same order.  It is not checked whether\n command corresponds to a valid operating system\n command."
                }
              ]
            },
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "public ProcessBuilder command(List<String> command)",
                  "description": "Sets this process builder's operating system program and\n arguments.  This method does not make a copy of the\n command list.  Subsequent updates to the list will\n be reflected in the state of the process builder.  It is not\n checked whether command corresponds to a valid\n operating system command."
                },
                {
                  "signature": "public ProcessBuilder command(String... command)",
                  "description": "Sets this process builder's operating system program and\n arguments.  This is a convenience method that sets the command\n to a string list containing the same strings as the\n command array, in the same order.  It is not\n checked whether command corresponds to a valid\n operating system command."
                },
                {
                  "signature": "public List<String> command()",
                  "description": "Returns this process builder's operating system program and\n arguments.  The returned list is not a copy.  Subsequent\n updates to the list will be reflected in the state of this\n process builder."
                }
              ]
            },
            {
              "name": "environment",
              "overloads": [
                {
                  "signature": "public Map<String,String> environment()",
                  "description": "Returns a string map view of this process builder's environment.\n\n Whenever a process builder is created, the environment is\n initialized to a copy of the current process environment (see\n System.getenv()).  Subprocesses subsequently started by\n this object's start() method will use this map as\n their environment.\n\n The returned object may be modified using ordinary Map operations.  These modifications will be\n visible to subprocesses started via the start()\n method.  Two ProcessBuilder instances always\n contain independent process environments, so changes to the\n returned map will never be reflected in any other\n ProcessBuilder instance or the values returned by\n System.getenv.\n\n If the system does not support environment variables, an\n empty map is returned.\n\n The returned map does not permit null keys or values.\n Attempting to insert or query the presence of a null key or\n value will throw a NullPointerException.\n Attempting to query the presence of a key or value which is not\n of type String will throw a ClassCastException.\n\n The behavior of the returned map is system-dependent.  A\n system may not allow modifications to environment variables or\n may forbid certain variable names or values.  For this reason,\n attempts to modify the map may fail with\n UnsupportedOperationException or\n IllegalArgumentException\n if the modification is not permitted by the operating system.\n\n Since the external format of environment variable names and\n values is system-dependent, there may not be a one-to-one\n mapping between them and Java's Unicode strings.  Nevertheless,\n the map is implemented in such a way that environment variables\n which are not modified by Java code will have an unmodified\n native representation in the subprocess.\n\n The returned map and its collection views may not obey the\n general contract of the Object.equals(java.lang.Object) and\n Object.hashCode() methods.\n\n The returned map is typically case-sensitive on all platforms.\n\n If a security manager exists, its\n checkPermission method\n is called with a\n RuntimePermission(\"getenv.*\") permission.\n This may result in a SecurityException being thrown.\n\n When passing information to a Java subprocess,\n system properties\n are generally preferred over environment variables."
                }
              ]
            },
            {
              "name": "directory",
              "overloads": [
                {
                  "signature": "public File directory()",
                  "description": "Returns this process builder's working directory.\n\n Subprocesses subsequently started by this object's start() method will use this as their working directory.\n The returned value may be null -- this means to use\n the working directory of the current Java process, usually the\n directory named by the system property user.dir,\n as the working directory of the child process."
                },
                {
                  "signature": "public ProcessBuilder directory(File directory)",
                  "description": "Sets this process builder's working directory.\n\n Subprocesses subsequently started by this object's start() method will use this as their working directory.\n The argument may be null -- this means to use the\n working directory of the current Java process, usually the\n directory named by the system property user.dir,\n as the working directory of the child process."
                }
              ]
            },
            {
              "name": "redirectInput",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectInput(ProcessBuilder.Redirect source)",
                  "description": "Sets this process builder's standard input source.\n\n Subprocesses subsequently started by this object's start()\n method obtain their standard input from this source.\n\n If the source is Redirect.PIPE\n (the initial value), then the standard input of a\n subprocess can be written to using the output stream\n returned by Process.getOutputStream().\n If the source is set to any other value, then\n Process.getOutputStream() will return a\n null output stream."
                },
                {
                  "signature": "public ProcessBuilder redirectInput(File file)",
                  "description": "Sets this process builder's standard input source to a file.\n\n This is a convenience method.  An invocation of the form\n redirectInput(file)\n behaves in exactly the same way as the invocation\n redirectInput\n (Redirect.from(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectInput()",
                  "description": "Returns this process builder's standard input source.\n\n Subprocesses subsequently started by this object's start()\n method obtain their standard input from this source.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "redirectOutput",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectOutput(ProcessBuilder.Redirect destination)",
                  "description": "Sets this process builder's standard output destination.\n\n Subprocesses subsequently started by this object's start()\n method send their standard output to this destination.\n\n If the destination is Redirect.PIPE\n (the initial value), then the standard output of a subprocess\n can be read using the input stream returned by Process.getInputStream().\n If the destination is set to any other value, then\n Process.getInputStream() will return a\n null input stream."
                },
                {
                  "signature": "public ProcessBuilder redirectOutput(File file)",
                  "description": "Sets this process builder's standard output destination to a file.\n\n This is a convenience method.  An invocation of the form\n redirectOutput(file)\n behaves in exactly the same way as the invocation\n redirectOutput\n (Redirect.to(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectOutput()",
                  "description": "Returns this process builder's standard output destination.\n\n Subprocesses subsequently started by this object's start()\n method redirect their standard output to this destination.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "redirectError",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectError(ProcessBuilder.Redirect destination)",
                  "description": "Sets this process builder's standard error destination.\n\n Subprocesses subsequently started by this object's start()\n method send their standard error to this destination.\n\n If the destination is Redirect.PIPE\n (the initial value), then the error output of a subprocess\n can be read using the input stream returned by Process.getErrorStream().\n If the destination is set to any other value, then\n Process.getErrorStream() will return a\n null input stream.\n\n If the redirectErrorStream\n attribute has been set true, then the redirection set\n by this method has no effect."
                },
                {
                  "signature": "public ProcessBuilder redirectError(File file)",
                  "description": "Sets this process builder's standard error destination to a file.\n\n This is a convenience method.  An invocation of the form\n redirectError(file)\n behaves in exactly the same way as the invocation\n redirectError\n (Redirect.to(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectError()",
                  "description": "Returns this process builder's standard error destination.\n\n Subprocesses subsequently started by this object's start()\n method redirect their standard error to this destination.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "inheritIO",
              "overloads": [
                {
                  "signature": "public ProcessBuilder inheritIO()",
                  "description": "Sets the source and destination for subprocess standard I/O\n to be the same as those of the current Java process.\n\n This is a convenience method.  An invocation of the form\n   \n pb.inheritIO()\n \n behaves in exactly the same way as the invocation\n   \n pb.redirectInput(Redirect.INHERIT)\n   .redirectOutput(Redirect.INHERIT)\n   .redirectError(Redirect.INHERIT)\n \n\n This gives behavior equivalent to most operating system\n command interpreters, or the standard C library function\n system()."
                }
              ]
            },
            {
              "name": "redirectErrorStream",
              "overloads": [
                {
                  "signature": "public boolean redirectErrorStream()",
                  "description": "Tells whether this process builder merges standard error and\n standard output.\n\n If this property is true, then any error output\n generated by subprocesses subsequently started by this object's\n start() method will be merged with the standard\n output, so that both can be read using the\n Process.getInputStream() method.  This makes it easier\n to correlate error messages with the corresponding output.\n The initial value is false."
                },
                {
                  "signature": "public ProcessBuilder redirectErrorStream(boolean redirectErrorStream)",
                  "description": "Sets this process builder's redirectErrorStream property.\n\n If this property is true, then any error output\n generated by subprocesses subsequently started by this object's\n start() method will be merged with the standard\n output, so that both can be read using the\n Process.getInputStream() method.  This makes it easier\n to correlate error messages with the corresponding output.\n The initial value is false."
                }
              ]
            },
            {
              "name": "start",
              "overloads": [
                {
                  "signature": "public Process start() throws IOException",
                  "description": "Starts a new process using the attributes of this process builder.\n\n The new process will\n invoke the command and arguments given by command(),\n in a working directory as given by directory(),\n with a process environment as given by environment().\n\n This method checks that the command is a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n\n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the process builder's environment().\n\n If there is a security manager, its\n checkExec\n method is called with the first component of this object's\n command array as its argument. This may result in\n a SecurityException being thrown.\n\n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n Invalid character in command argument, such as NUL.\n \n\n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n\n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown.\n\n Subsequent modifications to this process builder will not\n affect the returned Process."
                }
              ]
            },
            {
              "name": "startPipeline",
              "overloads": [
                {
                  "signature": "public static List<Process> startPipeline(List<ProcessBuilder> builders) throws IOException",
                  "description": "Starts a Process for each ProcessBuilder, creating a pipeline of\n processes linked by their standard output and standard input streams.\n The attributes of each ProcessBuilder are used to start the respective\n process except that as each process is started, its standard output\n is directed to the standard input of the next.  The redirects for standard\n input of the first process and standard output of the last process are\n initialized using the redirect settings of the respective ProcessBuilder.\n All other ProcessBuilder redirects should be\n Redirect.PIPE.\n \n All input and output streams between the intermediate processes are\n not accessible.\n The standard input of all processes\n except the first process are null output streams\n The standard output of all processes\n except the last process are null input streams.\n \n The redirectErrorStream() of each ProcessBuilder applies to the\n respective process.  If set to true, the error stream is written\n to the same stream as standard output.\n \n If starting any of the processes throws an Exception, all processes\n are forcibly destroyed.\n \n The startPipeline method performs the same checks on\n each ProcessBuilder as does the start() method. Each new process\n invokes the command and arguments given by the respective process builder's\n command(), in a working directory as given by its directory(),\n with a process environment as given by its environment().\n \n Each process builder's command is checked to be a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n \n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the process builder's environment().\n \n If there is a security manager, its\n checkExec\n method is called with the first component of each process builder's\n command array as its argument. This may result in\n a SecurityException being thrown.\n \n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n Invalid character in command argument, such as NUL.\n \n \n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n \n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown.\n \n Subsequent modifications to any of the specified builders\n will not affect the returned Process."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessBuilder.Redirect",
          "methods": [
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "public abstract ProcessBuilder.Redirect.Type type()",
                  "description": "Returns the type of this Redirect."
                }
              ]
            },
            {
              "name": "file",
              "overloads": [
                {
                  "signature": "public File file()",
                  "description": "Returns the File source or destination associated\n with this redirect, or null if there is no such file."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect from(File file)",
                  "description": "Returns a redirect to read from the specified file.\n\n It will always be true that\n   \n Redirect.from(file).file() == file &&\n Redirect.from(file).type() == Redirect.Type.READ"
                }
              ]
            },
            {
              "name": "to",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect to(File file)",
                  "description": "Returns a redirect to write to the specified file.\n If the specified file exists when the subprocess is started,\n its previous contents will be discarded.\n\n It will always be true that\n   \n Redirect.to(file).file() == file &&\n Redirect.to(file).type() == Redirect.Type.WRITE"
                }
              ]
            },
            {
              "name": "appendTo",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect appendTo(File file)",
                  "description": "Returns a redirect to append to the specified file.\n Each write operation first advances the position to the\n end of the file and then writes the requested data.\n Whether the advancement of the position and the writing\n of the data are done in a single atomic operation is\n system-dependent and therefore unspecified.\n\n It will always be true that\n   \n Redirect.appendTo(file).file() == file &&\n Redirect.appendTo(file).type() == Redirect.Type.APPEND"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the specified object with this Redirect for\n equality.  Returns true if and only if the two\n objects are identical or both objects are Redirect\n instances of the same type associated with non-null equal\n File instances."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for this Redirect."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessHandle",
          "methods": [
            {
              "name": "pid",
              "overloads": [
                {
                  "signature": "long pid()",
                  "description": "Returns the native process ID of the process. The native process ID is an\n identification number that the operating system assigns to the process.\n The operating system may reuse the process ID after a process terminates.\n Use equals or\n compareTo to compare ProcessHandles."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static Optional<ProcessHandle> of(long pid)",
                  "description": "Returns an Optional<ProcessHandle> for an existing native process."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "static ProcessHandle current()",
                  "description": "Returns a ProcessHandle for the current process. The ProcessHandle cannot be\n used to destroy the current process, use System.exit instead."
                }
              ]
            },
            {
              "name": "parent",
              "overloads": [
                {
                  "signature": "Optional<ProcessHandle> parent()",
                  "description": "Returns an Optional<ProcessHandle> for the parent process.\n Note that Processes in a zombie state usually don't have a parent."
                }
              ]
            },
            {
              "name": "children",
              "overloads": [
                {
                  "signature": "Stream<ProcessHandle> children()",
                  "description": "Returns a snapshot of the current direct children of the process.\n The parent() of a direct child process is the process.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "descendants",
              "overloads": [
                {
                  "signature": "Stream<ProcessHandle> descendants()",
                  "description": "Returns a snapshot of the descendants of the process.\n The descendants of a process are the children of the process\n plus the descendants of those children, recursively.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "allProcesses",
              "overloads": [
                {
                  "signature": "static Stream<ProcessHandle> allProcesses()",
                  "description": "Returns a snapshot of all processes visible to the current process.\n \n Note that processes are created and terminate asynchronously. There\n is no guarantee that a process in the stream is alive or that no other\n processes may have been created since the inception of the snapshot."
                }
              ]
            },
            {
              "name": "info",
              "overloads": [
                {
                  "signature": "ProcessHandle.Info info()",
                  "description": "Returns a snapshot of information about the process.\n\n  A ProcessHandle.Info instance has accessor methods that return\n information about the process if it is available."
                }
              ]
            },
            {
              "name": "onExit",
              "overloads": [
                {
                  "signature": "CompletableFuture<ProcessHandle> onExit()",
                  "description": "Returns a CompletableFuture<ProcessHandle> for the termination\n of the process.\n The CompletableFuture provides the ability\n to trigger dependent functions or actions that may be run synchronously\n or asynchronously upon process termination.\n When the process has terminated the CompletableFuture is\n completed regardless\n of the exit status of the process.\n The onExit method can be called multiple times to invoke\n independent actions when the process exits.\n \n Calling onExit().get() waits for the process to terminate and returns\n the ProcessHandle. The future can be used to check if the process is\n done or to\n wait for it to terminate.\n Cancelling\n the CompleteableFuture does not affect the Process."
                }
              ]
            },
            {
              "name": "supportsNormalTermination",
              "overloads": [
                {
                  "signature": "boolean supportsNormalTermination()",
                  "description": "Returns true if the implementation of destroy()\n normally terminates the process.\n Returns false if the implementation of destroy\n forcibly and immediately terminates the process."
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "boolean destroy()",
                  "description": "Requests the process to be killed.\n Whether the process represented by this ProcessHandle object is\n normally terminated or not is\n implementation dependent.\n Forcible process destruction is defined as the immediate termination of the\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n The operating system access controls may prevent the process\n from being killed.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Note: The process may not terminate immediately.\n For example, isAlive() may return true for a brief period\n after destroy() is called."
                }
              ]
            },
            {
              "name": "destroyForcibly",
              "overloads": [
                {
                  "signature": "boolean destroyForcibly()",
                  "description": "Requests the process to be killed forcibly.\n The process represented by this ProcessHandle object is\n forcibly terminated.\n Forcible process destruction is defined as the immediate termination of the\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n The operating system access controls may prevent the process\n from being killed.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Note: The process may not terminate immediately.\n For example, isAlive() may return true for a brief period\n after destroyForcibly() is called."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "boolean isAlive()",
                  "description": "Tests whether the process represented by this ProcessHandle is alive.\n Process termination is implementation and operating system specific.\n The process is considered alive as long as the PID is valid."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns a hash code value for this ProcessHandle.\n The hashcode value follows the general contract for Object.hashCode().\n The value is a function of the pid() value and\n may be a function of additional information to uniquely identify the process.\n If two ProcessHandles are equal according to the equals\n method, then calling the hashCode method on each of the two objects\n must produce the same integer result."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object other)",
                  "description": "Returns true if other object is non-null, is of the\n same implementation, and represents the same system process;\n otherwise it returns false."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "int compareTo(ProcessHandle other)",
                  "description": "Compares this ProcessHandle with the specified ProcessHandle for order.\n The order is not specified, but is consistent with Object.equals(java.lang.Object),\n which returns true if and only if two instances of ProcessHandle\n are of the same implementation and represent the same system process.\n Comparison is only supported among objects of same implementation.\n If attempt is made to mutually compare two different implementations\n of ProcessHandles, ClassCastException is thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessHandle.Info",
          "methods": [
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "Optional<String> command()",
                  "description": "Returns the executable pathname of the process."
                }
              ]
            },
            {
              "name": "commandLine",
              "overloads": [
                {
                  "signature": "Optional<String> commandLine()",
                  "description": "Returns the command line of the process.\n \n If command() and  arguments() return\n non-empty optionals, this is simply a convenience method which concatenates\n the values of the two functions separated by spaces. Otherwise it will return a\n best-effort, platform dependent representation of the command line."
                }
              ]
            },
            {
              "name": "arguments",
              "overloads": [
                {
                  "signature": "Optional<String[]> arguments()",
                  "description": "Returns an array of Strings of the arguments of the process."
                }
              ]
            },
            {
              "name": "startInstant",
              "overloads": [
                {
                  "signature": "Optional<Instant> startInstant()",
                  "description": "Returns the start time of the process."
                }
              ]
            },
            {
              "name": "totalCpuDuration",
              "overloads": [
                {
                  "signature": "Optional<Duration> totalCpuDuration()",
                  "description": "Returns the total cputime accumulated of the process."
                }
              ]
            },
            {
              "name": "user",
              "overloads": [
                {
                  "signature": "Optional<String> user()",
                  "description": "Return the user of the process."
                }
              ]
            }
          ]
        },
        {
          "name": "Readable",
          "methods": [
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "int read(CharBuffer cb) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                }
              ]
            }
          ]
        },
        {
          "name": "Record",
          "methods": [
            {
              "name": "Record",
              "overloads": [
                {
                  "signature": "protected Record()",
                  "description": "Constructor for record classes to call."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public abstract boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this one.  In addition\n to the general contract of Object.equals,\n record classes must further obey the invariant that when\n a record instance is \"copied\" by passing the result of the record component\n accessor methods to the canonical constructor, as follows:\n      R copy = new R(r.c1(), r.c2(), ..., r.cn());\n \n then it must be the case that r.equals(copy)."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public abstract int hashCode()",
                  "description": "Returns a hash code value for the record.\n Obeys the general contract of Object.hashCode.\n For records, hashing behavior is constrained by the refined contract\n of Record.equals, so that any two records\n created from the same components must have the same hash code."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public abstract String toString()",
                  "description": "Returns a string representation of the record.\n In accordance with the general contract of Object.toString(),\n the toString method returns a string that\n \"textually represents\" this record. The result should\n be a concise but informative representation that is easy for a\n person to read.\n \n In addition to this general contract, record classes must further\n participate in the invariant that any two records which are\n equal must produce equal\n strings.  This invariant is necessarily relaxed in the rare\n case where corresponding equal component values might fail\n to produce equal strings for themselves."
                }
              ]
            }
          ]
        },
        {
          "name": "ReflectiveOperationException",
          "methods": [
            {
              "name": "ReflectiveOperationException",
              "overloads": [
                {
                  "signature": "public ReflectiveOperationException()",
                  "description": "Constructs a new exception with null as its detail\n message.  The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public ReflectiveOperationException(String message)",
                  "description": "Constructs a new exception with the specified detail message.\n The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public ReflectiveOperationException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message\n and cause.\n\n Note that the detail message associated with\n cause is not automatically incorporated in\n this exception's detail message."
                },
                {
                  "signature": "public ReflectiveOperationException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Runnable",
          "methods": [
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "void run()",
                  "description": "When an object implementing interface Runnable is used\n to create a thread, starting the thread causes the object's\n run method to be called in that separately executing\n thread.\n \n The general contract of the method run is that it may\n take any action whatsoever."
                }
              ]
            }
          ]
        },
        {
          "name": "Runtime",
          "methods": [
            {
              "name": "getRuntime",
              "overloads": [
                {
                  "signature": "public static Runtime getRuntime()",
                  "description": "Returns the runtime object associated with the current Java application.\n Most of the methods of class Runtime are instance\n methods and must be invoked with respect to the current runtime object."
                }
              ]
            },
            {
              "name": "exit",
              "overloads": [
                {
                  "signature": "public void exit(int status)",
                  "description": "Terminates the currently running Java virtual machine by initiating its\n shutdown sequence.  This method never returns normally.  The argument\n serves as a status code; by convention, a nonzero status code indicates\n abnormal termination.\n\n  All registered shutdown hooks, if any,\n are started in some unspecified order and allowed to run concurrently\n until they finish.  Once this is done the virtual machine\n halts.\n\n  If this method is invoked after all shutdown hooks have already\n been run and the status is nonzero then this method halts the\n virtual machine with the given status code. Otherwise, this method\n blocks indefinitely.\n\n  The System.exit method is the\n conventional and convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "addShutdownHook",
              "overloads": [
                {
                  "signature": "public void addShutdownHook(Thread hook)",
                  "description": "Registers a new virtual-machine shutdown hook.\n\n  The Java virtual machine shuts down in response to two kinds\n of events:\n\n   \n\n    The program exits normally, when the last non-daemon\n   thread exits or when the exit (equivalently,\n   System.exit) method is invoked, or\n\n    The virtual machine is terminated in response to a\n   user interrupt, such as typing ^C, or a system-wide event,\n   such as user logoff or system shutdown.\n\n   \n\n  A shutdown hook is simply an initialized but unstarted\n thread.  When the virtual machine begins its shutdown sequence it will\n start all registered shutdown hooks in some unspecified order and let\n them run concurrently.  When all the hooks have finished it will then\n halt. Note that daemon threads will continue to run during the shutdown\n sequence, as will non-daemon threads if shutdown was initiated by\n invoking the exit method.\n\n  Once the shutdown sequence has begun it can be stopped only by\n invoking the halt method, which forcibly\n terminates the virtual machine.\n\n  Once the shutdown sequence has begun it is impossible to register a\n new shutdown hook or de-register a previously-registered hook.\n Attempting either of these operations will cause an\n IllegalStateException to be thrown.\n\n  Shutdown hooks run at a delicate time in the life cycle of a virtual\n machine and should therefore be coded defensively.  They should, in\n particular, be written to be thread-safe and to avoid deadlocks insofar\n as possible.  They should also not rely blindly upon services that may\n have registered their own shutdown hooks and therefore may themselves in\n the process of shutting down.  Attempts to use other thread-based\n services such as the AWT event-dispatch thread, for example, may lead to\n deadlocks.\n\n  Shutdown hooks should also finish their work quickly.  When a\n program invokes exit the expectation is\n that the virtual machine will promptly shut down and exit.  When the\n virtual machine is terminated due to user logoff or system shutdown the\n underlying operating system may only allow a fixed amount of time in\n which to shut down and exit.  It is therefore inadvisable to attempt any\n user interaction or to perform a long-running computation in a shutdown\n hook.\n\n  Uncaught exceptions are handled in shutdown hooks just as in any\n other thread, by invoking the\n uncaughtException method of the\n thread's ThreadGroup object. The default implementation of this\n method prints the exception's stack trace to System.err and\n terminates the thread; it does not cause the virtual machine to exit or\n halt.\n\n  In rare circumstances the virtual machine may abort, that is,\n stop running without shutting down cleanly.  This occurs when the\n virtual machine is terminated externally, for example with the\n SIGKILL signal on Unix or the TerminateProcess call on\n Microsoft Windows.  The virtual machine may also abort if a native\n method goes awry by, for example, corrupting internal data structures or\n attempting to access nonexistent memory.  If the virtual machine aborts\n then no guarantee can be made about whether or not any shutdown hooks\n will be run."
                }
              ]
            },
            {
              "name": "removeShutdownHook",
              "overloads": [
                {
                  "signature": "public boolean removeShutdownHook(Thread hook)",
                  "description": "De-registers a previously-registered virtual-machine shutdown hook."
                }
              ]
            },
            {
              "name": "halt",
              "overloads": [
                {
                  "signature": "public void halt(int status)",
                  "description": "Forcibly terminates the currently running Java virtual machine.  This\n method never returns normally.\n\n  This method should be used with extreme caution.  Unlike the\n exit method, this method does not cause shutdown\n hooks to be started.  If the shutdown sequence has already been\n initiated then this method does not wait for any running\n shutdown hooks to finish their work."
                }
              ]
            },
            {
              "name": "exec",
              "overloads": [
                {
                  "signature": "public Process exec(String command) throws IOException",
                  "description": "Executes the specified string command in a separate process.\n\n This is a convenience method.  An invocation of the form\n exec(command)\n behaves in exactly the same way as the invocation\n exec(command, null, null)."
                },
                {
                  "signature": "public Process exec(String command, String[] envp) throws IOException",
                  "description": "Executes the specified string command in a separate process with the\n specified environment.\n\n This is a convenience method.  An invocation of the form\n exec(command, envp)\n behaves in exactly the same way as the invocation\n exec(command, envp, null)."
                },
                {
                  "signature": "public Process exec(String command, String[] envp, File dir) throws IOException",
                  "description": "Executes the specified string command in a separate process with the\n specified environment and working directory.\n\n This is a convenience method.  An invocation of the form\n exec(command, envp, dir)\n behaves in exactly the same way as the invocation\n exec(cmdarray, envp, dir),\n where cmdarray is an array of all the tokens in\n command.\n\n More precisely, the command string is broken\n into tokens using a StringTokenizer created by the call\n new StringTokenizer(command) with no\n further modification of the character categories.  The tokens\n produced by the tokenizer are then placed in the new string\n array cmdarray, in the same order."
                },
                {
                  "signature": "public Process exec(String[] cmdarray) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process.\n\n This is a convenience method.  An invocation of the form\n exec(cmdarray)\n behaves in exactly the same way as the invocation\n exec(cmdarray, null, null)."
                },
                {
                  "signature": "public Process exec(String[] cmdarray, String[] envp) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process\n with the specified environment.\n\n This is a convenience method.  An invocation of the form\n exec(cmdarray, envp)\n behaves in exactly the same way as the invocation\n exec(cmdarray, envp, null)."
                },
                {
                  "signature": "public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process with\n the specified environment and working directory.\n\n Given an array of strings cmdarray, representing the\n tokens of a command line, and an array of strings envp,\n representing \"environment\" variable settings, this method creates\n a new process in which to execute the specified command.\n\n This method checks that cmdarray is a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n\n If envp is null, the subprocess inherits the\n environment settings of the current process.\n\n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the specified environment.\n\n ProcessBuilder.start() is now the preferred way to\n start a process with a modified environment.\n\n The working directory of the new subprocess is specified by dir.\n If dir is null, the subprocess inherits the\n current working directory of the current process.\n\n If a security manager exists, its\n checkExec\n method is invoked with the first component of the array\n cmdarray as its argument. This may result in a\n SecurityException being thrown.\n\n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n \n\n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n\n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown."
                }
              ]
            },
            {
              "name": "availableProcessors",
              "overloads": [
                {
                  "signature": "public int availableProcessors()",
                  "description": "Returns the number of processors available to the Java virtual machine.\n\n  This value may change during a particular invocation of the virtual\n machine.  Applications that are sensitive to the number of available\n processors should therefore occasionally poll this property and adjust\n their resource usage appropriately."
                }
              ]
            },
            {
              "name": "freeMemory",
              "overloads": [
                {
                  "signature": "public long freeMemory()",
                  "description": "Returns the amount of free memory in the Java Virtual Machine.\n Calling the\n gc method may result in increasing the value returned\n by freeMemory."
                }
              ]
            },
            {
              "name": "totalMemory",
              "overloads": [
                {
                  "signature": "public long totalMemory()",
                  "description": "Returns the total amount of memory in the Java virtual machine.\n The value returned by this method may vary over time, depending on\n the host environment.\n \n Note that the amount of memory required to hold an object of any\n given type may be implementation-dependent."
                }
              ]
            },
            {
              "name": "maxMemory",
              "overloads": [
                {
                  "signature": "public long maxMemory()",
                  "description": "Returns the maximum amount of memory that the Java virtual machine\n will attempt to use.  If there is no inherent limit then the value\n Long.MAX_VALUE will be returned."
                }
              ]
            },
            {
              "name": "gc",
              "overloads": [
                {
                  "signature": "public void gc()",
                  "description": "Runs the garbage collector in the Java Virtual Machine.\n \n Calling this method suggests that the Java Virtual Machine\n expend effort toward recycling unused objects in order to\n make the memory they currently occupy available for reuse\n by the Java Virtual Machine.\n When control returns from the method call, the Java Virtual Machine\n has made a best effort to reclaim space from all unused objects.\n There is no guarantee that this effort will recycle any particular\n number of unused objects, reclaim any particular amount of space, or\n complete at any particular time, if at all, before the method returns or ever.\n There is also no guarantee that this effort will determine\n the change of reachability in any particular number of objects,\n or that any particular number of Reference\n objects will be cleared and enqueued.\n \n The name gc stands for \"garbage\n collector\". The Java Virtual Machine performs this recycling\n process automatically as needed, in a separate thread, even if the\n gc method is not invoked explicitly.\n \n The method System.gc() is the conventional and convenient\n means of invoking this method."
                }
              ]
            },
            {
              "name": "runFinalization",
              "overloads": [
                {
                  "signature": "public void runFinalization()",
                  "description": "Runs the finalization methods of any objects pending finalization.\n Calling this method suggests that the Java virtual machine expend\n effort toward running the finalize methods of objects\n that have been found to be discarded but whose finalize\n methods have not yet been run. When control returns from the\n method call, the virtual machine has made a best effort to\n complete all outstanding finalizations.\n \n The virtual machine performs the finalization process\n automatically as needed, in a separate thread, if the\n runFinalization method is not invoked explicitly.\n \n The method System.runFinalization() is the conventional\n and convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public void load(String filename)",
                  "description": "Loads the native library specified by the filename argument.  The filename\n argument must be an absolute path name.\n (for example\n Runtime.getRuntime().load(\"/home/avh/lib/libX11.so\");).\n\n If the filename argument, when stripped of any platform-specific library\n prefix, path, and file extension, indicates a library whose name is,\n for example, L, and a native library called L is statically linked\n with the VM, then the JNI_OnLoad_L function exported by the library\n is invoked rather than attempting to load a dynamic library.\n A filename matching the argument does not have to exist in the file\n system.\n See the  JNI Specification\n for more details.\n\n Otherwise, the filename argument is mapped to a native library image in\n an implementation-dependent manner.\n \n First, if there is a security manager, its checkLink\n method is called with the filename as its argument.\n This may result in a security exception.\n \n This is similar to the method loadLibrary(String), but it\n accepts a general file name as an argument rather than just a library\n name, allowing any file of native code to be loaded.\n \n The method System.load(String) is the conventional and\n convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "loadLibrary",
              "overloads": [
                {
                  "signature": "public void loadLibrary(String libname)",
                  "description": "Loads the native library specified by the libname\n argument.  The libname argument must not contain any platform\n specific prefix, file extension or path. If a native library\n called libname is statically linked with the VM, then the\n JNI_OnLoad_libname function exported by the library is invoked.\n See the  JNI Specification\n for more details.\n\n Otherwise, the libname argument is loaded from a system library\n location and mapped to a native library image in an\n implementation-dependent manner.\n \n First, if there is a security manager, its checkLink\n method is called with the libname as its argument.\n This may result in a security exception.\n \n The method System.loadLibrary(String) is the conventional\n and convenient means of invoking this method. If native\n methods are to be used in the implementation of a class, a standard\n strategy is to put the native code in a library file (call it\n LibFile) and then to put a static initializer:\n  static { System.loadLibrary(\"LibFile\"); }\n \n within the class declaration. When the class is loaded and\n initialized, the necessary native code implementation for the native\n methods will then be loaded as well.\n \n If this method is called more than once with the same library\n name, the second and subsequent calls are ignored."
                }
              ]
            },
            {
              "name": "version",
              "overloads": [
                {
                  "signature": "public static Runtime.Version version()",
                  "description": "Returns the version of the Java Runtime Environment as a Runtime.Version."
                }
              ]
            }
          ]
        },
        {
          "name": "Runtime.Version",
          "methods": [
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Runtime.Version parse(String s)",
                  "description": "Parses the given string as a valid\n version string containing a\n version number followed by pre-release and\n build information."
                }
              ]
            },
            {
              "name": "feature",
              "overloads": [
                {
                  "signature": "public int feature()",
                  "description": "Returns the value of the feature element of\n the version number."
                }
              ]
            },
            {
              "name": "interim",
              "overloads": [
                {
                  "signature": "public int interim()",
                  "description": "Returns the value of the interim element of\n the version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "update",
              "overloads": [
                {
                  "signature": "public int update()",
                  "description": "Returns the value of the update element of the\n version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "patch",
              "overloads": [
                {
                  "signature": "public int patch()",
                  "description": "Returns the value of the patch element of the\n version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "major",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int major()",
                  "description": "Returns the value of the major element of the version number.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "minor",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int minor()",
                  "description": "Returns the value of the minor element of the version number, or\n zero if it is absent.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "security",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int security()",
                  "description": "Returns the value of the security element of the version number, or\n zero if it is absent.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "version",
              "overloads": [
                {
                  "signature": "public List<Integer> version()",
                  "description": "Returns an unmodifiable List of the integers\n represented in the version number.\n The List always contains at least one element corresponding to\n the feature version number."
                }
              ]
            },
            {
              "name": "pre",
              "overloads": [
                {
                  "signature": "public Optional<String> pre()",
                  "description": "Returns the optional pre-release information."
                }
              ]
            },
            {
              "name": "build",
              "overloads": [
                {
                  "signature": "public Optional<Integer> build()",
                  "description": "Returns the build number."
                }
              ]
            },
            {
              "name": "optional",
              "overloads": [
                {
                  "signature": "public Optional<String> optional()",
                  "description": "Returns optional additional identifying build\n information."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Runtime.Version obj)",
                  "description": "Compares this version to another.\n\n  Each of the components in the version is\n compared in the following order of precedence: version numbers,\n pre-release identifiers, build numbers, optional build information.\n \n\n  Comparison begins by examining the sequence of version numbers.\n If one sequence is shorter than another, then the missing elements\n of the shorter sequence are considered to be less than the\n corresponding elements of the longer sequence. \n\n  A version with a pre-release identifier is always considered to\n be less than a version without one.  Pre-release identifiers are\n compared numerically when they consist only of digits, and\n lexicographically otherwise.  Numeric identifiers are considered to\n be less than non-numeric identifiers.  \n\n  A version without a build number is always less than one with a\n build number; otherwise build numbers are compared numerically. \n\n  The optional build information is compared lexicographically.\n During this comparison, a version with optional build information is\n considered to be greater than a version without one."
                }
              ]
            },
            {
              "name": "compareToIgnoreOptional",
              "overloads": [
                {
                  "signature": "public int compareToIgnoreOptional(Runtime.Version obj)",
                  "description": "Compares this version to another disregarding optional build\n information.\n\n  Two versions are compared by examining the version string as\n described in compareTo(Version) with the exception that the\n optional build information is always ignored. \n\n  This method provides ordering which is consistent with\n equalsIgnoreOptional()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this version."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Determines whether this Version is equal to another object.\n\n  Two Versions are equal if and only if they represent the\n same version string."
                }
              ]
            },
            {
              "name": "equalsIgnoreOptional",
              "overloads": [
                {
                  "signature": "public boolean equalsIgnoreOptional(Object obj)",
                  "description": "Determines whether this Version is equal to another\n disregarding optional build information.\n\n  Two Versions are equal if and only if they represent the\n same version string disregarding the optional build information."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this version."
                }
              ]
            }
          ]
        },
        {
          "name": "RuntimeException",
          "methods": [
            {
              "name": "RuntimeException",
              "overloads": [
                {
                  "signature": "public RuntimeException()",
                  "description": "Constructs a new runtime exception with null as its\n detail message.  The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public RuntimeException(String message)",
                  "description": "Constructs a new runtime exception with the specified detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public RuntimeException(String message, Throwable cause)",
                  "description": "Constructs a new runtime exception with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this runtime exception's detail message."
                },
                {
                  "signature": "public RuntimeException(Throwable cause)",
                  "description": "Constructs a new runtime exception with the specified cause and a\n detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause).  This constructor is useful for runtime exceptions\n that are little more than wrappers for other throwables."
                },
                {
                  "signature": "protected RuntimeException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new runtime exception with the specified detail\n message, cause, suppression enabled or disabled, and writable\n stack trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "RuntimePermission",
          "methods": [
            {
              "name": "RuntimePermission",
              "overloads": [
                {
                  "signature": "public RuntimePermission(String name)",
                  "description": "Creates a new RuntimePermission with the specified name.\n The name is the symbolic name of the RuntimePermission, such as\n \"exit\", \"setFactory\", etc. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match."
                },
                {
                  "signature": "public RuntimePermission(String name, String actions)",
                  "description": "Creates a new RuntimePermission object with the specified name.\n The name is the symbolic name of the RuntimePermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "SecurityException",
          "methods": [
            {
              "name": "SecurityException",
              "overloads": [
                {
                  "signature": "public SecurityException()",
                  "description": "Constructs a SecurityException with no detail message."
                },
                {
                  "signature": "public SecurityException(String s)",
                  "description": "Constructs a SecurityException with the specified\n detail message."
                },
                {
                  "signature": "public SecurityException(String message, Throwable cause)",
                  "description": "Creates a SecurityException with the specified\n detail message and cause."
                },
                {
                  "signature": "public SecurityException(Throwable cause)",
                  "description": "Creates a SecurityException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "SecurityManager",
          "methods": [
            {
              "name": "SecurityManager",
              "overloads": [
                {
                  "signature": "public SecurityManager()",
                  "description": "Constructs a new SecurityManager.\n\n  If there is a security manager already installed, this method first\n calls the security manager's checkPermission method\n with the RuntimePermission(\"createSecurityManager\")\n permission to ensure the calling thread has permission to create a new\n security manager.\n This may result in throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getClassContext",
              "overloads": [
                {
                  "signature": "protected Class<?>[] getClassContext()",
                  "description": "Returns the current execution stack as an array of classes.\n \n The length of the array is the number of methods on the execution\n stack. The element at index 0 is the class of the\n currently executing method, the element at index 1 is\n the class of that method's caller, and so on.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSecurityContext",
              "overloads": [
                {
                  "signature": "public Object getSecurityContext()",
                  "description": "Creates an object that encapsulates the current execution\n environment. The result of this method is used, for example, by the\n three-argument checkConnect method and by the\n two-argument checkRead method.\n These methods are needed because a trusted method may be called\n on to read a file or open a socket on behalf of another method.\n The trusted method needs to determine if the other (possibly\n untrusted) method would be allowed to perform the operation on its\n own.\n  The default implementation of this method is to return\n an AccessControlContext object.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public void checkPermission(Permission perm)",
                  "description": "Throws a SecurityException if the requested\n access, specified by the given permission, is not permitted based\n on the security policy currently in effect.\n \n This method calls AccessController.checkPermission\n with the given permission.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkPermission(Permission perm, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is denied access to the resource\n specified by the given permission.\n The context must be a security\n context returned by a previous call to\n getSecurityContext and the access control\n decision is based upon the configured security policy for\n that security context.\n \n If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method is\n invoked with the specified permission.\n \n If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkCreateClassLoader",
              "overloads": [
                {
                  "signature": "public void checkCreateClassLoader()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to create a new class loader.\n \n This method calls checkPermission with the\n RuntimePermission(\"createClassLoader\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkCreateClassLoader\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "public void checkAccess(Thread t)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread argument.\n \n This method is invoked for the current security manager by the\n stop, suspend, resume,\n setPriority, setName, and\n setDaemon methods of class Thread.\n \n If the thread argument is a system thread (belongs to\n the thread group with a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThread\") permission.\n If the thread argument is not a system thread,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThread\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkAccess(ThreadGroup g)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread group argument.\n \n This method is invoked for the current security manager when a\n new child thread or child thread group is created, and by the\n setDaemon, setMaxPriority,\n stop, suspend, resume, and\n destroy methods of class ThreadGroup.\n \n If the thread group argument is the system thread group (\n has a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThreadGroup\") permission.\n If the thread group argument is not the system thread group,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThreadGroup\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkExit",
              "overloads": [
                {
                  "signature": "public void checkExit(int status)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to cause the Java Virtual Machine to\n halt with the specified status code.\n \n This method is invoked for the current security manager by the\n exit method of class Runtime. A status\n of 0 indicates success; other values indicate various\n errors.\n \n This method calls checkPermission with the\n RuntimePermission(\"exitVM.\"+status) permission.\n \n If you override this method, then you should make a call to\n super.checkExit\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkExec",
              "overloads": [
                {
                  "signature": "public void checkExec(String cmd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to create a subprocess.\n \n This method is invoked for the current security manager by the\n exec methods of class Runtime.\n \n This method calls checkPermission with the\n FilePermission(cmd,\"execute\") permission\n if cmd is an absolute path, otherwise it calls\n checkPermission with\n FilePermission(\"<<ALL FILES>>\",\"execute\").\n \n If you override this method, then you should make a call to\n super.checkExec\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkLink",
              "overloads": [
                {
                  "signature": "public void checkLink(String lib)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to dynamic link the library code\n specified by the string argument file. The argument is either a\n simple library name or a complete filename.\n \n This method is invoked for the current security manager by\n methods load and loadLibrary of class\n Runtime.\n \n This method calls checkPermission with the\n RuntimePermission(\"loadLibrary.\"+lib) permission.\n \n If you override this method, then you should make a call to\n super.checkLink\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkRead",
              "overloads": [
                {
                  "signature": "public void checkRead(FileDescriptor fd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to read from the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"readFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkRead(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to read the file specified by the\n string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkRead(String file, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is not allowed to read the file\n specified by the string argument. The context must be a security\n context returned by a previous call to\n getSecurityContext.\n  If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method will\n be invoked with the FilePermission(file,\"read\") permission.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkWrite",
              "overloads": [
                {
                  "signature": "public void checkWrite(FileDescriptor fd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"writeFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkWrite(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the file specified by\n the string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"write\") permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkDelete",
              "overloads": [
                {
                  "signature": "public void checkDelete(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to delete the specified file.\n \n This method is invoked for the current security manager by the\n delete method of class File.\n \n This method calls checkPermission with the\n FilePermission(file,\"delete\") permission.\n \n If you override this method, then you should make a call to\n super.checkDelete\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkConnect",
              "overloads": [
                {
                  "signature": "public void checkConnect(String host, int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to open a socket connection to the\n specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"connect\") permission if\n the port is not equal to -1. If the port is equal to -1, then\n it calls checkPermission with the\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkConnect(String host, int port, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is not allowed to open a socket\n connection to the specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n Otherwise, the port number is checked. If it is not equal\n to -1, the context's checkPermission\n method is called with a\n SocketPermission(host+\":\"+port,\"connect\") permission.\n If the port is equal to -1, then\n the context's checkPermission method\n is called with a\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkListen",
              "overloads": [
                {
                  "signature": "public void checkListen(int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to wait for a connection request on\n the specified local port number.\n \n This method calls checkPermission with the\n SocketPermission(\"localhost:\"+port,\"listen\").\n \n If you override this method, then you should make a call to\n super.checkListen\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkAccept",
              "overloads": [
                {
                  "signature": "public void checkAccept(String host, int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not permitted to accept a socket connection from\n the specified host and port number.\n \n This method is invoked for the current security manager by the\n accept method of class ServerSocket.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"accept\") permission.\n \n If you override this method, then you should make a call to\n super.checkAccept\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkMulticast",
              "overloads": [
                {
                  "signature": "public void checkMulticast(InetAddress maddr)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"1.4\", forRemoval=true) public void checkMulticast(InetAddress maddr, byte ttl)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPropertiesAccess",
              "overloads": [
                {
                  "signature": "public void checkPropertiesAccess()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to access or modify the system\n properties.\n \n This method is used by the getProperties and\n setProperties methods of class System.\n \n This method calls checkPermission with the\n PropertyPermission(\"*\", \"read,write\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertiesAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPropertyAccess",
              "overloads": [
                {
                  "signature": "public void checkPropertyAccess(String key)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to access the system property with\n the specified key name.\n \n This method is used by the getProperty method of\n class System.\n \n This method calls checkPermission with the\n PropertyPermission(key, \"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertyAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPrintJobAccess",
              "overloads": [
                {
                  "signature": "public void checkPrintJobAccess()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to initiate a print job request.\n \n This method calls\n checkPermission with the\n RuntimePermission(\"queuePrintJob\") permission.\n \n If you override this method, then you should make a call to\n super.checkPrintJobAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPackageAccess",
              "overloads": [
                {
                  "signature": "public void checkPackageAccess(String pkg)",
                  "description": "Throws a SecurityException if the calling thread is not allowed\n to access the specified package.\n \n During class loading, this method may be called by the loadClass\n method of class loaders and by the Java Virtual Machine to ensure that\n the caller is allowed to access the package of the class that is\n being loaded.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.access Security Property.\n An implementation may also check the package against an additional\n list of restricted packages as noted below. If the package is restricted,\n checkPermission(Permission) is called with a\n RuntimePermission(\"accessClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageAccess\n should be called as the first line in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPackageDefinition",
              "overloads": [
                {
                  "signature": "public void checkPackageDefinition(String pkg)",
                  "description": "Throws a SecurityException if the calling thread is not\n allowed to define classes in the specified package.\n \n This method is called by the loadClass method of some\n class loaders.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.definition Security\n Property. An implementation may also check the package against an\n additional list of restricted packages as noted below. If the package\n is restricted, checkPermission(Permission) is called with a\n RuntimePermission(\"defineClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageDefinition\n should be called as the first line in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkSetFactory",
              "overloads": [
                {
                  "signature": "public void checkSetFactory()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to set the socket factory used by\n ServerSocket or Socket, or the stream\n handler factory used by URL.\n \n This method calls checkPermission with the\n RuntimePermission(\"setFactory\") permission.\n \n If you override this method, then you should make a call to\n super.checkSetFactory\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkSecurityAccess",
              "overloads": [
                {
                  "signature": "public void checkSecurityAccess(String target)",
                  "description": "Determines whether the permission with the specified permission target\n name should be granted or denied.\n\n  If the requested permission is allowed, this method returns\n quietly. If denied, a SecurityException is raised.\n\n  This method creates a SecurityPermission object for\n the given permission target name and calls checkPermission\n with it.\n\n  See the documentation for\n SecurityPermission for\n a list of possible permission target names.\n\n  If you override this method, then you should make a call to\n super.checkSecurityAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getThreadGroup",
              "overloads": [
                {
                  "signature": "public ThreadGroup getThreadGroup()",
                  "description": "Returns the thread group into which to instantiate any new\n thread being created at the time this is being called.\n By default, it returns the thread group of the current\n thread. This should be overridden by a specific security\n manager to return the appropriate thread group.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Short",
          "methods": [
            {
              "name": "Short",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Short(short value)",
                  "description": "Constructs a newly allocated Short object that\n represents the specified short value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Short(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Short object that\n represents the short value indicated by the\n String parameter. The string is converted to a\n short value in exactly the manner used by the\n parseShort method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(short s)",
                  "description": "Returns a new String object representing the\n specified short. The radix is assumed to be 10."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Short's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the short value were given as an argument to the\n toString(short) method."
                }
              ]
            },
            {
              "name": "parseShort",
              "overloads": [
                {
                  "signature": "public static short parseShort(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed short in the\n radix specified by the second argument. The characters in the\n string must all be digits, of the specified radix (as\n determined by whether Character.digit(char, int) returns a nonnegative value) except that the first\n character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value.  The resulting short value\n is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n  The first argument is null or is a string of\n length zero.\n\n  The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n  Any character of the string is not a digit of the\n specified radix, except that the first character may be a minus\n sign '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n  The value represented by the string is not a value of type\n short."
                },
                {
                  "signature": "public static short parseShort(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal \n short. The characters in the string must all be decimal\n digits, except that the first character may be an ASCII minus\n sign '-' ('\\u002D') to indicate a\n negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value.  The\n resulting short value is returned, exactly as if the\n argument and the radix 10 were given as arguments to the parseShort(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Short valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Short object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed short in\n the radix specified by the second argument, exactly as if the\n argument were given to the parseShort(java.lang.String, int) method. The result is a Short object that\n represents the short value specified by the string.\n\n In other words, this method returns a Short object\n equal to the value of:\n\n \n  new Short(Short.parseShort(s, radix))"
                },
                {
                  "signature": "public static Short valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Short object holding the\n value given by the specified String. The argument\n is interpreted as representing a signed decimal\n short, exactly as if the argument were given to\n the parseShort(java.lang.String) method. The result is\n a Short object that represents the\n short value specified by the string.\n\n In other words, this method returns a Short object\n equal to the value of:\n\n \n  new Short(Short.parseShort(s))"
                },
                {
                  "signature": "public static Short valueOf(short s)",
                  "description": "Returns a Short instance representing the specified\n short value.\n If a new Short instance is not required, this method\n should generally be used in preference to the constructor\n Short(short), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Short>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Short decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Short.\n Accepts decimal, hexadecimal, and octal numbers given by\n the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Short.parseShort method with the indicated radix (10, 16, or\n 8).  This sequence of characters must represent a positive\n value or a NumberFormatException will be thrown.  The\n result is negated if first character of the specified \n String is the minus sign.  No whitespace characters are\n permitted in the String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Short as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Short as a\n short."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Short as an int after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Short as a long after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Short as a float\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Short as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Short; equal to the result\n of invoking intValue()."
                },
                {
                  "signature": "public static int hashCode(short value)",
                  "description": "Returns a hash code for a short value; compatible with\n Short.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Short object that\n contains the same short value as this object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Short anotherShort)",
                  "description": "Compares two Short objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(short x, short y)",
                  "description": "Compares two short values numerically.\n The value returned is identical to what would be returned by:\n     Short.valueOf(x).compareTo(Short.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(short x, short y)",
                  "description": "Compares two short values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static short reverseBytes(short i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified short value."
                }
              ]
            },
            {
              "name": "toUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int toUnsignedInt(short x)",
                  "description": "Converts the argument to an int by an unsigned\n conversion.  In an unsigned conversion to an int, the\n high-order 16 bits of the int are zero and the\n low-order 16 bits are equal to the bits of the short argument.\n\n Consequently, zero and positive short values are mapped\n to a numerically equal int value and negative \n short values are mapped to an int value equal to the\n input plus 216."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(short x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 48 bits of the long are zero and the\n low-order 16 bits are equal to the bits of the short argument.\n\n Consequently, zero and positive short values are mapped\n to a numerically equal long value and negative \n short values are mapped to a long value equal to the\n input plus 216."
                }
              ]
            }
          ]
        },
        {
          "name": "StackOverflowError",
          "methods": [
            {
              "name": "StackOverflowError",
              "overloads": [
                {
                  "signature": "public StackOverflowError()",
                  "description": "Constructs a StackOverflowError with no detail message."
                },
                {
                  "signature": "public StackOverflowError(String s)",
                  "description": "Constructs a StackOverflowError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "StackTraceElement",
          "methods": [
            {
              "name": "StackTraceElement",
              "overloads": [
                {
                  "signature": "public StackTraceElement(String declaringClass, String methodName, String fileName, int lineNumber)",
                  "description": "Creates a stack trace element representing the specified execution\n point. The module name and module version of the stack trace element will\n be null."
                },
                {
                  "signature": "public StackTraceElement(String classLoaderName, String moduleName, String moduleVersion, String declaringClass, String methodName, String fileName, int lineNumber)",
                  "description": "Creates a stack trace element representing the specified execution\n point."
                }
              ]
            },
            {
              "name": "getFileName",
              "overloads": [
                {
                  "signature": "public String getFileName()",
                  "description": "Returns the name of the source file containing the execution point\n represented by this stack trace element.  Generally, this corresponds\n to the SourceFile attribute of the relevant class\n file (as per The Java Virtual Machine Specification, Section\n 4.7.7).  In some systems, the name may refer to some source code unit\n other than a file, such as an entry in source repository."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Returns the line number of the source line containing the execution\n point represented by this stack trace element.  Generally, this is\n derived from the LineNumberTable attribute of the relevant\n class file (as per The Java Virtual Machine\n Specification, Section 4.7.8)."
                }
              ]
            },
            {
              "name": "getModuleName",
              "overloads": [
                {
                  "signature": "public String getModuleName()",
                  "description": "Returns the module name of the module containing the execution point\n represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getModuleVersion",
              "overloads": [
                {
                  "signature": "public String getModuleVersion()",
                  "description": "Returns the module version of the module containing the execution point\n represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getClassLoaderName",
              "overloads": [
                {
                  "signature": "public String getClassLoaderName()",
                  "description": "Returns the name of the class loader of the class containing the\n execution point represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "public String getClassName()",
                  "description": "Returns the fully qualified name of the class containing the\n execution point represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getMethodName",
              "overloads": [
                {
                  "signature": "public String getMethodName()",
                  "description": "Returns the name of the method containing the execution point\n represented by this stack trace element.  If the execution point is\n contained in an instance or class initializer, this method will return\n the appropriate special method name, <init> or\n <clinit>, as per Section 3.9 of The Java Virtual\n Machine Specification."
                }
              ]
            },
            {
              "name": "isNativeMethod",
              "overloads": [
                {
                  "signature": "public boolean isNativeMethod()",
                  "description": "Returns true if the method containing the execution point\n represented by this stack trace element is a native method."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this stack trace element."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if the specified object is another\n StackTraceElement instance representing the same execution\n point as this instance.  Two stack trace elements a and\n b are equal if and only if:\n \n     equals(a.getClassLoaderName(), b.getClassLoaderName()) &&\n     equals(a.getModuleName(), b.getModuleName()) &&\n     equals(a.getModuleVersion(), b.getModuleVersion()) &&\n     equals(a.getClassName(), b.getClassName()) &&\n     equals(a.getMethodName(), b.getMethodName())\n     equals(a.getFileName(), b.getFileName()) &&\n     a.getLineNumber() == b.getLineNumber()\n\n \n where equals has the semantics of Objects.equals."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for this stack trace element."
                }
              ]
            }
          ]
        },
        {
          "name": "StackWalker",
          "methods": [
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static StackWalker getInstance()",
                  "description": "Returns a StackWalker instance.\n\n  This StackWalker is configured to skip all\n hidden frames and\n no class reference is retained."
                },
                {
                  "signature": "public static StackWalker getInstance(StackWalker.Option option)",
                  "description": "Returns a StackWalker instance with the given option specifying\n the stack frame information it can access.\n\n \n If a security manager is present and the given option is\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\")."
                },
                {
                  "signature": "public static StackWalker getInstance(Set<StackWalker.Option> options)",
                  "description": "Returns a StackWalker instance with the given options specifying\n the stack frame information it can access.  If the given options\n is empty, this StackWalker is configured to skip all\n hidden frames and no\n class reference is retained.\n\n \n If a security manager is present and the given options contains\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\")."
                },
                {
                  "signature": "public static StackWalker getInstance(Set<StackWalker.Option> options, int estimateDepth)",
                  "description": "Returns a StackWalker instance with the given options specifying\n the stack frame information it can access. If the given options\n is empty, this StackWalker is configured to skip all\n hidden frames and no\n class reference is retained.\n\n \n If a security manager is present and the given options contains\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\").\n\n \n The estimateDepth specifies the estimate number of stack frames\n this StackWalker will traverse that the StackWalker could\n use as a hint for the buffer size."
                }
              ]
            },
            {
              "name": "walk",
              "overloads": [
                {
                  "signature": "public <T> T walk(Function<? super Stream<StackWalker.StackFrame>,? extends T> function)",
                  "description": "Applies the given function to the stream of StackFrames\n for the current thread, traversing from the top frame of the stack,\n which is the method calling this walk method.\n\n The StackFrame stream will be closed when\n this method returns.  When a closed Stream<StackFrame> object\n is reused, IllegalStateException will be thrown."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super StackWalker.StackFrame> action)",
                  "description": "Performs the given action on each element of StackFrame stream\n of the current thread, traversing from the top frame of the stack,\n which is the method calling this forEach method.\n\n  This method is equivalent to calling\n \n walk(s -> { s.forEach(action); return null; });"
                }
              ]
            },
            {
              "name": "getCallerClass",
              "overloads": [
                {
                  "signature": "public Class<?> getCallerClass()",
                  "description": "Gets the Class object of the caller who invoked the method\n that invoked getCallerClass.\n\n  This method filters reflection\n frames, MethodHandle, and\n hidden frames regardless of the\n SHOW_REFLECT_FRAMES\n and SHOW_HIDDEN_FRAMES options\n this StackWalker has been configured with.\n\n  This method should be called when a caller frame is present.  If\n it is called from the bottom most frame on the stack,\n IllegalCallerException will be thrown.\n\n  This method throws UnsupportedOperationException\n if this StackWalker is not configured with the\n RETAIN_CLASS_REFERENCE option."
                }
              ]
            }
          ]
        },
        {
          "name": "StackWalker.StackFrame",
          "methods": [
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "String getClassName()",
                  "description": "Gets the binary name\n of the declaring class of the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getMethodName",
              "overloads": [
                {
                  "signature": "String getMethodName()",
                  "description": "Gets the name of the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "Class<?> getDeclaringClass()",
                  "description": "Gets the declaring Class for the method represented by\n this stack frame."
                }
              ]
            },
            {
              "name": "getMethodType",
              "overloads": [
                {
                  "signature": "default MethodType getMethodType()",
                  "description": "Returns the MethodType representing the parameter types and\n the return type for the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getDescriptor",
              "overloads": [
                {
                  "signature": "default String getDescriptor()",
                  "description": "Returns the descriptor of the method represented by\n this stack frame as defined by\n The Java Virtual Machine Specification."
                }
              ]
            },
            {
              "name": "getByteCodeIndex",
              "overloads": [
                {
                  "signature": "int getByteCodeIndex()",
                  "description": "Returns the index to the code array of the Code attribute\n containing the execution point represented by this stack frame.\n The code array gives the actual bytes of Java Virtual Machine code\n that implement the method."
                }
              ]
            },
            {
              "name": "getFileName",
              "overloads": [
                {
                  "signature": "String getFileName()",
                  "description": "Returns the name of the source file containing the execution point\n represented by this stack frame.  Generally, this corresponds\n to the SourceFile attribute of the relevant class\n file as defined by The Java Virtual Machine Specification.\n In some systems, the name may refer to some source code unit\n other than a file, such as an entry in a source repository."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "int getLineNumber()",
                  "description": "Returns the line number of the source line containing the execution\n point represented by this stack frame.  Generally, this is\n derived from the LineNumberTable attribute of the relevant\n class file as defined by The Java Virtual Machine\n Specification."
                }
              ]
            },
            {
              "name": "isNativeMethod",
              "overloads": [
                {
                  "signature": "boolean isNativeMethod()",
                  "description": "Returns true if the method containing the execution point\n represented by this stack frame is a native method."
                }
              ]
            },
            {
              "name": "toStackTraceElement",
              "overloads": [
                {
                  "signature": "StackTraceElement toStackTraceElement()",
                  "description": "Gets a StackTraceElement for this stack frame."
                }
              ]
            }
          ]
        },
        {
          "name": "StrictMath",
          "methods": [
            {
              "name": "sin",
              "overloads": [
                {
                  "signature": "public static double sin(double a)",
                  "description": "Returns the trigonometric sine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "cos",
              "overloads": [
                {
                  "signature": "public static double cos(double a)",
                  "description": "Returns the trigonometric cosine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "tan",
              "overloads": [
                {
                  "signature": "public static double tan(double a)",
                  "description": "Returns the trigonometric tangent of an angle. Special cases:\n If the argument is NaN or an infinity, then the result\n is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "asin",
              "overloads": [
                {
                  "signature": "public static double asin(double a)",
                  "description": "Returns the arc sine of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "acos",
              "overloads": [
                {
                  "signature": "public static double acos(double a)",
                  "description": "Returns the arc cosine of a value; the returned angle is in the\n range 0.0 through pi.  Special case:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is 1.0, the result is positive zero."
                }
              ]
            },
            {
              "name": "atan",
              "overloads": [
                {
                  "signature": "public static double atan(double a)",
                  "description": "Returns the arc tangent of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n If the argument is infinite,\n then the result is the closest value to pi/2 with the\n same sign as the input."
                }
              ]
            },
            {
              "name": "toRadians",
              "overloads": [
                {
                  "signature": "public static double toRadians(double angdeg)",
                  "description": "Converts an angle measured in degrees to an approximately\n equivalent angle measured in radians.  The conversion from\n degrees to radians is generally inexact."
                }
              ]
            },
            {
              "name": "toDegrees",
              "overloads": [
                {
                  "signature": "public static double toDegrees(double angrad)",
                  "description": "Converts an angle measured in radians to an approximately\n equivalent angle measured in degrees.  The conversion from\n radians to degrees is generally inexact; users should\n not expect cos(toRadians(90.0)) to exactly\n equal 0.0."
                }
              ]
            },
            {
              "name": "exp",
              "overloads": [
                {
                  "signature": "public static double exp(double a)",
                  "description": "Returns Euler's number e raised to the power of a\n double value. Special cases:\n If the argument is NaN, the result is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is negative infinity, then the result is\n positive zero.\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "public static double log(double a)",
                  "description": "Returns the natural logarithm (base e) of a double\n value. Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is 1.0, then the result is positive\n zero."
                }
              ]
            },
            {
              "name": "log10",
              "overloads": [
                {
                  "signature": "public static double log10(double a)",
                  "description": "Returns the base 10 logarithm of a double value.\n Special cases:\n\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is equal to 10n for\n integer n, then the result is n. In particular,\n if the argument is 1.0 (100), then the\n result is positive zero."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public static double sqrt(double a)",
                  "description": "Returns the correctly rounded positive square root of a\n double value.\n Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is positive\n infinity.\n If the argument is positive zero or negative zero, then the\n result is the same as the argument.\n Otherwise, the result is the double value closest to\n the true mathematical square root of the argument value."
                }
              ]
            },
            {
              "name": "cbrt",
              "overloads": [
                {
                  "signature": "public static double cbrt(double a)",
                  "description": "Returns the cube root of a double value.  For\n positive finite x, cbrt(-x) ==\n -cbrt(x); that is, the cube root of a negative value is\n the negative of the cube root of that value's magnitude.\n Special cases:\n\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "IEEEremainder",
              "overloads": [
                {
                  "signature": "public static double IEEEremainder(double f1, double f2)",
                  "description": "Computes the remainder operation on two arguments as prescribed\n by the IEEE 754 standard.\n The remainder value is mathematically equal to\n f1-f2n,\n where n is the mathematical integer closest to the exact\n mathematical value of the quotient f1/f2, and if two\n mathematical integers are equally close to f1/f2,\n then n is the integer that is even. If the remainder is\n zero, its sign is the same as the sign of the first argument.\n Special cases:\n If either argument is NaN, or the first argument is infinite,\n or the second argument is positive zero or negative zero, then the\n result is NaN.\n If the first argument is finite and the second argument is\n infinite, then the result is the same as the first argument."
                }
              ]
            },
            {
              "name": "ceil",
              "overloads": [
                {
                  "signature": "public static double ceil(double a)",
                  "description": "Returns the smallest (closest to negative infinity)\n double value that is greater than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument.  If the argument value is less than zero but\n greater than -1.0, then the result is negative zero. Note\n that the value of StrictMath.ceil(x) is exactly the\n value of -StrictMath.floor(-x)."
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "public static double floor(double a)",
                  "description": "Returns the largest (closest to positive infinity)\n double value that is less than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument."
                }
              ]
            },
            {
              "name": "rint",
              "overloads": [
                {
                  "signature": "public static double rint(double a)",
                  "description": "Returns the double value that is closest in value\n to the argument and is equal to a mathematical integer. If two\n double values that are mathematical integers are\n equally close to the value of the argument, the result is the\n integer value that is even. Special cases:\n If the argument value is already equal to a mathematical\n integer, then the result is the same as the argument.\n If the argument is NaN or an infinity or positive zero or negative\n zero, then the result is the same as the argument."
                }
              ]
            },
            {
              "name": "atan2",
              "overloads": [
                {
                  "signature": "public static double atan2(double y, double x)",
                  "description": "Returns the angle theta from the conversion of rectangular\n coordinates (x,y) to polar\n coordinates (r,theta).\n This method computes the phase theta by computing an arc tangent\n of y/x in the range of -pi to pi. Special\n cases:\n If either argument is NaN, then the result is NaN.\n If the first argument is positive zero and the second argument\n is positive, or the first argument is positive and finite and the\n second argument is positive infinity, then the result is positive\n zero.\n If the first argument is negative zero and the second argument\n is positive, or the first argument is negative and finite and the\n second argument is positive infinity, then the result is negative zero.\n If the first argument is positive zero and the second argument\n is negative, or the first argument is positive and finite and the\n second argument is negative infinity, then the result is the\n double value closest to pi.\n If the first argument is negative zero and the second argument\n is negative, or the first argument is negative and finite and the\n second argument is negative infinity, then the result is the\n double value closest to -pi.\n If the first argument is positive and the second argument is\n positive zero or negative zero, or the first argument is positive\n infinity and the second argument is finite, then the result is the\n double value closest to pi/2.\n If the first argument is negative and the second argument is\n positive zero or negative zero, or the first argument is negative\n infinity and the second argument is finite, then the result is the\n double value closest to -pi/2.\n If both arguments are positive infinity, then the result is the\n double value closest to pi/4.\n If the first argument is positive infinity and the second argument\n is negative infinity, then the result is the double\n value closest to 3*pi/4.\n If the first argument is negative infinity and the second argument\n is positive infinity, then the result is the double value\n closest to -pi/4.\n If both arguments are negative infinity, then the result is the\n double value closest to -3*pi/4."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public static double pow(double a, double b)",
                  "description": "Returns the value of the first argument raised to the power of the\n second argument. Special cases:\n\n If the second argument is positive or negative zero, then the\n result is 1.0.\n If the second argument is 1.0, then the result is the same as the\n first argument.\n If the second argument is NaN, then the result is NaN.\n If the first argument is NaN and the second argument is nonzero,\n then the result is NaN.\n\n If\n \n the absolute value of the first argument is greater than 1\n and the second argument is positive infinity, or\n the absolute value of the first argument is less than 1 and\n the second argument is negative infinity,\n \n then the result is positive infinity.\n\n If\n \n the absolute value of the first argument is greater than 1 and\n the second argument is negative infinity, or\n the absolute value of the\n first argument is less than 1 and the second argument is positive\n infinity,\n \n then the result is positive zero.\n\n If the absolute value of the first argument equals 1 and the\n second argument is infinite, then the result is NaN.\n\n If\n \n the first argument is positive zero and the second argument\n is greater than zero, or\n the first argument is positive infinity and the second\n argument is less than zero,\n \n then the result is positive zero.\n\n If\n \n the first argument is positive zero and the second argument\n is less than zero, or\n the first argument is positive infinity and the second\n argument is greater than zero,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is greater than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is less than zero but not a finite odd integer,\n \n then the result is positive zero.\n\n If\n \n the first argument is negative zero and the second argument\n is a positive finite odd integer, or\n the first argument is negative infinity and the second\n argument is a negative finite odd integer,\n \n then the result is negative zero.\n\n If\n \n the first argument is negative zero and the second argument\n is less than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is greater than zero but not a finite odd integer,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is a negative finite odd integer, or\n the first argument is negative infinity and the second\n argument is a positive finite odd integer,\n \n then the result is negative infinity.\n\n If the first argument is finite and less than zero\n \n  if the second argument is a finite even integer, the\n result is equal to the result of raising the absolute value of\n the first argument to the power of the second argument\n\n if the second argument is a finite odd integer, the result\n is equal to the negative of the result of raising the absolute\n value of the first argument to the power of the second\n argument\n\n if the second argument is finite and not an integer, then\n the result is NaN.\n \n\n If both arguments are integers, then the result is exactly equal\n to the mathematical result of raising the first argument to the power\n of the second argument if that result can in fact be represented\n exactly as a double value.\n\n (In the foregoing descriptions, a floating-point value is\n considered to be an integer if and only if it is finite and a\n fixed point of the method ceil or,\n equivalently, a fixed point of the method floor. A value is a fixed point of a one-argument\n method if and only if the result of applying the method to the\n value is equal to the value.)"
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public static int round(float a)",
                  "description": "Returns the closest int to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Integer.MIN_VALUE, the result is\n equal to the value of Integer.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Integer.MAX_VALUE, the result is\n equal to the value of Integer.MAX_VALUE."
                },
                {
                  "signature": "public static long round(double a)",
                  "description": "Returns the closest long to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Long.MIN_VALUE, the result is\n equal to the value of Long.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Long.MAX_VALUE, the result is\n equal to the value of Long.MAX_VALUE."
                }
              ]
            },
            {
              "name": "random",
              "overloads": [
                {
                  "signature": "public static double random()",
                  "description": "Returns a double value with a positive sign, greater\n than or equal to 0.0 and less than 1.0.\n Returned values are chosen pseudorandomly with (approximately)\n uniform distribution from that range.\n\n When this method is first called, it creates a single new\n pseudorandom-number generator, exactly as if by the expression\n\n new java.util.Random()\n\n This new pseudorandom-number generator is used thereafter for\n all calls to this method and is used nowhere else.\n\n This method is properly synchronized to allow correct use by\n more than one thread. However, if many threads need to generate\n pseudorandom numbers at a great rate, it may reduce contention\n for each thread to have its own pseudorandom-number generator."
                }
              ]
            },
            {
              "name": "addExact",
              "overloads": [
                {
                  "signature": "public static int addExact(int x, int y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long addExact(long x, long y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "subtractExact",
              "overloads": [
                {
                  "signature": "public static int subtractExact(int x, int y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long subtractExact(long x, long y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "multiplyExact",
              "overloads": [
                {
                  "signature": "public static int multiplyExact(int x, int y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long multiplyExact(long x, int y)",
                  "description": "Returns the product of the arguments, throwing an exception if the result\n overflows a long."
                },
                {
                  "signature": "public static long multiplyExact(long x, long y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "incrementExact",
              "overloads": [
                {
                  "signature": "public static int incrementExact(int a)",
                  "description": "Returns the argument incremented by one,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the maximum value."
                },
                {
                  "signature": "public static long incrementExact(long a)",
                  "description": "Returns the argument incremented by one,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the maximum value."
                }
              ]
            },
            {
              "name": "decrementExact",
              "overloads": [
                {
                  "signature": "public static int decrementExact(int a)",
                  "description": "Returns the argument decremented by one,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long decrementExact(long a)",
                  "description": "Returns the argument decremented by one,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "negateExact",
              "overloads": [
                {
                  "signature": "public static int negateExact(int a)",
                  "description": "Returns the negation of the argument,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long negateExact(long a)",
                  "description": "Returns the negation of the argument,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "toIntExact",
              "overloads": [
                {
                  "signature": "public static int toIntExact(long value)",
                  "description": "Returns the value of the long argument, throwing an exception\n if the value overflows an int."
                }
              ]
            },
            {
              "name": "multiplyFull",
              "overloads": [
                {
                  "signature": "public static long multiplyFull(int x, int y)",
                  "description": "Returns the exact mathematical product of the arguments."
                }
              ]
            },
            {
              "name": "multiplyHigh",
              "overloads": [
                {
                  "signature": "public static long multiplyHigh(long x, long y)",
                  "description": "Returns as a long the most significant 64 bits of the 128-bit\n product of two 64-bit factors."
                }
              ]
            },
            {
              "name": "floorDiv",
              "overloads": [
                {
                  "signature": "public static int floorDiv(int x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n int value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Integer.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to the Integer.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                },
                {
                  "signature": "public static long floorDiv(long x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                },
                {
                  "signature": "public static long floorDiv(long x, long y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to the Long.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                }
              ]
            },
            {
              "name": "floorMod",
              "overloads": [
                {
                  "signature": "public static int floorMod(int x, int y)",
                  "description": "Returns the floor modulus of the int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                },
                {
                  "signature": "public static int floorMod(long x, int y)",
                  "description": "Returns the floor modulus of the long and int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                },
                {
                  "signature": "public static long floorMod(long x, long y)",
                  "description": "Returns the floor modulus of the long arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public static int abs(int a)",
                  "description": "Returns the absolute value of an int value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int\n value, the result is that same value, which is negative. In\n contrast, the absExact(int) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static long abs(long a)",
                  "description": "Returns the absolute value of a long value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Long.MIN_VALUE, the most negative representable long\n value, the result is that same value, which is negative. In\n contrast, the absExact(long) method throws\n an ArithmeticException for this value."
                },
                {
                  "signature": "public static float abs(float a)",
                  "description": "Returns the absolute value of a float value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the\n result is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                },
                {
                  "signature": "public static double abs(double a)",
                  "description": "Returns the absolute value of a double value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the result\n is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                }
              ]
            },
            {
              "name": "absExact",
              "overloads": [
                {
                  "signature": "public static int absExact(int a)",
                  "description": "Returns the mathematical absolute value of an int value\n if it is exactly representable as an int, throwing\n ArithmeticException if the result overflows the\n positive int range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Integer.MIN_VALUE\n overflows the positive int range, so an exception is\n thrown for that argument."
                },
                {
                  "signature": "public static long absExact(long a)",
                  "description": "Returns the mathematical absolute value of an long value\n if it is exactly representable as an long, throwing\n ArithmeticException if the result overflows the\n positive long range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Long.MIN_VALUE overflows\n the positive long range, so an exception is thrown for\n that argument."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values. That is, the\n result is the argument closer to the value of\n Integer.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values. That is, the\n result is the argument closer to the value of\n Long.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values.  That is,\n the result is the argument closer to positive infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                },
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values.  That\n is, the result is the argument closer to positive infinity. If\n the arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values. That is,\n the result the argument closer to the value of\n Integer.MIN_VALUE.  If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values. That is,\n the result is the argument closer to the value of\n Long.MIN_VALUE. If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values.  That is,\n the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero.  If\n one argument is positive zero and the other is negative zero,\n the result is negative zero."
                },
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values.  That\n is, the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other is negative zero, the\n result is negative zero."
                }
              ]
            },
            {
              "name": "fma",
              "overloads": [
                {
                  "signature": "public static double fma(double a, double b, double c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n double.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fusedMac(a, 1.0, c) returns the same\n result as (a + c).  However,\n fusedMac(a, b, +0.0) does not always return the\n same result as (a * b) since\n fusedMac(-0.0, +0.0, +0.0) is +0.0 while\n (-0.0 * +0.0) is -0.0; fusedMac(a, b, -0.0) is\n equivalent to (a * b) however."
                },
                {
                  "signature": "public static float fma(float a, float b, float c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n float.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0f, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0f) does not always return the\n same result as (a * b) since\n fma(-0.0f, +0.0f, +0.0f) is +0.0f while\n (-0.0f * +0.0f) is -0.0f; fma(a, b, -0.0f) is\n equivalent to (a * b) however."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public static double ulp(double d)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a double value is the positive\n distance between this floating-point value and the \n double value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Double.MIN_VALUE.\n  If the argument is Double.MAX_VALUE, then\n the result is equal to 2971."
                },
                {
                  "signature": "public static float ulp(float f)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a float value is the positive\n distance between this floating-point value and the \n float value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Float.MIN_VALUE.\n  If the argument is Float.MAX_VALUE, then\n the result is equal to 2104."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static double signum(double d)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0 if the argument is greater than zero, -1.0 if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                },
                {
                  "signature": "public static float signum(float f)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0f if the argument is greater than zero, -1.0f if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                }
              ]
            },
            {
              "name": "sinh",
              "overloads": [
                {
                  "signature": "public static double sinh(double x)",
                  "description": "Returns the hyperbolic sine of a double value.\n The hyperbolic sine of x is defined to be\n (ex-e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "cosh",
              "overloads": [
                {
                  "signature": "public static double cosh(double x)",
                  "description": "Returns the hyperbolic cosine of a double value.\n The hyperbolic cosine of x is defined to be\n (ex+e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is positive\n infinity.\n\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "tanh",
              "overloads": [
                {
                  "signature": "public static double tanh(double x)",
                  "description": "Returns the hyperbolic tangent of a double value.\n The hyperbolic tangent of x is defined to be\n (ex-e-x)/(ex+e-x),\n in other words, sinh(x)/cosh(x).  Note\n that the absolute value of the exact tanh is always less than\n 1.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n If the argument is positive infinity, then the result is\n +1.0.\n\n If the argument is negative infinity, then the result is\n -1.0."
                }
              ]
            },
            {
              "name": "hypot",
              "overloads": [
                {
                  "signature": "public static double hypot(double x, double y)",
                  "description": "Returns sqrt(x2+y2)\n without intermediate overflow or underflow.\n\n Special cases:\n \n\n  If either argument is infinite, then the result\n is positive infinity.\n\n  If either argument is NaN and neither argument is infinite,\n then the result is NaN.\n\n  If both arguments are zero, the result is positive zero."
                }
              ]
            },
            {
              "name": "expm1",
              "overloads": [
                {
                  "signature": "public static double expm1(double x)",
                  "description": "Returns ex-1.  Note that for values of\n x near 0, the exact sum of\n expm1(x)+1 is much closer to the true\n result of ex than exp(x).\n\n Special cases:\n \n If the argument is NaN, the result is NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "log1p",
              "overloads": [
                {
                  "signature": "public static double log1p(double x)",
                  "description": "Returns the natural logarithm of the sum of the argument and 1.\n Note that for small values x, the result of\n log1p(x) is much closer to the true result of ln(1\n + x) than the floating-point evaluation of\n log(1.0+x).\n\n Special cases:\n \n\n If the argument is NaN or less than -1, then the result is\n NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative one, then the result is\n negative infinity.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "copySign",
              "overloads": [
                {
                  "signature": "public static double copySign(double magnitude, double sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  For this method, a NaN\n sign argument is always treated as if it were\n positive."
                },
                {
                  "signature": "public static float copySign(float magnitude, float sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  For this method, a NaN\n sign argument is always treated as if it were\n positive."
                }
              ]
            },
            {
              "name": "getExponent",
              "overloads": [
                {
                  "signature": "public static int getExponent(float f)",
                  "description": "Returns the unbiased exponent used in the representation of a\n float.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Float.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Float.MIN_EXPONENT -1."
                },
                {
                  "signature": "public static int getExponent(double d)",
                  "description": "Returns the unbiased exponent used in the representation of a\n double.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Double.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Double.MIN_EXPONENT -1."
                }
              ]
            },
            {
              "name": "nextAfter",
              "overloads": [
                {
                  "signature": "public static double nextAfter(double start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal the second argument is returned.\n\n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, direction\n is returned unchanged (as implied by the requirement of\n returning the second argument if the arguments compare as\n equal).\n\n  If start is\n Double.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Double.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Double.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                },
                {
                  "signature": "public static float nextAfter(float start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal a value equivalent to the second argument\n is returned.\n\n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, a value equivalent\n to direction is returned.\n\n  If start is\n Float.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Float.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Float.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                }
              ]
            },
            {
              "name": "nextUp",
              "overloads": [
                {
                  "signature": "public static double nextUp(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextUp(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "nextDown",
              "overloads": [
                {
                  "signature": "public static double nextDown(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextDown(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "scalb",
              "overloads": [
                {
                  "signature": "public static double scalb(double d, int scaleFactor)",
                  "description": "Returns d  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Double.MIN_EXPONENT and Double.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Double.MAX_EXPONENT, an infinity is returned.  Note that if\n the result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as d.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                },
                {
                  "signature": "public static float scalb(float f, int scaleFactor)",
                  "description": "Returns f  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Float.MIN_EXPONENT and Float.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Float.MAX_EXPONENT, an infinity is returned.  Note that if the\n result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as f.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "String",
          "methods": [
            {
              "name": "String",
              "overloads": [
                {
                  "signature": "public String()",
                  "description": "Initializes a newly created String object so that it represents\n an empty character sequence.  Note that use of this constructor is\n unnecessary since Strings are immutable."
                },
                {
                  "signature": "public String(String original)",
                  "description": "Initializes a newly created String object so that it represents\n the same sequence of characters as the argument; in other words, the\n newly created string is a copy of the argument string. Unless an\n explicit copy of original is needed, use of this constructor is\n unnecessary since Strings are immutable."
                },
                {
                  "signature": "public String(char[] value)",
                  "description": "Allocates a new String so that it represents the sequence of\n characters currently contained in the character array argument. The\n contents of the character array are copied; subsequent modification of\n the character array does not affect the newly created string."
                },
                {
                  "signature": "public String(char[] value, int offset, int count)",
                  "description": "Allocates a new String that contains characters from a subarray\n of the character array argument. The offset argument is the\n index of the first character of the subarray and the count\n argument specifies the length of the subarray. The contents of the\n subarray are copied; subsequent modification of the character array does\n not affect the newly created string."
                },
                {
                  "signature": "public String(int[] codePoints, int offset, int count)",
                  "description": "Allocates a new String that contains characters from a subarray\n of the Unicode code point array\n argument.  The offset argument is the index of the first code\n point of the subarray and the count argument specifies the\n length of the subarray.  The contents of the subarray are converted to\n chars; subsequent modification of the int array does not\n affect the newly created string."
                },
                {
                  "signature": "@Deprecated(since=\"1.1\") public String(byte[] ascii, int hibyte, int offset, int count)",
                  "description": "Allocates a new String constructed from a subarray of an array\n of 8-bit integer values.\n\n  The offset argument is the index of the first byte of the\n subarray, and the count argument specifies the length of the\n subarray.\n\n  Each byte in the subarray is converted to a char as\n specified in the String(byte[],int) constructor.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"1.1\") public String(byte[] ascii, int hibyte)",
                  "description": "Allocates a new String containing characters constructed from\n an array of 8-bit integer values. Each character c in the\n resulting string is constructed from the corresponding component\n b in the byte array such that:\n\n      c == (char)(((hibyte & 0xff) << 8)\n                         | (b & 0xff))",
                  "deprecated": true
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length, String charsetName) throws UnsupportedEncodingException",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the specified charset.  The length of the new String\n is a function of the charset, and hence may not be equal to the length\n of the subarray.\n\n  The behavior of this constructor when the given bytes are not valid\n in the given charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length, Charset charset)",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the specified charset.\n The length of the new String is a function of the charset, and\n hence may not be equal to the length of the subarray.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement string.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException",
                  "description": "Constructs a new String by decoding the specified array of bytes\n using the specified charset.  The\n length of the new String is a function of the charset, and hence\n may not be equal to the length of the byte array.\n\n  The behavior of this constructor when the given bytes are not valid\n in the given charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, Charset charset)",
                  "description": "Constructs a new String by decoding the specified array of\n bytes using the specified charset.\n The length of the new String is a function of the charset, and\n hence may not be equal to the length of the byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement string.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length)",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the platform's default charset.  The length of the new\n String is a function of the charset, and hence may not be equal\n to the length of the subarray.\n\n  The behavior of this constructor when the given bytes are not valid\n in the default charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes)",
                  "description": "Constructs a new String by decoding the specified array of bytes\n using the platform's default charset.  The length of the new \n String is a function of the charset, and hence may not be equal to the\n length of the byte array.\n\n  The behavior of this constructor when the given bytes are not valid\n in the default charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(StringBuffer buffer)",
                  "description": "Allocates a new string that contains the sequence of characters\n currently contained in the string buffer argument. The contents of the\n string buffer are copied; subsequent modification of the string buffer\n does not affect the newly created string."
                },
                {
                  "signature": "public String(StringBuilder builder)",
                  "description": "Allocates a new string that contains the sequence of characters\n currently contained in the string builder argument. The contents of the\n string builder are copied; subsequent modification of the string builder\n does not affect the newly created string.\n\n  This constructor is provided to ease migration to \n StringBuilder. Obtaining a string from a string builder via the \n toString method is likely to run faster and is generally preferred."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length of this string.\n The length is equal to the number of Unicode\n code units in the string."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if, and only if, length() is 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value at the\n specified index. An index ranges from 0 to\n length() - 1. The first char value of the sequence\n is at index 0, the next at index 1,\n and so on, as for array indexing.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this String, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to length.\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this String. The text range begins at the\n specified beginIndex and extends to the\n char at index endIndex - 1. Thus the\n length (in chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n the text range count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this String that is\n offset from the given index by\n codePointOffset code points. Unpaired surrogates\n within the text range given by index and\n codePointOffset count as one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Copies characters from this string into the destination character\n array.\n \n The first character to be copied is at index srcBegin;\n the last character to be copied is at index srcEnd-1\n (thus the total number of characters to be copied is\n srcEnd-srcBegin). The characters are copied into the\n subarray of dst starting at index dstBegin\n and ending at index:\n      dstBegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "getBytes",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)",
                  "description": "Copies characters from this string into the destination byte array. Each\n byte receives the 8 low-order bits of the corresponding character. The\n eight high-order bits of each character are not copied and do not\n participate in the transfer in any way.\n\n  The first character to be copied is at index srcBegin; the\n last character to be copied is at index srcEnd-1.  The total\n number of characters to be copied is srcEnd-srcBegin. The\n characters, converted to bytes, are copied into the subarray of \n dst starting at index dstBegin and ending at index:\n\n      dstBegin + (srcEnd-srcBegin) - 1",
                  "deprecated": true
                },
                {
                  "signature": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException",
                  "description": "Encodes this String into a sequence of bytes using the named\n charset, storing the result into a new byte array.\n\n  The behavior of this method when this string cannot be encoded in\n the given charset is unspecified.  The CharsetEncoder class should be used when more control\n over the encoding process is required."
                },
                {
                  "signature": "public byte[] getBytes(Charset charset)",
                  "description": "Encodes this String into a sequence of bytes using the given\n charset, storing the result into a\n new byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement byte array.  The\n CharsetEncoder class should be used when more\n control over the encoding process is required."
                },
                {
                  "signature": "public byte[] getBytes()",
                  "description": "Encodes this String into a sequence of bytes using the\n platform's default charset, storing the result into a new byte array.\n\n  The behavior of this method when this string cannot be encoded in\n the default charset is unspecified.  The CharsetEncoder class should be used when more control\n over the encoding process is required."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object anObject)",
                  "description": "Compares this string to the specified object.  The result is \n true if and only if the argument is not null and is a \n String object that represents the same sequence of characters as this\n object.\n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "contentEquals",
              "overloads": [
                {
                  "signature": "public boolean contentEquals(StringBuffer sb)",
                  "description": "Compares this string to the specified StringBuffer.  The result\n is true if and only if this String represents the same\n sequence of characters as the specified StringBuffer. This method\n synchronizes on the StringBuffer.\n\n For finer-grained String comparison, refer to\n Collator."
                },
                {
                  "signature": "public boolean contentEquals(CharSequence cs)",
                  "description": "Compares this string to the specified CharSequence.  The\n result is true if and only if this String represents the\n same sequence of char values as the specified sequence. Note that if the\n CharSequence is a StringBuffer then the method\n synchronizes on it.\n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "equalsIgnoreCase",
              "overloads": [
                {
                  "signature": "public boolean equalsIgnoreCase(String anotherString)",
                  "description": "Compares this String to another String, ignoring case\n considerations.  Two strings are considered equal ignoring case if they\n are of the same length and corresponding Unicode code points in the two\n strings are equal ignoring case.\n\n  Two Unicode code points are considered the same\n ignoring case if at least one of the following is true:\n \n    The two Unicode code points are the same (as compared by the\n        == operator)\n    Calling Character.toLowerCase(Character.toUpperCase(int))\n        on each Unicode code point produces the same result\n \n\n Note that this method does not take locale into account, and\n will result in unsatisfactory results for certain locales.  The\n Collator class provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(String anotherString)",
                  "description": "Compares two strings lexicographically.\n The comparison is based on the Unicode value of each character in\n the strings. The character sequence represented by this\n String object is compared lexicographically to the\n character sequence represented by the argument string. The result is\n a negative integer if this String object\n lexicographically precedes the argument string. The result is a\n positive integer if this String object lexicographically\n follows the argument string. The result is zero if the strings\n are equal; compareTo returns 0 exactly when\n the equals(Object) method would return true.\n \n This is the definition of lexicographic ordering. If two strings are\n different, then either they have different characters at some index\n that is a valid index for both strings, or their lengths are different,\n or both. If they have different characters at one or more index\n positions, let k be the smallest such index; then the string\n whose character at position k has the smaller value, as\n determined by using the < operator, lexicographically precedes the\n other string. In this case, compareTo returns the\n difference of the two character values at position k in\n the two string -- that is, the value:\n  this.charAt(k)-anotherString.charAt(k)\n \n If there is no index position at which they differ, then the shorter\n string lexicographically precedes the longer string. In this case,\n compareTo returns the difference of the lengths of the\n strings -- that is, the value:\n  this.length()-anotherString.length()\n \n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "compareToIgnoreCase",
              "overloads": [
                {
                  "signature": "public int compareToIgnoreCase(String str)",
                  "description": "Compares two strings lexicographically, ignoring case\n differences. This method returns an integer whose sign is that of\n calling compareTo with case folded versions of the strings\n where case differences have been eliminated by calling\n Character.toLowerCase(Character.toUpperCase(int)) on\n each Unicode code point.\n \n Note that this method does not take locale into account,\n and will result in an unsatisfactory ordering for certain locales.\n The Collator class provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "regionMatches",
              "overloads": [
                {
                  "signature": "public boolean regionMatches(int toffset, String other, int ooffset, int len)",
                  "description": "Tests if two string regions are equal.\n \n A substring of this String object is compared to a substring\n of the argument other. The result is true if these substrings\n represent identical character sequences. The substring of this\n String object to be compared begins at index toffset\n and has length len. The substring of other to be compared\n begins at index ooffset and has length len. The\n result is false if and only if at least one of the following\n is true:\n toffset is negative.\n ooffset is negative.\n toffset+len is greater than the length of this\n String object.\n ooffset+len is greater than the length of the other\n argument.\n There is some nonnegative integer k less than len\n such that:\n this.charAt(toffset + k) != other.charAt(ooffset + \n k)\n \n\n Note that this method does not take locale into account.  The\n Collator class provides locale-sensitive comparison."
                },
                {
                  "signature": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)",
                  "description": "Tests if two string regions are equal.\n \n A substring of this String object is compared to a substring\n of the argument other. The result is true if these\n substrings represent Unicode code point sequences that are the same,\n ignoring case if and only if ignoreCase is true.\n The sequences tsequence and osequence are compared,\n where tsequence is the sequence produced as if by calling\n this.substring(toffset, toffset + len).codePoints() and\n osequence is the sequence produced as if by calling\n other.substring(ooffset, ooffset + len).codePoints().\n The result is true if and only if all of the following\n are true:\n toffset is non-negative.\n ooffset is non-negative.\n toffset+len is less than or equal to the length of this\n String object.\n ooffset+len is less than or equal to the length of the other\n argument.\n if ignoreCase is false, all pairs of corresponding Unicode\n code points are equal integer values; or if ignoreCase is true,\n Character.toLowerCase(\n Character.toUpperCase(int)) on all pairs of Unicode code points\n results in equal integer values.\n \n\n Note that this method does not take locale into account,\n and will result in unsatisfactory results for certain locales when\n ignoreCase is true.  The Collator class\n provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "startsWith",
              "overloads": [
                {
                  "signature": "public boolean startsWith(String prefix, int toffset)",
                  "description": "Tests if the substring of this string beginning at the\n specified index starts with the specified prefix."
                },
                {
                  "signature": "public boolean startsWith(String prefix)",
                  "description": "Tests if this string starts with the specified prefix."
                }
              ]
            },
            {
              "name": "endsWith",
              "overloads": [
                {
                  "signature": "public boolean endsWith(String suffix)",
                  "description": "Tests if this string ends with the specified suffix."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this string. The hash code for a\n String object is computed as\n  s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n \n using int arithmetic, where s[i] is the\n ith character of the string, n is the length of\n the string, and ^ indicates exponentiation.\n (The hash value of the empty string is zero.)"
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(int ch)",
                  "description": "Returns the index within this string of the first occurrence of\n the specified character. If a character with value\n ch occurs in the character sequence represented by\n this String object, then the index (in Unicode\n code units) of the first such occurrence is returned. For\n values of ch in the range from 0 to 0xFFFF\n (inclusive), this is the smallest value k such that:\n  this.charAt(k) == ch\n \n is true. For other values of ch, it is the\n smallest value k such that:\n  this.codePointAt(k) == ch\n \n is true. In either case, if no such character occurs in this\n string, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(int ch, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified character, starting the search at the specified index.\n \n If a character with value ch occurs in the\n character sequence represented by this String\n object at an index no smaller than fromIndex, then\n the index of the first such occurrence is returned. For values\n of ch in the range from 0 to 0xFFFF (inclusive),\n this is the smallest value k such that:\n  (this.charAt(k) == ch) && (k >= fromIndex)\n \n is true. For other values of ch, it is the\n smallest value k such that:\n  (this.codePointAt(k) == ch) && (k >= fromIndex)\n \n is true. In either case, if no such character occurs in this\n string at or after position fromIndex, then\n -1 is returned.\n\n \n There is no restriction on the value of fromIndex. If it\n is negative, it has the same effect as if it were zero: this entire\n string may be searched. If it is greater than the length of this\n string, it has the same effect as if it were equal to the length of\n this string: -1 is returned.\n\n All indices are specified in char values\n (Unicode code units)."
                },
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(int ch)",
                  "description": "Returns the index within this string of the last occurrence of\n the specified character. For values of ch in the\n range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n units) returned is the largest value k such that:\n  this.charAt(k) == ch\n \n is true. For other values of ch, it is the\n largest value k such that:\n  this.codePointAt(k) == ch\n \n is true.  In either case, if no such character occurs in this\n string, then -1 is returned.  The\n String is searched backwards starting at the last\n character."
                },
                {
                  "signature": "public int lastIndexOf(int ch, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of\n the specified character, searching backward starting at the\n specified index. For values of ch in the range\n from 0 to 0xFFFF (inclusive), the index returned is the largest\n value k such that:\n  (this.charAt(k) == ch) && (k <= fromIndex)\n \n is true. For other values of ch, it is the\n largest value k such that:\n  (this.codePointAt(k) == ch) && (k <= fromIndex)\n \n is true. In either case, if no such character occurs in this\n string at or before position fromIndex, then\n -1 is returned.\n\n All indices are specified in char values\n (Unicode code units)."
                },
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\"\n is considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int beginIndex)",
                  "description": "Returns a string that is a substring of this string. The\n substring begins with the character at the specified index and\n extends to the end of this string. \n Examples:\n  \"unhappy\".substring(2) returns \"happy\"\n \"Harbison\".substring(3) returns \"bison\"\n \"emptiness\".substring(9) returns \"\" (an empty string)"
                },
                {
                  "signature": "public String substring(int beginIndex, int endIndex)",
                  "description": "Returns a string that is a substring of this string. The\n substring begins at the specified beginIndex and\n extends to the character at index endIndex - 1.\n Thus the length of the substring is endIndex-beginIndex.\n \n Examples:\n  \"hamburger\".substring(4, 8) returns \"urge\"\n \"smiles\".substring(1, 5) returns \"mile\""
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int beginIndex, int endIndex)",
                  "description": "Returns a character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n  str.subSequence(begin,end)\n\n behaves in exactly the same way as the invocation\n\n  str.substring(begin,end)"
                }
              ]
            },
            {
              "name": "concat",
              "overloads": [
                {
                  "signature": "public String concat(String str)",
                  "description": "Concatenates the specified string to the end of this string.\n \n If the length of the argument string is 0, then this\n String object is returned. Otherwise, a\n String object is returned that represents a character\n sequence that is the concatenation of the character sequence\n represented by this String object and the character\n sequence represented by the argument string.\n Examples:\n  \"cares\".concat(\"s\") returns \"caress\"\n \"to\".concat(\"get\").concat(\"her\") returns \"together\""
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public String replace(char oldChar, char newChar)",
                  "description": "Returns a string resulting from replacing all occurrences of\n oldChar in this string with newChar.\n \n If the character oldChar does not occur in the\n character sequence represented by this String object,\n then a reference to this String object is returned.\n Otherwise, a String object is returned that\n represents a character sequence identical to the character sequence\n represented by this String object, except that every\n occurrence of oldChar is replaced by an occurrence\n of newChar.\n \n Examples:\n  \"mesquite in your cellar\".replace('e', 'o')\n         returns \"mosquito in your collar\"\n \"the war of baronets\".replace('r', 'y')\n         returns \"the way of bayonets\"\n \"sparring with a purple porpoise\".replace('p', 't')\n         returns \"starring with a turtle tortoise\"\n \"JonL\".replace('q', 'x') returns \"JonL\" (no change)"
                },
                {
                  "signature": "public String replace(CharSequence target, CharSequence replacement)",
                  "description": "Replaces each substring of this string that matches the literal target\n sequence with the specified literal replacement sequence. The\n replacement proceeds from the beginning of the string to the end, for\n example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n \"ba\" rather than \"ab\"."
                }
              ]
            },
            {
              "name": "matches",
              "overloads": [
                {
                  "signature": "public boolean matches(String regex)",
                  "description": "Tells whether or not this string matches the given regular expression.\n\n  An invocation of this method of the form\n str.matches(regex) yields exactly the\n same result as the expression\n\n \n Pattern.matches(regex, str)"
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(CharSequence s)",
                  "description": "Returns true if and only if this string contains the specified\n sequence of char values."
                }
              ]
            },
            {
              "name": "replaceFirst",
              "overloads": [
                {
                  "signature": "public String replaceFirst(String regex, String replacement)",
                  "description": "Replaces the first substring of this string that matches the given regular expression with the\n given replacement.\n\n  An invocation of this method of the form\n str.replaceFirst(regex, repl)\n yields exactly the same result as the expression\n\n \n \n Pattern.compile(regex).matcher(str).replaceFirst(repl)\n \n \n\n\n Note that backslashes (\\) and dollar signs ($) in the\n replacement string may cause the results to be different than if it were\n being treated as a literal replacement string; see\n Matcher.replaceFirst(java.lang.String).\n Use Matcher.quoteReplacement(java.lang.String) to suppress the special\n meaning of these characters, if desired."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public String replaceAll(String regex, String replacement)",
                  "description": "Replaces each substring of this string that matches the given regular expression with the\n given replacement.\n\n  An invocation of this method of the form\n str.replaceAll(regex, repl)\n yields exactly the same result as the expression\n\n \n \n Pattern.compile(regex).matcher(str).replaceAll(repl)\n \n \n\n\n Note that backslashes (\\) and dollar signs ($) in the\n replacement string may cause the results to be different than if it were\n being treated as a literal replacement string; see\n Matcher.replaceAll.\n Use Matcher.quoteReplacement(java.lang.String) to suppress the special\n meaning of these characters, if desired."
                }
              ]
            },
            {
              "name": "split",
              "overloads": [
                {
                  "signature": "public String[] split(String regex, int limit)",
                  "description": "Splits this string around matches of the given\n regular expression.\n\n  The array returned by this method contains each substring of this\n string that is terminated by another substring that matches the given\n expression or is terminated by the end of the string.  The substrings in\n the array are in the order in which they occur in this string.  If the\n expression does not match any part of the input then the resulting array\n has just one element, namely this string.\n\n  When there is a positive-width match at the beginning of this\n string then an empty leading substring is included at the beginning\n of the resulting array. A zero-width match at the beginning however\n never produces such empty leading substring.\n\n  The limit parameter controls the number of times the\n pattern is applied and therefore affects the length of the resulting\n array.\n \n    \n    If the limit is positive then the pattern will be applied\n    at most limit-1 times, the array's length will be\n    no greater than limit, and the array's last entry will contain\n    all input beyond the last matched delimiter.\n\n    \n    If the limit is zero then the pattern will be applied as\n    many times as possible, the array can have any length, and trailing\n    empty strings will be discarded.\n\n    \n    If the limit is negative then the pattern will be applied\n    as many times as possible and the array can have any length.\n \n\n  The string \"boo:and:foo\", for example, yields the\n following results with these parameters:\n\n \n Split example showing regex, limit, and result\n \n \n     Regex\n     Limit\n     Result\n \n \n \n :\n     2\n     { \"boo\", \"and:foo\" }\n \n     5\n     { \"boo\", \"and\", \"foo\" }\n \n     -2\n     { \"boo\", \"and\", \"foo\" }\n o\n     5\n     { \"b\", \"\", \":and:f\", \"\", \"\" }\n \n     -2\n     { \"b\", \"\", \":and:f\", \"\", \"\" }\n \n     0\n     { \"b\", \"\", \":and:f\" }\n \n \n\n  An invocation of this method of the form\n str.split(regex,n)\n yields the same result as the expression\n\n \n \n Pattern.compile(regex).split(str,n)"
                },
                {
                  "signature": "public String[] split(String regex)",
                  "description": "Splits this string around matches of the given regular expression.\n\n  This method works as if by invoking the two-argument split method with the given expression and a limit\n argument of zero.  Trailing empty strings are therefore not included in\n the resulting array.\n\n  The string \"boo:and:foo\", for example, yields the following\n results with these expressions:\n\n \n Split examples showing regex and result\n \n \n  Regex\n  Result\n \n \n \n :\n     { \"boo\", \"and\", \"foo\" }\n o\n     { \"b\", \"\", \":and:f\" }"
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "public static String join(CharSequence delimiter, CharSequence... elements)",
                  "description": "Returns a new String composed of copies of the\n CharSequence elements joined together with a copy of\n the specified delimiter.\n\n For example,\n \n     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     // message returned is: \"Java-is-cool\"\n \n\n Note that if an element is null, then \"null\" is added."
                },
                {
                  "signature": "public static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)",
                  "description": "Returns a new String composed of copies of the\n CharSequence elements joined together with a copy of the\n specified delimiter.\n\n For example,\n \n     List<String> strings = List.of(\"Java\", \"is\", \"cool\");\n     String message = String.join(\" \", strings);\n     // message returned is: \"Java is cool\"\n\n     Set<String> strings =\n         new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     String message = String.join(\"-\", strings);\n     // message returned is: \"Java-is-very-cool\"\n \n\n Note that if an individual element is null, then \"null\" is added."
                }
              ]
            },
            {
              "name": "toLowerCase",
              "overloads": [
                {
                  "signature": "public String toLowerCase(Locale locale)",
                  "description": "Converts all of the characters in this String to lower\n case using the rules of the given Locale.  Case mapping is based\n on the Unicode Standard version specified by the Character\n class. Since case mappings are not always 1:1 char mappings, the resulting\n String may be a different length than the original String.\n \n Examples of lowercase  mappings are in the following table:\n \n Lowercase mapping examples showing language code of locale, upper case, lower case, and description\n \n \n   Language Code of Locale\n   Upper Case\n   Lower Case\n   Description\n \n \n \n \n   tr (Turkish)\n   \\u0130\n   \\u0069\n   capital letter I with dot above -> small letter i\n \n \n   tr (Turkish)\n   \\u0049\n   \\u0131\n   capital letter I -> small letter dotless i \n \n \n   (all)\n   French Fries\n   french fries\n   lowercased all chars in String\n \n \n   (all)\n   \n       \n   \n   lowercased all chars in String"
                },
                {
                  "signature": "public String toLowerCase()",
                  "description": "Converts all of the characters in this String to lower\n case using the rules of the default locale. This is equivalent to calling\n toLowerCase(Locale.getDefault()).\n \n Note: This method is locale sensitive, and may produce unexpected\n results if used for strings that are intended to be interpreted locale\n independently.\n Examples are programming language identifiers, protocol keys, and HTML\n tags.\n For instance, \"TITLE\".toLowerCase() in a Turkish locale\n returns \"t\\u0131tle\", where '\\u0131' is the\n LATIN SMALL LETTER DOTLESS I character.\n To obtain correct results for locale insensitive strings, use\n toLowerCase(Locale.ROOT)."
                }
              ]
            },
            {
              "name": "toUpperCase",
              "overloads": [
                {
                  "signature": "public String toUpperCase(Locale locale)",
                  "description": "Converts all of the characters in this String to upper\n case using the rules of the given Locale. Case mapping is based\n on the Unicode Standard version specified by the Character\n class. Since case mappings are not always 1:1 char mappings, the resulting\n String may be a different length than the original String.\n \n Examples of locale-sensitive and 1:M case mappings are in the following table.\n\n \n Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\n \n \n   Language Code of Locale\n   Lower Case\n   Upper Case\n   Description\n \n \n \n \n   tr (Turkish)\n   \\u0069\n   \\u0130\n   small letter i -> capital letter I with dot above\n \n \n   tr (Turkish)\n   \\u0131\n   \\u0049\n   small letter dotless i -> capital letter I\n \n \n   (all)\n   \\u00df\n   \\u0053 \\u0053\n   small letter sharp s -> two letters: SS\n \n \n   (all)\n   Fahrvergngen\n   FAHRVERGNGEN"
                },
                {
                  "signature": "public String toUpperCase()",
                  "description": "Converts all of the characters in this String to upper\n case using the rules of the default locale. This method is equivalent to\n toUpperCase(Locale.getDefault()).\n \n Note: This method is locale sensitive, and may produce unexpected\n results if used for strings that are intended to be interpreted locale\n independently.\n Examples are programming language identifiers, protocol keys, and HTML\n tags.\n For instance, \"title\".toUpperCase() in a Turkish locale\n returns \"T\\u0130TLE\", where '\\u0130' is the\n LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n To obtain correct results for locale insensitive strings, use\n toUpperCase(Locale.ROOT)."
                }
              ]
            },
            {
              "name": "trim",
              "overloads": [
                {
                  "signature": "public String trim()",
                  "description": "Returns a string whose value is this string, with all leading\n and trailing space removed, where space is defined\n as any character whose codepoint is less than or equal to\n 'U+0020' (the space character).\n \n If this String object represents an empty character\n sequence, or the first and last characters of character sequence\n represented by this String object both have codes\n that are not space (as defined above), then a\n reference to this String object is returned.\n \n Otherwise, if all characters in this string are space (as\n defined above), then a  String object representing an\n empty string is returned.\n \n Otherwise, let k be the index of the first character in the\n string whose code is not a space (as defined above) and let\n m be the index of the last character in the string whose code\n is not a space (as defined above). A String\n object is returned, representing the substring of this string that\n begins with the character at index k and ends with the\n character at index m-that is, the result of\n this.substring(k, m + 1).\n \n This method may be used to trim space (as defined above) from\n the beginning and end of a string."
                }
              ]
            },
            {
              "name": "strip",
              "overloads": [
                {
                  "signature": "public String strip()",
                  "description": "Returns a string whose value is this string, with all leading\n and trailing white space\n removed.\n \n If this String object represents an empty string,\n or if all code points in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point that is not a white space\n up to and including the last code point that is not a\n white space.\n \n This method may be used to strip\n white space from\n the beginning and end of a string."
                }
              ]
            },
            {
              "name": "stripLeading",
              "overloads": [
                {
                  "signature": "public String stripLeading()",
                  "description": "Returns a string whose value is this string, with all leading\n white space removed.\n \n If this String object represents an empty string,\n or if all code points in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point that is not a white space\n up to and including the last code point of this string.\n \n This method may be used to trim\n white space from\n the beginning of a string."
                }
              ]
            },
            {
              "name": "stripTrailing",
              "overloads": [
                {
                  "signature": "public String stripTrailing()",
                  "description": "Returns a string whose value is this string, with all trailing\n white space removed.\n \n If this String object represents an empty string,\n or if all characters in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point of this string up to and including the last code point\n that is not a white space.\n \n This method may be used to trim\n white space from\n the end of a string."
                }
              ]
            },
            {
              "name": "isBlank",
              "overloads": [
                {
                  "signature": "public boolean isBlank()",
                  "description": "Returns true if the string is empty or contains only\n white space codepoints,\n otherwise false."
                }
              ]
            },
            {
              "name": "lines",
              "overloads": [
                {
                  "signature": "public Stream<String> lines()",
                  "description": "Returns a stream of lines extracted from this string,\n separated by line terminators.\n \n A line terminator is one of the following:\n a line feed character \"\\n\" (U+000A),\n a carriage return character \"\\r\" (U+000D),\n or a carriage return followed immediately by a line feed\n \"\\r\\n\" (U+000D U+000A).\n \n A line is either a sequence of zero or more characters\n followed by a line terminator, or it is a sequence of one or\n more characters followed by the end of the string. A\n line does not include the line terminator.\n \n The stream returned by this method contains the lines from\n this string in the order in which they occur."
                }
              ]
            },
            {
              "name": "indent",
              "overloads": [
                {
                  "signature": "public String indent(int n)",
                  "description": "Adjusts the indentation of each line of this string based on the value of\n n, and normalizes line termination characters.\n \n This string is conceptually separated into lines using\n lines(). Each line is then adjusted as described below\n and then suffixed with a line feed \"\\n\" (U+000A). The resulting\n lines are then concatenated and returned.\n \n If n > 0 then n spaces (U+0020) are inserted at the\n beginning of each line.\n \n If n < 0 then up to n\n white space characters are removed\n from the beginning of each line. If a given line does not contain\n sufficient white space then all leading\n white space characters are removed.\n Each white space character is treated as a single character. In\n particular, the tab character \"\\t\" (U+0009) is considered a\n single character; it is not expanded.\n \n If n == 0 then the line remains unchanged. However, line\n terminators are still normalized."
                }
              ]
            },
            {
              "name": "stripIndent",
              "overloads": [
                {
                  "signature": "public String stripIndent()",
                  "description": "Returns a string whose value is this string, with incidental\n white space removed from\n the beginning and end of every line.\n \n Incidental white space\n is often present in a text block to align the content with the opening\n delimiter. For example, in the following code, dots represent incidental\n white space:\n  String html = \"\"\"\n ..............<html>\n ..............    <body>\n ..............        <p>Hello, world</p>\n ..............    </body>\n ..............</html>\n ..............\"\"\";\n \n This method treats the incidental\n white space as indentation to be\n stripped, producing a string that preserves the relative indentation of\n the content. Using | to visualize the start of each line of the string:\n  |<html>\n |    <body>\n |        <p>Hello, world</p>\n |    </body>\n |</html>\n \n First, the individual lines of this string are extracted. A line\n is a sequence of zero or more characters followed by either a line\n terminator or the end of the string.\n If the string has at least one line terminator, the last line consists\n of the characters between the last terminator and the end of the string.\n Otherwise, if the string has no terminators, the last line is the start\n of the string to the end of the string, in other words, the entire\n string.\n A line does not include the line terminator.\n \n Then, the minimum indentation (min) is determined as follows:\n \n   For each non-blank line (as defined by isBlank()),\n   the leading white space\n   characters are counted.\n   \n   The leading white space\n   characters on the last line are also counted even if\n   blank.\n   \n \n The min value is the smallest of these counts.\n \n For each non-blank line, min leading\n white space characters are\n removed, and any trailing white\n space characters are removed. Blank lines\n are replaced with the empty string.\n\n \n Finally, the lines are joined into a new string, using the LF character\n \"\\n\" (U+000A) to separate lines."
                }
              ]
            },
            {
              "name": "translateEscapes",
              "overloads": [
                {
                  "signature": "public String translateEscapes()",
                  "description": "Returns a string whose value is this string, with escape sequences\n translated as if in a string literal.\n \n Escape sequences are translated as follows;\n \n   Translation\n   \n   \n     Escape\n     Name\n     Translation\n   \n   \n   \n   \n     \\b\n     backspace\n     U+0008\n   \n   \n     \\t\n     horizontal tab\n     U+0009\n   \n   \n     \\n\n     line feed\n     U+000A\n   \n   \n     \\f\n     form feed\n     U+000C\n   \n   \n     \\r\n     carriage return\n     U+000D\n   \n   \n     \\s\n     space\n     U+0020\n   \n   \n     \\\"\n     double quote\n     U+0022\n   \n   \n     \\'\n     single quote\n     U+0027\n   \n   \n     \\\\\n     backslash\n     U+005C\n   \n   \n     \\0 - \\377\n     octal escape\n     code point equivalents\n   \n   \n     \\<line-terminator>\n     continuation\n     discard"
                }
              ]
            },
            {
              "name": "transform",
              "overloads": [
                {
                  "signature": "public <R> R transform(Function<? super String,? extends R> f)",
                  "description": "This method allows the application of a function to this\n string. The function should expect a single String argument\n and produce an R result.\n \n Any exception thrown by f.apply() will be propagated to the\n caller."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "This object (which is already a string!) is itself returned."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream."
                }
              ]
            },
            {
              "name": "toCharArray",
              "overloads": [
                {
                  "signature": "public char[] toCharArray()",
                  "description": "Converts this string to a new character array."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public static String format(String format, Object... args)",
                  "description": "Returns a formatted string using the specified format string and\n arguments.\n\n  The locale always used is the one returned by Locale.getDefault(Locale.Category) with\n FORMAT category specified."
                },
                {
                  "signature": "public static String format(Locale l, String format, Object... args)",
                  "description": "Returns a formatted string using the specified locale, format string,\n and arguments."
                }
              ]
            },
            {
              "name": "formatted",
              "overloads": [
                {
                  "signature": "public String formatted(Object... args)",
                  "description": "Formats using this string as the format string, and the supplied\n arguments."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static String valueOf(Object obj)",
                  "description": "Returns the string representation of the Object argument."
                },
                {
                  "signature": "public static String valueOf(char[] data)",
                  "description": "Returns the string representation of the char array\n argument. The contents of the character array are copied; subsequent\n modification of the character array does not affect the returned\n string."
                },
                {
                  "signature": "public static String valueOf(char[] data, int offset, int count)",
                  "description": "Returns the string representation of a specific subarray of the\n char array argument.\n \n The offset argument is the index of the first\n character of the subarray. The count argument\n specifies the length of the subarray. The contents of the subarray\n are copied; subsequent modification of the character array does not\n affect the returned string."
                },
                {
                  "signature": "public static String valueOf(boolean b)",
                  "description": "Returns the string representation of the boolean argument."
                },
                {
                  "signature": "public static String valueOf(char c)",
                  "description": "Returns the string representation of the char\n argument."
                },
                {
                  "signature": "public static String valueOf(int i)",
                  "description": "Returns the string representation of the int argument.\n \n The representation is exactly the one returned by the\n Integer.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(long l)",
                  "description": "Returns the string representation of the long argument.\n \n The representation is exactly the one returned by the\n Long.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(float f)",
                  "description": "Returns the string representation of the float argument.\n \n The representation is exactly the one returned by the\n Float.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(double d)",
                  "description": "Returns the string representation of the double argument.\n \n The representation is exactly the one returned by the\n Double.toString method of one argument."
                }
              ]
            },
            {
              "name": "copyValueOf",
              "overloads": [
                {
                  "signature": "public static String copyValueOf(char[] data, int offset, int count)",
                  "description": "Equivalent to valueOf(char[], int, int)."
                },
                {
                  "signature": "public static String copyValueOf(char[] data)",
                  "description": "Equivalent to valueOf(char[])."
                }
              ]
            },
            {
              "name": "intern",
              "overloads": [
                {
                  "signature": "public String intern()",
                  "description": "Returns a canonical representation for the string object.\n \n A pool of strings, initially empty, is maintained privately by the\n class String.\n \n When the intern method is invoked, if the pool already contains a\n string equal to this String object as determined by\n the equals(Object) method, then the string from the pool is\n returned. Otherwise, this String object is added to the\n pool and a reference to this String object is returned.\n \n It follows that for any two strings s and t,\n s.intern() == t.intern() is true\n if and only if s.equals(t) is true.\n \n All literal strings and string-valued constant expressions are\n interned. String literals are defined in section 3.10.5 of the\n The Java Language Specification."
                }
              ]
            },
            {
              "name": "repeat",
              "overloads": [
                {
                  "signature": "public String repeat(int count)",
                  "description": "Returns a string whose value is the concatenation of this\n string repeated count times.\n \n If this string is empty or count is zero then the empty\n string is returned."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<String> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public String resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "StringBuffer",
          "methods": [
            {
              "name": "StringBuffer",
              "overloads": [
                {
                  "signature": "public StringBuffer()",
                  "description": "Constructs a string buffer with no characters in it and an\n initial capacity of 16 characters."
                },
                {
                  "signature": "public StringBuffer(int capacity)",
                  "description": "Constructs a string buffer with no characters in it and\n the specified initial capacity."
                },
                {
                  "signature": "public StringBuffer(String str)",
                  "description": "Constructs a string buffer initialized to the contents of the\n specified string. The initial capacity of the string buffer is\n 16 plus the length of the string argument."
                },
                {
                  "signature": "public StringBuffer(CharSequence seq)",
                  "description": "Constructs a string buffer that contains the same characters\n as the specified CharSequence. The initial capacity of\n the string buffer is 16 plus the length of the\n CharSequence argument."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(StringBuffer another)",
                  "description": "Compares two StringBuffer instances lexicographically. This method\n follows the same rules for lexicographical comparison as defined in the\n CharSequence.compare(this, another) method.\n\n \n For finer-grained, locale-sensitive String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length (character count)."
                }
              ]
            },
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public int capacity()",
                  "description": "Returns the current capacity. The capacity is the number of characters\n that can be stored (including already written characters), beyond which\n an allocation will occur."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minimumCapacity)",
                  "description": "Ensures that the capacity is at least equal to the specified minimum.\n If the current capacity is less than the argument, then a new internal\n array is allocated with greater capacity. The new capacity is the\n larger of:\n \n The minimumCapacity argument.\n Twice the old capacity, plus 2.\n \n If the minimumCapacity argument is nonpositive, this\n method takes no action and simply returns.\n Note that subsequent operations on this object can reduce the\n actual capacity below that requested here."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Attempts to reduce storage used for the character sequence.\n If the buffer is larger than necessary to hold its current sequence of\n characters, then it may be resized to become more space efficient.\n Calling this method may, but is not required to, affect the value\n returned by a subsequent call to the capacity() method."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int newLength)",
                  "description": "Sets the length of the character sequence.\n The sequence is changed to a new character sequence\n whose length is specified by the argument. For every nonnegative\n index k less than newLength, the character at\n index k in the new character sequence is the same as the\n character at index k in the old sequence if k is less\n than the length of the old character sequence; otherwise, it is the\n null character '\\u0000'.\n\n In other words, if the newLength argument is less than\n the current length, the length is changed to the specified length.\n \n If the newLength argument is greater than or equal\n to the current length, sufficient null characters\n ('\\u0000') are appended so that\n length becomes the newLength argument.\n \n The newLength argument must be greater than or equal\n to 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value in this sequence at the specified index.\n The first char value is at index 0, the next at index\n 1, and so on, as in array indexing.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n CharSequence.length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this sequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to CharSequence.length().\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this sequence. The text range begins at the specified\n beginIndex and extends to the char at\n index endIndex - 1. Thus the length (in\n chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n this sequence count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this sequence that is offset from the\n given index by codePointOffset code\n points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Characters are copied from this sequence into the\n destination character array dst. The first character to\n be copied is at index srcBegin; the last character to\n be copied is at index srcEnd-1. The total number of\n characters to be copied is srcEnd-srcBegin. The\n characters are copied into the subarray of dst starting\n at index dstBegin and ending at index:\n \n dstbegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "setCharAt",
              "overloads": [
                {
                  "signature": "public void setCharAt(int index, char ch)",
                  "description": "The character at the specified index is set to ch. This\n sequence is altered to represent a new character sequence that is\n identical to the old character sequence, except that it contains the\n character ch at position index.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringBuffer append(Object obj)",
                  "description": "Appends the string representation of the Object argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(Object),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(String str)",
                  "description": "Appends the specified string to this character sequence.\n \n The characters of the String argument are appended, in\n order, increasing the length of this sequence by the length of the\n argument. If str is null, then the four\n characters \"null\" are appended.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in the new character sequence is equal to the character\n at index k in the old character sequence, if k is less\n than n; otherwise, it is equal to the character at index\n k-n in the argument str."
                },
                {
                  "signature": "public StringBuffer append(StringBuffer sb)",
                  "description": "Appends the specified StringBuffer to this sequence.\n \n The characters of the StringBuffer argument are appended,\n in order, to the contents of this StringBuffer, increasing the\n length of this StringBuffer by the length of the argument.\n If sb is null, then the four characters\n \"null\" are appended to this StringBuffer.\n \n Let n be the length of the old character sequence, the one\n contained in the StringBuffer just prior to execution of the\n append method. Then the character at index k in\n the new character sequence is equal to the character at index k\n in the old character sequence, if k is less than n;\n otherwise, it is equal to the character at index k-n in the\n argument sb.\n \n This method synchronizes on this, the destination\n object, but does not synchronize on the source (sb)."
                },
                {
                  "signature": "public StringBuffer append(CharSequence s)",
                  "description": "Appends the specified CharSequence to this\n sequence.\n \n The characters of the CharSequence argument are appended,\n in order, increasing the length of this sequence by the length of the\n argument.\n\n The result of this method is exactly the same as if it were an\n invocation of this.append(s, 0, s.length());\n\n This method synchronizes on this, the destination\n object, but does not synchronize on the source (s).\n\n If s is null, then the four characters\n \"null\" are appended."
                },
                {
                  "signature": "public StringBuffer append(CharSequence s, int start, int end)",
                  "description": "Appends a subsequence of the specified CharSequence to this\n sequence.\n \n Characters of the argument s, starting at\n index start, are appended, in order, to the contents of\n this sequence up to the (exclusive) index end. The length\n of this sequence is increased by the value of end - start.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in this character sequence becomes equal to the\n character at index k in this sequence, if k is less than\n n; otherwise, it is equal to the character at index\n k+start-n in the argument s.\n \n If s is null, then this method appends\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuffer append(char[] str)",
                  "description": "Appends the string representation of the char array\n argument to this sequence.\n \n The characters of the array argument are appended, in order, to\n the contents of this sequence. The length of this sequence\n increases by the length of the argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(char[] str, int offset, int len)",
                  "description": "Appends the string representation of a subarray of the\n char array argument to this sequence.\n \n Characters of the char array str, starting at\n index offset, are appended, in order, to the contents\n of this sequence. The length of this sequence increases\n by the value of len.\n \n The overall effect is exactly as if the arguments were converted\n to a string by the method String.valueOf(char[],int,int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(boolean b)",
                  "description": "Appends the string representation of the boolean\n argument to the sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(char c)",
                  "description": "Appends the string representation of the char\n argument to this sequence.\n \n The argument is appended to the contents of this sequence.\n The length of this sequence increases by 1.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char),\n and the character in that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(int i)",
                  "description": "Appends the string representation of the int\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(long lng)",
                  "description": "Appends the string representation of the long\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(long),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(float f)",
                  "description": "Appends the string representation of the float\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(float),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(double d)",
                  "description": "Appends the string representation of the double\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(double),\n and the characters of that string were then\n appended to this character sequence."
                }
              ]
            },
            {
              "name": "appendCodePoint",
              "overloads": [
                {
                  "signature": "public StringBuffer appendCodePoint(int codePoint)",
                  "description": "Appends the string representation of the codePoint\n argument to this sequence.\n\n  The argument is appended to the contents of this sequence.\n The length of this sequence increases by\n Character.charCount(codePoint).\n\n  The overall effect is exactly as if the argument were\n converted to a char array by the method\n Character.toChars(int) and the character in that array\n were then appended to this character\n sequence."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public StringBuffer delete(int start, int end)",
                  "description": "Removes the characters in a substring of this sequence.\n The substring begins at the specified start and extends to\n the character at index end - 1 or to the end of the\n sequence if no such character exists. If\n start is equal to end, no changes are made."
                }
              ]
            },
            {
              "name": "deleteCharAt",
              "overloads": [
                {
                  "signature": "public StringBuffer deleteCharAt(int index)",
                  "description": "Removes the char at the specified position in this\n sequence. This sequence is shortened by one char.\n\n Note: If the character at the given index is a supplementary\n character, this method does not remove the entire character. If\n correct handling of supplementary characters is required,\n determine the number of chars to remove by calling\n Character.charCount(thisSequence.codePointAt(index)),\n where thisSequence is this sequence."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public StringBuffer replace(int start, int end, String str)",
                  "description": "Replaces the characters in a substring of this sequence\n with characters in the specified String. The substring\n begins at the specified start and extends to the character\n at index end - 1 or to the end of the\n sequence if no such character exists. First the\n characters in the substring are removed and then the specified\n String is inserted at start. (This\n sequence will be lengthened to accommodate the\n specified String if necessary.)"
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int start)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this character sequence. The\n substring begins at the specified index and extends to the end of\n this sequence."
                },
                {
                  "signature": "public String substring(int start, int end)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this sequence. The\n substring begins at the specified start and\n extends to the character at index end - 1."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int start, int end)",
                  "description": "Returns a new character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n \n sb.subSequence(begin, end)\n\n behaves in exactly the same way as the invocation\n\n \n sb.substring(begin, end)\n\n This method is provided so that this class can\n implement the CharSequence interface."
                }
              ]
            },
            {
              "name": "insert",
              "overloads": [
                {
                  "signature": "public StringBuffer insert(int index, char[] str, int offset, int len)",
                  "description": "Inserts the string representation of a subarray of the str\n array argument into this sequence. The subarray begins at the\n specified offset and extends len chars.\n The characters of the subarray are inserted into this sequence at\n the position indicated by index. The length of this\n sequence increases by len chars."
                },
                {
                  "signature": "public StringBuffer insert(int offset, Object obj)",
                  "description": "Inserts the string representation of the Object\n argument into this character sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(Object),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, String str)",
                  "description": "Inserts the string into this character sequence.\n \n The characters of the String argument are inserted, in\n order, into this sequence at the indicated offset, moving up any\n characters originally above that position and increasing the length\n of this sequence by the length of the argument. If\n str is null, then the four characters\n \"null\" are inserted into this sequence.\n \n The character at index k in the new character sequence is\n equal to:\n \n the character at index k in the old character sequence, if\n k is less than offset\n the character at index k-offset in the\n argument str, if k is not less than\n offset but is less than offset+str.length()\n the character at index k-str.length() in the\n old character sequence, if k is not less than\n offset+str.length()\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, char[] str)",
                  "description": "Inserts the string representation of the char array\n argument into this sequence.\n \n The characters of the array argument are inserted into the\n contents of this sequence at the position indicated by\n offset. The length of this sequence increases by\n the length of the argument.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int dstOffset, CharSequence s)",
                  "description": "Inserts the specified CharSequence into this sequence.\n \n The characters of the CharSequence argument are inserted,\n in order, into this sequence at the indicated offset, moving up\n any characters originally above that position and increasing the length\n of this sequence by the length of the argument s.\n \n The result of this method is exactly the same as if it were an\n invocation of this object's\n insert(dstOffset, s, 0, s.length())\n method.\n\n If s is null, then the four characters\n \"null\" are inserted into this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int dstOffset, CharSequence s, int start, int end)",
                  "description": "Inserts a subsequence of the specified CharSequence into\n this sequence.\n \n The subsequence of the argument s specified by\n start and end are inserted,\n in order, into this sequence at the specified destination offset, moving\n up any characters originally above that position. The length of this\n sequence is increased by end - start.\n \n The character at index k in this sequence becomes equal to:\n \n the character at index k in this sequence, if\n k is less than dstOffset\n the character at index k+start-dstOffset in\n the argument s, if k is greater than or equal to\n dstOffset but is less than dstOffset+end-start\n the character at index k-(end-start) in this\n sequence, if k is greater than or equal to\n dstOffset+end-start\n \n The dstOffset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence.\n The start argument must be nonnegative, and not greater than\n end.\n The end argument must be greater than or equal to\n start, and less than or equal to the length of s.\n\n If s is null, then this method inserts\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuffer insert(int offset, boolean b)",
                  "description": "Inserts the string representation of the boolean\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, char c)",
                  "description": "Inserts the string representation of the char\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char),\n and the character in that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, int i)",
                  "description": "Inserts the string representation of the second int\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(int),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, long l)",
                  "description": "Inserts the string representation of the long\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(long),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, float f)",
                  "description": "Inserts the string representation of the float\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(float),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, double d)",
                  "description": "Inserts the string representation of the double\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(double),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\" is\n considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public StringBuffer reverse()",
                  "description": "Causes this character sequence to be replaced by the reverse of\n the sequence. If there are any surrogate pairs included in the\n sequence, these are treated as single characters for the\n reverse operation. Thus, the order of the high-low surrogates\n is never reversed.\n\n Let n be the character length of this character sequence\n (not the length in char values) just prior to\n execution of the reverse method. Then the\n character at index k in the new character sequence is\n equal to the character at index n-k-1 in the old\n character sequence.\n\n Note that the reverse operation may result in producing\n surrogate pairs that were unpaired low-surrogates and\n high-surrogates before the operation. For example, reversing\n \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is\n a valid surrogate pair."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representing the data in this sequence.\n A new String object is allocated and initialized to\n contain the character sequence currently represented by this\n object. This String is then returned. Subsequent\n changes to this sequence do not affect the contents of the\n String."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            }
          ]
        },
        {
          "name": "StringBuilder",
          "methods": [
            {
              "name": "StringBuilder",
              "overloads": [
                {
                  "signature": "public StringBuilder()",
                  "description": "Constructs a string builder with no characters in it and an\n initial capacity of 16 characters."
                },
                {
                  "signature": "public StringBuilder(int capacity)",
                  "description": "Constructs a string builder with no characters in it and an\n initial capacity specified by the capacity argument."
                },
                {
                  "signature": "public StringBuilder(String str)",
                  "description": "Constructs a string builder initialized to the contents of the\n specified string. The initial capacity of the string builder is\n 16 plus the length of the string argument."
                },
                {
                  "signature": "public StringBuilder(CharSequence seq)",
                  "description": "Constructs a string builder that contains the same characters\n as the specified CharSequence. The initial capacity of\n the string builder is 16 plus the length of the\n CharSequence argument."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(StringBuilder another)",
                  "description": "Compares two StringBuilder instances lexicographically. This method\n follows the same rules for lexicographical comparison as defined in the\n CharSequence.compare(this, another) method.\n\n \n For finer-grained, locale-sensitive String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringBuilder append(Object obj)",
                  "description": "Appends the string representation of the Object argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(Object),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(String str)",
                  "description": "Appends the specified string to this character sequence.\n \n The characters of the String argument are appended, in\n order, increasing the length of this sequence by the length of the\n argument. If str is null, then the four\n characters \"null\" are appended.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in the new character sequence is equal to the character\n at index k in the old character sequence, if k is less\n than n; otherwise, it is equal to the character at index\n k-n in the argument str."
                },
                {
                  "signature": "public StringBuilder append(StringBuffer sb)",
                  "description": "Appends the specified StringBuffer to this sequence.\n \n The characters of the StringBuffer argument are appended,\n in order, to this sequence, increasing the\n length of this sequence by the length of the argument.\n If sb is null, then the four characters\n \"null\" are appended to this sequence.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at index\n k in the new character sequence is equal to the character at\n index k in the old character sequence, if k is less than\n n; otherwise, it is equal to the character at index k-n\n in the argument sb."
                },
                {
                  "signature": "public StringBuilder append(CharSequence s)",
                  "description": "Description copied from interface:Appendable"
                },
                {
                  "signature": "public StringBuilder append(CharSequence s, int start, int end)",
                  "description": "Appends a subsequence of the specified CharSequence to this\n sequence.\n \n Characters of the argument s, starting at\n index start, are appended, in order, to the contents of\n this sequence up to the (exclusive) index end. The length\n of this sequence is increased by the value of end - start.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in this character sequence becomes equal to the\n character at index k in this sequence, if k is less than\n n; otherwise, it is equal to the character at index\n k+start-n in the argument s.\n \n If s is null, then this method appends\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuilder append(char[] str)",
                  "description": "Appends the string representation of the char array\n argument to this sequence.\n \n The characters of the array argument are appended, in order, to\n the contents of this sequence. The length of this sequence\n increases by the length of the argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(char[] str, int offset, int len)",
                  "description": "Appends the string representation of a subarray of the\n char array argument to this sequence.\n \n Characters of the char array str, starting at\n index offset, are appended, in order, to the contents\n of this sequence. The length of this sequence increases\n by the value of len.\n \n The overall effect is exactly as if the arguments were converted\n to a string by the method String.valueOf(char[],int,int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(boolean b)",
                  "description": "Appends the string representation of the boolean\n argument to the sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(char c)",
                  "description": "Appends the string representation of the char\n argument to this sequence.\n \n The argument is appended to the contents of this sequence.\n The length of this sequence increases by 1.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char),\n and the character in that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(int i)",
                  "description": "Appends the string representation of the int\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(long lng)",
                  "description": "Appends the string representation of the long\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(long),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(float f)",
                  "description": "Appends the string representation of the float\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(float),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(double d)",
                  "description": "Appends the string representation of the double\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(double),\n and the characters of that string were then\n appended to this character sequence."
                }
              ]
            },
            {
              "name": "appendCodePoint",
              "overloads": [
                {
                  "signature": "public StringBuilder appendCodePoint(int codePoint)",
                  "description": "Appends the string representation of the codePoint\n argument to this sequence.\n\n  The argument is appended to the contents of this sequence.\n The length of this sequence increases by\n Character.charCount(codePoint).\n\n  The overall effect is exactly as if the argument were\n converted to a char array by the method\n Character.toChars(int) and the character in that array\n were then appended to this character\n sequence."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public StringBuilder delete(int start, int end)",
                  "description": "Removes the characters in a substring of this sequence.\n The substring begins at the specified start and extends to\n the character at index end - 1 or to the end of the\n sequence if no such character exists. If\n start is equal to end, no changes are made."
                }
              ]
            },
            {
              "name": "deleteCharAt",
              "overloads": [
                {
                  "signature": "public StringBuilder deleteCharAt(int index)",
                  "description": "Removes the char at the specified position in this\n sequence. This sequence is shortened by one char.\n\n Note: If the character at the given index is a supplementary\n character, this method does not remove the entire character. If\n correct handling of supplementary characters is required,\n determine the number of chars to remove by calling\n Character.charCount(thisSequence.codePointAt(index)),\n where thisSequence is this sequence."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public StringBuilder replace(int start, int end, String str)",
                  "description": "Replaces the characters in a substring of this sequence\n with characters in the specified String. The substring\n begins at the specified start and extends to the character\n at index end - 1 or to the end of the\n sequence if no such character exists. First the\n characters in the substring are removed and then the specified\n String is inserted at start. (This\n sequence will be lengthened to accommodate the\n specified String if necessary.)"
                }
              ]
            },
            {
              "name": "insert",
              "overloads": [
                {
                  "signature": "public StringBuilder insert(int index, char[] str, int offset, int len)",
                  "description": "Inserts the string representation of a subarray of the str\n array argument into this sequence. The subarray begins at the\n specified offset and extends len chars.\n The characters of the subarray are inserted into this sequence at\n the position indicated by index. The length of this\n sequence increases by len chars."
                },
                {
                  "signature": "public StringBuilder insert(int offset, Object obj)",
                  "description": "Inserts the string representation of the Object\n argument into this character sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(Object),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, String str)",
                  "description": "Inserts the string into this character sequence.\n \n The characters of the String argument are inserted, in\n order, into this sequence at the indicated offset, moving up any\n characters originally above that position and increasing the length\n of this sequence by the length of the argument. If\n str is null, then the four characters\n \"null\" are inserted into this sequence.\n \n The character at index k in the new character sequence is\n equal to:\n \n the character at index k in the old character sequence, if\n k is less than offset\n the character at index k-offset in the\n argument str, if k is not less than\n offset but is less than offset+str.length()\n the character at index k-str.length() in the\n old character sequence, if k is not less than\n offset+str.length()\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, char[] str)",
                  "description": "Inserts the string representation of the char array\n argument into this sequence.\n \n The characters of the array argument are inserted into the\n contents of this sequence at the position indicated by\n offset. The length of this sequence increases by\n the length of the argument.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int dstOffset, CharSequence s)",
                  "description": "Inserts the specified CharSequence into this sequence.\n \n The characters of the CharSequence argument are inserted,\n in order, into this sequence at the indicated offset, moving up\n any characters originally above that position and increasing the length\n of this sequence by the length of the argument s.\n \n The result of this method is exactly the same as if it were an\n invocation of this object's\n insert(dstOffset, s, 0, s.length())\n method.\n\n If s is null, then the four characters\n \"null\" are inserted into this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int dstOffset, CharSequence s, int start, int end)",
                  "description": "Inserts a subsequence of the specified CharSequence into\n this sequence.\n \n The subsequence of the argument s specified by\n start and end are inserted,\n in order, into this sequence at the specified destination offset, moving\n up any characters originally above that position. The length of this\n sequence is increased by end - start.\n \n The character at index k in this sequence becomes equal to:\n \n the character at index k in this sequence, if\n k is less than dstOffset\n the character at index k+start-dstOffset in\n the argument s, if k is greater than or equal to\n dstOffset but is less than dstOffset+end-start\n the character at index k-(end-start) in this\n sequence, if k is greater than or equal to\n dstOffset+end-start\n \n The dstOffset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence.\n The start argument must be nonnegative, and not greater than\n end.\n The end argument must be greater than or equal to\n start, and less than or equal to the length of s.\n\n If s is null, then this method inserts\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuilder insert(int offset, boolean b)",
                  "description": "Inserts the string representation of the boolean\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, char c)",
                  "description": "Inserts the string representation of the char\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char),\n and the character in that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, int i)",
                  "description": "Inserts the string representation of the second int\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(int),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, long l)",
                  "description": "Inserts the string representation of the long\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(long),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, float f)",
                  "description": "Inserts the string representation of the float\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(float),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, double d)",
                  "description": "Inserts the string representation of the double\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(double),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\" is\n considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public StringBuilder reverse()",
                  "description": "Causes this character sequence to be replaced by the reverse of\n the sequence. If there are any surrogate pairs included in the\n sequence, these are treated as single characters for the\n reverse operation. Thus, the order of the high-low surrogates\n is never reversed.\n\n Let n be the character length of this character sequence\n (not the length in char values) just prior to\n execution of the reverse method. Then the\n character at index k in the new character sequence is\n equal to the character at index n-k-1 in the old\n character sequence.\n\n Note that the reverse operation may result in producing\n surrogate pairs that were unpaired low-surrogates and\n high-surrogates before the operation. For example, reversing\n \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is\n a valid surrogate pair."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representing the data in this sequence.\n A new String object is allocated and initialized to\n contain the character sequence currently represented by this\n object. This String is then returned. Subsequent\n changes to this sequence do not affect the contents of the\n String."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length (character count)."
                }
              ]
            },
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public int capacity()",
                  "description": "Returns the current capacity. The capacity is the number of characters\n that can be stored (including already written characters), beyond which\n an allocation will occur."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minimumCapacity)",
                  "description": "Ensures that the capacity is at least equal to the specified minimum.\n If the current capacity is less than the argument, then a new internal\n array is allocated with greater capacity. The new capacity is the\n larger of:\n \n The minimumCapacity argument.\n Twice the old capacity, plus 2.\n \n If the minimumCapacity argument is nonpositive, this\n method takes no action and simply returns.\n Note that subsequent operations on this object can reduce the\n actual capacity below that requested here."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Attempts to reduce storage used for the character sequence.\n If the buffer is larger than necessary to hold its current sequence of\n characters, then it may be resized to become more space efficient.\n Calling this method may, but is not required to, affect the value\n returned by a subsequent call to the capacity() method."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int newLength)",
                  "description": "Sets the length of the character sequence.\n The sequence is changed to a new character sequence\n whose length is specified by the argument. For every nonnegative\n index k less than newLength, the character at\n index k in the new character sequence is the same as the\n character at index k in the old sequence if k is less\n than the length of the old character sequence; otherwise, it is the\n null character '\\u0000'.\n\n In other words, if the newLength argument is less than\n the current length, the length is changed to the specified length.\n \n If the newLength argument is greater than or equal\n to the current length, sufficient null characters\n ('\\u0000') are appended so that\n length becomes the newLength argument.\n \n The newLength argument must be greater than or equal\n to 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value in this sequence at the specified index.\n The first char value is at index 0, the next at index\n 1, and so on, as in array indexing.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n CharSequence.length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this sequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to CharSequence.length().\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this sequence. The text range begins at the specified\n beginIndex and extends to the char at\n index endIndex - 1. Thus the length (in\n chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n this sequence count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this sequence that is offset from the\n given index by codePointOffset code\n points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Characters are copied from this sequence into the\n destination character array dst. The first character to\n be copied is at index srcBegin; the last character to\n be copied is at index srcEnd-1. The total number of\n characters to be copied is srcEnd-srcBegin. The\n characters are copied into the subarray of dst starting\n at index dstBegin and ending at index:\n \n dstbegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "setCharAt",
              "overloads": [
                {
                  "signature": "public void setCharAt(int index, char ch)",
                  "description": "The character at the specified index is set to ch. This\n sequence is altered to represent a new character sequence that is\n identical to the old character sequence, except that it contains the\n character ch at position index.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence."
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int start)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this character sequence. The\n substring begins at the specified index and extends to the end of\n this sequence."
                },
                {
                  "signature": "public String substring(int start, int end)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this sequence. The\n substring begins at the specified start and\n extends to the character at index end - 1."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int start, int end)",
                  "description": "Returns a new character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n \n sb.subSequence(begin, end)\n\n behaves in exactly the same way as the invocation\n\n \n sb.substring(begin, end)\n\n This method is provided so that this class can\n implement the CharSequence interface."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            }
          ]
        },
        {
          "name": "StringIndexOutOfBoundsException",
          "methods": [
            {
              "name": "StringIndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public StringIndexOutOfBoundsException()",
                  "description": "Constructs a StringIndexOutOfBoundsException with no detail\n message."
                },
                {
                  "signature": "public StringIndexOutOfBoundsException(String s)",
                  "description": "Constructs a StringIndexOutOfBoundsException with the specified\n detail message."
                },
                {
                  "signature": "public StringIndexOutOfBoundsException(int index)",
                  "description": "Constructs a new StringIndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "System",
          "methods": [
            {
              "name": "setIn",
              "overloads": [
                {
                  "signature": "public static void setIn(InputStream in)",
                  "description": "Reassigns the \"standard\" input stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" input stream."
                }
              ]
            },
            {
              "name": "setOut",
              "overloads": [
                {
                  "signature": "public static void setOut(PrintStream out)",
                  "description": "Reassigns the \"standard\" output stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" output stream."
                }
              ]
            },
            {
              "name": "setErr",
              "overloads": [
                {
                  "signature": "public static void setErr(PrintStream err)",
                  "description": "Reassigns the \"standard\" error output stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" error output stream."
                }
              ]
            },
            {
              "name": "console",
              "overloads": [
                {
                  "signature": "public static Console console()",
                  "description": "Returns the unique Console object associated\n with the current Java virtual machine, if any."
                }
              ]
            },
            {
              "name": "inheritedChannel",
              "overloads": [
                {
                  "signature": "public static Channel inheritedChannel() throws IOException",
                  "description": "Returns the channel inherited from the entity that created this\n Java virtual machine.\n\n This method returns the channel obtained by invoking the\n inheritedChannel method of the system-wide default\n SelectorProvider object.\n\n  In addition to the network-oriented channels described in\n inheritedChannel, this method may return other kinds of\n channels in the future."
                }
              ]
            },
            {
              "name": "setSecurityManager",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public static void setSecurityManager(SecurityManager sm)",
                  "description": "Sets the system-wide security manager.\n\n If there is a security manager already installed, this method first\n calls the security manager's checkPermission method\n with a RuntimePermission(\"setSecurityManager\")\n permission to ensure it's ok to replace the existing\n security manager.\n This may result in throwing a SecurityException.\n\n  Otherwise, the argument is established as the current\n security manager. If the argument is null and no\n security manager has been established, then no action is taken and\n the method simply returns.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSecurityManager",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public static SecurityManager getSecurityManager()",
                  "description": "Gets the system-wide security manager.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "currentTimeMillis",
              "overloads": [
                {
                  "signature": "public static long currentTimeMillis()",
                  "description": "Returns the current time in milliseconds.  Note that\n while the unit of time of the return value is a millisecond,\n the granularity of the value depends on the underlying\n operating system and may be larger.  For example, many\n operating systems measure time in units of tens of\n milliseconds.\n\n  See the description of the class Date for\n a discussion of slight discrepancies that may arise between\n \"computer time\" and coordinated universal time (UTC)."
                }
              ]
            },
            {
              "name": "nanoTime",
              "overloads": [
                {
                  "signature": "public static long nanoTime()",
                  "description": "Returns the current value of the running Java Virtual Machine's\n high-resolution time source, in nanoseconds.\n\n This method can only be used to measure elapsed time and is\n not related to any other notion of system or wall-clock time.\n The value returned represents nanoseconds since some fixed but\n arbitrary origin time (perhaps in the future, so values\n may be negative).  The same origin is used by all invocations of\n this method in an instance of a Java virtual machine; other\n virtual machine instances are likely to use a different origin.\n\n This method provides nanosecond precision, but not necessarily\n nanosecond resolution (that is, how frequently the value changes)\n - no guarantees are made except that the resolution is at least as\n good as that of currentTimeMillis().\n\n Differences in successive calls that span greater than\n approximately 292 years (263 nanoseconds) will not\n correctly compute elapsed time due to numerical overflow.\n\n The values returned by this method become meaningful only when\n the difference between two such values, obtained within the same\n instance of a Java virtual machine, is computed.\n\n For example, to measure how long some code takes to execute:\n  \n long startTime = System.nanoTime();\n // ... the code being measured ...\n long elapsedNanos = System.nanoTime() - startTime;\n\n To compare elapsed time against a timeout, use  \n if (System.nanoTime() - startTime >= timeoutNanos) ...\n instead of  \n if (System.nanoTime() >= startTime + timeoutNanos) ...\n because of the possibility of numerical overflow."
                }
              ]
            },
            {
              "name": "arraycopy",
              "overloads": [
                {
                  "signature": "public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)",
                  "description": "Copies an array from the specified source array, beginning at the\n specified position, to the specified position of the destination array.\n A subsequence of array components are copied from the source\n array referenced by src to the destination array\n referenced by dest. The number of components copied is\n equal to the length argument. The components at\n positions srcPos through\n srcPos+length-1 in the source array are copied into\n positions destPos through\n destPos+length-1, respectively, of the destination\n array.\n \n If the src and dest arguments refer to the\n same array object, then the copying is performed as if the\n components at positions srcPos through\n srcPos+length-1 were first copied to a temporary\n array with length components and then the contents of\n the temporary array were copied into positions\n destPos through destPos+length-1 of the\n destination array.\n \n If dest is null, then a\n NullPointerException is thrown.\n \n If src is null, then a\n NullPointerException is thrown and the destination\n array is not modified.\n \n Otherwise, if any of the following is true, an\n ArrayStoreException is thrown and the destination is\n not modified:\n \n The src argument refers to an object that is not an\n     array.\n The dest argument refers to an object that is not an\n     array.\n The src argument and dest argument refer\n     to arrays whose component types are different primitive types.\n The src argument refers to an array with a primitive\n    component type and the dest argument refers to an array\n     with a reference component type.\n The src argument refers to an array with a reference\n    component type and the dest argument refers to an array\n     with a primitive component type.\n \n \n Otherwise, if any of the following is true, an\n IndexOutOfBoundsException is\n thrown and the destination is not modified:\n \n The srcPos argument is negative.\n The destPos argument is negative.\n The length argument is negative.\n srcPos+length is greater than\n     src.length, the length of the source array.\n destPos+length is greater than\n     dest.length, the length of the destination array.\n \n \n Otherwise, if any actual component of the source array from\n position srcPos through\n srcPos+length-1 cannot be converted to the component\n type of the destination array by assignment conversion, an\n ArrayStoreException is thrown. In this case, let\n k be the smallest nonnegative integer less than\n length such that src[srcPos+k]\n cannot be converted to the component type of the destination\n array; when the exception is thrown, source array components from\n positions srcPos through\n srcPos+k-1\n will already have been copied to destination array positions\n destPos through\n destPos+k-1 and no other\n positions of the destination array will have been modified.\n (Because of the restrictions already itemized, this\n paragraph effectively applies only to the situation where both\n arrays have component types that are reference types.)"
                }
              ]
            },
            {
              "name": "identityHashCode",
              "overloads": [
                {
                  "signature": "public static int identityHashCode(Object x)",
                  "description": "Returns the same hash code for the given object as\n would be returned by the default method hashCode(),\n whether or not the given object's class overrides\n hashCode().\n The hash code for the null reference is zero."
                }
              ]
            },
            {
              "name": "getProperties",
              "overloads": [
                {
                  "signature": "public static Properties getProperties()",
                  "description": "Determines the current system properties.\n\n First, if there is a security manager, its\n checkPropertiesAccess method is called with no\n arguments. This may result in a security exception.\n \n The current set of system properties for use by the\n getProperty(String) method is returned as a\n Properties object. If there is no current set of\n system properties, a set of system properties is first created and\n initialized. This set of system properties includes a value\n for each of the following keys unless the description of the associated\n value indicates that the value is optional.\n \n Shows property keys and associated values\n \n Key\n     Description of Associated Value\n \n \n java.version\n     Java Runtime Environment version, which may be interpreted\n     as a Runtime.Version\n java.version.date\n     Java Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     format, which may be interpreted as a LocalDate\n java.vendor\n     Java Runtime Environment vendor\n java.vendor.url\n     Java vendor URL\n java.vendor.version\n     Java vendor version (optional) \n java.home\n     Java installation directory\n java.vm.specification.version\n     Java Virtual Machine specification version, whose value is the\n     feature element of the\n     runtime version\n java.vm.specification.vendor\n     Java Virtual Machine specification vendor\n java.vm.specification.name\n     Java Virtual Machine specification name\n java.vm.version\n     Java Virtual Machine implementation version which may be\n     interpreted as a Runtime.Version\n java.vm.vendor\n     Java Virtual Machine implementation vendor\n java.vm.name\n     Java Virtual Machine implementation name\n java.specification.version\n     Java Runtime Environment specification version, whose value is\n     the feature element of the\n     runtime version\n java.specification.maintenance.version\n     Java Runtime Environment specification maintenance version,\n     may be interpreted as a positive integer (optional, see below)\n java.specification.vendor\n     Java Runtime Environment specification  vendor\n java.specification.name\n     Java Runtime Environment specification  name\n java.class.version\n     Java class format version number\n java.class.path\n     Java class path  (refer to\n        ClassLoader.getSystemClassLoader() for details)\n java.library.path\n     List of paths to search when loading libraries\n java.io.tmpdir\n     Default temp file path\n java.compiler\n     Name of JIT compiler to use\n os.name\n     Operating system name\n os.arch\n     Operating system architecture\n os.version\n     Operating system version\n file.separator\n     File separator (\"/\" on UNIX)\n path.separator\n     Path separator (\":\" on UNIX)\n line.separator\n     Line separator (\"\\n\" on UNIX)\n user.name\n     User's account name\n user.home\n     User's home directory\n user.dir\n     User's current working directory\n native.encoding\n     Character encoding name derived from the host environment and/or\n     the user's settings. Setting this system property has no effect.\n \n \n \n The java.specification.maintenance.version property is\n defined if the specification implemented by this runtime at the\n time of its construction had undergone a maintenance\n release. When defined, its value identifies that\n maintenance release. To indicate the first maintenance release\n this property will have the value \"1\", to indicate the\n second maintenance release this property will have the value\n \"2\", and so on.\n \n Multiple paths in a system property value are separated by the path\n separator character of the platform.\n \n Note that even if the security manager does not permit the\n getProperties operation, it may choose to permit the\n getProperty(String) operation."
                }
              ]
            },
            {
              "name": "lineSeparator",
              "overloads": [
                {
                  "signature": "public static String lineSeparator()",
                  "description": "Returns the system-dependent line separator string.  It always\n returns the same value - the initial value of the system property line.separator.\n\n On UNIX systems, it returns \"\\n\"; on Microsoft\n Windows systems it returns \"\\r\\n\"."
                }
              ]
            },
            {
              "name": "setProperties",
              "overloads": [
                {
                  "signature": "public static void setProperties(Properties props)",
                  "description": "Sets the system properties to the Properties argument.\n\n First, if there is a security manager, its\n checkPropertiesAccess method is called with no\n arguments. This may result in a security exception.\n \n The argument becomes the current set of system properties for use\n by the getProperty(String) method. If the argument is\n null, then the current set of system properties is\n forgotten."
                }
              ]
            },
            {
              "name": "getProperty",
              "overloads": [
                {
                  "signature": "public static String getProperty(String key)",
                  "description": "Gets the system property indicated by the specified key.\n\n First, if there is a security manager, its\n checkPropertyAccess method is called with the key as\n its argument. This may result in a SecurityException.\n \n If there is no current set of system properties, a set of system\n properties is first created and initialized in the same manner as\n for the getProperties method."
                },
                {
                  "signature": "public static String getProperty(String key, String def)",
                  "description": "Gets the system property indicated by the specified key.\n\n First, if there is a security manager, its\n checkPropertyAccess method is called with the\n key as its argument.\n \n If there is no current set of system properties, a set of system\n properties is first created and initialized in the same manner as\n for the getProperties method."
                }
              ]
            },
            {
              "name": "setProperty",
              "overloads": [
                {
                  "signature": "public static String setProperty(String key, String value)",
                  "description": "Sets the system property indicated by the specified key.\n\n First, if a security manager exists, its\n SecurityManager.checkPermission method\n is called with a PropertyPermission(key, \"write\")\n permission. This may result in a SecurityException being thrown.\n If no exception is thrown, the specified property is set to the given\n value."
                }
              ]
            },
            {
              "name": "clearProperty",
              "overloads": [
                {
                  "signature": "public static String clearProperty(String key)",
                  "description": "Removes the system property indicated by the specified key.\n\n First, if a security manager exists, its\n SecurityManager.checkPermission method\n is called with a PropertyPermission(key, \"write\")\n permission. This may result in a SecurityException being thrown.\n If no exception is thrown, the specified property is removed."
                }
              ]
            },
            {
              "name": "getenv",
              "overloads": [
                {
                  "signature": "public static String getenv(String name)",
                  "description": "Gets the value of the specified environment variable. An\n environment variable is a system-dependent external named\n value.\n\n If a security manager exists, its\n checkPermission\n method is called with a\n RuntimePermission(\"getenv.\"+name)\n permission.  This may result in a SecurityException\n being thrown.  If no exception is thrown the value of the\n variable name is returned.\n\n System\n properties and environment variables are both\n conceptually mappings between names and values.  Both\n mechanisms can be used to pass user-defined information to a\n Java process.  Environment variables have a more global effect,\n because they are visible to all descendants of the process\n which defines them, not just the immediate Java subprocess.\n They can have subtly different semantics, such as case\n insensitivity, on different operating systems.  For these\n reasons, environment variables are more likely to have\n unintended side effects.  It is best to use system properties\n where possible.  Environment variables should be used when a\n global effect is desired, or when an external system interface\n requires an environment variable (such as PATH).\n\n On UNIX systems the alphabetic case of name is\n typically significant, while on Microsoft Windows systems it is\n typically not.  For example, the expression\n System.getenv(\"FOO\").equals(System.getenv(\"foo\"))\n is likely to be true on Microsoft Windows."
                },
                {
                  "signature": "public static Map<String,String> getenv()",
                  "description": "Returns an unmodifiable string map view of the current system environment.\n The environment is a system-dependent mapping from names to\n values which is passed from parent to child processes.\n\n If the system does not support environment variables, an\n empty map is returned.\n\n The returned map will never contain null keys or values.\n Attempting to query the presence of a null key or value will\n throw a NullPointerException.  Attempting to query\n the presence of a key or value which is not of type\n String will throw a ClassCastException.\n\n The returned map and its collection views may not obey the\n general contract of the Object.equals(java.lang.Object) and\n Object.hashCode() methods.\n\n The returned map is typically case-sensitive on all platforms.\n\n If a security manager exists, its\n checkPermission\n method is called with a\n RuntimePermission(\"getenv.*\") permission.\n This may result in a SecurityException being thrown.\n\n When passing information to a Java subprocess,\n system properties\n are generally preferred over environment variables."
                }
              ]
            },
            {
              "name": "getLogger",
              "overloads": [
                {
                  "signature": "public static System.Logger getLogger(String name)",
                  "description": "Returns an instance of Logger for the caller's\n use."
                },
                {
                  "signature": "public static System.Logger getLogger(String name, ResourceBundle bundle)",
                  "description": "Returns a localizable instance of Logger for the caller's use.\n The returned logger will use the provided resource bundle for message\n localization."
                }
              ]
            },
            {
              "name": "exit",
              "overloads": [
                {
                  "signature": "public static void exit(int status)",
                  "description": "Terminates the currently running Java Virtual Machine. The\n argument serves as a status code; by convention, a nonzero status\n code indicates abnormal termination.\n \n This method calls the exit method in class\n Runtime. This method never returns normally.\n \n The call System.exit(n) is effectively equivalent to\n the call:\n  Runtime.getRuntime().exit(n)"
                }
              ]
            },
            {
              "name": "gc",
              "overloads": [
                {
                  "signature": "public static void gc()",
                  "description": "Runs the garbage collector in the Java Virtual Machine.\n \n Calling the gc method suggests that the Java Virtual Machine\n expend effort toward recycling unused objects in order to\n make the memory they currently occupy available for reuse\n by the Java Virtual Machine.\n When control returns from the method call, the Java Virtual Machine\n has made a best effort to reclaim space from all unused objects.\n There is no guarantee that this effort will recycle any particular\n number of unused objects, reclaim any particular amount of space, or\n complete at any particular time, if at all, before the method returns or ever.\n There is also no guarantee that this effort will determine\n the change of reachability in any particular number of objects,\n or that any particular number of Reference\n objects will be cleared and enqueued.\n\n \n The call System.gc() is effectively equivalent to the\n call:\n  Runtime.getRuntime().gc()"
                }
              ]
            },
            {
              "name": "runFinalization",
              "overloads": [
                {
                  "signature": "public static void runFinalization()",
                  "description": "Runs the finalization methods of any objects pending finalization.\n\n Calling this method suggests that the Java Virtual Machine expend\n effort toward running the finalize methods of objects\n that have been found to be discarded but whose finalize\n methods have not yet been run. When control returns from the\n method call, the Java Virtual Machine has made a best effort to\n complete all outstanding finalizations.\n \n The call System.runFinalization() is effectively\n equivalent to the call:\n  Runtime.getRuntime().runFinalization()"
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public static void load(String filename)",
                  "description": "Loads the native library specified by the filename argument.  The filename\n argument must be an absolute path name.\n\n If the filename argument, when stripped of any platform-specific library\n prefix, path, and file extension, indicates a library whose name is,\n for example, L, and a native library called L is statically linked\n with the VM, then the JNI_OnLoad_L function exported by the library\n is invoked rather than attempting to load a dynamic library.\n A filename matching the argument does not have to exist in the\n file system.\n See the  JNI Specification\n for more details.\n\n Otherwise, the filename argument is mapped to a native library image in\n an implementation-dependent manner.\n\n \n The call System.load(name) is effectively equivalent\n to the call:\n  Runtime.getRuntime().load(name)"
                }
              ]
            },
            {
              "name": "loadLibrary",
              "overloads": [
                {
                  "signature": "public static void loadLibrary(String libname)",
                  "description": "Loads the native library specified by the libname\n argument.  The libname argument must not contain any platform\n specific prefix, file extension or path. If a native library\n called libname is statically linked with the VM, then the\n JNI_OnLoad_libname function exported by the library is invoked.\n See the  JNI Specification\n for more details.\n\n Otherwise, the libname argument is loaded from a system library\n location and mapped to a native library image in an\n implementation-dependent manner.\n \n The call System.loadLibrary(name) is effectively\n equivalent to the call\n  Runtime.getRuntime().loadLibrary(name)"
                }
              ]
            },
            {
              "name": "mapLibraryName",
              "overloads": [
                {
                  "signature": "public static String mapLibraryName(String libname)",
                  "description": "Maps a library name into a platform-specific string representing\n a native library."
                }
              ]
            }
          ]
        },
        {
          "name": "System.Logger",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "String getName()",
                  "description": "Returns the name of this logger."
                }
              ]
            },
            {
              "name": "isLoggable",
              "overloads": [
                {
                  "signature": "boolean isLoggable(System.Logger.Level level)",
                  "description": "Checks if a message of the given level would be logged by\n this logger."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "default void log(System.Logger.Level level, String msg)",
                  "description": "Logs a message."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Supplier<String> msgSupplier)",
                  "description": "Logs a lazily supplied message.\n\n If the logger is currently enabled for the given log message level\n then a message is logged that is the result produced by the\n given supplier function.  Otherwise, the supplier is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Object obj)",
                  "description": "Logs a message produced from the given object.\n\n If the logger is currently enabled for the given log message level then\n a message is logged that, by default, is the result produced from\n calling  toString on the given object.\n Otherwise, the object is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, String msg, Throwable thrown)",
                  "description": "Logs a message associated with a given throwable."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Supplier<String> msgSupplier, Throwable thrown)",
                  "description": "Logs a lazily supplied message associated with a given throwable.\n\n If the logger is currently enabled for the given log message level\n then a message is logged that is the result produced by the\n given supplier function.  Otherwise, the supplier is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, String format, Object... params)",
                  "description": "Logs a message with an optional list of parameters."
                },
                {
                  "signature": "void log(System.Logger.Level level, ResourceBundle bundle, String msg, Throwable thrown)",
                  "description": "Logs a localized message associated with a given throwable.\n\n If the given resource bundle is non-null,  the msg\n string is localized using the given resource bundle.\n Otherwise the msg string is not localized."
                },
                {
                  "signature": "void log(System.Logger.Level level, ResourceBundle bundle, String format, Object... params)",
                  "description": "Logs a message with resource bundle and an optional list of\n parameters.\n\n If the given resource bundle is non-null,  the format\n string is localized using the given resource bundle.\n Otherwise the format string is not localized."
                }
              ]
            }
          ]
        },
        {
          "name": "System.LoggerFinder",
          "methods": [
            {
              "name": "LoggerFinder",
              "overloads": [
                {
                  "signature": "protected LoggerFinder()",
                  "description": "Creates a new instance of LoggerFinder."
                }
              ]
            },
            {
              "name": "getLogger",
              "overloads": [
                {
                  "signature": "public abstract System.Logger getLogger(String name, Module module)",
                  "description": "Returns an instance of Logger\n for the given module."
                }
              ]
            },
            {
              "name": "getLocalizedLogger",
              "overloads": [
                {
                  "signature": "public System.Logger getLocalizedLogger(String name, ResourceBundle bundle, Module module)",
                  "description": "Returns a localizable instance of Logger\n for the given module.\n The returned logger will use the provided resource bundle for\n message localization."
                }
              ]
            },
            {
              "name": "getLoggerFinder",
              "overloads": [
                {
                  "signature": "public static System.LoggerFinder getLoggerFinder()",
                  "description": "Returns the LoggerFinder instance. There is one\n single system-wide LoggerFinder instance in\n the Java Runtime.  See the class specification of how the\n LoggerFinder implementation is located and\n loaded."
                }
              ]
            }
          ]
        },
        {
          "name": "Thread",
          "methods": [
            {
              "name": "Thread",
              "overloads": [
                {
                  "signature": "public Thread()",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, null, gname), where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(Runnable target)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, target, gname), where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (group, target, gname) ,where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, null, name)."
                },
                {
                  "signature": "public Thread(ThreadGroup group, String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (group, null, name)."
                },
                {
                  "signature": "public Thread(Runnable target, String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, target, name)."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n and belongs to the thread group referred to by group.\n\n If there is a security manager, its\n checkAccess\n method is invoked with the ThreadGroup as its argument.\n\n In addition, its checkPermission method is invoked with\n the RuntimePermission(\"enableContextClassLoaderOverride\")\n permission when invoked directly or indirectly by the constructor\n of a subclass which overrides the getContextClassLoader\n or setContextClassLoader methods.\n\n The priority of the newly created thread is set equal to the\n priority of the thread creating it, that is, the currently running\n thread. The method setPriority may be\n used to change the priority to a new value.\n\n The newly created thread is initially marked as being a daemon\n thread if and only if the thread creating it is currently marked\n as a daemon thread. The method setDaemon\n may be used to change whether or not a thread is a daemon."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name, long stackSize)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n and belongs to the thread group referred to by group, and has\n the specified stack size.\n\n This constructor is identical to Thread(ThreadGroup,Runnable,String) with the exception of the fact\n that it allows the thread stack size to be specified.  The stack size\n is the approximate number of bytes of address space that the virtual\n machine is to allocate for this thread's stack.  The effect of the\n stackSize parameter, if any, is highly platform dependent.\n\n On some platforms, specifying a higher value for the\n stackSize parameter may allow a thread to achieve greater\n recursion depth before throwing a StackOverflowError.\n Similarly, specifying a lower value may allow a greater number of\n threads to exist concurrently without throwing an OutOfMemoryError (or other internal error).  The details of\n the relationship between the value of the stackSize parameter\n and the maximum recursion depth and concurrency level are\n platform-dependent.  On some platforms, the value of the\n stackSize parameter may have no effect whatsoever.\n\n The virtual machine is free to treat the stackSize\n parameter as a suggestion.  If the specified value is unreasonably low\n for the platform, the virtual machine may instead use some\n platform-specific minimum value; if the specified value is unreasonably\n high, the virtual machine may instead use some platform-specific\n maximum.  Likewise, the virtual machine is free to round the specified\n value up or down as it sees fit (or to ignore it completely).\n\n Specifying a value of zero for the stackSize parameter will\n cause this constructor to behave exactly like the\n Thread(ThreadGroup, Runnable, String) constructor.\n\n Due to the platform-dependent nature of the behavior of this\n constructor, extreme care should be exercised in its use.\n The thread stack size necessary to perform a given computation will\n likely vary from one JRE implementation to another.  In light of this\n variation, careful tuning of the stack size parameter may be required,\n and the tuning may need to be repeated for each JRE implementation on\n which an application is to run.\n\n Implementation note: Java platform implementers are encouraged to\n document their implementation's behavior with respect to the\n stackSize parameter."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n belongs to the thread group referred to by group, has\n the specified stackSize, and inherits initial values for\n inheritable thread-local variables\n if inheritThreadLocals is true.\n\n  This constructor is identical to Thread(ThreadGroup,Runnable,String,long) with the added ability to\n suppress, or not, the inheriting of initial values for inheritable\n thread-local variables from the constructing thread. This allows for\n finer grain control over inheritable thread-locals. Care must be taken\n when passing a value of false for inheritThreadLocals,\n as it may lead to unexpected behavior if the new thread executes code\n that expects a specific thread-local value to be inherited.\n\n  Specifying a value of true for the inheritThreadLocals\n parameter will cause this constructor to behave exactly like the\n Thread(ThreadGroup, Runnable, String, long) constructor."
                }
              ]
            },
            {
              "name": "currentThread",
              "overloads": [
                {
                  "signature": "public static Thread currentThread()",
                  "description": "Returns a reference to the currently executing thread object."
                }
              ]
            },
            {
              "name": "yield",
              "overloads": [
                {
                  "signature": "public static void yield()",
                  "description": "A hint to the scheduler that the current thread is willing to yield\n its current use of a processor. The scheduler is free to ignore this\n hint.\n\n  Yield is a heuristic attempt to improve relative progression\n between threads that would otherwise over-utilise a CPU. Its use\n should be combined with detailed profiling and benchmarking to\n ensure that it actually has the desired effect.\n\n  It is rarely appropriate to use this method. It may be useful\n for debugging or testing purposes, where it may help to reproduce\n bugs due to race conditions. It may also be useful when designing\n concurrency control constructs such as the ones in the\n java.util.concurrent.locks package."
                }
              ]
            },
            {
              "name": "sleep",
              "overloads": [
                {
                  "signature": "public static void sleep(long millis) throws InterruptedException",
                  "description": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds, subject to\n the precision and accuracy of system timers and schedulers. The thread\n does not lose ownership of any monitors."
                },
                {
                  "signature": "public static void sleep(long millis, int nanos) throws InterruptedException",
                  "description": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds plus the specified\n number of nanoseconds, subject to the precision and accuracy of system\n timers and schedulers. The thread does not lose ownership of any\n monitors."
                }
              ]
            },
            {
              "name": "onSpinWait",
              "overloads": [
                {
                  "signature": "public static void onSpinWait()",
                  "description": "Indicates that the caller is momentarily unable to progress, until the\n occurrence of one or more actions on the part of other activities. By\n invoking this method within each iteration of a spin-wait loop construct,\n the calling thread indicates to the runtime that it is busy-waiting.\n The runtime may take action to improve the performance of invoking\n spin-wait loop constructions."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected Object clone() throws CloneNotSupportedException",
                  "description": "Throws CloneNotSupportedException as a Thread can not be meaningfully\n cloned. Construct a new Thread instead."
                }
              ]
            },
            {
              "name": "start",
              "overloads": [
                {
                  "signature": "public void start()",
                  "description": "Causes this thread to begin execution; the Java Virtual Machine\n calls the run method of this thread.\n \n The result is that two threads are running concurrently: the\n current thread (which returns from the call to the\n start method) and the other thread (which executes its\n run method).\n \n It is never legal to start a thread more than once.\n In particular, a thread may not be restarted once it has completed\n execution."
                }
              ]
            },
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "public void run()",
                  "description": "If this thread was constructed using a separate\n Runnable run object, then that\n Runnable object's run method is called;\n otherwise, this method does nothing and returns.\n \n Subclasses of Thread should override this method."
                }
              ]
            },
            {
              "name": "stop",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\") public final void stop()",
                  "description": "Forces the thread to stop executing.\n \n If there is a security manager installed, its checkAccess\n method is called with this\n as its argument. This may result in a\n SecurityException being raised (in the current thread).\n \n If this thread is different from the current thread (that is, the current\n thread is trying to stop a thread other than itself), the\n security manager's checkPermission method (with a\n RuntimePermission(\"stopThread\") argument) is called in\n addition.\n Again, this may result in throwing a\n SecurityException (in the current thread).\n \n The thread represented by this thread is forced to stop whatever\n it is doing abnormally and to throw a newly created\n ThreadDeath object as an exception.\n \n It is permitted to stop a thread that has not yet been started.\n If the thread is eventually started, it immediately terminates.\n \n An application should not normally try to catch\n ThreadDeath unless it must do some extraordinary\n cleanup operation (note that the throwing of\n ThreadDeath causes finally clauses of\n try statements to be executed before the thread\n officially dies).  If a catch clause catches a\n ThreadDeath object, it is important to rethrow the\n object so that the thread actually dies.\n \n The top-level error handler that reacts to otherwise uncaught\n exceptions does not print out a message or otherwise notify the\n application if the uncaught exception is an instance of\n ThreadDeath.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "interrupt",
              "overloads": [
                {
                  "signature": "public void interrupt()",
                  "description": "Interrupts this thread.\n\n  Unless the current thread is interrupting itself, which is\n always permitted, the checkAccess method\n of this thread is invoked, which may cause a SecurityException to be thrown.\n\n  If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object\n class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int)\n methods of this class, then its interrupt status will be cleared and it\n will receive an InterruptedException.\n\n  If this thread is blocked in an I/O operation upon an InterruptibleChannel\n then the channel will be closed, the thread's interrupt\n status will be set, and the thread will receive a ClosedByInterruptException.\n\n  If this thread is blocked in a Selector\n then the thread's interrupt status will be set and it will return\n immediately from the selection operation, possibly with a non-zero\n value, just as if the selector's wakeup method were invoked.\n\n  If none of the previous conditions hold then this thread's interrupt\n status will be set. \n\n  Interrupting a thread that is not alive need not have any effect."
                }
              ]
            },
            {
              "name": "interrupted",
              "overloads": [
                {
                  "signature": "public static boolean interrupted()",
                  "description": "Tests whether the current thread has been interrupted.  The\n interrupted status of the thread is cleared by this method.  In\n other words, if this method were to be called twice in succession, the\n second call would return false (unless the current thread were\n interrupted again, after the first call had cleared its interrupted\n status and before the second call had examined it)."
                }
              ]
            },
            {
              "name": "isInterrupted",
              "overloads": [
                {
                  "signature": "public boolean isInterrupted()",
                  "description": "Tests whether this thread has been interrupted.  The interrupted\n status of the thread is unaffected by this method."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "public final boolean isAlive()",
                  "description": "Tests if this thread is alive. A thread is alive if it has\n been started and has not yet died."
                }
              ]
            },
            {
              "name": "suspend",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void suspend()",
                  "description": "Suspends this thread.\n \n First, the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException (in the current thread).\n \n If the thread is alive, it is suspended and makes no further\n progress unless and until it is resumed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "resume",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void resume()",
                  "description": "Resumes a suspended thread.\n \n First, the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException (in the current thread).\n \n If the thread is alive but suspended, it is resumed and is\n permitted to make progress in its execution.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPriority",
              "overloads": [
                {
                  "signature": "public final void setPriority(int newPriority)",
                  "description": "Changes the priority of this thread.\n \n First the checkAccess method of this thread is called\n with no arguments. This may result in throwing a SecurityException.\n \n Otherwise, the priority of this thread is set to the smaller of\n the specified newPriority and the maximum permitted\n priority of the thread's thread group."
                }
              ]
            },
            {
              "name": "getPriority",
              "overloads": [
                {
                  "signature": "public final int getPriority()",
                  "description": "Returns this thread's priority."
                }
              ]
            },
            {
              "name": "setName",
              "overloads": [
                {
                  "signature": "public final void setName(String name)",
                  "description": "Changes the name of this thread to be equal to the argument name.\n \n First the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns this thread's name."
                }
              ]
            },
            {
              "name": "getThreadGroup",
              "overloads": [
                {
                  "signature": "public final ThreadGroup getThreadGroup()",
                  "description": "Returns the thread group to which this thread belongs.\n This method returns null if this thread has died\n (been stopped)."
                }
              ]
            },
            {
              "name": "activeCount",
              "overloads": [
                {
                  "signature": "public static int activeCount()",
                  "description": "Returns an estimate of the number of active threads in the current\n thread's thread group and its\n subgroups. Recursively iterates over all subgroups in the current\n thread's thread group.\n\n  The value returned is only an estimate because the number of\n threads may change dynamically while this method traverses internal\n data structures, and might be affected by the presence of certain\n system threads. This method is intended primarily for debugging\n and monitoring purposes."
                }
              ]
            },
            {
              "name": "enumerate",
              "overloads": [
                {
                  "signature": "public static int enumerate(Thread[] tarray)",
                  "description": "Copies into the specified array every active thread in the current\n thread's thread group and its subgroups. This method simply\n invokes the ThreadGroup.enumerate(Thread[])\n method of the current thread's thread group.\n\n  An application might use the activeCount\n method to get an estimate of how big the array should be, however\n if the array is too short to hold all the threads, the extra threads\n are silently ignored.  If it is critical to obtain every active\n thread in the current thread's thread group and its subgroups, the\n invoker should verify that the returned int value is strictly less\n than the length of tarray.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "countStackFrames",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public int countStackFrames()",
                  "description": "Throws UnsupportedOperationException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "public final void join(long millis) throws InterruptedException",
                  "description": "Waits at most millis milliseconds for this thread to\n die. A timeout of 0 means to wait forever.\n\n  This implementation uses a loop of this.wait calls\n conditioned on this.isAlive. As a thread terminates the\n this.notifyAll method is invoked. It is recommended that\n applications not use wait, notify, or\n notifyAll on Thread instances."
                },
                {
                  "signature": "public final void join(long millis, int nanos) throws InterruptedException",
                  "description": "Waits at most millis milliseconds plus\n nanos nanoseconds for this thread to die.\n If both arguments are 0, it means to wait forever.\n\n  This implementation uses a loop of this.wait calls\n conditioned on this.isAlive. As a thread terminates the\n this.notifyAll method is invoked. It is recommended that\n applications not use wait, notify, or\n notifyAll on Thread instances."
                },
                {
                  "signature": "public final void join() throws InterruptedException",
                  "description": "Waits for this thread to die.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n join(0)"
                }
              ]
            },
            {
              "name": "dumpStack",
              "overloads": [
                {
                  "signature": "public static void dumpStack()",
                  "description": "Prints a stack trace of the current thread to the standard error stream.\n This method is used only for debugging."
                }
              ]
            },
            {
              "name": "setDaemon",
              "overloads": [
                {
                  "signature": "public final void setDaemon(boolean on)",
                  "description": "Marks this thread as either a daemon thread\n or a user thread. The Java Virtual Machine exits when the only\n threads running are all daemon threads.\n\n  This method must be invoked before the thread is started."
                }
              ]
            },
            {
              "name": "isDaemon",
              "overloads": [
                {
                  "signature": "public final boolean isDaemon()",
                  "description": "Tests if this thread is a daemon thread."
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public final void checkAccess()",
                  "description": "Determines if the currently running thread has permission to\n modify this thread.\n \n If there is a security manager, its checkAccess method\n is called with this thread as its argument. This may result in\n throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this thread, including the\n thread's name, priority, and thread group."
                }
              ]
            },
            {
              "name": "getContextClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getContextClassLoader()",
                  "description": "Returns the context ClassLoader for this thread. The context\n ClassLoader is provided by the creator of the thread for use\n by code running in this thread when loading classes and resources.\n If not set, the default is the\n ClassLoader context of the parent thread. The context\n ClassLoader of the\n primordial thread is typically set to the class loader used to load the\n application."
                }
              ]
            },
            {
              "name": "setContextClassLoader",
              "overloads": [
                {
                  "signature": "public void setContextClassLoader(ClassLoader cl)",
                  "description": "Sets the context ClassLoader for this Thread. The context\n ClassLoader can be set when a thread is created, and allows\n the creator of the thread to provide the appropriate class loader,\n through getContextClassLoader, to code running in the thread\n when loading classes and resources.\n\n If a security manager is present, its checkPermission\n method is invoked with a RuntimePermission\n (\"setContextClassLoader\") permission to see if setting the context\n ClassLoader is permitted."
                }
              ]
            },
            {
              "name": "holdsLock",
              "overloads": [
                {
                  "signature": "public static boolean holdsLock(Object obj)",
                  "description": "Returns true if and only if the current thread holds the\n monitor lock on the specified object.\n\n This method is designed to allow a program to assert that\n the current thread already holds a specified lock:\n      assert Thread.holdsLock(obj);"
                }
              ]
            },
            {
              "name": "getStackTrace",
              "overloads": [
                {
                  "signature": "public StackTraceElement[] getStackTrace()",
                  "description": "Returns an array of stack trace elements representing the stack dump\n of this thread.  This method will return a zero-length array if\n this thread has not started, has started but has not yet been\n scheduled to run by the system, or has terminated.\n If the returned array is of non-zero length then the first element of\n the array represents the top of the stack, which is the most recent\n method invocation in the sequence.  The last element of the array\n represents the bottom of the stack, which is the least recent method\n invocation in the sequence.\n\n If there is a security manager, and this thread is not\n the current thread, then the security manager's\n checkPermission method is called with a\n RuntimePermission(\"getStackTrace\") permission\n to see if it's ok to get the stack trace.\n\n Some virtual machines may, under some circumstances, omit one\n or more stack frames from the stack trace.  In the extreme case,\n a virtual machine that has no stack trace information concerning\n this thread is permitted to return a zero-length array from this\n method."
                }
              ]
            },
            {
              "name": "getAllStackTraces",
              "overloads": [
                {
                  "signature": "public static Map<Thread,StackTraceElement[]> getAllStackTraces()",
                  "description": "Returns a map of stack traces for all live threads.\n The map keys are threads and each map value is an array of\n StackTraceElement that represents the stack dump\n of the corresponding Thread.\n The returned stack traces are in the format specified for\n the getStackTrace method.\n\n The threads may be executing while this method is called.\n The stack trace of each thread only represents a snapshot and\n each stack trace may be obtained at different time.  A zero-length\n array will be returned in the map value if the virtual machine has\n no stack trace information about a thread.\n\n If there is a security manager, then the security manager's\n checkPermission method is called with a\n RuntimePermission(\"getStackTrace\") permission as well as\n RuntimePermission(\"modifyThreadGroup\") permission\n to see if it is ok to get the stack trace of all threads."
                }
              ]
            },
            {
              "name": "getId",
              "overloads": [
                {
                  "signature": "public long getId()",
                  "description": "Returns the identifier of this Thread.  The thread ID is a positive\n long number generated when this thread was created.\n The thread ID is unique and remains unchanged during its lifetime.\n When a thread is terminated, this thread ID may be reused."
                }
              ]
            },
            {
              "name": "getState",
              "overloads": [
                {
                  "signature": "public Thread.State getState()",
                  "description": "Returns the state of this thread.\n This method is designed for use in monitoring of the system state,\n not for synchronization control."
                }
              ]
            },
            {
              "name": "setDefaultUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)",
                  "description": "Set the default handler invoked when a thread abruptly terminates\n due to an uncaught exception, and no other handler has been defined\n for that thread.\n\n Uncaught exception handling is controlled first by the thread, then\n by the thread's ThreadGroup object and finally by the default\n uncaught exception handler. If the thread does not have an explicit\n uncaught exception handler set, and the thread's thread group\n (including parent thread groups)  does not specialize its\n uncaughtException method, then the default handler's\n uncaughtException method will be invoked.\n By setting the default uncaught exception handler, an application\n can change the way in which uncaught exceptions are handled (such as\n logging to a specific device, or file) for those threads that would\n already accept whatever \"default\" behavior the system\n provided.\n\n Note that the default uncaught exception handler should not usually\n defer to the thread's ThreadGroup object, as that could cause\n infinite recursion."
                }
              ]
            },
            {
              "name": "getDefaultUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()",
                  "description": "Returns the default handler invoked when a thread abruptly terminates\n due to an uncaught exception. If the returned value is null,\n there is no default."
                }
              ]
            },
            {
              "name": "getUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()",
                  "description": "Returns the handler invoked when this thread abruptly terminates\n due to an uncaught exception. If this thread has not had an\n uncaught exception handler explicitly set then this thread's\n ThreadGroup object is returned, unless this thread\n has terminated, in which case null is returned."
                }
              ]
            },
            {
              "name": "setUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)",
                  "description": "Set the handler invoked when this thread abruptly terminates\n due to an uncaught exception.\n A thread can take full control of how it responds to uncaught\n exceptions by having its uncaught exception handler explicitly set.\n If no such handler is set then the thread's ThreadGroup\n object acts as its handler."
                }
              ]
            }
          ]
        },
        {
          "name": "Thread.UncaughtExceptionHandler",
          "methods": [
            {
              "name": "uncaughtException",
              "overloads": [
                {
                  "signature": "void uncaughtException(Thread t, Throwable e)",
                  "description": "Method invoked when the given thread terminates due to the\n given uncaught exception.\n Any exception thrown by this method will be ignored by the\n Java Virtual Machine."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadDeath",
          "methods": [
            {
              "name": "ThreadDeath",
              "overloads": [
                {
                  "signature": "public ThreadDeath()",
                  "description": "Constructs a ThreadDeath."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadGroup",
          "methods": [
            {
              "name": "ThreadGroup",
              "overloads": [
                {
                  "signature": "public ThreadGroup(String name)",
                  "description": "Constructs a new thread group. The parent of this new group is\n the thread group of the currently running thread.\n \n The checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                },
                {
                  "signature": "public ThreadGroup(ThreadGroup parent, String name)",
                  "description": "Creates a new thread group. The parent of this new group is the\n specified thread group.\n \n The checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns the name of this thread group."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public final ThreadGroup getParent()",
                  "description": "Returns the parent of this thread group.\n \n First, if the parent is not null, the\n checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                }
              ]
            },
            {
              "name": "getMaxPriority",
              "overloads": [
                {
                  "signature": "public final int getMaxPriority()",
                  "description": "Returns the maximum priority of this thread group. Threads that are\n part of this group cannot have a higher priority than the maximum\n priority."
                }
              ]
            },
            {
              "name": "isDaemon",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final boolean isDaemon()",
                  "description": "Tests if this thread group is a daemon thread group. A\n daemon thread group is automatically destroyed when its last\n thread is stopped or its last thread group is destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isDestroyed",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public boolean isDestroyed()",
                  "description": "Tests if this thread group has been destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setDaemon",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final void setDaemon(boolean daemon)",
                  "description": "Changes the daemon status of this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n A daemon thread group is automatically destroyed when its last\n thread is stopped or its last thread group is destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setMaxPriority",
              "overloads": [
                {
                  "signature": "public final void setMaxPriority(int pri)",
                  "description": "Sets the maximum priority of the group. Threads in the thread\n group that already have a higher priority are not affected.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n If the pri argument is less than\n Thread.MIN_PRIORITY or greater than\n Thread.MAX_PRIORITY, the maximum priority of the group\n remains unchanged.\n \n Otherwise, the priority of this ThreadGroup object is set to the\n smaller of the specified pri and the maximum permitted\n priority of the parent of this thread group. (If this thread group\n is the system thread group, which has no parent, then its maximum\n priority is simply set to pri.) Then this method is\n called recursively, with pri as its argument, for\n every thread group that belongs to this thread group."
                }
              ]
            },
            {
              "name": "parentOf",
              "overloads": [
                {
                  "signature": "public final boolean parentOf(ThreadGroup g)",
                  "description": "Tests if this thread group is either the thread group\n argument or one of its ancestor thread groups."
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public final void checkAccess()",
                  "description": "Determines if the currently running thread has permission to\n modify this thread group.\n \n If there is a security manager, its checkAccess method\n is called with this thread group as its argument. This may result\n in throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "activeCount",
              "overloads": [
                {
                  "signature": "public int activeCount()",
                  "description": "Returns an estimate of the number of active threads in this thread\n group and its subgroups. Recursively iterates over all subgroups in\n this thread group.\n\n  The value returned is only an estimate because the number of\n threads may change dynamically while this method traverses internal\n data structures, and might be affected by the presence of certain\n system threads. This method is intended primarily for debugging\n and monitoring purposes."
                }
              ]
            },
            {
              "name": "enumerate",
              "overloads": [
                {
                  "signature": "public int enumerate(Thread[] list)",
                  "description": "Copies into the specified array every active thread in this\n thread group and its subgroups.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n enumerate(list, true)"
                },
                {
                  "signature": "public int enumerate(Thread[] list, boolean recurse)",
                  "description": "Copies into the specified array every active thread in this\n thread group. If recurse is true,\n this method recursively enumerates all subgroups of this\n thread group and references to every active thread in these\n subgroups are also included. If the array is too short to\n hold all the threads, the extra threads are silently ignored.\n\n  An application might use the activeCount\n method to get an estimate of how big the array should be, however\n if the array is too short to hold all the threads, the extra threads\n are silently ignored.  If it is critical to obtain every active\n thread in this thread group, the caller should verify that the returned\n int value is strictly less than the length of list.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                },
                {
                  "signature": "public int enumerate(ThreadGroup[] list)",
                  "description": "Copies into the specified array references to every active\n subgroup in this thread group and its subgroups.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n enumerate(list, true)"
                },
                {
                  "signature": "public int enumerate(ThreadGroup[] list, boolean recurse)",
                  "description": "Copies into the specified array references to every active\n subgroup in this thread group. If recurse is\n true, this method recursively enumerates all subgroups of this\n thread group and references to every active thread group in these\n subgroups are also included.\n\n  An application might use the\n activeGroupCount method to\n get an estimate of how big the array should be, however if the\n array is too short to hold all the thread groups, the extra thread\n groups are silently ignored.  If it is critical to obtain every\n active subgroup in this thread group, the caller should verify that\n the returned int value is strictly less than the length of\n list.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "activeGroupCount",
              "overloads": [
                {
                  "signature": "public int activeGroupCount()",
                  "description": "Returns an estimate of the number of active groups in this\n thread group and its subgroups. Recursively iterates over\n all subgroups in this thread group.\n\n  The value returned is only an estimate because the number of\n thread groups may change dynamically while this method traverses\n internal data structures. This method is intended primarily for\n debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "stop",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void stop()",
                  "description": "Stops all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the stop method on all the\n threads in this thread group and in all of its subgroups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "interrupt",
              "overloads": [
                {
                  "signature": "public final void interrupt()",
                  "description": "Interrupts all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the interrupt method on all the\n threads in this thread group and in all of its subgroups."
                }
              ]
            },
            {
              "name": "suspend",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void suspend()",
                  "description": "Suspends all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the suspend method on all the\n threads in this thread group and in all of its subgroups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "resume",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void resume()",
                  "description": "Resumes all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the resume method on all the\n threads in this thread group and in all of its sub groups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final void destroy()",
                  "description": "Destroys this thread group and all of its subgroups. This thread\n group must be empty, indicating that all threads that had been in\n this thread group have since stopped.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public void list()",
                  "description": "Prints information about this thread group to the standard\n output. This method is useful only for debugging."
                }
              ]
            },
            {
              "name": "uncaughtException",
              "overloads": [
                {
                  "signature": "public void uncaughtException(Thread t, Throwable e)",
                  "description": "Called by the Java Virtual Machine when a thread in this\n thread group stops because of an uncaught exception, and the thread\n does not have a specific Thread.UncaughtExceptionHandler\n installed.\n \n The uncaughtException method of\n ThreadGroup does the following:\n \n If this thread group has a parent thread group, the\n     uncaughtException method of that parent is called\n     with the same two arguments.\n Otherwise, this method checks to see if there is a\n     default\n     uncaught exception handler installed, and if so, its\n     uncaughtException method is called with the same\n     two arguments.\n Otherwise, this method determines if the Throwable\n     argument is an instance of ThreadDeath. If so, nothing\n     special is done. Otherwise, a message containing the\n     thread's name, as returned from the thread's getName method, and a stack backtrace,\n     using the Throwable's printStackTrace method, is\n     printed to the standard error stream.\n \n \n Applications can override this method in subclasses of\n ThreadGroup to provide alternative handling of\n uncaught exceptions."
                }
              ]
            },
            {
              "name": "allowThreadSuspension",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public boolean allowThreadSuspension(boolean b)",
                  "description": "Used by VM to control lowmem implicit suspension.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Thread group."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadLocal<T>",
          "methods": [
            {
              "name": "ThreadLocal",
              "overloads": [
                {
                  "signature": "public ThreadLocal()",
                  "description": "Creates a thread local variable."
                }
              ]
            },
            {
              "name": "initialValue",
              "overloads": [
                {
                  "signature": "protected T initialValue()",
                  "description": "Returns the current thread's \"initial value\" for this\n thread-local variable.  This method will be invoked the first\n time a thread accesses the variable with the get()\n method, unless the thread previously invoked the set(T)\n method, in which case the initialValue method will not\n be invoked for the thread.  Normally, this method is invoked at\n most once per thread, but it may be invoked again in case of\n subsequent invocations of remove() followed by get().\n\n This implementation simply returns null; if the\n programmer desires thread-local variables to have an initial\n value other than null, ThreadLocal must be\n subclassed, and this method overridden.  Typically, an\n anonymous inner class will be used."
                }
              ]
            },
            {
              "name": "withInitial",
              "overloads": [
                {
                  "signature": "public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier)",
                  "description": "Creates a thread local variable. The initial value of the variable is\n determined by invoking the get method on the Supplier."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public T get()",
                  "description": "Returns the value in the current thread's copy of this\n thread-local variable.  If the variable has no value for the\n current thread, it is first initialized to the value returned\n by an invocation of the initialValue() method."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public void set(T value)",
                  "description": "Sets the current thread's copy of this thread-local variable\n to the specified value.  Most subclasses will have no need to\n override this method, relying solely on the initialValue()\n method to set the values of thread-locals."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public void remove()",
                  "description": "Removes the current thread's value for this thread-local\n variable.  If this thread-local variable is subsequently\n read by the current thread, its value will be\n reinitialized by invoking its initialValue() method,\n unless its value is set by the current thread\n in the interim.  This may result in multiple invocations of the\n initialValue method in the current thread."
                }
              ]
            }
          ]
        },
        {
          "name": "Throwable",
          "methods": [
            {
              "name": "Throwable",
              "overloads": [
                {
                  "signature": "public Throwable()",
                  "description": "Constructs a new throwable with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to initCause(java.lang.Throwable).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(String message)",
                  "description": "Constructs a new throwable with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to initCause(java.lang.Throwable).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(String message, Throwable cause)",
                  "description": "Constructs a new throwable with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this throwable's detail message.\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(Throwable cause)",
                  "description": "Constructs a new throwable with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for throwables that are little more than\n wrappers for other throwables (for example, PrivilegedActionException).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new throwable with the specified detail message,\n cause, suppression enabled or\n disabled, and writable stack trace enabled or disabled.  If\n suppression is disabled, getSuppressed() for this object\n will return a zero-length array and calls to addSuppressed(java.lang.Throwable) that would otherwise append an exception to the\n suppressed list will have no effect.  If the writable stack\n trace is false, this constructor will not call fillInStackTrace(), a null will be written to the\n stackTrace field, and subsequent calls to \n fillInStackTrace and setStackTrace(StackTraceElement[]) will not set the stack\n trace.  If the writable stack trace is false, getStackTrace() will return a zero length array.\n\n Note that the other constructors of Throwable treat\n suppression as being enabled and the stack trace as being\n writable.  Subclasses of Throwable should document any\n conditions under which suppression is disabled and document\n conditions under which the stack trace is not writable.\n Disabling of suppression should only occur in exceptional\n circumstances where special requirements exist, such as a\n virtual machine reusing exception objects under low-memory\n situations.  Circumstances where a given exception object is\n repeatedly caught and rethrown, such as to implement control\n flow between two sub-systems, is another situation where\n immutable throwable objects would be appropriate."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns the detail message string of this throwable."
                }
              ]
            },
            {
              "name": "getLocalizedMessage",
              "overloads": [
                {
                  "signature": "public String getLocalizedMessage()",
                  "description": "Creates a localized description of this throwable.\n Subclasses may override this method in order to produce a\n locale-specific message.  For subclasses that do not override this\n method, the default implementation returns the same result as\n getMessage()."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public Throwable getCause()",
                  "description": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.  (The cause is the throwable that\n caused this throwable to get thrown.)\n\n This implementation returns the cause that was supplied via one of\n the constructors requiring a Throwable, or that was set after\n creation with the initCause(Throwable) method.  While it is\n typically unnecessary to override this method, a subclass can override\n it to return a cause set by some other means.  This is appropriate for\n a \"legacy chained throwable\" that predates the addition of chained\n exceptions to Throwable.  Note that it is not\n necessary to override any of the PrintStackTrace methods,\n all of which invoke the getCause method to determine the\n cause of a throwable."
                }
              ]
            },
            {
              "name": "initCause",
              "overloads": [
                {
                  "signature": "public Throwable initCause(Throwable cause)",
                  "description": "Initializes the cause of this throwable to the specified value.\n (The cause is the throwable that caused this throwable to get thrown.)\n\n This method can be called at most once.  It is generally called from\n within the constructor, or immediately after creating the\n throwable.  If this throwable was created\n with Throwable(Throwable) or\n Throwable(String,Throwable), this method cannot be called\n even once.\n\n An example of using this method on a legacy throwable type\n without other support for setting the cause is:\n\n  try {\n     lowLevelOp();\n } catch (LowLevelException le) {\n     throw (HighLevelException)\n           new HighLevelException().initCause(le); // Legacy constructor\n }"
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a short description of this throwable.\n The result is the concatenation of:\n \n  the name of the class of this object\n  \": \" (a colon and a space)\n  the result of invoking this object's getLocalizedMessage()\n      method\n \n If getLocalizedMessage returns null, then just\n the class name is returned."
                }
              ]
            },
            {
              "name": "printStackTrace",
              "overloads": [
                {
                  "signature": "public void printStackTrace()",
                  "description": "Prints this throwable and its backtrace to the\n standard error stream. This method prints a stack trace for this\n Throwable object on the error output stream that is\n the value of the field System.err. The first line of\n output contains the result of the toString() method for\n this object.  Remaining lines represent data previously recorded by\n the method fillInStackTrace(). The format of this\n information depends on the implementation, but the following\n example may be regarded as typical:\n  java.lang.NullPointerException\n         at MyClass.mash(MyClass.java:9)\n         at MyClass.crunch(MyClass.java:6)\n         at MyClass.main(MyClass.java:3)\n \n This example was produced by running the program:\n  class MyClass {\n     public static void main(String[] args) {\n         crunch(null);\n     }\n     static void crunch(int[] a) {\n         mash(a);\n     }\n     static void mash(int[] b) {\n         System.out.println(b[0]);\n     }\n }\n \n The backtrace for a throwable with an initialized, non-null cause\n should generally include the backtrace for the cause.  The format\n of this information depends on the implementation, but the following\n example may be regarded as typical:\n  HighLevelException: MidLevelException: LowLevelException\n         at Junk.a(Junk.java:13)\n         at Junk.main(Junk.java:4)\n Caused by: MidLevelException: LowLevelException\n         at Junk.c(Junk.java:23)\n         at Junk.b(Junk.java:17)\n         at Junk.a(Junk.java:11)\n         ... 1 more\n Caused by: LowLevelException\n         at Junk.e(Junk.java:30)\n         at Junk.d(Junk.java:27)\n         at Junk.c(Junk.java:21)\n         ... 3 more\n \n Note the presence of lines containing the characters \"...\".\n These lines indicate that the remainder of the stack trace for this\n exception matches the indicated number of frames from the bottom of the\n stack trace of the exception that was caused by this exception (the\n \"enclosing\" exception).  This shorthand can greatly reduce the length\n of the output in the common case where a wrapped exception is thrown\n from same method as the \"causative exception\" is caught.  The above\n example was produced by running the program:\n  public class Junk {\n     public static void main(String args[]) {\n         try {\n             a();\n         } catch(HighLevelException e) {\n             e.printStackTrace();\n         }\n     }\n     static void a() throws HighLevelException {\n         try {\n             b();\n         } catch(MidLevelException e) {\n             throw new HighLevelException(e);\n         }\n     }\n     static void b() throws MidLevelException {\n         c();\n     }\n     static void c() throws MidLevelException {\n         try {\n             d();\n         } catch(LowLevelException e) {\n             throw new MidLevelException(e);\n         }\n     }\n     static void d() throws LowLevelException {\n        e();\n     }\n     static void e() throws LowLevelException {\n         throw new LowLevelException();\n     }\n }\n\n class HighLevelException extends Exception {\n     HighLevelException(Throwable cause) { super(cause); }\n }\n\n class MidLevelException extends Exception {\n     MidLevelException(Throwable cause)  { super(cause); }\n }\n\n class LowLevelException extends Exception {\n }\n \n As of release 7, the platform supports the notion of\n suppressed exceptions (in conjunction with the \n try-with-resources statement). Any exceptions that were\n suppressed in order to deliver an exception are printed out\n beneath the stack trace.  The format of this information\n depends on the implementation, but the following example may be\n regarded as typical:\n\n  Exception in thread \"main\" java.lang.Exception: Something happened\n  at Foo.bar(Foo.java:10)\n  at Foo.main(Foo.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID = 0\n          at Resource.close(Resource.java:26)\n          at Foo.bar(Foo.java:9)\n          ... 1 more\n \n Note that the \"... n more\" notation is used on suppressed exceptions\n just as it is used on causes. Unlike causes, suppressed exceptions are\n indented beyond their \"containing exceptions.\"\n\n An exception can have both a cause and one or more suppressed\n exceptions:\n  Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo3.main(Foo3.java:7)\n  Suppressed: Resource$CloseFailException: Resource ID = 2\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID = 1\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n Caused by: java.lang.Exception: I did it\n  at Foo3.main(Foo3.java:8)\n \n Likewise, a suppressed exception can have a cause:\n  Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo4.main(Foo4.java:6)\n  Suppressed: Resource2$CloseFailException: Resource ID = 1\n          at Resource2.close(Resource2.java:20)\n          at Foo4.main(Foo4.java:5)\n  Caused by: java.lang.Exception: Rats, you caught me\n          at Resource2$CloseFailException.<init>(Resource2.java:45)\n          ... 2 more"
                },
                {
                  "signature": "public void printStackTrace(PrintStream s)",
                  "description": "Prints this throwable and its backtrace to the specified print stream."
                },
                {
                  "signature": "public void printStackTrace(PrintWriter s)",
                  "description": "Prints this throwable and its backtrace to the specified\n print writer."
                }
              ]
            },
            {
              "name": "fillInStackTrace",
              "overloads": [
                {
                  "signature": "public Throwable fillInStackTrace()",
                  "description": "Fills in the execution stack trace. This method records within this\n Throwable object information about the current state of\n the stack frames for the current thread.\n\n If the stack trace of this Throwable is not\n writable, calling this method has no effect."
                }
              ]
            },
            {
              "name": "getStackTrace",
              "overloads": [
                {
                  "signature": "public StackTraceElement[] getStackTrace()",
                  "description": "Provides programmatic access to the stack trace information printed by\n printStackTrace().  Returns an array of stack trace elements,\n each representing one stack frame.  The zeroth element of the array\n (assuming the array's length is non-zero) represents the top of the\n stack, which is the last method invocation in the sequence.  Typically,\n this is the point at which this throwable was created and thrown.\n The last element of the array (assuming the array's length is non-zero)\n represents the bottom of the stack, which is the first method invocation\n in the sequence.\n\n Some virtual machines may, under some circumstances, omit one\n or more stack frames from the stack trace.  In the extreme case,\n a virtual machine that has no stack trace information concerning\n this throwable is permitted to return a zero-length array from this\n method.  Generally speaking, the array returned by this method will\n contain one element for every frame that would be printed by\n printStackTrace.  Writes to the returned array do not\n affect future calls to this method."
                }
              ]
            },
            {
              "name": "setStackTrace",
              "overloads": [
                {
                  "signature": "public void setStackTrace(StackTraceElement[] stackTrace)",
                  "description": "Sets the stack trace elements that will be returned by\n getStackTrace() and printed by printStackTrace()\n and related methods.\n\n This method, which is designed for use by RPC frameworks and other\n advanced systems, allows the client to override the default\n stack trace that is either generated by fillInStackTrace()\n when a throwable is constructed or deserialized when a throwable is\n read from a serialization stream.\n\n If the stack trace of this Throwable is not\n writable, calling this method has no effect other than\n validating its argument."
                }
              ]
            },
            {
              "name": "addSuppressed",
              "overloads": [
                {
                  "signature": "public final void addSuppressed(Throwable exception)",
                  "description": "Appends the specified exception to the exceptions that were\n suppressed in order to deliver this exception. This method is\n thread-safe and typically called (automatically and implicitly)\n by the try-with-resources statement.\n\n The suppression behavior is enabled unless disabled\n via\n a constructor.  When suppression is disabled, this method does\n nothing other than to validate its argument.\n\n Note that when one exception causes another exception, the first\n exception is usually caught and then the second exception is\n thrown in response.  In other words, there is a causal\n connection between the two exceptions.\n\n In contrast, there are situations where two independent\n exceptions can be thrown in sibling code blocks, in particular\n in the try block of a try-with-resources\n statement and the compiler-generated finally block\n which closes the resource.\n\n In these situations, only one of the thrown exceptions can be\n propagated.  In the try-with-resources statement, when\n there are two such exceptions, the exception originating from\n the try block is propagated and the exception from the\n finally block is added to the list of exceptions\n suppressed by the exception from the try block.  As an\n exception unwinds the stack, it can accumulate multiple\n suppressed exceptions.\n\n An exception may have suppressed exceptions while also being\n caused by another exception.  Whether or not an exception has a\n cause is semantically known at the time of its creation, unlike\n whether or not an exception will suppress other exceptions\n which is typically only determined after an exception is\n thrown.\n\n Note that programmer written code is also able to take\n advantage of calling this method in situations where there are\n multiple sibling exceptions and only one can be propagated."
                }
              ]
            },
            {
              "name": "getSuppressed",
              "overloads": [
                {
                  "signature": "public final Throwable[] getSuppressed()",
                  "description": "Returns an array containing all of the exceptions that were\n suppressed, typically by the try-with-resources\n statement, in order to deliver this exception.\n\n If no exceptions were suppressed or suppression is\n disabled, an empty array is returned.  This method is\n thread-safe.  Writes to the returned array do not affect future\n calls to this method."
                }
              ]
            }
          ]
        },
        {
          "name": "TypeNotPresentException",
          "methods": [
            {
              "name": "TypeNotPresentException",
              "overloads": [
                {
                  "signature": "public TypeNotPresentException(String typeName, Throwable cause)",
                  "description": "Constructs a TypeNotPresentException for the named type\n with the specified cause."
                }
              ]
            },
            {
              "name": "typeName",
              "overloads": [
                {
                  "signature": "public String typeName()",
                  "description": "Returns the fully qualified name of the unavailable type."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownError",
          "methods": [
            {
              "name": "UnknownError",
              "overloads": [
                {
                  "signature": "public UnknownError()",
                  "description": "Constructs an UnknownError with no detail message."
                },
                {
                  "signature": "public UnknownError(String s)",
                  "description": "Constructs an UnknownError with the specified detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsatisfiedLinkError",
          "methods": [
            {
              "name": "UnsatisfiedLinkError",
              "overloads": [
                {
                  "signature": "public UnsatisfiedLinkError()",
                  "description": "Constructs an UnsatisfiedLinkError with no detail message."
                },
                {
                  "signature": "public UnsatisfiedLinkError(String s)",
                  "description": "Constructs an UnsatisfiedLinkError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedClassVersionError",
          "methods": [
            {
              "name": "UnsupportedClassVersionError",
              "overloads": [
                {
                  "signature": "public UnsupportedClassVersionError()",
                  "description": "Constructs a UnsupportedClassVersionError\n with no detail message."
                },
                {
                  "signature": "public UnsupportedClassVersionError(String s)",
                  "description": "Constructs a UnsupportedClassVersionError with\n the specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedOperationException",
          "methods": [
            {
              "name": "UnsupportedOperationException",
              "overloads": [
                {
                  "signature": "public UnsupportedOperationException()",
                  "description": "Constructs an UnsupportedOperationException with no detail message."
                },
                {
                  "signature": "public UnsupportedOperationException(String message)",
                  "description": "Constructs an UnsupportedOperationException with the specified\n detail message."
                },
                {
                  "signature": "public UnsupportedOperationException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public UnsupportedOperationException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "VerifyError",
          "methods": [
            {
              "name": "VerifyError",
              "overloads": [
                {
                  "signature": "public VerifyError()",
                  "description": "Constructs an VerifyError with no detail message."
                },
                {
                  "signature": "public VerifyError(String s)",
                  "description": "Constructs an VerifyError with the specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "VirtualMachineError",
          "methods": [
            {
              "name": "VirtualMachineError",
              "overloads": [
                {
                  "signature": "public VirtualMachineError()",
                  "description": "Constructs a VirtualMachineError with no detail message."
                },
                {
                  "signature": "public VirtualMachineError(String message)",
                  "description": "Constructs a VirtualMachineError with the specified\n detail message."
                },
                {
                  "signature": "public VirtualMachineError(String message, Throwable cause)",
                  "description": "Constructs a VirtualMachineError with the specified\n detail message and cause.  Note that the detail message\n associated with cause is not automatically\n incorporated in this error's detail message."
                },
                {
                  "signature": "public VirtualMachineError(Throwable cause)",
                  "description": "Constructs an a VirtualMachineError with the specified\n cause and a detail message of (cause==null ? null :\n cause.toString()) (which typically contains the class and\n detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Void",
          "methods": []
        }
      ]
    },
    {
      "package": "java.util",
      "description": "Utility classes and collections",
      "classes": [
        {
          "name": "Calendar",
          "methods": [
            {
              "name": "Calendar",
              "overloads": [
                {
                  "signature": "protected Calendar()",
                  "description": "Constructs a Calendar with the default time zone\n and the default FORMAT\n locale."
                },
                {
                  "signature": "protected Calendar(TimeZone zone, Locale aLocale)",
                  "description": "Constructs a calendar with the specified time zone and locale."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Calendar getInstance()",
                  "description": "Gets a calendar using the default time zone and locale. The\n Calendar returned is based on the current time\n in the default time zone with the default\n FORMAT locale.\n \n If the locale contains the time zone with \"tz\"\n Unicode extension,\n that time zone is used instead."
                },
                {
                  "signature": "public static Calendar getInstance(TimeZone zone)",
                  "description": "Gets a calendar using the specified time zone and default locale.\n The Calendar returned is based on the current time\n in the given time zone with the default\n FORMAT locale."
                },
                {
                  "signature": "public static Calendar getInstance(Locale aLocale)",
                  "description": "Gets a calendar using the default time zone and specified locale.\n The Calendar returned is based on the current time\n in the default time zone with the given locale.\n \n If the locale contains the time zone with \"tz\"\n Unicode extension,\n that time zone is used instead."
                },
                {
                  "signature": "public static Calendar getInstance(TimeZone zone, Locale aLocale)",
                  "description": "Gets a calendar with the specified time zone and locale.\n The Calendar returned is based on the current time\n in the given time zone with the given locale."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the getInstance\n methods of this class can return localized instances.\n The array returned must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "computeTime",
              "overloads": [
                {
                  "signature": "protected abstract void computeTime()",
                  "description": "Converts the current calendar field values in fields[]\n to the millisecond time value\n time."
                }
              ]
            },
            {
              "name": "computeFields",
              "overloads": [
                {
                  "signature": "protected abstract void computeFields()",
                  "description": "Converts the current millisecond time value time\n to calendar field values in fields[].\n This allows you to sync up the calendar field values with\n a new time that is set for the calendar.  The time is not\n recomputed first; to recompute the time, then the fields, call the\n complete() method."
                }
              ]
            },
            {
              "name": "getTime",
              "overloads": [
                {
                  "signature": "public final Date getTime()",
                  "description": "Returns a Date object representing this\n Calendar's time value (millisecond offset from the Epoch\")."
                }
              ]
            },
            {
              "name": "setTime",
              "overloads": [
                {
                  "signature": "public final void setTime(Date date)",
                  "description": "Sets this Calendar's time with the given Date.\n \n Note: Calling setTime() with\n Date(Long.MAX_VALUE) or Date(Long.MIN_VALUE)\n may yield incorrect field values from get()."
                }
              ]
            },
            {
              "name": "getTimeInMillis",
              "overloads": [
                {
                  "signature": "public long getTimeInMillis()",
                  "description": "Returns this Calendar's time value in milliseconds."
                }
              ]
            },
            {
              "name": "setTimeInMillis",
              "overloads": [
                {
                  "signature": "public void setTimeInMillis(long millis)",
                  "description": "Sets this Calendar's current time from the given long value."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(int field)",
                  "description": "Returns the value of the given calendar field. In lenient mode,\n all calendar fields are normalized. In non-lenient mode, all\n calendar fields are validated and this method throws an\n exception if any calendar fields have out-of-range values. The\n normalization and validation are handled by the\n complete() method, which process is calendar\n system dependent."
                }
              ]
            },
            {
              "name": "internalGet",
              "overloads": [
                {
                  "signature": "protected final int internalGet(int field)",
                  "description": "Returns the value of the given calendar field. This method does\n not involve normalization or validation of the field value."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public void set(int field, int value)",
                  "description": "Sets the given calendar field to the given value. The value is not\n interpreted by this method regardless of the leniency mode."
                },
                {
                  "signature": "public final void set(int year, int month, int date)",
                  "description": "Sets the values for the calendar fields YEAR,\n MONTH, and DAY_OF_MONTH.\n Previous values of other calendar fields are retained.  If this is not desired,\n call clear() first."
                },
                {
                  "signature": "public final void set(int year, int month, int date, int hourOfDay, int minute)",
                  "description": "Sets the values for the calendar fields YEAR,\n MONTH, DAY_OF_MONTH,\n HOUR_OF_DAY, and MINUTE.\n Previous values of other fields are retained.  If this is not desired,\n call clear() first."
                },
                {
                  "signature": "public final void set(int year, int month, int date, int hourOfDay, int minute, int second)",
                  "description": "Sets the values for the fields YEAR, MONTH,\n DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, and\n SECOND.\n Previous values of other fields are retained.  If this is not desired,\n call clear() first."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final void clear()",
                  "description": "Sets all the calendar field values and the time value\n (millisecond offset from the Epoch) of\n this Calendar undefined. This means that isSet() will return false for all the\n calendar fields, and the date and time calculations will treat\n the fields as if they had never been set. A\n Calendar implementation class may use its specific\n default field values for date/time calculations. For example,\n GregorianCalendar uses 1970 if the\n YEAR field value is undefined."
                },
                {
                  "signature": "public final void clear(int field)",
                  "description": "Sets the given calendar field value and the time value\n (millisecond offset from the Epoch) of\n this Calendar undefined. This means that isSet(field) will return false, and\n the date and time calculations will treat the field as if it\n had never been set. A Calendar implementation\n class may use the field's specific default value for date and\n time calculations.\n\n The HOUR_OF_DAY, HOUR and AM_PM\n fields are handled independently and the the resolution rule for the time of\n day is applied. Clearing one of the fields doesn't reset\n the hour of day value of this Calendar. Use set(Calendar.HOUR_OF_DAY, 0) to reset the hour\n value."
                }
              ]
            },
            {
              "name": "isSet",
              "overloads": [
                {
                  "signature": "public final boolean isSet(int field)",
                  "description": "Determines if the given calendar field has a value set,\n including cases that the value has been set by internal fields\n calculations triggered by a get method call."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName(int field, int style, Locale locale)",
                  "description": "Returns the string representation of the calendar\n field value in the given style and\n locale.  If no string representation is\n applicable, null is returned. This method calls\n get(field) to get the calendar\n field value if the string representation is\n applicable to the given calendar field.\n\n For example, if this Calendar is a\n GregorianCalendar and its date is 2005-01-01, then\n the string representation of the MONTH field would be\n \"January\" in the long style in an English locale or \"Jan\" in\n the short style. However, no string representation would be\n available for the DAY_OF_MONTH field, and this method\n would return null.\n\n The default implementation supports the calendar fields for\n which a DateFormatSymbols has names in the given\n locale."
                }
              ]
            },
            {
              "name": "getDisplayNames",
              "overloads": [
                {
                  "signature": "public Map<String,Integer> getDisplayNames(int field, int style, Locale locale)",
                  "description": "Returns a Map containing all names of the calendar\n field in the given style and\n locale and their corresponding field values. For\n example, if this Calendar is a GregorianCalendar, the returned map would contain \"Jan\" to\n JANUARY, \"Feb\" to FEBRUARY, and so on, in the\n short style in an English locale.\n\n Narrow names may not be unique due to use of single characters,\n such as \"S\" for Sunday and Saturday. In that case narrow names are not\n included in the returned Map.\n\n The values of other calendar fields may be taken into\n account to determine a set of display names. For example, if\n this Calendar is a lunisolar calendar system and\n the year value given by the YEAR field has a leap\n month, this method would return month names containing the leap\n month name, and month names are mapped to their values specific\n for the year.\n\n The default implementation supports display names contained in\n a DateFormatSymbols. For example, if field\n is MONTH and style is ALL_STYLES, this method returns a Map containing\n all strings returned by DateFormatSymbols.getShortMonths()\n and DateFormatSymbols.getMonths()."
                }
              ]
            },
            {
              "name": "complete",
              "overloads": [
                {
                  "signature": "protected void complete()",
                  "description": "Fills in any unset fields in the calendar fields. First, the computeTime() method is called if the time value (millisecond offset\n from the Epoch) has not been calculated from\n calendar field values. Then, the computeFields() method is\n called to calculate all calendar field values."
                }
              ]
            },
            {
              "name": "getAvailableCalendarTypes",
              "overloads": [
                {
                  "signature": "public static Set<String> getAvailableCalendarTypes()",
                  "description": "Returns an unmodifiable Set containing all calendar types\n supported by Calendar in the runtime environment. The available\n calendar types can be used for the Unicode locale extensions.\n The Set returned contains at least \"gregory\". The\n calendar types don't include aliases, such as \"gregorian\" for\n \"gregory\"."
                }
              ]
            },
            {
              "name": "getCalendarType",
              "overloads": [
                {
                  "signature": "public String getCalendarType()",
                  "description": "Returns the calendar type of this Calendar. Calendar types are\n defined by the Unicode Locale Data Markup Language (LDML)\n specification.\n\n The default implementation of this method returns the class name of\n this Calendar instance. Any subclasses that implement\n LDML-defined calendar systems should override this method to return\n appropriate calendar types."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this Calendar to the specified\n Object.  The result is true if and only if\n the argument is a Calendar object of the same calendar\n system that represents the same time value (millisecond offset from the\n Epoch) under the same\n Calendar parameters as this object.\n\n The Calendar parameters are the values represented\n by the isLenient, getFirstDayOfWeek,\n getMinimalDaysInFirstWeek and getTimeZone\n methods. If there is any difference in those parameters\n between the two Calendars, this method returns\n false.\n\n Use the compareTo method to\n compare only the time values."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this calendar."
                }
              ]
            },
            {
              "name": "before",
              "overloads": [
                {
                  "signature": "public boolean before(Object when)",
                  "description": "Returns whether this Calendar represents a time\n before the time represented by the specified\n Object. This method is equivalent to:\n \n         compareTo(when) < 0\n \n if and only if when is a Calendar\n instance. Otherwise, the method returns false."
                }
              ]
            },
            {
              "name": "after",
              "overloads": [
                {
                  "signature": "public boolean after(Object when)",
                  "description": "Returns whether this Calendar represents a time\n after the time represented by the specified\n Object. This method is equivalent to:\n \n         compareTo(when) > 0\n \n if and only if when is a Calendar\n instance. Otherwise, the method returns false."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Calendar anotherCalendar)",
                  "description": "Compares the time values (millisecond offsets from the Epoch) represented by two\n Calendar objects."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public abstract void add(int field, int amount)",
                  "description": "Adds or subtracts the specified amount of time to the given calendar field,\n based on the calendar's rules. For example, to subtract 5 days from\n the current time of the calendar, you can achieve it by calling:\n add(Calendar.DAY_OF_MONTH, -5)."
                }
              ]
            },
            {
              "name": "roll",
              "overloads": [
                {
                  "signature": "public abstract void roll(int field, boolean up)",
                  "description": "Adds or subtracts (up/down) a single unit of time on the given time\n field without changing larger fields. For example, to roll the current\n date up by one day, you can achieve it by calling:\n roll(Calendar.DATE, true).\n When rolling on the year or Calendar.YEAR field, it will roll the year\n value in the range between 1 and the value returned by calling\n getMaximum(Calendar.YEAR).\n When rolling on the month or Calendar.MONTH field, other fields like\n date might conflict and, need to be changed. For instance,\n rolling the month on the date 01/31/96 will result in 02/29/96.\n When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will\n roll the hour value in the range between 0 and 23, which is zero-based."
                },
                {
                  "signature": "public void roll(int field, int amount)",
                  "description": "Adds the specified (signed) amount to the specified calendar field\n without changing larger fields.  A negative amount means to roll\n down.\n\n NOTE:  This default implementation on Calendar just repeatedly calls the\n version of roll() that rolls by one unit.  This may not\n always do the right thing.  For example, if the DAY_OF_MONTH field is 31,\n rolling through February will leave it set to 28.  The GregorianCalendar\n version of this function takes care of this problem.  Other subclasses\n should also provide overrides of this function that do the right thing."
                }
              ]
            },
            {
              "name": "setTimeZone",
              "overloads": [
                {
                  "signature": "public void setTimeZone(TimeZone value)",
                  "description": "Sets the time zone with the given time zone value."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone getTimeZone()",
                  "description": "Gets the time zone."
                }
              ]
            },
            {
              "name": "setLenient",
              "overloads": [
                {
                  "signature": "public void setLenient(boolean lenient)",
                  "description": "Specifies whether or not date/time interpretation is to be lenient.  With\n lenient interpretation, a date such as \"February 942, 1996\" will be\n treated as being equivalent to the 941st day after February 1, 1996.\n With strict (non-lenient) interpretation, such dates will cause an exception to be\n thrown. The default is lenient."
                }
              ]
            },
            {
              "name": "isLenient",
              "overloads": [
                {
                  "signature": "public boolean isLenient()",
                  "description": "Tells whether date/time interpretation is to be lenient."
                }
              ]
            },
            {
              "name": "setFirstDayOfWeek",
              "overloads": [
                {
                  "signature": "public void setFirstDayOfWeek(int value)",
                  "description": "Sets what the first day of the week is; e.g., SUNDAY in the U.S.,\n MONDAY in France."
                }
              ]
            },
            {
              "name": "getFirstDayOfWeek",
              "overloads": [
                {
                  "signature": "public int getFirstDayOfWeek()",
                  "description": "Gets what the first day of the week is; e.g., SUNDAY in the U.S.,\n MONDAY in France."
                }
              ]
            },
            {
              "name": "setMinimalDaysInFirstWeek",
              "overloads": [
                {
                  "signature": "public void setMinimalDaysInFirstWeek(int value)",
                  "description": "Sets what the minimal days required in the first week of the year are;\n For example, if the first week is defined as one that contains the first\n day of the first month of a year, call this method with value 1. If it\n must be a full week, use value 7."
                }
              ]
            },
            {
              "name": "getMinimalDaysInFirstWeek",
              "overloads": [
                {
                  "signature": "public int getMinimalDaysInFirstWeek()",
                  "description": "Gets what the minimal days required in the first week of the year are;\n e.g., if the first week is defined as one that contains the first day\n of the first month of a year, this method returns 1. If\n the minimal days required must be a full week, this method\n returns 7."
                }
              ]
            },
            {
              "name": "isWeekDateSupported",
              "overloads": [
                {
                  "signature": "public boolean isWeekDateSupported()",
                  "description": "Returns whether this Calendar supports week dates.\n\n The default implementation of this method returns false."
                }
              ]
            },
            {
              "name": "getWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeekYear()",
                  "description": "Returns the week year represented by this Calendar. The\n week year is in sync with the week cycle. The first day of the first week is the first\n day of the week year.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "setWeekDate",
              "overloads": [
                {
                  "signature": "public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)",
                  "description": "Sets the date of this Calendar with the given date\n specifiers - week year, week of year, and day of week.\n\n Unlike the set method, all of the calendar fields\n and time values are calculated upon return.\n\n If weekOfYear is out of the valid week-of-year range\n in weekYear, the weekYear and \n weekOfYear values are adjusted in lenient mode, or an \n IllegalArgumentException is thrown in non-lenient mode.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getWeeksInWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeeksInWeekYear()",
                  "description": "Returns the number of weeks in the week year represented by this\n Calendar.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getMinimum",
              "overloads": [
                {
                  "signature": "public abstract int getMinimum(int field)",
                  "description": "Returns the minimum value for the given calendar field of this\n Calendar instance. The minimum value is defined as\n the smallest value returned by the get method\n for any possible time value.  The minimum value depends on\n calendar system specific parameters of the instance."
                }
              ]
            },
            {
              "name": "getMaximum",
              "overloads": [
                {
                  "signature": "public abstract int getMaximum(int field)",
                  "description": "Returns the maximum value for the given calendar field of this\n Calendar instance. The maximum value is defined as\n the largest value returned by the get method\n for any possible time value. The maximum value depends on\n calendar system specific parameters of the instance."
                }
              ]
            },
            {
              "name": "getGreatestMinimum",
              "overloads": [
                {
                  "signature": "public abstract int getGreatestMinimum(int field)",
                  "description": "Returns the highest minimum value for the given calendar field\n of this Calendar instance. The highest minimum\n value is defined as the largest value returned by getActualMinimum(int) for any possible time value. The\n greatest minimum value depends on calendar system specific\n parameters of the instance."
                }
              ]
            },
            {
              "name": "getLeastMaximum",
              "overloads": [
                {
                  "signature": "public abstract int getLeastMaximum(int field)",
                  "description": "Returns the lowest maximum value for the given calendar field\n of this Calendar instance. The lowest maximum\n value is defined as the smallest value returned by getActualMaximum(int) for any possible time value. The least\n maximum value depends on calendar system specific parameters of\n the instance. For example, a Calendar for the\n Gregorian calendar system returns 28 for the\n DAY_OF_MONTH field, because the 28th is the last\n day of the shortest month of this calendar, February in a\n common year."
                }
              ]
            },
            {
              "name": "getActualMinimum",
              "overloads": [
                {
                  "signature": "public int getActualMinimum(int field)",
                  "description": "Returns the minimum value that the specified calendar field\n could have, given the time value of this Calendar.\n\n The default implementation of this method uses an iterative\n algorithm to determine the actual minimum value for the\n calendar field. Subclasses should, if possible, override this\n with a more efficient implementation - in many cases, they can\n simply return getMinimum()."
                }
              ]
            },
            {
              "name": "getActualMaximum",
              "overloads": [
                {
                  "signature": "public int getActualMaximum(int field)",
                  "description": "Returns the maximum value that the specified calendar field\n could have, given the time value of this\n Calendar. For example, the actual maximum value of\n the MONTH field is 12 in some years, and 13 in\n other years in the Hebrew calendar system.\n\n The default implementation of this method uses an iterative\n algorithm to determine the actual maximum value for the\n calendar field. Subclasses should, if possible, override this\n with a more efficient implementation."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates and returns a copy of this object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string representation of this calendar. This method\n is intended to be used only for debugging purposes, and the\n format of the returned string may vary between implementations.\n The returned string may be empty but may not be null."
                }
              ]
            },
            {
              "name": "toInstant",
              "overloads": [
                {
                  "signature": "public final Instant toInstant()",
                  "description": "Converts this object to an Instant.\n \n The conversion creates an Instant that represents the\n same point on the time-line as this Calendar."
                }
              ]
            }
          ]
        },
        {
          "name": "Currency",
          "methods": [
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Currency getInstance(String currencyCode)",
                  "description": "Returns the Currency instance for the given currency code."
                },
                {
                  "signature": "public static Currency getInstance(Locale locale)",
                  "description": "Returns the Currency instance for the country of the\n given locale. The language and variant components of the locale\n are ignored. The result may vary over time, as countries change their\n currencies. For example, for the original member countries of the\n European Monetary Union, the method returns the old national currencies\n until December 31, 2001, and the Euro from January 1, 2002, local time\n of the respective countries.\n \n If the specified locale contains \"cu\" and/or \"rg\"\n Unicode extensions,\n the instance returned from this method reflects\n the values specified with those extensions. If both \"cu\" and \"rg\" are\n specified, the currency from the \"cu\" extension supersedes the implicit one\n from the \"rg\" extension.\n \n The method returns null for territories that don't\n have a currency, such as Antarctica."
                }
              ]
            },
            {
              "name": "getAvailableCurrencies",
              "overloads": [
                {
                  "signature": "public static Set<Currency> getAvailableCurrencies()",
                  "description": "Gets the set of available currencies.  The returned set of currencies\n contains all of the available currencies, which may include currencies\n that represent obsolete ISO 4217 codes.  The set can be modified\n without affecting the available currencies in the runtime."
                }
              ]
            },
            {
              "name": "getCurrencyCode",
              "overloads": [
                {
                  "signature": "public String getCurrencyCode()",
                  "description": "Gets the ISO 4217 currency code of this currency."
                }
              ]
            },
            {
              "name": "getSymbol",
              "overloads": [
                {
                  "signature": "public String getSymbol()",
                  "description": "Gets the symbol of this currency for the default\n DISPLAY locale.\n For example, for the US Dollar, the symbol is \"$\" if the default\n locale is the US, while for other locales it may be \"US$\". If no\n symbol can be determined, the ISO 4217 currency code is returned.\n \n If the default DISPLAY locale\n contains \"rg\" (region override)\n Unicode extension,\n the symbol returned from this method reflects\n the value specified with that extension.\n \n This is equivalent to calling\n getSymbol(Locale.getDefault(Locale.Category.DISPLAY))."
                },
                {
                  "signature": "public String getSymbol(Locale locale)",
                  "description": "Gets the symbol of this currency for the specified locale.\n For example, for the US Dollar, the symbol is \"$\" if the specified\n locale is the US, while for other locales it may be \"US$\". If no\n symbol can be determined, the ISO 4217 currency code is returned.\n \n If the specified locale contains \"rg\" (region override)\n Unicode extension,\n the symbol returned from this method reflects\n the value specified with that extension."
                }
              ]
            },
            {
              "name": "getDefaultFractionDigits",
              "overloads": [
                {
                  "signature": "public int getDefaultFractionDigits()",
                  "description": "Gets the default number of fraction digits used with this currency.\n Note that the number of fraction digits is the same as ISO 4217's\n minor unit for the currency.\n For example, the default number of fraction digits for the Euro is 2,\n while for the Japanese Yen it's 0.\n In the case of pseudo-currencies, such as IMF Special Drawing Rights,\n -1 is returned."
                }
              ]
            },
            {
              "name": "getNumericCode",
              "overloads": [
                {
                  "signature": "public int getNumericCode()",
                  "description": "Returns the ISO 4217 numeric code of this currency."
                }
              ]
            },
            {
              "name": "getNumericCodeAsString",
              "overloads": [
                {
                  "signature": "public String getNumericCodeAsString()",
                  "description": "Returns the 3 digit ISO 4217 numeric code of this currency as a String.\n Unlike getNumericCode(), which returns the numeric code as int,\n this method always returns the numeric code as a 3 digit string.\n e.g. a numeric value of 32 would be returned as \"032\",\n and a numeric value of 6 would be returned as \"006\"."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName()",
                  "description": "Gets the name that is suitable for displaying this currency for\n the default DISPLAY locale.\n If there is no suitable display name found\n for the default locale, the ISO 4217 currency code is returned.\n \n This is equivalent to calling\n getDisplayName(Locale.getDefault(Locale.Category.DISPLAY))."
                },
                {
                  "signature": "public String getDisplayName(Locale locale)",
                  "description": "Gets the name that is suitable for displaying this currency for\n the specified locale.  If there is no suitable display name found\n for the specified locale, the ISO 4217 currency code is returned."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the ISO 4217 currency code of this currency."
                }
              ]
            }
          ]
        },
        {
          "name": "List<E>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this list.  If this list contains\n more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this list contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this list contains the specified element.\n More formally, returns true if and only if this list contains\n at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list in proper sequence."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this list in proper\n sequence (from first to last element).\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this list.  (In other words, this method must\n allocate a new array even if this list is backed by an array).\n The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "<T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this list in\n proper sequence (from first to last element); the runtime type of\n the returned array is that of the specified array.  If the list fits\n in the specified array, it is returned therein.  Otherwise, a new\n array is allocated with the runtime type of the specified array and\n the size of this list.\n\n If the list fits in the specified array with room to spare (i.e.,\n the array has more elements than the list), the element in the array\n immediately following the end of the list is set to null.\n (This is useful in determining the length of the list only if\n the caller knows that the list does not contain any null elements.)\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a list known to contain only strings.\n The following code can be used to dump the list into a newly\n allocated array of String:\n\n \n     String[] y = x.toArray(new String[0]);\n \n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Appends the specified element to the end of this list (optional\n operation).\n\n Lists that support this operation may place limitations on what\n elements may be added to this list.  In particular, some\n lists will refuse to add null elements, and others will impose\n restrictions on the type of elements that may be added.  List\n classes should clearly specify in their documentation any restrictions\n on what elements may be added."
                },
                {
                  "signature": "void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this list\n (optional operation).  Shifts the element currently at that position\n (if any) and any subsequent elements to the right (adds one to their\n indices)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element from this list,\n if it is present (optional operation).  If this list does not contain\n the element, it is unchanged.  More formally, removes the element with\n the lowest index i such that\n Objects.equals(o, get(i))\n (if such an element exists).  Returns true if this list\n contained the specified element (or equivalently, if this list changed\n as a result of the call)."
                },
                {
                  "signature": "E remove(int index)",
                  "description": "Removes the element at the specified position in this list (optional\n operation).  Shifts any subsequent elements to the left (subtracts one\n from their indices).  Returns the element that was removed from the\n list."
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this list contains all of the elements of the\n specified collection."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the specified\n collection's iterator (optional operation).  The behavior of this\n operation is undefined if the specified collection is modified while\n the operation is in progress.  (Note that this will occur if the\n specified collection is this list, and it's nonempty.)"
                },
                {
                  "signature": "boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list at the specified position (optional operation).  Shifts the\n element currently at that position (if any) and any subsequent\n elements to the right (increases their indices).  The new elements\n will appear in this list in the order that they are returned by the\n specified collection's iterator.  The behavior of this operation is\n undefined if the specified collection is modified while the\n operation is in progress.  (Note that this will occur if the specified\n collection is this list, and it's nonempty.)"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll(Collection<?> c)",
                  "description": "Removes from this list all of its elements that are contained in the\n specified collection (optional operation)."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this list that are contained in the\n specified collection (optional operation).  In other words, removes\n from this list all of its elements that are not contained in the\n specified collection."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "default void replaceAll(UnaryOperator<E> operator)",
                  "description": "Replaces each element of this list with the result of applying the\n operator to that element.  Errors or runtime exceptions thrown by\n the operator are relayed to the caller."
                }
              ]
            },
            {
              "name": "sort",
              "overloads": [
                {
                  "signature": "default void sort(Comparator<? super E> c)",
                  "description": "Sorts this list according to the order induced by the specified\n Comparator.  The sort is stable: this method must not\n reorder equal elements.\n\n All elements in this list must be mutually comparable using the\n specified comparator (that is, c.compare(e1, e2) must not throw\n a ClassCastException for any elements e1 and e2\n in the list).\n\n If the specified comparator is null then all elements in this\n list must implement the Comparable interface and the elements'\n natural ordering should be used.\n\n This list must be modifiable, but need not be resizable."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the elements from this list (optional operation).\n The list will be empty after this call returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this list for equality.  Returns\n true if and only if the specified object is also a list, both\n lists have the same size, and all corresponding pairs of elements in\n the two lists are equal.  (Two elements e1 and\n e2 are equal if Objects.equals(e1, e2).)\n In other words, two lists are defined to be\n equal if they contain the same elements in the same order.  This\n definition ensures that the equals method works properly across\n different implementations of the List interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this list.  The hash code of a list\n is defined to be the result of the following calculation:\n \n     int hashCode = 1;\n     for (E e : list)\n         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n \n This ensures that list1.equals(list2) implies that\n list1.hashCode()==list2.hashCode() for any two lists,\n list1 and list2, as required by the general\n contract of Object.hashCode()."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "E get(int index)",
                  "description": "Returns the element at the specified position in this list."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with the\n specified element (optional operation)."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "ListIterator<E> listIterator()",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence)."
                },
                {
                  "signature": "ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.\n The specified index indicates the first element that would be\n returned by an initial call to next.\n An initial call to previous would\n return the element with the specified index minus one."
                }
              ]
            },
            {
              "name": "subList",
              "overloads": [
                {
                  "signature": "List<E> subList(int fromIndex, int toIndex)",
                  "description": "Returns a view of the portion of this list between the specified\n fromIndex, inclusive, and toIndex, exclusive.  (If\n fromIndex and toIndex are equal, the returned list is\n empty.)  The returned list is backed by this list, so non-structural\n changes in the returned list are reflected in this list, and vice-versa.\n The returned list supports all of the optional list operations supported\n by this list.\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n \n      list.subList(from, to).clear();\n \n Similar idioms may be constructed for indexOf and\n lastIndexOf, and all of the algorithms in the\n Collections class can be applied to a subList.\n\n The semantics of the list returned by this method become undefined if\n the backing list (i.e., this list) is structurally modified in\n any way other than via the returned list.  (Structural modifications are\n those that change the size of this list, or otherwise perturb it in such\n a fashion that iterations in progress may yield incorrect results.)"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this list.\n\n The Spliterator reports Spliterator.SIZED and\n Spliterator.ORDERED.  Implementations should document the\n reporting of additional characteristic values."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <E> List<E> of()",
                  "description": "Returns an unmodifiable list containing zero elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1)",
                  "description": "Returns an unmodifiable list containing one element.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2)",
                  "description": "Returns an unmodifiable list containing two elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3)",
                  "description": "Returns an unmodifiable list containing three elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4)",
                  "description": "Returns an unmodifiable list containing four elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)",
                  "description": "Returns an unmodifiable list containing five elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6)",
                  "description": "Returns an unmodifiable list containing six elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)",
                  "description": "Returns an unmodifiable list containing seven elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)",
                  "description": "Returns an unmodifiable list containing eight elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)",
                  "description": "Returns an unmodifiable list containing nine elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)",
                  "description": "Returns an unmodifiable list containing ten elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "@SafeVarargs static <E> List<E> of(E... elements)",
                  "description": "Returns an unmodifiable list containing an arbitrary number of elements.\n See Unmodifiable Lists for details."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <E> List<E> copyOf(Collection<? extends E> coll)",
                  "description": "Returns an unmodifiable List containing the elements of\n the given Collection, in its iteration order. The given Collection must not be null,\n and it must not contain any null elements. If the given Collection is subsequently\n modified, the returned List will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "Locale",
          "methods": [
            {
              "name": "Locale",
              "overloads": [
                {
                  "signature": "public Locale(String language, String country, String variant)",
                  "description": "Construct a locale from language, country and variant.\n This constructor normalizes the language value to lowercase and\n the country value to uppercase."
                },
                {
                  "signature": "public Locale(String language, String country)",
                  "description": "Construct a locale from language and country.\n This constructor normalizes the language value to lowercase and\n the country value to uppercase."
                },
                {
                  "signature": "public Locale(String language)",
                  "description": "Construct a locale from a language code.\n This constructor normalizes the language value to lowercase."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static Locale getDefault()",
                  "description": "Gets the current value of the default locale for this instance\n of the Java Virtual Machine.\n \n The Java Virtual Machine sets the default locale during startup\n based on the host environment. It is used by many locale-sensitive\n methods if no locale is explicitly specified.\n It can be changed using the\n setDefault method."
                },
                {
                  "signature": "public static Locale getDefault(Locale.Category category)",
                  "description": "Gets the current value of the default locale for the specified Category\n for this instance of the Java Virtual Machine.\n \n The Java Virtual Machine sets the default locale during startup based\n on the host environment. It is used by many locale-sensitive methods\n if no locale is explicitly specified. It can be changed using the\n setDefault(Locale.Category, Locale) method."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(Locale newLocale)",
                  "description": "Sets the default locale for this instance of the Java Virtual Machine.\n This does not affect the host locale.\n \n If there is a security manager, its checkPermission\n method is called with a PropertyPermission(\"user.language\", \"write\")\n permission before the default locale is changed.\n \n The Java Virtual Machine sets the default locale during startup\n based on the host environment. It is used by many locale-sensitive\n methods if no locale is explicitly specified.\n \n Since changing the default locale may affect many different areas\n of functionality, this method should only be used if the caller\n is prepared to reinitialize locale-sensitive code running\n within the same Java Virtual Machine.\n \n By setting the default locale with this method, all of the default\n locales for each Category are also set to the specified default locale."
                },
                {
                  "signature": "public static void setDefault(Locale.Category category, Locale newLocale)",
                  "description": "Sets the default locale for the specified Category for this instance\n of the Java Virtual Machine. This does not affect the host locale.\n \n If there is a security manager, its checkPermission method is called\n with a PropertyPermission(\"user.language\", \"write\") permission before\n the default locale is changed.\n \n The Java Virtual Machine sets the default locale during startup based\n on the host environment. It is used by many locale-sensitive methods\n if no locale is explicitly specified.\n \n Since changing the default locale may affect many different areas of\n functionality, this method should only be used if the caller is\n prepared to reinitialize locale-sensitive code running within the\n same Java Virtual Machine."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all installed locales.\n The returned array represents the union of locales supported\n by the Java runtime environment and by installed\n LocaleServiceProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getISOCountries",
              "overloads": [
                {
                  "signature": "public static String[] getISOCountries()",
                  "description": "Returns a list of all 2-letter country codes defined in ISO 3166.\n Can be used to create Locales.\n This method is equivalent to getISOCountries(Locale.IsoCountryCode type)\n with type  Locale.IsoCountryCode.PART1_ALPHA2.\n \n Note: The Locale class also supports other codes for\n country (region), such as 3-letter numeric UN M.49 area codes.\n Therefore, the list returned by this method does not contain ALL valid\n codes that can be used to create Locales.\n \n Note that this method does not return obsolete 2-letter country codes.\n ISO3166-3 codes which designate country codes for those obsolete codes,\n can be retrieved from getISOCountries(Locale.IsoCountryCode type) with\n type  Locale.IsoCountryCode.PART3."
                },
                {
                  "signature": "public static Set<String> getISOCountries(Locale.IsoCountryCode type)",
                  "description": "Returns a Set of ISO3166 country codes for the specified type."
                }
              ]
            },
            {
              "name": "getISOLanguages",
              "overloads": [
                {
                  "signature": "public static String[] getISOLanguages()",
                  "description": "Returns a list of all 2-letter language codes defined in ISO 639.\n Can be used to create Locales.\n \n Note:\n \n ISO 639 is not a stable standard some languages' codes have changed.\n The list this function returns includes both the new and the old codes for the\n languages whose codes have changed.\n The Locale class also supports language codes up to\n 8 characters in length.  Therefore, the list returned by this method does\n not contain ALL valid codes that can be used to create Locales."
                }
              ]
            },
            {
              "name": "getLanguage",
              "overloads": [
                {
                  "signature": "public String getLanguage()",
                  "description": "Returns the language code of this Locale."
                }
              ]
            },
            {
              "name": "getScript",
              "overloads": [
                {
                  "signature": "public String getScript()",
                  "description": "Returns the script for this locale, which should\n either be the empty string or an ISO 15924 4-letter script\n code. The first letter is uppercase and the rest are\n lowercase, for example, 'Latn', 'Cyrl'."
                }
              ]
            },
            {
              "name": "getCountry",
              "overloads": [
                {
                  "signature": "public String getCountry()",
                  "description": "Returns the country/region code for this locale, which should\n either be the empty string, an uppercase ISO 3166 2-letter code,\n or a UN M.49 3-digit code."
                }
              ]
            },
            {
              "name": "getVariant",
              "overloads": [
                {
                  "signature": "public String getVariant()",
                  "description": "Returns the variant code for this locale."
                }
              ]
            },
            {
              "name": "hasExtensions",
              "overloads": [
                {
                  "signature": "public boolean hasExtensions()",
                  "description": "Returns true if this Locale has any \n extensions."
                }
              ]
            },
            {
              "name": "stripExtensions",
              "overloads": [
                {
                  "signature": "public Locale stripExtensions()",
                  "description": "Returns a copy of this Locale with no \n extensions. If this Locale has no extensions, this Locale\n is returned."
                }
              ]
            },
            {
              "name": "getExtension",
              "overloads": [
                {
                  "signature": "public String getExtension(char key)",
                  "description": "Returns the extension (or private use) value associated with\n the specified key, or null if there is no extension\n associated with the key. To be well-formed, the key must be one\n of [0-9A-Za-z]. Keys are case-insensitive, so\n for example 'z' and 'Z' represent the same extension."
                }
              ]
            },
            {
              "name": "getExtensionKeys",
              "overloads": [
                {
                  "signature": "public Set<Character> getExtensionKeys()",
                  "description": "Returns the set of extension keys associated with this locale, or the\n empty set if it has no extensions. The returned set is unmodifiable.\n The keys will all be lower-case."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleAttributes",
              "overloads": [
                {
                  "signature": "public Set<String> getUnicodeLocaleAttributes()",
                  "description": "Returns the set of unicode locale attributes associated with\n this locale, or the empty set if it has no attributes. The\n returned set is unmodifiable."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleType",
              "overloads": [
                {
                  "signature": "public String getUnicodeLocaleType(String key)",
                  "description": "Returns the Unicode locale type associated with the specified Unicode locale key\n for this locale. Returns the empty string for keys that are defined with no type.\n Returns null if the key is not defined. Keys are case-insensitive. The key must\n be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is\n thrown."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleKeys",
              "overloads": [
                {
                  "signature": "public Set<String> getUnicodeLocaleKeys()",
                  "description": "Returns the set of Unicode locale keys defined by this locale, or the empty set if\n this locale has none.  The returned set is immutable.  Keys are all lower case."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns a string representation of this Locale\n object, consisting of language, country, variant, script,\n and extensions as below:\n \n language + \"_\" + country + \"_\" + (variant + \"_#\" | \"#\") + script + \"_\" + extensions\n \n\n Language is always lower case, country is always upper case, script is always title\n case, and extensions are always lower case.  Extensions and private use subtags\n will be in canonical order as explained in toLanguageTag().\n\n When the locale has neither script nor extensions, the result is the same as in\n Java 6 and prior.\n\n If both the language and country fields are missing, this function will return\n the empty string, even if the variant, script, or extensions field is present (you\n can't have a locale with just a variant, the variant must accompany a well-formed\n language or country code).\n\n If script or extensions are present and variant is missing, no underscore is\n added before the \"#\".\n\n This behavior is designed to support debugging and to be compatible with\n previous uses of toString that expected language, country, and variant\n fields only.  To represent a Locale as a String for interchange purposes, use\n toLanguageTag().\n\n Examples: \n en\n de_DE\n _GB\n en_US_WIN\n de__POSIX\n zh_CN_#Hans\n zh_TW_#Hant_x-java\n th_TH_TH_#u-nu-thai"
                }
              ]
            },
            {
              "name": "toLanguageTag",
              "overloads": [
                {
                  "signature": "public String toLanguageTag()",
                  "description": "Returns a well-formed IETF BCP 47 language tag representing\n this locale.\n\n If this Locale has a language, country, or\n variant that does not satisfy the IETF BCP 47 language tag\n syntax requirements, this method handles these fields as\n described below:\n\n Language: If language is empty, or not well-formed (for example \"a\" or\n \"e2\"), it will be emitted as \"und\" (Undetermined).\n\n Country: If country is not well-formed (for example \"12\" or \"USA\"),\n it will be omitted.\n\n Variant: If variant is well-formed, each sub-segment\n (delimited by '-' or '_') is emitted as a subtag.  Otherwise:\n \n\n if all sub-segments match [0-9a-zA-Z]{1,8}\n (for example \"WIN\" or \"Oracle_JDK_Standard_Edition\"), the first\n ill-formed sub-segment and all following will be appended to\n the private use subtag.  The first appended subtag will be\n \"lvariant\", followed by the sub-segments in order, separated by\n hyphen. For example, \"x-lvariant-WIN\",\n \"Oracle-x-lvariant-JDK-Standard-Edition\".\n\n if any sub-segment does not match\n [0-9a-zA-Z]{1,8}, the variant will be truncated\n and the problematic sub-segment and all following sub-segments\n will be omitted.  If the remainder is non-empty, it will be\n emitted as a private use subtag as above (even if the remainder\n turns out to be well-formed).  For example,\n \"Solaris_isjustthecoolestthing\" is emitted as\n \"x-lvariant-Solaris\", not as \"solaris\".\n\n Special Conversions: Java supports some old locale\n representations, including deprecated ISO language codes,\n for compatibility. This method performs the following\n conversions:\n \n\n Deprecated ISO language codes \"iw\", \"ji\", and \"in\" are\n converted to \"he\", \"yi\", and \"id\", respectively.\n\n A locale with language \"no\", country \"NO\", and variant\n \"NY\", representing Norwegian Nynorsk (Norway), is converted\n to a language tag \"nn-NO\".\n\n Note: Although the language tag created by this\n method is well-formed (satisfies the syntax requirements\n defined by the IETF BCP 47 specification), it is not\n necessarily a valid BCP 47 language tag.  For example,\n    new Locale(\"xx\", \"YY\").toLanguageTag();\n\n will return \"xx-YY\", but the language subtag \"xx\" and the\n region subtag \"YY\" are invalid because they are not registered\n in the IANA Language Subtag Registry."
                }
              ]
            },
            {
              "name": "forLanguageTag",
              "overloads": [
                {
                  "signature": "public static Locale forLanguageTag(String languageTag)",
                  "description": "Returns a locale for the specified IETF BCP 47 language tag string.\n\n If the specified language tag contains any ill-formed subtags,\n the first such subtag and all following subtags are ignored.  Compare\n to Locale.Builder.setLanguageTag(java.lang.String) which throws an exception\n in this case.\n\n The following conversions are performed:\n\n The language code \"und\" is mapped to language \"\".\n\n The language codes \"iw\", \"ji\", and \"in\" are mapped to \"he\",\n \"yi\", and \"id\" respectively. (This is the same canonicalization\n that's done in Locale's constructors.) See\n Legacy language codes\n for more information.\n\n The portion of a private use subtag prefixed by \"lvariant\",\n if any, is removed and appended to the variant field in the\n result locale (without case normalization).  If it is then\n empty, the private use subtag is discarded:\n\n      Locale loc;\n     loc = Locale.forLanguageTag(\"en-US-x-lvariant-POSIX\");\n     loc.getVariant(); // returns \"POSIX\"\n     loc.getExtension('x'); // returns null\n\n     loc = Locale.forLanguageTag(\"de-POSIX-x-URP-lvariant-Abc-Def\");\n     loc.getVariant(); // returns \"POSIX_Abc_Def\"\n     loc.getExtension('x'); // returns \"urp\"\n \n\n When the languageTag argument contains an extlang subtag,\n the first such subtag is used as the language, and the primary\n language subtag and other extlang subtags are ignored:\n\n      Locale.forLanguageTag(\"ar-aao\").getLanguage(); // returns \"aao\"\n     Locale.forLanguageTag(\"en-abc-def-us\").toString(); // returns \"abc_US\"\n \n\n Case is normalized except for variant tags, which are left\n unchanged.  Language is normalized to lower case, script to\n title case, country to upper case, and extensions to lower\n case.\n\n If, after processing, the locale would exactly match either\n ja_JP_JP or th_TH_TH with no extensions, the appropriate\n extensions are added as though the constructor had been called:\n\n     Locale.forLanguageTag(\"ja-JP-x-lvariant-JP\").toLanguageTag();\n    // returns \"ja-JP-u-ca-japanese-x-lvariant-JP\"\n    Locale.forLanguageTag(\"th-TH-x-lvariant-TH\").toLanguageTag();\n    // returns \"th-TH-u-nu-thai-x-lvariant-TH\"\n \n\n This implements the 'Language-Tag' production of BCP47, and\n so supports legacy (regular and irregular, referred to as\n \"Type: grandfathered\" in BCP47) as well as\n private use language tags.  Stand alone private use tags are\n represented as empty language and extension 'x-whatever',\n and legacy tags are converted to their canonical replacements\n where they exist.\n\n Legacy tags with canonical replacements are as follows:\n\n \n Legacy tags with canonical replacements\n \n legacy tagmodern replacement\n \n \n art-lojbanjbo\n i-amiami\n i-bnnbnn\n i-hakhak\n i-klingontlh\n i-luxlb\n i-navajonv\n i-pwnpwn\n i-taotao\n i-taytay\n i-tsutsu\n no-boknb\n no-nynnn\n sgn-BE-FRsfb\n sgn-BE-NLvgt\n sgn-CH-DEsgg\n zh-guoyucmn\n zh-hakkahak\n zh-min-nannan\n zh-xianghsn\n \n \n\n Legacy tags with no modern replacement will be\n converted as follows:\n\n \n Legacy tags with no modern replacement\n \n legacy tagconverts to\n \n \n cel-gaulishxtg-x-cel-gaulish\n en-GB-oeden-GB-x-oed\n i-defaulten-x-i-default\n i-enochianund-x-i-enochian\n i-mingosee-x-i-mingo\n zh-minnan-x-zh-min\n \n \n\n For a list of all legacy tags, see the\n IANA Language Subtag Registry (search for \"Type: grandfathered\").\n\n Note: there is no guarantee that toLanguageTag\n and forLanguageTag will round-trip."
                }
              ]
            },
            {
              "name": "getISO3Language",
              "overloads": [
                {
                  "signature": "public String getISO3Language() throws MissingResourceException",
                  "description": "Returns a three-letter abbreviation of this locale's language.\n If the language matches an ISO 639-1 two-letter code, the\n corresponding ISO 639-2/T three-letter lowercase code is\n returned.  The ISO 639-2 language codes can be found on-line,\n see \"Codes for the Representation of Names of Languages Part 2:\n Alpha-3 Code\".  If the locale specifies a three-letter\n language, the language is returned as is.  If the locale does\n not specify a language the empty string is returned."
                }
              ]
            },
            {
              "name": "getISO3Country",
              "overloads": [
                {
                  "signature": "public String getISO3Country() throws MissingResourceException",
                  "description": "Returns a three-letter abbreviation for this locale's country.\n If the country matches an ISO 3166-1 alpha-2 code, the\n corresponding ISO 3166-1 alpha-3 uppercase code is returned.\n If the locale doesn't specify a country, this will be the empty\n string.\n\n The ISO 3166-1 codes can be found on-line."
                }
              ]
            },
            {
              "name": "getDisplayLanguage",
              "overloads": [
                {
                  "signature": "public final String getDisplayLanguage()",
                  "description": "Returns a name for the locale's language that is appropriate for display to the\n user.\n If possible, the name returned will be localized for the default\n DISPLAY locale.\n For example, if the locale is fr_FR and the default\n DISPLAY locale\n is en_US, getDisplayLanguage() will return \"French\"; if the locale is en_US and\n the default DISPLAY locale is fr_FR,\n getDisplayLanguage() will return \"anglais\".\n If the name returned cannot be localized for the default\n DISPLAY locale,\n (say, we don't have a Japanese name for Croatian),\n this function falls back on the English name, and uses the ISO code as a last-resort\n value.  If the locale doesn't specify a language, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayLanguage(Locale inLocale)",
                  "description": "Returns a name for the locale's language that is appropriate for display to the\n user.\n If possible, the name returned will be localized according to inLocale.\n For example, if the locale is fr_FR and inLocale\n is en_US, getDisplayLanguage() will return \"French\"; if the locale is en_US and\n inLocale is fr_FR, getDisplayLanguage() will return \"anglais\".\n If the name returned cannot be localized according to inLocale,\n (say, we don't have a Japanese name for Croatian),\n this function falls back on the English name, and finally\n on the ISO code as a last-resort value.  If the locale doesn't specify a language,\n this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayScript",
              "overloads": [
                {
                  "signature": "public String getDisplayScript()",
                  "description": "Returns a name for the locale's script that is appropriate for display to\n the user. If possible, the name will be localized for the default\n DISPLAY locale.  Returns\n the empty string if this locale doesn't specify a script code."
                },
                {
                  "signature": "public String getDisplayScript(Locale inLocale)",
                  "description": "Returns a name for the locale's script that is appropriate\n for display to the user. If possible, the name will be\n localized for the given locale. Returns the empty string if\n this locale doesn't specify a script code."
                }
              ]
            },
            {
              "name": "getDisplayCountry",
              "overloads": [
                {
                  "signature": "public final String getDisplayCountry()",
                  "description": "Returns a name for the locale's country that is appropriate for display to the\n user.\n If possible, the name returned will be localized for the default\n DISPLAY locale.\n For example, if the locale is fr_FR and the default\n DISPLAY locale\n is en_US, getDisplayCountry() will return \"France\"; if the locale is en_US and\n the default DISPLAY locale is fr_FR,\n getDisplayCountry() will return \"Etats-Unis\".\n If the name returned cannot be localized for the default\n DISPLAY locale,\n (say, we don't have a Japanese name for Croatia),\n this function falls back on the English name, and uses the ISO code as a last-resort\n value.  If the locale doesn't specify a country, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayCountry(Locale inLocale)",
                  "description": "Returns a name for the locale's country that is appropriate for display to the\n user.\n If possible, the name returned will be localized according to inLocale.\n For example, if the locale is fr_FR and inLocale\n is en_US, getDisplayCountry() will return \"France\"; if the locale is en_US and\n inLocale is fr_FR, getDisplayCountry() will return \"Etats-Unis\".\n If the name returned cannot be localized according to inLocale.\n (say, we don't have a Japanese name for Croatia),\n this function falls back on the English name, and finally\n on the ISO code as a last-resort value.  If the locale doesn't specify a country,\n this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayVariant",
              "overloads": [
                {
                  "signature": "public final String getDisplayVariant()",
                  "description": "Returns a name for the locale's variant code that is appropriate for display to the\n user.  If possible, the name will be localized for the default\n DISPLAY locale.  If the locale\n doesn't specify a variant code, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayVariant(Locale inLocale)",
                  "description": "Returns a name for the locale's variant code that is appropriate for display to the\n user.  If possible, the name will be localized for inLocale.  If the locale\n doesn't specify a variant code, this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public final String getDisplayName()",
                  "description": "Returns a name for the locale that is appropriate for display to the\n user. This will be the values returned by getDisplayLanguage(),\n getDisplayScript(), getDisplayCountry(), getDisplayVariant() and\n optional Unicode extensions\n assembled into a single string. The non-empty values are used in order, with\n the second and subsequent names in parentheses.  For example:\n \n language (script, country, variant(, extension)*)\n language (country(, extension)*)\n language (variant(, extension)*)\n script (country(, extension)*)\n country (extension)*\n \n depending on which fields are specified in the locale. The field\n separator in the above parentheses, denoted as a comma character, may\n be localized depending on the locale. If the language, script, country,\n and variant fields are all empty, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayName(Locale inLocale)",
                  "description": "Returns a name for the locale that is appropriate for display\n to the user.  This will be the values returned by\n getDisplayLanguage(), getDisplayScript(),getDisplayCountry()\n getDisplayVariant(), and optional \n Unicode extensions assembled into a single string. The non-empty\n values are used in order, with the second and subsequent names in\n parentheses.  For example:\n \n language (script, country, variant(, extension)*)\n language (country(, extension)*)\n language (variant(, extension)*)\n script (country(, extension)*)\n country (extension)*\n \n depending on which fields are specified in the locale. The field\n separator in the above parentheses, denoted as a comma character, may\n be localized depending on the locale. If the language, script, country,\n and variant fields are all empty, this function returns the empty string."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode.\n Since Locales are often used in hashtables, caches the value\n for speed."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if this Locale is equal to another object.  A Locale is\n deemed equal to another Locale with identical language, script, country,\n variant and extensions, and unequal to all other objects."
                }
              ]
            },
            {
              "name": "filter",
              "overloads": [
                {
                  "signature": "public static List<Locale> filter(List<Locale.LanguageRange> priorityList, Collection<Locale> locales, Locale.FilteringMode mode)",
                  "description": "Returns a list of matching Locale instances using the filtering\n mechanism defined in RFC 4647.\n\n This filter operation on the given locales ensures that only\n unique matching locale(s) are returned."
                },
                {
                  "signature": "public static List<Locale> filter(List<Locale.LanguageRange> priorityList, Collection<Locale> locales)",
                  "description": "Returns a list of matching Locale instances using the filtering\n mechanism defined in RFC 4647. This is equivalent to\n filter(List, Collection, FilteringMode) when mode is\n Locale.FilteringMode.AUTOSELECT_FILTERING.\n\n This filter operation on the given locales ensures that only\n unique matching locale(s) are returned."
                }
              ]
            },
            {
              "name": "filterTags",
              "overloads": [
                {
                  "signature": "public static List<String> filterTags(List<Locale.LanguageRange> priorityList, Collection<String> tags, Locale.FilteringMode mode)",
                  "description": "Returns a list of matching languages tags using the basic filtering\n mechanism defined in RFC 4647.\n\n This filter operation on the given tags ensures that only\n unique matching tag(s) are returned with preserved case. In case of\n duplicate matching tags with the case difference, the first matching\n tag with preserved case is returned.\n For example, \"de-ch\" is returned out of the duplicate matching tags\n \"de-ch\" and \"de-CH\", if \"de-ch\" is checked first for matching in the\n given tags. Note that if the given tags is an unordered\n Collection, the returned matching tag out of duplicate tags is\n subject to change, depending on the implementation of the\n Collection."
                },
                {
                  "signature": "public static List<String> filterTags(List<Locale.LanguageRange> priorityList, Collection<String> tags)",
                  "description": "Returns a list of matching languages tags using the basic filtering\n mechanism defined in RFC 4647. This is equivalent to\n filterTags(List, Collection, FilteringMode) when mode\n is Locale.FilteringMode.AUTOSELECT_FILTERING.\n\n This filter operation on the given tags ensures that only\n unique matching tag(s) are returned with preserved case. In case of\n duplicate matching tags with the case difference, the first matching\n tag with preserved case is returned.\n For example, \"de-ch\" is returned out of the duplicate matching tags\n \"de-ch\" and \"de-CH\", if \"de-ch\" is checked first for matching in the\n given tags. Note that if the given tags is an unordered\n Collection, the returned matching tag out of duplicate tags is\n subject to change, depending on the implementation of the\n Collection."
                }
              ]
            },
            {
              "name": "lookup",
              "overloads": [
                {
                  "signature": "public static Locale lookup(List<Locale.LanguageRange> priorityList, Collection<Locale> locales)",
                  "description": "Returns a Locale instance for the best-matching language\n tag using the lookup mechanism defined in RFC 4647."
                }
              ]
            },
            {
              "name": "lookupTag",
              "overloads": [
                {
                  "signature": "public static String lookupTag(List<Locale.LanguageRange> priorityList, Collection<String> tags)",
                  "description": "Returns the best-matching language tag using the lookup mechanism\n defined in RFC 4647.\n\n This lookup operation on the given tags ensures that the\n first matching tag with preserved case is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Map<K,V>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of key-value mappings in this map.  If the\n map contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this map contains no key-value mappings."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the specified\n key.  More formally, returns true if and only if\n this map contains a mapping for a key k such that\n Objects.equals(key, k).  (There can be\n at most one such mapping.)"
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value.  More formally, returns true if and only if\n this map contains at least one mapping to a value v such that\n Objects.equals(value, v).  This operation\n will probably require time linear in the map size for most\n implementations of the Map interface."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that\n Objects.equals(key, k),\n then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contains no mapping for the key; it's also possible that the map\n explicitly maps the key to null.  The containsKey operation may be used to distinguish these two cases."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map\n (optional operation).  If the map previously contained a mapping for\n the key, the old value is replaced by the specified value.  (A map\n m is said to contain a mapping for a key k if and only\n if m.containsKey(k) would return\n true.)"
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "V remove(Object key)",
                  "description": "Removes the mapping for a key from this map if it is present\n (optional operation).   More formally, if this map contains a mapping\n from key k to value v such that\n Objects.equals(key, k), that mapping\n is removed.  (The map can contain at most one such mapping.)\n\n Returns the value to which this map previously associated the key,\n or null if the map contained no mapping for the key.\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contained no mapping for the key; it's also possible that the map\n explicitly mapped the key to null.\n\n The map will not contain a mapping for the specified key once the\n call returns."
                },
                {
                  "signature": "default boolean remove(Object key, Object value)",
                  "description": "Removes the entry for the specified key only if it is currently\n mapped to the specified value."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map\n (optional operation).  The effect of this call is equivalent to that\n of calling put(k, v) on this map once\n for each mapping from key k to value v in the\n specified map.  The behavior of this operation is undefined if the\n specified map is modified while the operation is in progress."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the mappings from this map (optional operation).\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent the same mappings.  More formally, two maps m1 and\n m2 represent the same mappings if\n m1.entrySet().equals(m2.entrySet()).  This ensures that the\n equals method works properly across different implementations\n of the Map interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map's\n entrySet() view.  This ensures that m1.equals(m2)\n implies that m1.hashCode()==m2.hashCode() for any two maps\n m1 and m2, as required by the general contract of\n Object.hashCode()."
                }
              ]
            },
            {
              "name": "getOrDefault",
              "overloads": [
                {
                  "signature": "default V getOrDefault(Object key, V defaultValue)",
                  "description": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "default void forEach(BiConsumer<? super K,? super V> action)",
                  "description": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.   Unless\n otherwise specified by the implementing class, actions are performed in\n the order of entry set iteration (if an iteration order is specified.)\n Exceptions thrown by the action are relayed to the caller."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "default void replaceAll(BiFunction<? super K,? super V,? extends V> function)",
                  "description": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.  Exceptions thrown by the function are\n relayed to the caller."
                }
              ]
            },
            {
              "name": "putIfAbsent",
              "overloads": [
                {
                  "signature": "default V putIfAbsent(K key, V value)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "default boolean replace(K key, V oldValue, V newValue)",
                  "description": "Replaces the entry for the specified key only if currently\n mapped to the specified value."
                },
                {
                  "signature": "default V replace(K key, V value)",
                  "description": "Replaces the entry for the specified key only if it is\n currently mapped to some value."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "default V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \n\n Or to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \n\n The mapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "default V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "default V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "default V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <K, V> Map<K,V> of()",
                  "description": "Returns an unmodifiable map containing zero mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1)",
                  "description": "Returns an unmodifiable map containing a single mapping.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2)",
                  "description": "Returns an unmodifiable map containing two mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3)",
                  "description": "Returns an unmodifiable map containing three mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)",
                  "description": "Returns an unmodifiable map containing four mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)",
                  "description": "Returns an unmodifiable map containing five mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)",
                  "description": "Returns an unmodifiable map containing six mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)",
                  "description": "Returns an unmodifiable map containing seven mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)",
                  "description": "Returns an unmodifiable map containing eight mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)",
                  "description": "Returns an unmodifiable map containing nine mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)",
                  "description": "Returns an unmodifiable map containing ten mappings.\n See Unmodifiable Maps for details."
                }
              ]
            },
            {
              "name": "ofEntries",
              "overloads": [
                {
                  "signature": "@SafeVarargs static <K, V> Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)",
                  "description": "Returns an unmodifiable map containing keys and values extracted from the given entries.\n The entries themselves are not stored in the map.\n See Unmodifiable Maps for details."
                }
              ]
            },
            {
              "name": "entry",
              "overloads": [
                {
                  "signature": "static <K, V> Map.Entry<K,V> entry(K k, V v)",
                  "description": "Returns an unmodifiable Map.Entry containing the given key and value.\n These entries are suitable for populating Map instances using the\n Map.ofEntries() method.\n The Entry instances created by this method have the following characteristics:\n\n \n They disallow null keys and values. Attempts to create them using a null\n key or value result in NullPointerException.\n They are unmodifiable. Calls to Entry.setValue()\n on a returned Entry result in UnsupportedOperationException.\n They are not serializable.\n They are value-based.\n Programmers should treat instances that are equal\n as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. This method is free to\n create new instances or reuse existing ones."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <K, V> Map<K,V> copyOf(Map<? extends K,? extends V> map)",
                  "description": "Returns an unmodifiable Map containing the entries\n of the given Map. The given Map must not be null, and it must not contain any\n null keys or values. If the given Map is subsequently modified, the returned\n Map will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "ResourceBundle.Control",
          "methods": [
            {
              "name": "Control",
              "overloads": [
                {
                  "signature": "protected Control()",
                  "description": "Sole constructor. (For invocation by subclass constructors,\n typically implicit.)"
                }
              ]
            },
            {
              "name": "getControl",
              "overloads": [
                {
                  "signature": "public static final ResourceBundle.Control getControl(List<String> formats)",
                  "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats. The formats must be equal to\n one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT. ResourceBundle.Control\n instances returned by this method are singletons and thread-safe.\n\n Specifying FORMAT_DEFAULT is equivalent to\n instantiating the ResourceBundle.Control class,\n except that this method returns a singleton."
                }
              ]
            },
            {
              "name": "getNoFallbackControl",
              "overloads": [
                {
                  "signature": "public static final ResourceBundle.Control getNoFallbackControl(List<String> formats)",
                  "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats and the getFallbackLocale\n method returns null. The formats must\n be equal to one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT.\n ResourceBundle.Control instances returned by this\n method are singletons and thread-safe."
                }
              ]
            },
            {
              "name": "getFormats",
              "overloads": [
                {
                  "signature": "public List<String> getFormats(String baseName)",
                  "description": "Returns a List of Strings containing\n formats to be used to load resource bundles for the given\n baseName. The ResourceBundle.getBundle\n factory method tries to load resource bundles with formats in the\n order specified by the list. The list returned by this method\n must have at least one String. The predefined\n formats are \"java.class\" for class-based resource\n bundles and \"java.properties\" for properties-based ones. Strings starting\n with \"java.\" are reserved for future extensions and\n must not be used by application-defined formats.\n\n It is not a requirement to return an immutable (unmodifiable)\n List.  However, the returned List must\n not be mutated after it has been returned by\n getFormats.\n\n The default implementation returns FORMAT_DEFAULT so\n that the ResourceBundle.getBundle factory method\n looks up first class-based resource bundles, then\n properties-based ones."
                }
              ]
            },
            {
              "name": "getCandidateLocales",
              "overloads": [
                {
                  "signature": "public List<Locale> getCandidateLocales(String baseName, Locale locale)",
                  "description": "Returns a List of Locales as candidate\n locales for baseName and locale. This\n method is called by the ResourceBundle.getBundle\n factory method each time the factory method tries finding a\n resource bundle for a target Locale.\n\n The sequence of the candidate locales also corresponds to the\n runtime resource lookup path (also known as the parent\n chain), if the corresponding resource bundles for the\n candidate locales exist and their parents are not defined by\n loaded resource bundles themselves.  The last element of the list\n must be a root locale if it is desired to\n have the base bundle as the terminal of the parent chain.\n\n If the given locale is equal to Locale.ROOT (the\n root locale), a List containing only the root\n Locale must be returned. In this case, the\n ResourceBundle.getBundle factory method loads only\n the base bundle as the resulting resource bundle.\n\n It is not a requirement to return an immutable (unmodifiable)\n List. However, the returned List must not\n be mutated after it has been returned by\n getCandidateLocales.\n\n The default implementation returns a List containing\n Locales using the rules described below.  In the\n description below, L, S, C and V\n respectively represent non-empty language, script, country, and\n variant.  For example, [L, C] represents a\n Locale that has non-empty values only for language and\n country.  The form L(\"xx\") represents the (non-empty)\n language value is \"xx\".  For all cases, Locales whose\n final component values are empty strings are omitted.\n\n For an input Locale with an empty script value,\n append candidate Locales by omitting the final component\n one by one as below:\n\n \n  [L, C, V] \n  [L, C] \n  [L] \n  Locale.ROOT \n \n\n For an input Locale with a non-empty script value,\n append candidate Locales by omitting the final component\n up to language, then append candidates generated from the\n Locale with country and variant restored:\n\n \n  [L, S, C, V]\n  [L, S, C]\n  [L, S]\n  [L, C, V]\n  [L, C]\n  [L]\n  Locale.ROOT\n \n\n For an input Locale with a variant value consisting\n of multiple subtags separated by underscore, generate candidate\n Locales by omitting the variant subtags one by one, then\n insert them after every occurrence of  Locales with the\n full variant value in the original list.  For example, if\n the variant consists of two subtags V1 and V2:\n\n \n  [L, S, C, V1, V2]\n  [L, S, C, V1]\n  [L, S, C]\n  [L, S]\n  [L, C, V1, V2]\n  [L, C, V1]\n  [L, C]\n  [L]\n  Locale.ROOT\n \n\n Special cases for Chinese.  When an input Locale has the\n language \"zh\" (Chinese) and an empty script value, either \"Hans\" (Simplified) or\n \"Hant\" (Traditional) might be supplied, depending on the country.\n When the country is \"CN\" (China) or \"SG\" (Singapore), \"Hans\" is supplied.\n When the country is \"HK\" (Hong Kong SAR China), \"MO\" (Macau SAR China),\n or \"TW\" (Taiwan), \"Hant\" is supplied.  For all other countries or when the country\n is empty, no script is supplied.  For example, for Locale(\"zh\", \"CN\")\n , the candidate list will be:\n \n  [L(\"zh\"), S(\"Hans\"), C(\"CN\")]\n  [L(\"zh\"), S(\"Hans\")]\n  [L(\"zh\"), C(\"CN\")]\n  [L(\"zh\")]\n  Locale.ROOT\n \n\n For Locale(\"zh\", \"TW\"), the candidate list will be:\n \n  [L(\"zh\"), S(\"Hant\"), C(\"TW\")]\n  [L(\"zh\"), S(\"Hant\")]\n  [L(\"zh\"), C(\"TW\")]\n  [L(\"zh\")]\n  Locale.ROOT\n \n\n Special cases for Norwegian.  Both Locale(\"no\", \"NO\",\n \"NY\") and Locale(\"nn\", \"NO\") represent Norwegian\n Nynorsk.  When a locale's language is \"nn\", the standard candidate\n list is generated up to [L(\"nn\")], and then the following\n candidates are added:\n\n  [L(\"no\"), C(\"NO\"), V(\"NY\")]\n  [L(\"no\"), C(\"NO\")]\n  [L(\"no\")]\n  Locale.ROOT\n \n\n If the locale is exactly Locale(\"no\", \"NO\", \"NY\"), it is first\n converted to Locale(\"nn\", \"NO\") and then the above procedure is\n followed.\n\n Also, Java treats the language \"no\" as a synonym of Norwegian\n Bokml \"nb\".  Except for the single case Locale(\"no\",\n \"NO\", \"NY\") (handled above), when an input Locale\n has language \"no\" or \"nb\", candidate Locales with\n language code \"no\" and \"nb\" are interleaved, first using the\n requested language, then using its synonym. For example,\n Locale(\"nb\", \"NO\", \"POSIX\") generates the following\n candidate list:\n\n \n  [L(\"nb\"), C(\"NO\"), V(\"POSIX\")]\n  [L(\"no\"), C(\"NO\"), V(\"POSIX\")]\n  [L(\"nb\"), C(\"NO\")]\n  [L(\"no\"), C(\"NO\")]\n  [L(\"nb\")]\n  [L(\"no\")]\n  Locale.ROOT\n \n\n Locale(\"no\", \"NO\", \"POSIX\") would generate the same list\n except that locales with \"no\" would appear before the corresponding\n locales with \"nb\".\n \n\n The default implementation uses an ArrayList that\n overriding implementations may modify before returning it to the\n caller. However, a subclass must not modify it after it has\n been returned by getCandidateLocales.\n\n For example, if the given baseName is \"Messages\"\n and the given locale is\n Locale(\"ja\",\"\",\"XX\"), then a\n List of Locales:\n      Locale(\"ja\", \"\", \"XX\")\n     Locale(\"ja\")\n     Locale.ROOT\n \n is returned. And if the resource bundles for the \"ja\" and\n \"\" Locales are found, then the runtime resource\n lookup path (parent chain) is:\n \n     Messages_ja -> Messages"
                }
              ]
            },
            {
              "name": "getFallbackLocale",
              "overloads": [
                {
                  "signature": "public Locale getFallbackLocale(String baseName, Locale locale)",
                  "description": "Returns a Locale to be used as a fallback locale for\n further resource bundle searches by the\n ResourceBundle.getBundle factory method. This method\n is called from the factory method every time when no resulting\n resource bundle has been found for baseName and\n locale, where locale is either the parameter for\n ResourceBundle.getBundle or the previous fallback\n locale returned by this method.\n\n The method returns null if no further fallback\n search is desired.\n\n The default implementation returns the default Locale if the given\n locale isn't the default one.  Otherwise,\n null is returned."
                }
              ]
            },
            {
              "name": "newBundle",
              "overloads": [
                {
                  "signature": "public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException",
                  "description": "Instantiates a resource bundle for the given bundle name of the\n given format and locale, using the given class loader if\n necessary. This method returns null if there is no\n resource bundle available for the given parameters. If a resource\n bundle can't be instantiated due to an unexpected error, the\n error must be reported by throwing an Error or\n Exception rather than simply returning\n null.\n\n If the reload flag is true, it\n indicates that this method is being called because the previously\n loaded resource bundle has expired."
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "public long getTimeToLive(String baseName, Locale locale)",
                  "description": "Returns the time-to-live (TTL) value for resource bundles that\n are loaded under this\n ResourceBundle.Control. Positive time-to-live values\n specify the number of milliseconds a bundle can remain in the\n cache without being validated against the source data from which\n it was constructed. The value 0 indicates that a bundle must be\n validated each time it is retrieved from the cache. TTL_DONT_CACHE specifies that loaded resource bundles are not\n put in the cache. TTL_NO_EXPIRATION_CONTROL specifies\n that loaded resource bundles are put in the cache with no\n expiration control.\n\n The expiration affects only the bundle loading process by the\n ResourceBundle.getBundle factory method.  That is,\n if the factory method finds a resource bundle in the cache that\n has expired, the factory method calls the needsReload method to determine whether the resource\n bundle needs to be reloaded. If needsReload returns\n true, the cached resource bundle instance is removed\n from the cache. Otherwise, the instance stays in the cache,\n updated with the new TTL value returned by this method.\n\n All cached resource bundles are subject to removal from the\n cache due to memory constraints of the runtime environment.\n Returning a large positive value doesn't mean to lock loaded\n resource bundles in the cache.\n\n The default implementation returns TTL_NO_EXPIRATION_CONTROL."
                }
              ]
            },
            {
              "name": "needsReload",
              "overloads": [
                {
                  "signature": "public boolean needsReload(String baseName, Locale locale, String format, ClassLoader loader, ResourceBundle bundle, long loadTime)",
                  "description": "Determines if the expired bundle in the cache needs\n to be reloaded based on the loading time given by\n loadTime or some other criteria. The method returns\n true if reloading is required; false\n otherwise. loadTime is a millisecond offset since\n the  Calendar\n Epoch.\n\n \n The calling ResourceBundle.getBundle factory method\n calls this method on the ResourceBundle.Control\n instance used for its current invocation, not on the instance\n used in the invocation that originally loaded the resource\n bundle.\n\n The default implementation compares loadTime and\n the last modified time of the source data of the resource\n bundle. If it's determined that the source data has been modified\n since loadTime, true is\n returned. Otherwise, false is returned. This\n implementation assumes that the given format is the\n same string as its file suffix if it's not one of the default\n formats, \"java.class\" or\n \"java.properties\"."
                }
              ]
            },
            {
              "name": "toBundleName",
              "overloads": [
                {
                  "signature": "public String toBundleName(String baseName, Locale locale)",
                  "description": "Converts the given baseName and locale\n to the bundle name. This method is called from the default\n implementation of the newBundle and needsReload\n methods.\n\n This implementation returns the following value:\n      baseName + \"_\" + language + \"_\" + script + \"_\" + country + \"_\" + variant\n \n where language, script, country,\n and variant are the language, script, country, and variant\n values of locale, respectively. Final component values that\n are empty Strings are omitted along with the preceding '_'.  When the\n script is empty, the script value is omitted along with the preceding '_'.\n If all of the values are empty strings, then baseName\n is returned.\n\n For example, if baseName is\n \"baseName\" and locale is\n Locale(\"ja\",\"\",\"XX\"), then\n \"baseName_ja__XX\" is returned. If the given\n locale is Locale(\"en\"), then\n \"baseName_en\" is returned.\n\n Overriding this method allows applications to use different\n conventions in the organization and packaging of localized\n resources."
                }
              ]
            },
            {
              "name": "toResourceName",
              "overloads": [
                {
                  "signature": "public final String toResourceName(String bundleName, String suffix)",
                  "description": "Converts the given bundleName to the form required\n by the ClassLoader.getResource\n method by replacing all occurrences of '.' in\n bundleName with '/' and appending a\n '.' and the given file suffix. For\n example, if bundleName is\n \"foo.bar.MyResources_ja_JP\" and suffix\n is \"properties\", then\n \"foo/bar/MyResources_ja_JP.properties\" is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "ServiceConfigurationError",
          "methods": [
            {
              "name": "ServiceConfigurationError",
              "overloads": [
                {
                  "signature": "public ServiceConfigurationError(String msg)",
                  "description": "Constructs a new instance with the specified message."
                },
                {
                  "signature": "public ServiceConfigurationError(String msg, Throwable cause)",
                  "description": "Constructs a new instance with the specified message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "ServiceLoader<S>",
          "methods": [
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<S> iterator()",
                  "description": "Returns an iterator to lazily load and instantiate the available\n providers of this loader's service.\n\n  To achieve laziness the actual work of locating and instantiating\n providers is done by the iterator itself. Its hasNext and next methods can therefore throw a\n ServiceConfigurationError for any of the reasons specified in\n the Errors section above. To write robust code it\n is only necessary to catch ServiceConfigurationError when using\n the iterator. If an error is thrown then subsequent invocations of the\n iterator will make a best effort to locate and instantiate the next\n available provider, but in general such recovery cannot be guaranteed.\n\n  Caching: The iterator returned by this method first yields all of\n the elements of the provider cache, in the order that they were loaded.\n It then lazily loads and instantiates any remaining service providers,\n adding each one to the cache in turn. If this loader's provider caches are\n cleared by invoking the reload method then existing\n iterators for this service loader should be discarded.\n The  hasNext and next methods of the iterator throw ConcurrentModificationException\n if used after the provider cache has been cleared.\n\n  The iterator returned by this method does not support removal.\n Invoking its remove method will\n cause an UnsupportedOperationException to be thrown."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public Stream<ServiceLoader.Provider<S>> stream()",
                  "description": "Returns a stream to lazily load available providers of this loader's\n service. The stream elements are of type Provider, the\n Provider's get method must be invoked to\n get or instantiate the provider.\n\n  To achieve laziness the actual work of locating providers is done\n when processing the stream. If a service provider cannot be loaded for any\n of the reasons specified in the Errors section\n above then ServiceConfigurationError is thrown by whatever method\n caused the service provider to be loaded. \n\n  Caching: When processing the stream then providers that were previously\n loaded by stream operations are processed first, in load order. It then\n lazily loads any remaining service providers. If this loader's provider\n caches are cleared by invoking the reload method then\n existing streams for this service loader should be discarded. The returned\n stream's source spliterator is fail-fast and\n will throw ConcurrentModificationException if the provider cache\n has been cleared. \n\n  The following examples demonstrate usage. The first example creates\n a stream of CodecFactory objects, the second example is the same\n except that it sorts the providers by provider class name (and so locate\n all providers).\n \n    Stream<CodecFactory> providers = ServiceLoader.load(CodecFactory.class)\n            .stream()\n            .map(Provider::get);\n\n    Stream<CodecFactory> providers = ServiceLoader.load(CodecFactory.class)\n            .stream()\n            .sorted(Comparator.comparing(p -> p.type().getName()))\n            .map(Provider::get);"
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public static <S> ServiceLoader<S> load(Class<S> service, ClassLoader loader)",
                  "description": "Creates a new service loader for the given service. The service loader\n uses the given class loader as the starting point to locate service\n providers for the service. The service loader's iterator and stream locate providers in both named\n and unnamed modules, as follows:\n\n \n     Step 1: Locate providers in named modules. \n\n    Service providers are located in all named modules of the class\n   loader or to any class loader reachable via parent delegation. \n\n    In addition, if the class loader is not the bootstrap or platform class loader, then service\n   providers may be located in the named modules of other class loaders.\n   Specifically, if the class loader, or any class loader reachable via\n   parent delegation, has a module in a module\n   layer, then service providers in all modules in the module layer are\n   located.  \n\n    For example, suppose there is a module layer where each module is\n   in its own class loader (see defineModulesWithManyLoaders). If this ServiceLoader.load method\n   is invoked to locate providers using any of the class loaders created for\n   the module layer, then it will locate all of the providers in the module\n   layer, irrespective of their defining class loader. \n\n    Ordering: The service loader will first locate any service providers\n   in modules defined to the class loader, then its parent class loader,\n   its parent parent, and so on to the bootstrap class loader. If a class\n   loader has modules in a module layer then all providers in that module\n   layer are located (irrespective of their class loader) before the\n   providers in the parent class loader are located. The ordering of\n   modules in same class loader, or the ordering of modules in a module\n   layer, is not defined. \n\n    If a module declares more than one provider then the providers\n   are located in the order that its module descriptor lists the\n   providers. Providers added dynamically by instrumentation agents (see\n   redefineModule)\n   are always located after providers declared by the module.  \n\n     Step 2: Locate providers in unnamed modules. \n\n    Service providers in unnamed modules are located if their class names\n   are listed in provider-configuration files located by the class loader's\n   getResources method. \n\n    The ordering is based on the order that the class loader's \n   getResources method finds the service configuration files and within\n   that, the order that the class names are listed in the file. \n\n    In a provider-configuration file, any mention of a service provider\n   that is deployed in a named module is ignored. This is to avoid\n   duplicates that would otherwise arise when a named module has both a\n   provides directive and a provider-configuration file that mention\n   the same service provider. \n\n    The provider class must be visible to the class loader."
                },
                {
                  "signature": "public static <S> ServiceLoader<S> load(Class<S> service)",
                  "description": "Creates a new service loader for the given service type, using the\n current thread's context class loader.\n\n  An invocation of this convenience method of the form\n \n     ServiceLoader.load(service)\n \n\n is equivalent to\n\n \n     ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())"
                },
                {
                  "signature": "public static <S> ServiceLoader<S> load(ModuleLayer layer, Class<S> service)",
                  "description": "Creates a new service loader for the given service type to load service\n providers from modules in the given module layer and its ancestors. It\n does not locate providers in unnamed modules. The ordering that the service\n loader's iterator and stream locate\n providers and yield elements is as follows:\n\n \n    Providers are located in a module layer before locating providers\n   in parent layers. Traversal of parent layers is depth-first with each\n   layer visited at most once. For example, suppose L0 is the boot layer, L1\n   and L2 are modules layers with L0 as their parent. Now suppose that L3 is\n   created with L1 and L2 as the parents (in that order). Using a service\n   loader to locate providers with L3 as the context will locate providers\n   in the following order: L3, L1, L0, L2. \n\n    If a module declares more than one provider then the providers\n   are located in the order that its module descriptor\n   lists the providers. Providers added dynamically by instrumentation\n   agents are always located after providers declared by the module. \n\n    The ordering of modules in a module layer is not defined."
                }
              ]
            },
            {
              "name": "loadInstalled",
              "overloads": [
                {
                  "signature": "public static <S> ServiceLoader<S> loadInstalled(Class<S> service)",
                  "description": "Creates a new service loader for the given service type, using the\n platform class loader.\n\n  This convenience method is equivalent to: \n\n \n     ServiceLoader.load(service, ClassLoader.getPlatformClassLoader())\n \n\n  This method is intended for use when only installed providers are\n desired.  The resulting service will only find and load providers that\n have been installed into the current Java virtual machine; providers on\n the application's module path or class path will be ignored."
                }
              ]
            },
            {
              "name": "findFirst",
              "overloads": [
                {
                  "signature": "public Optional<S> findFirst()",
                  "description": "Load the first available service provider of this loader's service. This\n convenience method is equivalent to invoking the iterator() method and obtaining the first element. It therefore\n returns the first element from the provider cache if possible, it\n otherwise attempts to load and instantiate the first provider.\n\n  The following example loads the first available service provider. If\n no service providers are located then it uses a default implementation.\n \n    CodecFactory factory = ServiceLoader.load(CodecFactory.class)\n                                        .findFirst()\n                                        .orElse(DEFAULT_CODECSET_FACTORY);"
                }
              ]
            },
            {
              "name": "reload",
              "overloads": [
                {
                  "signature": "public void reload()",
                  "description": "Clear this loader's provider cache so that all providers will be\n reloaded.\n\n  After invoking this method, subsequent invocations of the iterator or stream methods will lazily\n locate providers (and instantiate in the case of iterator)\n from scratch, just as is done by a newly-created service loader.\n\n  This method is intended for use in situations in which new service\n providers can be installed into a running Java virtual machine."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this service."
                }
              ]
            }
          ]
        },
        {
          "name": "Set<E>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this set (its cardinality).  If this\n set contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this set contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this set contains the specified element.\n More formally, returns true if and only if this set\n contains an element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this set.  The elements are\n returned in no particular order (unless this set is an instance of some\n class that provides a guarantee)."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this set.\n If this set makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the\n elements in the same order.\n\n The returned array will be \"safe\" in that no references to it\n are maintained by this set.  (In other words, this method must\n allocate a new array even if this set is backed by an array).\n The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "<T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this set; the\n runtime type of the returned array is that of the specified array.\n If the set fits in the specified array, it is returned therein.\n Otherwise, a new array is allocated with the runtime type of the\n specified array and the size of this set.\n\n If this set fits in the specified array with room to spare\n (i.e., the array has more elements than this set), the element in\n the array immediately following the end of the set is set to\n null.  (This is useful in determining the length of this\n set only if the caller knows that this set does not contain\n any null elements.)\n\n If this set makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements\n in the same order.\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a set known to contain only strings.\n The following code can be used to dump the set into a newly allocated\n array of String:\n\n      String[] y = x.toArray(new String[0]);\n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Adds the specified element to this set if it is not already present\n (optional operation).  More formally, adds the specified element\n e to this set if the set contains no element e2\n such that\n Objects.equals(e, e2).\n If this set already contains the element, the call leaves the set\n unchanged and returns false.  In combination with the\n restriction on constructors, this ensures that sets never contain\n duplicate elements.\n\n The stipulation above does not imply that sets must accept all\n elements; sets may refuse to add any particular element, including\n null, and throw an exception, as described in the\n specification for Collection.add.\n Individual set implementations should clearly document any\n restrictions on the elements that they may contain."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes the specified element from this set if it is present\n (optional operation).  More formally, removes an element e\n such that\n Objects.equals(o, e), if\n this set contains such an element.  Returns true if this set\n contained the element (or equivalently, if this set changed as a\n result of the call).  (This set will not contain the element once the\n call returns.)"
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this set contains all of the elements of the\n specified collection.  If the specified collection is also a set, this\n method returns true if it is a subset of this set."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this set if\n they're not already present (optional operation).  If the specified\n collection is also a set, the addAll operation effectively\n modifies this set so that its value is the union of the two\n sets.  The behavior of this operation is undefined if the specified\n collection is modified while the operation is in progress."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this set that are contained in the\n specified collection (optional operation).  In other words, removes\n from this set all of its elements that are not contained in the\n specified collection.  If the specified collection is also a set, this\n operation effectively modifies this set so that its value is the\n intersection of the two sets."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll(Collection<?> c)",
                  "description": "Removes from this set all of its elements that are contained in the\n specified collection (optional operation).  If the specified\n collection is also a set, this operation effectively modifies this\n set so that its value is the asymmetric set difference of\n the two sets."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the elements from this set (optional operation).\n The set will be empty after this call returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this set for equality.  Returns\n true if the specified object is also a set, the two sets\n have the same size, and every member of the specified set is\n contained in this set (or equivalently, every member of this set is\n contained in the specified set).  This definition ensures that the\n equals method works properly across different implementations of the\n set interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this set.  The hash code of a set is\n defined to be the sum of the hash codes of the elements in the set,\n where the hash code of a null element is defined to be zero.\n This ensures that s1.equals(s2) implies that\n s1.hashCode()==s2.hashCode() for any two sets s1\n and s2, as required by the general contract of\n Object.hashCode()."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this set.\n\n The Spliterator reports Spliterator.DISTINCT.\n Implementations should document the reporting of additional\n characteristic values."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <E> Set<E> of()",
                  "description": "Returns an unmodifiable set containing zero elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1)",
                  "description": "Returns an unmodifiable set containing one element.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2)",
                  "description": "Returns an unmodifiable set containing two elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3)",
                  "description": "Returns an unmodifiable set containing three elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4)",
                  "description": "Returns an unmodifiable set containing four elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5)",
                  "description": "Returns an unmodifiable set containing five elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6)",
                  "description": "Returns an unmodifiable set containing six elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)",
                  "description": "Returns an unmodifiable set containing seven elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)",
                  "description": "Returns an unmodifiable set containing eight elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)",
                  "description": "Returns an unmodifiable set containing nine elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)",
                  "description": "Returns an unmodifiable set containing ten elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "@SafeVarargs static <E> Set<E> of(E... elements)",
                  "description": "Returns an unmodifiable set containing an arbitrary number of elements.\n See Unmodifiable Sets for details."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <E> Set<E> copyOf(Collection<? extends E> coll)",
                  "description": "Returns an unmodifiable Set containing the elements\n of the given Collection. The given Collection must not be null, and it must not\n contain any null elements. If the given Collection contains duplicate elements,\n an arbitrary element of the duplicates is preserved. If the given Collection is\n subsequently modified, the returned Set will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "TimeZone",
          "methods": [
            {
              "name": "TimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public abstract int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds)",
                  "description": "Gets the time zone offset, for current date, modified in case of\n daylight savings. This is the offset to add to UTC to get local time.\n \n This method returns a historically correct offset if an\n underlying TimeZone implementation subclass\n supports historical Daylight Saving Time schedule and GMT\n offset changes."
                },
                {
                  "signature": "public int getOffset(long date)",
                  "description": "Returns the offset of this time zone from UTC at the specified\n date. If Daylight Saving Time is in effect at the specified\n date, the offset value is adjusted with the amount of daylight\n saving.\n \n This method returns a historically correct offset value if an\n underlying TimeZone implementation subclass supports historical\n Daylight Saving Time schedule and GMT offset changes."
                }
              ]
            },
            {
              "name": "setRawOffset",
              "overloads": [
                {
                  "signature": "public abstract void setRawOffset(int offsetMillis)",
                  "description": "Sets the base time zone offset to GMT.\n This is the offset to add to UTC to get local time.\n \n If an underlying TimeZone implementation subclass\n supports historical GMT offset changes, the specified GMT\n offset is set as the latest GMT offset and the difference from\n the known latest GMT offset value is used to adjust all\n historical GMT offset values."
                }
              ]
            },
            {
              "name": "getRawOffset",
              "overloads": [
                {
                  "signature": "public abstract int getRawOffset()",
                  "description": "Returns the amount of time in milliseconds to add to UTC to get\n standard time in this time zone. Because this value is not\n affected by daylight saving time, it is called raw\n offset.\n \n If an underlying TimeZone implementation subclass\n supports historical GMT offset changes, the method returns the\n raw offset value of the current date. In Honolulu, for example,\n its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and\n this method always returns -36000000 milliseconds (i.e., -10\n hours)."
                }
              ]
            },
            {
              "name": "getID",
              "overloads": [
                {
                  "signature": "public String getID()",
                  "description": "Gets the ID of this time zone."
                }
              ]
            },
            {
              "name": "setID",
              "overloads": [
                {
                  "signature": "public void setID(String ID)",
                  "description": "Sets the time zone ID. This does not change any other data in\n the time zone object."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public final String getDisplayName()",
                  "description": "Returns a long standard time name of this TimeZone suitable for\n presentation to the user in the default locale.\n\n This method is equivalent to:\n  getDisplayName(false, LONG,\n                Locale.getDefault(Locale.Category.DISPLAY))"
                },
                {
                  "signature": "public final String getDisplayName(Locale locale)",
                  "description": "Returns a long standard time name of this TimeZone suitable for\n presentation to the user in the specified locale.\n\n This method is equivalent to:\n  getDisplayName(false, LONG, locale)"
                },
                {
                  "signature": "public final String getDisplayName(boolean daylight, int style)",
                  "description": "Returns a name in the specified style of this TimeZone\n suitable for presentation to the user in the default locale. If the\n specified daylight is true, a Daylight Saving Time name\n is returned (even if this TimeZone doesn't observe Daylight Saving\n Time). Otherwise, a Standard Time name is returned.\n\n This method is equivalent to:\n  getDisplayName(daylight, style,\n                Locale.getDefault(Locale.Category.DISPLAY))"
                },
                {
                  "signature": "public String getDisplayName(boolean daylight, int style, Locale locale)",
                  "description": "Returns a name in the specified style of this TimeZone\n suitable for presentation to the user in the specified \n locale. If the specified daylight is true, a Daylight\n Saving Time name is returned (even if this TimeZone doesn't\n observe Daylight Saving Time). Otherwise, a Standard Time name is\n returned.\n\n When looking up a time zone name, the default\n Locale search path of ResourceBundle derived\n from the specified locale is used. (No fallback\n Locale search is performed.) If a time zone name in any\n Locale of the search path, including Locale.ROOT, is\n found, the name is returned. Otherwise, a string in the\n normalized custom ID format is returned."
                }
              ]
            },
            {
              "name": "getDSTSavings",
              "overloads": [
                {
                  "signature": "public int getDSTSavings()",
                  "description": "Returns the amount of time to be added to local standard time\n to get local wall clock time.\n\n The default implementation returns 3600000 milliseconds\n (i.e., one hour) if a call to useDaylightTime()\n returns true. Otherwise, 0 (zero) is returned.\n\n If an underlying TimeZone implementation subclass\n supports historical and future Daylight Saving Time schedule\n changes, this method returns the amount of saving time of the\n last known Daylight Saving Time rule that can be a future\n prediction.\n\n If the amount of saving time at any given time stamp is\n required, construct a Calendar with this \n TimeZone and the time stamp, and call Calendar.get(Calendar.DST_OFFSET)."
                }
              ]
            },
            {
              "name": "useDaylightTime",
              "overloads": [
                {
                  "signature": "public abstract boolean useDaylightTime()",
                  "description": "Queries if this TimeZone uses Daylight Saving Time.\n\n If an underlying TimeZone implementation subclass\n supports historical and future Daylight Saving Time schedule\n changes, this method refers to the last known Daylight Saving Time\n rule that can be a future prediction and may not be the same as\n the current rule. Consider calling observesDaylightTime()\n if the current rule should also be taken into account."
                }
              ]
            },
            {
              "name": "observesDaylightTime",
              "overloads": [
                {
                  "signature": "public boolean observesDaylightTime()",
                  "description": "Returns true if this TimeZone is currently in\n Daylight Saving Time, or if a transition from Standard Time to\n Daylight Saving Time occurs at any future time.\n\n The default implementation returns true if\n useDaylightTime() or inDaylightTime(new Date())\n returns true."
                }
              ]
            },
            {
              "name": "inDaylightTime",
              "overloads": [
                {
                  "signature": "public abstract boolean inDaylightTime(Date date)",
                  "description": "Queries if the given date is in Daylight Saving Time in\n this time zone."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public static TimeZone getTimeZone(String ID)",
                  "description": "Gets the TimeZone for the given ID."
                },
                {
                  "signature": "public static TimeZone getTimeZone(ZoneId zoneId)",
                  "description": "Gets the TimeZone for the given zoneId."
                }
              ]
            },
            {
              "name": "toZoneId",
              "overloads": [
                {
                  "signature": "public ZoneId toZoneId()",
                  "description": "Converts this TimeZone object to a ZoneId."
                }
              ]
            },
            {
              "name": "getAvailableIDs",
              "overloads": [
                {
                  "signature": "public static String[] getAvailableIDs(int rawOffset)",
                  "description": "Gets the available IDs according to the given time zone offset in milliseconds."
                },
                {
                  "signature": "public static String[] getAvailableIDs()",
                  "description": "Gets all the available IDs supported."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static TimeZone getDefault()",
                  "description": "Gets the default TimeZone of the Java virtual machine. If the\n cached default TimeZone is available, its clone is returned.\n Otherwise, the method takes the following steps to determine the default\n time zone.\n\n \n Use the user.timezone property value as the default\n time zone ID if it's available.\n Detect the platform time zone ID. The source of the\n platform time zone and ID mapping may vary with implementation.\n Use GMT as the last resort if the given or detected\n time zone ID is unknown.\n \n\n The default TimeZone created from the ID is cached,\n and its clone is returned. The user.timezone property\n value is set to the ID upon return."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(TimeZone zone)",
                  "description": "Sets the TimeZone that is returned by the getDefault\n method. zone is cached. If zone is null, the cached\n default TimeZone is cleared. This method doesn't change the value\n of the user.timezone property."
                }
              ]
            },
            {
              "name": "hasSameRules",
              "overloads": [
                {
                  "signature": "public boolean hasSameRules(TimeZone other)",
                  "description": "Returns true if this zone has the same rule and offset as another zone.\n That is, if this zone differs only in ID, if at all.  Returns false\n if the other zone is null."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates a copy of this TimeZone."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.io",
      "description": "Input/output classes",
      "classes": [
        {
          "name": "BufferedInputStream",
          "methods": [
            {
              "name": "BufferedInputStream",
              "overloads": [
                {
                  "signature": "public BufferedInputStream(InputStream in)",
                  "description": "Creates a BufferedInputStream\n and saves its  argument, the input stream\n in, for later use. An internal\n buffer array is created and  stored in buf."
                },
                {
                  "signature": "public BufferedInputStream(InputStream in, int size)",
                  "description": "Creates a BufferedInputStream\n with the specified buffer size,\n and saves its  argument, the input stream\n in, for later use.  An internal\n buffer array of length  size\n is created and stored in buf."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "See\n the general contract of the read\n method of InputStream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads bytes from this byte-input stream into the specified byte array,\n starting at the given offset.\n\n  This method implements the general contract of the corresponding\n read method of\n the InputStream class.  As an additional\n convenience, it attempts to read as many bytes as possible by repeatedly\n invoking the read method of the underlying stream.  This\n iterated read continues until one of the following\n conditions becomes true: \n\n    The specified number of bytes have been read,\n\n    The read method of the underlying stream returns\n   -1, indicating end-of-file, or\n\n    The available method of the underlying stream\n   returns zero, indicating that further input requests would block.\n\n  If the first read on the underlying stream returns\n -1 to indicate end-of-file then this method returns\n -1.  Otherwise this method returns the number of bytes\n actually read.\n\n  Subclasses of this class are encouraged, but not required, to\n attempt to read as many bytes as possible in the same fashion."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "See the general contract of the skip\n method of InputStream."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method returns the sum of the number of bytes remaining to be read in\n the buffer (count - pos) and the result of calling the\n in.available()."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "See the general contract of the mark\n method of InputStream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "See the general contract of the reset\n method of InputStream.\n \n If markpos is -1\n (no mark has been set or the mark has been\n invalidated), an IOException\n is thrown. Otherwise, pos is\n set equal to markpos."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark\n and reset methods. The markSupported\n method of BufferedInputStream returns\n true."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n Once the stream has been closed, further read(), available(), reset(),\n or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedOutputStream",
          "methods": [
            {
              "name": "BufferedOutputStream",
              "overloads": [
                {
                  "signature": "public BufferedOutputStream(OutputStream out)",
                  "description": "Creates a new buffered output stream to write data to the\n specified underlying output stream."
                },
                {
                  "signature": "public BufferedOutputStream(OutputStream out, int size)",
                  "description": "Creates a new buffered output stream to write data to the\n specified underlying output stream with the specified buffer\n size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this buffered output stream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this buffered output stream.\n\n  Ordinarily this method stores bytes from the given array into this\n stream's buffer, flushing the buffer to the underlying output stream as\n needed.  If the requested length is at least as large as this stream's\n buffer, however, then this method will flush the buffer and write the\n bytes directly to the underlying output stream.  Thus redundant\n BufferedOutputStreams will not copy data unnecessarily."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this buffered output stream. This forces any buffered\n output bytes to be written out to the underlying output stream."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedReader",
          "methods": [
            {
              "name": "BufferedReader",
              "overloads": [
                {
                  "signature": "public BufferedReader(Reader in, int sz)",
                  "description": "Creates a buffering character-input stream that uses an input buffer of\n the specified size."
                },
                {
                  "signature": "public BufferedReader(Reader in)",
                  "description": "Creates a buffering character-input stream that uses a default-sized\n input buffer."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  This method implements the general contract of the corresponding\n read method of the\n Reader class.  As an additional convenience, it\n attempts to read as many characters as possible by repeatedly invoking\n the read method of the underlying stream.  This iterated\n read continues until one of the following conditions becomes\n true:\n \n\n    The specified number of characters have been read,\n\n    The read method of the underlying stream returns\n   -1, indicating end-of-file, or\n\n    The ready method of the underlying stream\n   returns false, indicating that further input requests\n   would block.\n\n \n If the first read on the underlying stream returns\n -1 to indicate end-of-file then this method returns\n -1.  Otherwise this method returns the number of characters\n actually read.\n\n  Subclasses of this class are encouraged, but not required, to\n attempt to read as many characters as possible in the same fashion.\n\n  Ordinarily this method takes characters from this stream's character\n buffer, filling it from the underlying stream as necessary.  If,\n however, the buffer is empty, the mark is not valid, and the requested\n length is at least as large as the buffer, then this method will read\n characters directly from the underlying stream into the given array.\n Thus redundant BufferedReaders will not copy data\n unnecessarily."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine() throws IOException",
                  "description": "Reads a line of text.  A line is considered to be terminated by any one\n of a line feed ('\\n'), a carriage return ('\\r'), a carriage return\n followed immediately by a line feed, or by reaching the end-of-file\n (EOF)."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  A buffered character\n stream is ready if the buffer is not empty, or if the underlying\n character stream is ready."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            },
            {
              "name": "lines",
              "overloads": [
                {
                  "signature": "public Stream<String> lines()",
                  "description": "Returns a Stream, the elements of which are lines read from\n this BufferedReader.  The Stream is lazily populated,\n i.e., read only occurs during the\n terminal\n stream operation.\n\n  The reader must not be operated on during the execution of the\n terminal stream operation. Otherwise, the result of the terminal stream\n operation is undefined.\n\n  After execution of the terminal stream operation there are no\n guarantees that the reader will be at a specific position from which to\n read the next character or line.\n\n  If an IOException is thrown when accessing the underlying\n BufferedReader, it is wrapped in an UncheckedIOException which will be thrown from the Stream\n method that caused the read to take place. This method will return a\n Stream if invoked on a BufferedReader that is closed. Any operation on\n that stream that requires reading from the BufferedReader after it is\n closed, will cause an UncheckedIOException to be thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedWriter",
          "methods": [
            {
              "name": "BufferedWriter",
              "overloads": [
                {
                  "signature": "public BufferedWriter(Writer out)",
                  "description": "Creates a buffered character-output stream that uses a default-sized\n output buffer."
                },
                {
                  "signature": "public BufferedWriter(Writer out, int sz)",
                  "description": "Creates a new buffered character-output stream that uses an output\n buffer of the given size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters.\n\n  Ordinarily this method stores characters from the given array into\n this stream's buffer, flushing the buffer to the underlying stream as\n needed.  If the requested length is at least as large as the buffer,\n however, then this method will flush the buffer and write the characters\n directly to the underlying stream.  Thus redundant\n BufferedWriters will not copy data unnecessarily."
                },
                {
                  "signature": "public void write(String s, int off, int len) throws IOException",
                  "description": "Writes a portion of a String."
                }
              ]
            },
            {
              "name": "newLine",
              "overloads": [
                {
                  "signature": "public void newLine() throws IOException",
                  "description": "Writes a line separator.  The line separator string is defined by the\n system property line.separator, and is not necessarily a single\n newline ('\\n') character."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "ByteArrayInputStream",
          "methods": [
            {
              "name": "ByteArrayInputStream",
              "overloads": [
                {
                  "signature": "public ByteArrayInputStream(byte[] buf)",
                  "description": "Creates a ByteArrayInputStream\n so that it  uses buf as its\n buffer array.\n The buffer array is not copied.\n The initial value of pos\n is 0 and the initial value\n of  count is the length of\n buf."
                },
                {
                  "signature": "public ByteArrayInputStream(byte[] buf, int offset, int length)",
                  "description": "Creates ByteArrayInputStream\n that uses buf as its\n buffer array. The initial value of pos\n is offset and the initial value\n of count is the minimum of offset+length\n and buf.length.\n The buffer array is not copied. The buffer's mark is\n set to the specified offset."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read()",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned.\n \n This read method\n cannot block."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len)",
                  "description": "Reads up to len bytes of data into an array of bytes from this\n input stream.  If pos equals count, then -1 is\n returned to indicate end of file.  Otherwise, the  number k of\n bytes read is equal to the smaller of len and count-pos.\n If k is positive, then bytes buf[pos] through\n buf[pos+k-1] are copied into b[off] through\n b[off+k-1] in the manner performed by System.arraycopy.\n The value k is added into pos and k is returned.\n \n Unlike the overridden method\n of InputStream, this method returns -1 instead of zero\n if the end of the stream has been reached and len == 0.\n \n This read method cannot block."
                }
              ]
            },
            {
              "name": "readAllBytes",
              "overloads": [
                {
                  "signature": "public byte[] readAllBytes()",
                  "description": "Description copied from class:InputStream"
                }
              ]
            },
            {
              "name": "readNBytes",
              "overloads": [
                {
                  "signature": "public int readNBytes(byte[] b, int off, int len)",
                  "description": "Description copied from class:InputStream"
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n)",
                  "description": "Skips n bytes of input from this input stream. Fewer\n bytes might be skipped if the end of the input stream is reached.\n The actual number k\n of bytes to be skipped is equal to the smaller\n of n and  count-pos.\n The value k is added into pos\n and k is returned."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available()",
                  "description": "Returns the number of remaining bytes that can be read (or skipped over)\n from this input stream.\n \n The value returned is count - pos,\n which is the number of bytes remaining to be read from the input buffer."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this InputStream supports mark/reset. The\n markSupported method of ByteArrayInputStream\n always returns true."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit)",
                  "description": "Set the current marked position in the stream.\n ByteArrayInputStream objects are marked at position zero by\n default when constructed.  They may be marked at another\n position within the buffer by this method.\n \n If no mark has been set, then the value of the mark is the\n offset passed to the constructor (or 0 if the offset was not\n supplied).\n\n  Note: The readAheadLimit for this class\n  has no meaning."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the buffer to the marked position.  The marked position\n is 0 unless another position was marked or an offset was specified\n in the constructor."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a ByteArrayInputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteArrayOutputStream",
          "methods": [
            {
              "name": "ByteArrayOutputStream",
              "overloads": [
                {
                  "signature": "public ByteArrayOutputStream()",
                  "description": "Creates a new ByteArrayOutputStream. The buffer capacity is\n initially 32 bytes, though its size increases if necessary."
                },
                {
                  "signature": "public ByteArrayOutputStream(int size)",
                  "description": "Creates a new ByteArrayOutputStream, with a buffer capacity of\n the specified size, in bytes."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b)",
                  "description": "Writes the specified byte to this ByteArrayOutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len)",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this ByteArrayOutputStream."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(byte[] b)",
                  "description": "Writes the complete contents of the specified byte array\n to this ByteArrayOutputStream."
                }
              ]
            },
            {
              "name": "writeTo",
              "overloads": [
                {
                  "signature": "public void writeTo(OutputStream out) throws IOException",
                  "description": "Writes the complete contents of this ByteArrayOutputStream to\n the specified output stream argument, as if by calling the output\n stream's write method using out.write(buf, 0, count)."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the count field of this ByteArrayOutputStream\n to zero, so that all currently accumulated output in the\n output stream is discarded. The output stream can be used again,\n reusing the already allocated buffer space."
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public byte[] toByteArray()",
                  "description": "Creates a newly allocated byte array. Its size is the current\n size of this output stream and the valid contents of the buffer\n have been copied into it."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the current size of the buffer."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts the buffer's contents into a string decoding bytes using the\n platform's default character set. The length of the new String\n is a function of the character set, and hence may not be equal to the\n size of the buffer.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with the default replacement string for the platform's\n default character set. The CharsetDecoder\n class should be used when more control over the decoding process is\n required."
                },
                {
                  "signature": "public String toString(String charsetName) throws UnsupportedEncodingException",
                  "description": "Converts the buffer's contents into a string by decoding the bytes using\n the named charset.\n\n  This method is equivalent to #toString(charset) that takes a\n charset.\n\n  An invocation of this method of the form\n\n  \n      ByteArrayOutputStream b = ...\n      b.toString(\"UTF-8\")\n      \n \n\n behaves in exactly the same way as the expression\n\n  \n      ByteArrayOutputStream b = ...\n      b.toString(StandardCharsets.UTF_8)"
                },
                {
                  "signature": "public String toString(Charset charset)",
                  "description": "Converts the buffer's contents into a string by decoding the bytes using\n the specified charset. The length of the new\n String is a function of the charset, and hence may not be equal\n to the length of the byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with the charset's default replacement string. The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "@Deprecated public String toString(int hibyte)",
                  "description": "Creates a newly allocated string. Its size is the current size of\n the output stream and the valid contents of the buffer have been\n copied into it. Each character c in the resulting string is\n constructed from the corresponding element b in the byte\n array such that:\n \n     c == (char)(((hibyte & 0xff) << 8) | (b & 0xff))",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a ByteArrayOutputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "CharArrayReader",
          "methods": [
            {
              "name": "CharArrayReader",
              "overloads": [
                {
                  "signature": "public CharArrayReader(char[] buf)",
                  "description": "Creates a CharArrayReader from the specified array of chars."
                },
                {
                  "signature": "public CharArrayReader(char[] buf, int offset, int length)",
                  "description": "Creates a CharArrayReader from the specified array of chars.\n\n  The resulting reader will start reading at the given\n offset.  The total number of char values that can be\n read from this reader will be either length or\n buf.length-offset, whichever is smaller."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters. If the stream is already at its end before this method\n is invoked, then no characters are skipped and zero is returned.\n\n The n parameter may be negative, even though the\n skip method of the Reader superclass throws\n an exception in this case. If n is negative, then\n this method does nothing and returns 0."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  Character-array readers\n are always ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark, or to the beginning if it has\n never been marked."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated with\n it.  Once the stream has been closed, further read(), ready(),\n mark(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "CharArrayWriter",
          "methods": [
            {
              "name": "CharArrayWriter",
              "overloads": [
                {
                  "signature": "public CharArrayWriter()",
                  "description": "Creates a new CharArrayWriter."
                },
                {
                  "signature": "public CharArrayWriter(int initialSize)",
                  "description": "Creates a new CharArrayWriter with the specified initial size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Writes a character to the buffer."
                },
                {
                  "signature": "public void write(char[] c, int off, int len)",
                  "description": "Writes characters to the buffer."
                },
                {
                  "signature": "public void write(String str, int off, int len)",
                  "description": "Write a portion of a string to the buffer."
                }
              ]
            },
            {
              "name": "writeTo",
              "overloads": [
                {
                  "signature": "public void writeTo(Writer out) throws IOException",
                  "description": "Writes the contents of the buffer to another character stream."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public CharArrayWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public CharArrayWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when\n csq is not null, behaves in\n exactly the same way as the invocation\n\n      out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public CharArrayWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the buffer so that you can use it again without\n throwing away the already allocated buffer."
                }
              ]
            },
            {
              "name": "toCharArray",
              "overloads": [
                {
                  "signature": "public char[] toCharArray()",
                  "description": "Returns a copy of the input data."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the current size of the buffer."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts input data to a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flush the stream.\n\n  The flush method of CharArrayWriter does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Close the stream.  This method does not release the buffer, since its\n contents might still be required. Note: Invoking this method in this class\n will have no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "CharConversionException",
          "methods": [
            {
              "name": "CharConversionException",
              "overloads": [
                {
                  "signature": "public CharConversionException()",
                  "description": "This provides no detailed message."
                },
                {
                  "signature": "public CharConversionException(String s)",
                  "description": "This provides a detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter.Status[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter.Status valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Closeable",
          "methods": [
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes this stream and releases any system resources associated\n with it. If the stream is already closed then invoking this\n method has no effect.\n\n  As noted in AutoCloseable.close(), cases where the\n close may fail require careful attention. It is strongly advised\n to relinquish the underlying resources and to internally\n mark the Closeable as closed, prior to throwing\n the IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "Console",
          "methods": [
            {
              "name": "writer",
              "overloads": [
                {
                  "signature": "public PrintWriter writer()",
                  "description": "Retrieves the unique PrintWriter object\n associated with this console."
                }
              ]
            },
            {
              "name": "reader",
              "overloads": [
                {
                  "signature": "public Reader reader()",
                  "description": "Retrieves the unique Reader object associated\n with this console.\n \n This method is intended to be used by sophisticated applications, for\n example, a Scanner object which utilizes the rich\n parsing/scanning functionality provided by the Scanner:\n  Console con = System.console();\n if (con != null) {\n     Scanner sc = new Scanner(con.reader());\n     ...\n }\n \n \n For simple applications requiring only line-oriented reading, use\n readLine(java.lang.String, java.lang.Object...).\n \n The bulk read operations read(char[]) ,\n read(char[], int, int)  and\n read(java.nio.CharBuffer)\n on the returned object will not read in characters beyond the line\n bound for each invocation, even if the destination buffer has space for\n more characters. The Reader's read methods may block if a\n line bound has not been entered or reached on the console's input device.\n A line bound is considered to be any one of a line feed ('\\n'),\n a carriage return ('\\r'), a carriage return followed immediately\n by a linefeed, or an end of stream."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public Console format(String fmt, Object... args)",
                  "description": "Writes a formatted string to this console's output stream using\n the specified format string and arguments."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public Console printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this console's\n output stream using the specified format string and arguments.\n\n  An invocation of this method of the form\n con.printf(format, args) behaves in exactly the same way\n as the invocation of\n con.format(format, args)."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine(String fmt, Object... args)",
                  "description": "Provides a formatted prompt, then reads a single line of text from the\n console."
                },
                {
                  "signature": "public String readLine()",
                  "description": "Reads a single line of text from the console."
                }
              ]
            },
            {
              "name": "readPassword",
              "overloads": [
                {
                  "signature": "public char[] readPassword(String fmt, Object... args)",
                  "description": "Provides a formatted prompt, then reads a password or passphrase from\n the console with echoing disabled."
                },
                {
                  "signature": "public char[] readPassword()",
                  "description": "Reads a password or passphrase from the console with echoing disabled"
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the console and forces any buffered output to be written\n immediately ."
                }
              ]
            },
            {
              "name": "charset",
              "overloads": [
                {
                  "signature": "public Charset charset()",
                  "description": "Returns the Charset object used for\n the Console.\n \n The returned charset corresponds to the input and output source\n (e.g., keyboard and/or display) specified by the host environment or user.\n It may not necessarily be the same as the default charset returned from\n Charset.defaultCharset()."
                }
              ]
            }
          ]
        },
        {
          "name": "DataInput",
          "methods": [
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "void readFully(byte[] b) throws IOException",
                  "description": "Reads some bytes from an input\n stream and stores them into the buffer\n array b. The number of bytes\n read is equal\n to the length of b.\n \n This method blocks until one of the\n following conditions occurs:\n \n b.length\n bytes of input data are available, in which\n case a normal return is made.\n\n End of\n file is detected, in which case an EOFException\n is thrown.\n\n An I/O error occurs, in\n which case an IOException other\n than EOFException is thrown.\n \n \n If b is null,\n a NullPointerException is thrown.\n If b.length is zero, then\n no bytes are read. Otherwise, the first\n byte read is stored into element b[0],\n the next one into b[1], and\n so on.\n If an exception is thrown from\n this method, then it may be that some but\n not all bytes of b have been\n updated with data from the input stream."
                },
                {
                  "signature": "void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "Reads len\n bytes from\n an input stream.\n \n This method\n blocks until one of the following conditions\n occurs:\n \n len bytes\n of input data are available, in which case\n a normal return is made.\n\n End of file\n is detected, in which case an EOFException\n is thrown.\n\n An I/O error occurs, in\n which case an IOException other\n than EOFException is thrown.\n \n \n If b is null,\n a NullPointerException is thrown.\n If off is negative, or len\n is negative, or off+len is\n greater than the length of the array b,\n then an IndexOutOfBoundsException\n is thrown.\n If len is zero,\n then no bytes are read. Otherwise, the first\n byte read is stored into element b[off],\n the next one into b[off+1],\n and so on. The number of bytes read is,\n at most, equal to len."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "int skipBytes(int n) throws IOException",
                  "description": "Makes an attempt to skip over\n n bytes\n of data from the input\n stream, discarding the skipped bytes. However,\n it may skip\n over some smaller number of\n bytes, possibly zero. This may result from\n any of a\n number of conditions; reaching\n end of file before n bytes\n have been skipped is\n only one possibility.\n This method never throws an EOFException.\n The actual\n number of bytes skipped is returned."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "boolean readBoolean() throws IOException",
                  "description": "Reads one input byte and returns\n true if that byte is nonzero,\n false if that byte is zero.\n This method is suitable for reading\n the byte written by the writeBoolean\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "byte readByte() throws IOException",
                  "description": "Reads and returns one input byte.\n The byte is treated as a signed value in\n the range -128 through 127,\n inclusive.\n This method is suitable for\n reading the byte written by the writeByte\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "int readUnsignedByte() throws IOException",
                  "description": "Reads one input byte, zero-extends\n it to type int, and returns\n the result, which is therefore in the range\n 0\n through 255.\n This method is suitable for reading\n the byte written by the writeByte\n method of interface DataOutput\n if the argument to writeByte\n was intended to be a value in the range\n 0 through 255."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "short readShort() throws IOException",
                  "description": "Reads two input bytes and returns\n a short value. Let a\n be the first byte read and b\n be the second byte. The value\n returned\n is:\n (short)((a << 8) | (b & 0xff))\n \n This method\n is suitable for reading the bytes written\n by the writeShort method of\n interface DataOutput."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "int readUnsignedShort() throws IOException",
                  "description": "Reads two input bytes and returns\n an int value in the range 0\n through 65535. Let a\n be the first byte read and\n b\n be the second byte. The value returned is:\n (((a & 0xff) << 8) | (b & 0xff))\n \n This method is suitable for reading the bytes\n written by the writeShort method\n of interface DataOutput  if\n the argument to writeShort\n was intended to be a value in the range\n 0 through 65535."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "char readChar() throws IOException",
                  "description": "Reads two input bytes and returns a char value.\n Let a\n be the first byte read and b\n be the second byte. The value\n returned is:\n (char)((a << 8) | (b & 0xff))\n \n This method\n is suitable for reading bytes written by\n the writeChar method of interface\n DataOutput."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "int readInt() throws IOException",
                  "description": "Reads four input bytes and returns an\n int value. Let a-d\n be the first through fourth bytes read. The value returned is:\n \n (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n  ((c & 0xff) <<  8) | (d & 0xff))\n \n This method is suitable\n for reading bytes written by the writeInt\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "long readLong() throws IOException",
                  "description": "Reads eight input bytes and returns\n a long value. Let a-h\n be the first through eighth bytes read.\n The value returned is:\n \n (((long)(a & 0xff) << 56) |\n  ((long)(b & 0xff) << 48) |\n  ((long)(c & 0xff) << 40) |\n  ((long)(d & 0xff) << 32) |\n  ((long)(e & 0xff) << 24) |\n  ((long)(f & 0xff) << 16) |\n  ((long)(g & 0xff) <<  8) |\n  ((long)(h & 0xff)))\n \n \n This method is suitable\n for reading bytes written by the writeLong\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "float readFloat() throws IOException",
                  "description": "Reads four input bytes and returns\n a float value. It does this\n by first constructing an int\n value in exactly the manner\n of the readInt\n method, then converting this int\n value to a float in\n exactly the manner of the method Float.intBitsToFloat.\n This method is suitable for reading\n bytes written by the writeFloat\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "double readDouble() throws IOException",
                  "description": "Reads eight input bytes and returns\n a double value. It does this\n by first constructing a long\n value in exactly the manner\n of the readLong\n method, then converting this long\n value to a double in exactly\n the manner of the method Double.longBitsToDouble.\n This method is suitable for reading\n bytes written by the writeDouble\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "String readLine() throws IOException",
                  "description": "Reads the next line of text from the input stream.\n It reads successive bytes, converting\n each byte separately into a character,\n until it encounters a line terminator or\n end of\n file; the characters read are then\n returned as a String. Note\n that because this\n method processes bytes,\n it does not support input of the full Unicode\n character set.\n \n If end of file is encountered\n before even one byte can be read, then null\n is returned. Otherwise, each byte that is\n read is converted to type char\n by zero-extension. If the character '\\n'\n is encountered, it is discarded and reading\n ceases. If the character '\\r'\n is encountered, it is discarded and, if\n the following byte converts  to the\n character '\\n', then that is\n discarded also; reading then ceases. If\n end of file is encountered before either\n of the characters '\\n' and\n '\\r' is encountered, reading\n ceases. Once reading has ceased, a String\n is returned that contains all the characters\n read and not discarded, taken in order.\n Note that every character in this string\n will have a value less than \\u0100,\n that is, (char)256."
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "String readUTF() throws IOException",
                  "description": "Reads in a string that has been encoded using a\n modified UTF-8\n format.\n The general contract of readUTF\n is that it reads a representation of a Unicode\n character string encoded in modified\n UTF-8 format; this string of characters\n is then returned as a String.\n \n First, two bytes are read and used to\n construct an unsigned 16-bit integer in\n exactly the manner of the readUnsignedShort\n method . This integer value is called the\n UTF length and specifies the number\n of additional bytes to be read. These bytes\n are then converted to characters by considering\n them in groups. The length of each group\n is computed from the value of the first\n byte of the group. The byte following a\n group, if any, is the first byte of the\n next group.\n \n If the first byte of a group\n matches the bit pattern 0xxxxxxx\n (where x means \"may be 0\n or 1\"), then the group consists\n of just that byte. The byte is zero-extended\n to form a character.\n \n If the first byte\n of a group matches the bit pattern 110xxxxx,\n then the group consists of that byte a\n and a second byte b. If there\n is no byte b (because byte\n a was the last of the bytes\n to be read), or if byte b does\n not match the bit pattern 10xxxxxx,\n then a UTFDataFormatException\n is thrown. Otherwise, the group is converted\n to the character:\n (char)(((a & 0x1F) << 6) | (b & 0x3F))\n \n If the first byte of a group\n matches the bit pattern 1110xxxx,\n then the group consists of that byte a\n and two more bytes b and c.\n If there is no byte c (because\n byte a was one of the last\n two of the bytes to be read), or either\n byte b or byte c\n does not match the bit pattern 10xxxxxx,\n then a UTFDataFormatException\n is thrown. Otherwise, the group is converted\n to the character:\n \n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n \n If the first byte of a group matches the\n pattern 1111xxxx or the pattern\n 10xxxxxx, then a UTFDataFormatException\n is thrown.\n \n If end of file is encountered\n at any time during this entire process,\n then an EOFException is thrown.\n \n After every group has been converted to\n a character by this process, the characters\n are gathered, in the same order in which\n their corresponding groups were read from\n the input stream, to form a String,\n which is returned.\n \n The writeUTF\n method of interface DataOutput\n may be used to write data that is suitable\n for reading by this method."
                }
              ]
            }
          ]
        },
        {
          "name": "DataInputStream",
          "methods": [
            {
              "name": "DataInputStream",
              "overloads": [
                {
                  "signature": "public DataInputStream(InputStream in)",
                  "description": "Creates a DataInputStream that uses the specified\n underlying InputStream."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public final int read(byte[] b) throws IOException",
                  "description": "Reads some number of bytes from the contained input stream and\n stores them into the buffer array b. The number of\n bytes actually read is returned as an integer. This method blocks\n until input data is available, end of file is detected, or an\n exception is thrown.\n\n If b is null, a NullPointerException is\n thrown. If the length of b is zero, then no bytes are\n read and 0 is returned; otherwise, there is an attempt\n to read at least one byte. If no byte is available because the\n stream is at end of file, the value -1 is returned;\n otherwise, at least one byte is read and stored into b.\n\n The first byte read is stored into element b[0], the\n next one into b[1], and so on. The number of bytes read\n is, at most, equal to the length of b. Let k\n be the number of bytes actually read; these bytes will be stored in\n elements b[0] through b[k-1], leaving\n elements b[k] through b[b.length-1]\n unaffected.\n\n The read(b) method has the same effect as:\n  read(b, 0, b.length)"
                },
                {
                  "signature": "public final int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from the contained\n input stream into an array of bytes.  An attempt is made to read\n as many as len bytes, but a smaller number may be read,\n possibly zero. The number of bytes actually read is returned as an\n integer.\n\n  This method blocks until input data is available, end of file is\n detected, or an exception is thrown.\n\n  If len is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at end of\n file, the value -1 is returned; otherwise, at least one\n byte is read and stored into b.\n\n  The first byte read is stored into element b[off], the\n next one into b[off+1], and so on. The number of bytes read\n is, at most, equal to len. Let k be the number of\n bytes actually read; these bytes will be stored in elements\n b[off] through b[off+k-1],\n leaving elements b[off+k] through\n b[off+len-1] unaffected.\n\n  In every case, elements b[0] through\n b[off] and elements b[off+len] through\n b[b.length-1] are unaffected."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public final void readFully(byte[] b) throws IOException",
                  "description": "See the general contract of the readFully\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                },
                {
                  "signature": "public final void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "See the general contract of the readFully\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public final int skipBytes(int n) throws IOException",
                  "description": "See the general contract of the skipBytes\n method of DataInput.\n \n Bytes for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public final boolean readBoolean() throws IOException",
                  "description": "See the general contract of the readBoolean\n method of DataInput.\n \n Bytes for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public final byte readByte() throws IOException",
                  "description": "See the general contract of the readByte\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public final int readUnsignedByte() throws IOException",
                  "description": "See the general contract of the readUnsignedByte\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public final short readShort() throws IOException",
                  "description": "See the general contract of the readShort\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public final int readUnsignedShort() throws IOException",
                  "description": "See the general contract of the readUnsignedShort\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public final char readChar() throws IOException",
                  "description": "See the general contract of the readChar\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public final int readInt() throws IOException",
                  "description": "See the general contract of the readInt\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public final long readLong() throws IOException",
                  "description": "See the general contract of the readLong\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public final float readFloat() throws IOException",
                  "description": "See the general contract of the readFloat\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public final double readDouble() throws IOException",
                  "description": "See the general contract of the readDouble\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "@Deprecated public final String readLine() throws IOException",
                  "description": "See the general contract of the readLine\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public final String readUTF() throws IOException",
                  "description": "See the general contract of the readUTF\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                },
                {
                  "signature": "public static final String readUTF(DataInput in) throws IOException",
                  "description": "Reads from the\n stream in a representation\n of a Unicode  character string encoded in\n modified UTF-8 format;\n this string of characters is then returned as a String.\n The details of the modified UTF-8 representation\n are  exactly the same as for the readUTF\n method of DataInput."
                }
              ]
            }
          ]
        },
        {
          "name": "DataOutput",
          "methods": [
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "void write(int b) throws IOException",
                  "description": "Writes to the output stream the eight\n low-order bits of the argument b.\n The 24 high-order  bits of b\n are ignored."
                },
                {
                  "signature": "void write(byte[] b) throws IOException",
                  "description": "Writes to the output stream all the bytes in array b.\n If b is null,\n a NullPointerException is thrown.\n If b.length is zero, then\n no bytes are written. Otherwise, the byte\n b[0] is written first, then\n b[1], and so on; the last byte\n written is b[b.length-1]."
                },
                {
                  "signature": "void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from array\n b, in order,  to\n the output stream.  If b\n is null, a NullPointerException\n is thrown.  If off is negative,\n or len is negative, or off+len\n is greater than the length of the array\n b, then an IndexOutOfBoundsException\n is thrown.  If len is zero,\n then no bytes are written. Otherwise, the\n byte b[off] is written first,\n then b[off+1], and so on; the\n last byte written is b[off+len-1]."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean value to this output stream.\n If the argument v\n is true, the value (byte)1\n is written; if v is false,\n the  value (byte)0 is written.\n The byte written by this method may\n be read by the readBoolean\n method of interface DataInput,\n which will then return a boolean\n equal to v."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "void writeByte(int v) throws IOException",
                  "description": "Writes to the output stream the eight low-order\n bits of the argument v.\n The 24 high-order bits of v\n are ignored. (This means  that writeByte\n does exactly the same thing as write\n for an integer argument.) The byte written\n by this method may be read by the readByte\n method of interface DataInput,\n which will then return a byte\n equal to (byte)v."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "void writeShort(int v) throws IOException",
                  "description": "Writes two bytes to the output\n stream to represent the value of the argument.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n  \n The bytes written by this method may be\n read by the readShort method\n of interface DataInput, which\n will then return a short equal\n to (short)v."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "void writeChar(int v) throws IOException",
                  "description": "Writes a char value, which\n is comprised of two bytes, to the\n output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n \n The bytes written by this method may be\n read by the readChar method\n of interface DataInput, which\n will then return a char equal\n to (char)v."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "void writeInt(int v) throws IOException",
                  "description": "Writes an int value, which is\n comprised of four bytes, to the output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n \n The bytes written by this method may be read\n by the readInt method of interface\n DataInput, which will then\n return an int equal to v."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "void writeLong(long v) throws IOException",
                  "description": "Writes a long value, which is\n comprised of eight bytes, to the output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 56))\n (byte)(0xff & (v >> 48))\n (byte)(0xff & (v >> 40))\n (byte)(0xff & (v >> 32))\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n \n The bytes written by this method may be\n read by the readLong method\n of interface DataInput, which\n will then return a long equal\n to v."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "void writeFloat(float v) throws IOException",
                  "description": "Writes a float value,\n which is comprised of four bytes, to the output stream.\n It does this as if it first converts this\n float value to an int\n in exactly the manner of the Float.floatToIntBits\n method  and then writes the int\n value in exactly the manner of the  writeInt\n method.  The bytes written by this method\n may be read by the readFloat\n method of interface DataInput,\n which will then return a float\n equal to v."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "void writeDouble(double v) throws IOException",
                  "description": "Writes a double value,\n which is comprised of eight bytes, to the output stream.\n It does this as if it first converts this\n double value to a long\n in exactly the manner of the Double.doubleToLongBits\n method  and then writes the long\n value in exactly the manner of the  writeLong\n method. The bytes written by this method\n may be read by the readDouble\n method of interface DataInput,\n which will then return a double\n equal to v."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "void writeBytes(String s) throws IOException",
                  "description": "Writes a string to the output stream.\n For every character in the string\n s,  taken in order, one byte\n is written to the output stream.  If\n s is null, a NullPointerException\n is thrown.  If s.length\n is zero, then no bytes are written. Otherwise,\n the character s[0] is written\n first, then s[1], and so on;\n the last character written is s[s.length-1].\n For each character, one byte is written,\n the low-order byte, in exactly the manner\n of the writeByte method . The\n high-order eight bits of each character\n in the string are ignored."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "void writeChars(String s) throws IOException",
                  "description": "Writes every character in the string s,\n to the output stream, in order,\n two bytes per character. If s\n is null, a NullPointerException\n is thrown.  If s.length\n is zero, then no characters are written.\n Otherwise, the character s[0]\n is written first, then s[1],\n and so on; the last character written is\n s[s.length-1]. For each character,\n two bytes are actually written, high-order\n byte first, in exactly the manner of the\n writeChar method."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "void writeUTF(String s) throws IOException",
                  "description": "Writes two bytes of length information\n to the output stream, followed\n by the\n modified UTF-8\n representation\n of  every character in the string s.\n If s is null,\n a NullPointerException is thrown.\n Each character in the string s\n is converted to a group of one, two, or\n three bytes, depending on the value of the\n character.\n If a character c\n is in the range \\u0001 through\n \\u007f, it is represented\n by one byte:\n (byte)c   \n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown: \n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n   If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown: \n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n    First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written.  The\n bytes written by this method may be read\n by the readUTF method of interface\n DataInput, which will then\n return a String equal to s."
                }
              ]
            }
          ]
        },
        {
          "name": "DataOutputStream",
          "methods": [
            {
              "name": "DataOutputStream",
              "overloads": [
                {
                  "signature": "public DataOutputStream(OutputStream out)",
                  "description": "Creates a new data output stream to write data to the specified\n underlying output stream. The counter written is\n set to zero."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte (the low eight bits of the argument\n b) to the underlying output stream. If no exception\n is thrown, the counter written is incremented by\n 1.\n \n Implements the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to the underlying output stream.\n If no exception is thrown, the counter written is\n incremented by len."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this data output stream. This forces any buffered output\n bytes to be written out to the stream.\n \n The flush method of DataOutputStream\n calls the flush method of its underlying output stream."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public final void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean to the underlying output stream as\n a 1-byte value. The value true is written out as the\n value (byte)1; the value false is\n written out as the value (byte)0. If no exception is\n thrown, the counter written is incremented by\n 1."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public final void writeByte(int v) throws IOException",
                  "description": "Writes out a byte to the underlying output stream as\n a 1-byte value. If no exception is thrown, the counter\n written is incremented by 1."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public final void writeShort(int v) throws IOException",
                  "description": "Writes a short to the underlying output stream as two\n bytes, high byte first. If no exception is thrown, the counter\n written is incremented by 2."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public final void writeChar(int v) throws IOException",
                  "description": "Writes a char to the underlying output stream as a\n 2-byte value, high byte first. If no exception is thrown, the\n counter written is incremented by 2."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public final void writeInt(int v) throws IOException",
                  "description": "Writes an int to the underlying output stream as four\n bytes, high byte first. If no exception is thrown, the counter\n written is incremented by 4."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public final void writeLong(long v) throws IOException",
                  "description": "Writes a long to the underlying output stream as eight\n bytes, high byte first. In no exception is thrown, the counter\n written is incremented by 8."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public final void writeFloat(float v) throws IOException",
                  "description": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the underlying\n output stream as a 4-byte quantity, high byte first. If no\n exception is thrown, the counter written is\n incremented by 4."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public final void writeDouble(double v) throws IOException",
                  "description": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the underlying\n output stream as an 8-byte quantity, high byte first. If no\n exception is thrown, the counter written is\n incremented by 8."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public final void writeBytes(String s) throws IOException",
                  "description": "Writes out the string to the underlying output stream as a\n sequence of bytes. Each character in the string is written out, in\n sequence, by discarding its high eight bits. If no exception is\n thrown, the counter written is incremented by the\n length of s."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public final void writeChars(String s) throws IOException",
                  "description": "Writes a string to the underlying output stream as a sequence of\n characters. Each character is written to the data output stream as\n if by the writeChar method. If no exception is\n thrown, the counter written is incremented by twice\n the length of s."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public final void writeUTF(String str) throws IOException",
                  "description": "Writes a string to the underlying output stream using\n modified UTF-8\n encoding in a machine-independent manner.\n \n First, two bytes are written to the output stream as if by the\n writeShort method giving the number of bytes to\n follow. This value is the number of bytes actually written out,\n not the length of the string. Following the length, each character\n of the string is output, in sequence, using the modified UTF-8 encoding\n for the character. If no exception is thrown, the counter\n written is incremented by the total number of\n bytes written to the output stream. This will be at least two\n plus the length of str, and at most two plus\n thrice the length of str."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public final int size()",
                  "description": "Returns the current value of the counter written,\n the number of bytes written to this data output stream so far.\n If the counter overflows, it will be wrapped to Integer.MAX_VALUE."
                }
              ]
            }
          ]
        },
        {
          "name": "EOFException",
          "methods": [
            {
              "name": "EOFException",
              "overloads": [
                {
                  "signature": "public EOFException()",
                  "description": "Constructs an EOFException with null\n as its error detail message."
                },
                {
                  "signature": "public EOFException(String s)",
                  "description": "Constructs an EOFException with the specified detail\n message. The string s may later be retrieved by the\n Throwable.getMessage() method of class\n java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "Externalizable",
          "methods": [
            {
              "name": "writeExternal",
              "overloads": [
                {
                  "signature": "void writeExternal(ObjectOutput out) throws IOException",
                  "description": "The object implements the writeExternal method to save its contents\n by calling the methods of DataOutput for its primitive values or\n calling the writeObject method of ObjectOutput for objects, strings,\n and arrays."
                }
              ]
            },
            {
              "name": "readExternal",
              "overloads": [
                {
                  "signature": "void readExternal(ObjectInput in) throws IOException, ClassNotFoundException",
                  "description": "The object implements the readExternal method to restore its\n contents by calling the methods of DataInput for primitive\n types and readObject for objects, strings and arrays.  The\n readExternal method must read the values in the same sequence\n and with the same types as were written by writeExternal."
                }
              ]
            }
          ]
        },
        {
          "name": "File",
          "methods": [
            {
              "name": "File",
              "overloads": [
                {
                  "signature": "public File(String pathname)",
                  "description": "Creates a new File instance by converting the given\n pathname string into an abstract pathname.  If the given string is\n the empty string, then the result is the empty abstract pathname."
                },
                {
                  "signature": "public File(String parent, String child)",
                  "description": "Creates a new File instance from a parent pathname string\n and a child pathname string.\n\n  If parent is null then the new\n File instance is created as if by invoking the\n single-argument File constructor on the given\n child pathname string.\n\n  Otherwise the parent pathname string is taken to denote\n a directory, and the child pathname string is taken to\n denote either a directory or a file.  If the child pathname\n string is absolute then it is converted into a relative pathname in a\n system-dependent way.  If parent is the empty string then\n the new File instance is created by converting\n child into an abstract pathname and resolving the result\n against a system-dependent default directory.  Otherwise each pathname\n string is converted into an abstract pathname and the child abstract\n pathname is resolved against the parent."
                },
                {
                  "signature": "public File(File parent, String child)",
                  "description": "Creates a new File instance from a parent abstract\n pathname and a child pathname string.\n\n  If parent is null then the new\n File instance is created as if by invoking the\n single-argument File constructor on the given\n child pathname string.\n\n  Otherwise the parent abstract pathname is taken to\n denote a directory, and the child pathname string is taken\n to denote either a directory or a file.  If the child\n pathname string is absolute then it is converted into a relative\n pathname in a system-dependent way.  If parent is the empty\n abstract pathname then the new File instance is created by\n converting child into an abstract pathname and resolving\n the result against a system-dependent default directory.  Otherwise each\n pathname string is converted into an abstract pathname and the child\n abstract pathname is resolved against the parent."
                },
                {
                  "signature": "public File(URI uri)",
                  "description": "Creates a new File instance by converting the given\n file: URI into an abstract pathname.\n\n  The exact form of a file: URI is system-dependent, hence\n the transformation performed by this constructor is also\n system-dependent.\n\n  For a given abstract pathname f it is guaranteed that\n\n \n new File(f.toURI()).equals(f.getAbsoluteFile())\n \n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  This relationship typically does not hold,\n however, when a file: URI that is created in a virtual machine\n on one operating system is converted into an abstract pathname in a\n virtual machine on a different operating system."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the file or directory denoted by this abstract\n pathname.  This is just the last name in the pathname's name\n sequence.  If the pathname's name sequence is empty, then the empty\n string is returned."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public String getParent()",
                  "description": "Returns the pathname string of this abstract pathname's parent, or\n null if this pathname does not name a parent directory.\n\n  The parent of an abstract pathname consists of the\n pathname's prefix, if any, and each name in the pathname's name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory."
                }
              ]
            },
            {
              "name": "getParentFile",
              "overloads": [
                {
                  "signature": "public File getParentFile()",
                  "description": "Returns the abstract pathname of this abstract pathname's parent,\n or null if this pathname does not name a parent\n directory.\n\n  The parent of an abstract pathname consists of the\n pathname's prefix, if any, and each name in the pathname's name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Converts this abstract pathname into a pathname string.  The resulting\n string uses the default name-separator character to\n separate the names in the name sequence."
                }
              ]
            },
            {
              "name": "isAbsolute",
              "overloads": [
                {
                  "signature": "public boolean isAbsolute()",
                  "description": "Tests whether this abstract pathname is absolute.  The definition of\n absolute pathname is system dependent.  On UNIX systems, a pathname is\n absolute if its prefix is \"/\".  On Microsoft Windows systems, a\n pathname is absolute if its prefix is a drive specifier followed by\n \"\\\\\", or if its prefix is \"\\\\\\\\\"."
                }
              ]
            },
            {
              "name": "getAbsolutePath",
              "overloads": [
                {
                  "signature": "public String getAbsolutePath()",
                  "description": "Returns the absolute pathname string of this abstract pathname.\n\n  If this abstract pathname is already absolute, then the pathname\n string is simply returned as if by the getPath()\n method.  If this abstract pathname is the empty abstract pathname then\n the pathname string of the current user directory, which is named by the\n system property user.dir, is returned.  Otherwise this\n pathname is resolved in a system-dependent way.  On UNIX systems, a\n relative pathname is made absolute by resolving it against the current\n user directory.  On Microsoft Windows systems, a relative pathname is made absolute\n by resolving it against the current directory of the drive named by the\n pathname, if any; if not, it is resolved against the current user\n directory."
                }
              ]
            },
            {
              "name": "getAbsoluteFile",
              "overloads": [
                {
                  "signature": "public File getAbsoluteFile()",
                  "description": "Returns the absolute form of this abstract pathname.  Equivalent to\n newFile(this.getAbsolutePath())."
                }
              ]
            },
            {
              "name": "getCanonicalPath",
              "overloads": [
                {
                  "signature": "public String getCanonicalPath() throws IOException",
                  "description": "Returns the canonical pathname string of this abstract pathname.\n\n  A canonical pathname is both absolute and unique.  The precise\n definition of canonical form is system-dependent.  This method first\n converts this pathname to absolute form if necessary, as if by invoking the\n getAbsolutePath() method, and then maps it to its unique form in a\n system-dependent way.  This typically involves removing redundant names\n such as \".\" and \"..\" from the pathname, resolving\n symbolic links (on UNIX platforms), and converting drive letters to a\n standard case (on Microsoft Windows platforms).\n\n  Every pathname that denotes an existing file or directory has a\n unique canonical form.  Every pathname that denotes a nonexistent file\n or directory also has a unique canonical form.  The canonical form of\n the pathname of a nonexistent file or directory may be different from\n the canonical form of the same pathname after the file or directory is\n created.  Similarly, the canonical form of the pathname of an existing\n file or directory may be different from the canonical form of the same\n pathname after the file or directory is deleted."
                }
              ]
            },
            {
              "name": "getCanonicalFile",
              "overloads": [
                {
                  "signature": "public File getCanonicalFile() throws IOException",
                  "description": "Returns the canonical form of this abstract pathname.  Equivalent to\n newFile(this.getCanonicalPath())."
                }
              ]
            },
            {
              "name": "toURL",
              "overloads": [
                {
                  "signature": "@Deprecated public URL toURL() throws MalformedURLException",
                  "description": "Converts this abstract pathname into a file: URL.  The\n exact form of the URL is system-dependent.  If it can be determined that\n the file denoted by this abstract pathname is a directory, then the\n resulting URL will end with a slash.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toURI",
              "overloads": [
                {
                  "signature": "public URI toURI()",
                  "description": "Constructs a file: URI that represents this abstract pathname.\n\n  The exact form of the URI is system-dependent.  If it can be\n determined that the file denoted by this abstract pathname is a\n directory, then the resulting URI will end with a slash.\n\n  For a given abstract pathname f, it is guaranteed that\n\n \n new File(f.toURI()).equals(\n f.getAbsoluteFile())\n \n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  Due to the system-dependent nature of abstract\n pathnames, however, this relationship typically does not hold when a\n file: URI that is created in a virtual machine on one operating\n system is converted into an abstract pathname in a virtual machine on a\n different operating system.\n\n  Note that when this abstract pathname represents a UNC pathname then\n all components of the UNC (including the server name component) are encoded\n in the URI path. The authority component is undefined, meaning\n that it is represented as null. The Path class defines the\n toUri method to encode the server name in the authority\n component of the resulting URI. The toPath method\n may be used to obtain a Path representing this abstract pathname."
                }
              ]
            },
            {
              "name": "canRead",
              "overloads": [
                {
                  "signature": "public boolean canRead()",
                  "description": "Tests whether the application can read the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to read\n files that are marked as unreadable. Consequently this method may return\n true even though the file does not have read permissions."
                }
              ]
            },
            {
              "name": "canWrite",
              "overloads": [
                {
                  "signature": "public boolean canWrite()",
                  "description": "Tests whether the application can modify the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Consequently this method may return\n true even though the file is marked read-only."
                }
              ]
            },
            {
              "name": "exists",
              "overloads": [
                {
                  "signature": "public boolean exists()",
                  "description": "Tests whether the file or directory denoted by this abstract pathname\n exists."
                }
              ]
            },
            {
              "name": "isDirectory",
              "overloads": [
                {
                  "signature": "public boolean isDirectory()",
                  "description": "Tests whether the file denoted by this abstract pathname is a\n directory.\n\n  Where it is required to distinguish an I/O exception from the case\n that the file is not a directory, or where several attributes of the\n same file are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "isFile",
              "overloads": [
                {
                  "signature": "public boolean isFile()",
                  "description": "Tests whether the file denoted by this abstract pathname is a normal\n file.  A file is normal if it is not a directory and, in\n addition, satisfies other system-dependent criteria.  Any non-directory\n file created by a Java application is guaranteed to be a normal file.\n\n  Where it is required to distinguish an I/O exception from the case\n that the file is not a normal file, or where several attributes of the\n same file are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "isHidden",
              "overloads": [
                {
                  "signature": "public boolean isHidden()",
                  "description": "Tests whether the file named by this abstract pathname is a hidden\n file.  The exact definition of hidden is system-dependent.  On\n UNIX systems, a file is considered to be hidden if its name begins with\n a period character ('.').  On Microsoft Windows systems, a file is\n considered to be hidden if it has been marked as such in the filesystem."
                }
              ]
            },
            {
              "name": "lastModified",
              "overloads": [
                {
                  "signature": "public long lastModified()",
                  "description": "Returns the time that the file denoted by this abstract pathname was\n last modified."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public long length()",
                  "description": "Returns the length of the file denoted by this abstract pathname.\n The return value is unspecified if this pathname denotes a directory.\n\n  Where it is required to distinguish an I/O exception from the case\n that 0L is returned, or where several attributes of the same file\n are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "createNewFile",
              "overloads": [
                {
                  "signature": "public boolean createNewFile() throws IOException",
                  "description": "Atomically creates a new, empty file named by this abstract pathname if\n and only if a file with this name does not yet exist.  The check for the\n existence of the file and the creation of the file if it does not exist\n are a single operation that is atomic with respect to all other\n filesystem activities that might affect the file.\n \n Note: this method should not be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n FileLock\n facility should be used instead."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public boolean delete()",
                  "description": "Deletes the file or directory denoted by this abstract pathname.  If\n this pathname denotes a directory, then the directory must be empty in\n order to be deleted.\n\n  Note that the Files class defines the delete method to throw an IOException\n when a file cannot be deleted. This is useful for error reporting and to\n diagnose why a file cannot be deleted."
                }
              ]
            },
            {
              "name": "deleteOnExit",
              "overloads": [
                {
                  "signature": "public void deleteOnExit()",
                  "description": "Requests that the file or directory denoted by this abstract\n pathname be deleted when the virtual machine terminates.\n Files (or directories) are deleted in the reverse order that\n they are registered. Invoking this method to delete a file or\n directory that is already registered for deletion has no effect.\n Deletion will be attempted only for normal termination of the\n virtual machine, as defined by the Java Language Specification.\n\n  Once deletion has been requested, it is not possible to cancel the\n request.  This method should therefore be used with care.\n\n \n Note: this method should not be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n FileLock\n facility should be used instead."
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public String[] list()",
                  "description": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname.\n\n  If this abstract pathname does not denote a directory, then this\n method returns null.  Otherwise an array of strings is\n returned, one for each file or directory in the directory.  Names\n denoting the directory itself and the directory's parent directory are\n not included in the result.  Each string is a file name rather than a\n complete path.\n\n  There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n  Note that the Files class defines the newDirectoryStream method to\n open a directory and iterate over the names of the files in the directory.\n This may use less resources when working with very large directories, and\n may be more responsive when working with remote directories."
                },
                {
                  "signature": "public String[] list(FilenameFilter filter)",
                  "description": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname that satisfy the specified\n filter.  The behavior of this method is the same as that of the\n list() method, except that the strings in the returned array\n must satisfy the filter.  If the given filter is null\n then all names are accepted.  Otherwise, a name satisfies the filter if\n and only if the value true results when the FilenameFilter.accept(File,String) method\n of the filter is invoked on this abstract pathname and the name of a\n file or directory in the directory that it denotes."
                }
              ]
            },
            {
              "name": "listFiles",
              "overloads": [
                {
                  "signature": "public File[] listFiles()",
                  "description": "Returns an array of abstract pathnames denoting the files in the\n directory denoted by this abstract pathname.\n\n  If this abstract pathname does not denote a directory, then this\n method returns null.  Otherwise an array of File objects\n is returned, one for each file or directory in the directory.  Pathnames\n denoting the directory itself and the directory's parent directory are\n not included in the result.  Each resulting abstract pathname is\n constructed from this abstract pathname using the File(File,String) constructor.  Therefore if this\n pathname is absolute then each resulting pathname is absolute; if this\n pathname is relative then each resulting pathname will be relative to\n the same directory.\n\n  There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n  Note that the Files class defines the newDirectoryStream method\n to open a directory and iterate over the names of the files in the\n directory. This may use less resources when working with very large\n directories."
                },
                {
                  "signature": "public File[] listFiles(FilenameFilter filter)",
                  "description": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the listFiles() method, except that the pathnames in\n the returned array must satisfy the filter.  If the given filter\n is null then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value true results when\n the FilenameFilter.accept(File,String) method of the filter is\n invoked on this abstract pathname and the name of a file or directory in\n the directory that it denotes."
                },
                {
                  "signature": "public File[] listFiles(FileFilter filter)",
                  "description": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the listFiles() method, except that the pathnames in\n the returned array must satisfy the filter.  If the given filter\n is null then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value true results when\n the FileFilter.accept(File) method of the\n filter is invoked on the pathname."
                }
              ]
            },
            {
              "name": "mkdir",
              "overloads": [
                {
                  "signature": "public boolean mkdir()",
                  "description": "Creates the directory named by this abstract pathname."
                }
              ]
            },
            {
              "name": "mkdirs",
              "overloads": [
                {
                  "signature": "public boolean mkdirs()",
                  "description": "Creates the directory named by this abstract pathname, including any\n necessary but nonexistent parent directories.  Note that if this\n operation fails it may have succeeded in creating some of the necessary\n parent directories."
                }
              ]
            },
            {
              "name": "renameTo",
              "overloads": [
                {
                  "signature": "public boolean renameTo(File dest)",
                  "description": "Renames the file denoted by this abstract pathname.\n\n  Many aspects of the behavior of this method are inherently\n platform-dependent: The rename operation might not be able to move a\n file from one filesystem to another, it might not be atomic, and it\n might not succeed if a file with the destination abstract pathname\n already exists.  The return value should always be checked to make sure\n that the rename operation was successful.  As instances of File\n are immutable, this File object is not changed to name the destination\n file or directory.\n\n  Note that the Files class defines the move method to move or rename a file in a\n platform independent manner."
                }
              ]
            },
            {
              "name": "setLastModified",
              "overloads": [
                {
                  "signature": "public boolean setLastModified(long time)",
                  "description": "Sets the last-modified time of the file or directory named by this\n abstract pathname.\n\n  All platforms support file-modification times to the nearest second,\n but some provide more precision.  The argument will be truncated to fit\n the supported precision.  If the operation succeeds and no intervening\n operations on the file take place, then the next invocation of the\n lastModified() method will return the (possibly\n truncated) time argument that was passed to this method."
                }
              ]
            },
            {
              "name": "setReadOnly",
              "overloads": [
                {
                  "signature": "public boolean setReadOnly()",
                  "description": "Marks the file or directory named by this abstract pathname so that\n only read operations are allowed. After invoking this method the file\n or directory will not change until it is either deleted or marked\n to allow write access. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Whether or not a read-only file or\n directory may be deleted depends upon the underlying system."
                }
              ]
            },
            {
              "name": "setWritable",
              "overloads": [
                {
                  "signature": "public boolean setWritable(boolean writable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setWritable(boolean writable)",
                  "description": "A convenience method to set the owner's write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n  An invocation of this method of the form file.setWritable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setWritable(arg, true)"
                }
              ]
            },
            {
              "name": "setReadable",
              "overloads": [
                {
                  "signature": "public boolean setReadable(boolean readable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that are\n marked as unreadable.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setReadable(boolean readable)",
                  "description": "A convenience method to set the owner's read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that are\n marked as unreadable.\n\n An invocation of this method of the form file.setReadable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setReadable(arg, true)"
                }
              ]
            },
            {
              "name": "setExecutable",
              "overloads": [
                {
                  "signature": "public boolean setExecutable(boolean executable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's execute permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to execute files that are\n not marked executable.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setExecutable(boolean executable)",
                  "description": "A convenience method to set the owner's execute permission for this\n abstract pathname. On some platforms it may be possible to start the Java\n virtual machine with special privileges that allow it to execute files\n that are not marked executable.\n\n An invocation of this method of the form file.setExcutable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setExecutable(arg, true)"
                }
              ]
            },
            {
              "name": "canExecute",
              "overloads": [
                {
                  "signature": "public boolean canExecute()",
                  "description": "Tests whether the application can execute the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to execute\n files that are not marked executable. Consequently this method may return\n true even though the file does not have execute permissions."
                }
              ]
            },
            {
              "name": "listRoots",
              "overloads": [
                {
                  "signature": "public static File[] listRoots()",
                  "description": "List the available filesystem roots.\n\n  A particular Java platform may support zero or more\n hierarchically-organized file systems.  Each file system has a\n root directory from which all other files in that file system\n can be reached.  Windows platforms, for example, have a root directory\n for each active drive; UNIX platforms have a single root directory,\n namely \"/\".  The set of available filesystem roots is affected\n by various system-level operations such as the insertion or ejection of\n removable media and the disconnecting or unmounting of physical or\n virtual disk drives.\n\n  This method returns an array of File objects that denote the\n root directories of the available filesystem roots.  It is guaranteed\n that the canonical pathname of any file physically present on the local\n machine will begin with one of the roots returned by this method.\n\n  The canonical pathname of a file that resides on some other machine\n and is accessed via a remote-filesystem protocol such as SMB or NFS may\n or may not begin with one of the roots returned by this method.  If the\n pathname of a remote file is syntactically indistinguishable from the\n pathname of a local file then it will begin with one of the roots\n returned by this method.  Thus, for example, File objects\n denoting the root directories of the mapped network drives of a Windows\n platform will be returned by this method, while File objects\n containing UNC pathnames will not be returned by this method.\n\n  Unlike most methods in this class, this method does not throw\n security exceptions.  If a security manager exists and its SecurityManager.checkRead(String) method denies read access to a\n particular root directory, then that directory will not appear in the\n result."
                }
              ]
            },
            {
              "name": "getTotalSpace",
              "overloads": [
                {
                  "signature": "public long getTotalSpace()",
                  "description": "Returns the size of the partition named by this\n abstract pathname. If the total number of bytes in the partition is\n greater than Long.MAX_VALUE, then Long.MAX_VALUE will be\n returned."
                }
              ]
            },
            {
              "name": "getFreeSpace",
              "overloads": [
                {
                  "signature": "public long getFreeSpace()",
                  "description": "Returns the number of unallocated bytes in the partition named by this abstract path name.  If the\n number of unallocated bytes in the partition is greater than\n Long.MAX_VALUE, then Long.MAX_VALUE will be returned.\n\n  The returned number of unallocated bytes is a hint, but not\n a guarantee, that it is possible to use most or any of these\n bytes.  The number of unallocated bytes is most likely to be\n accurate immediately after this call.  It is likely to be made\n inaccurate by any external I/O operations including those made\n on the system outside of this virtual machine.  This method\n makes no guarantee that write operations to this file system\n will succeed."
                }
              ]
            },
            {
              "name": "getUsableSpace",
              "overloads": [
                {
                  "signature": "public long getUsableSpace()",
                  "description": "Returns the number of bytes available to this virtual machine on the\n partition named by this abstract pathname.  If\n the number of available bytes in the partition is greater than\n Long.MAX_VALUE, then Long.MAX_VALUE will be returned.\n When possible, this method checks for write permissions and other\n operating system restrictions and will therefore usually provide a more\n accurate estimate of how much new data can actually be written than\n getFreeSpace().\n\n  The returned number of available bytes is a hint, but not a\n guarantee, that it is possible to use most or any of these bytes.  The\n number of available bytes is most likely to be accurate immediately\n after this call.  It is likely to be made inaccurate by any external\n I/O operations including those made on the system outside of this\n virtual machine.  This method makes no guarantee that write operations\n to this file system will succeed."
                }
              ]
            },
            {
              "name": "createTempFile",
              "overloads": [
                {
                  "signature": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException",
                  "description": "Creates a new empty file in the specified directory, using the\n given prefix and suffix strings to generate its name.  If this method\n returns successfully then it is guaranteed that:\n\n \n  The file denoted by the returned abstract pathname did not exist\n      before this method was invoked, and\n  Neither this method nor any of its variants will return the same\n      abstract pathname again in the current invocation of the virtual\n      machine.\n \n\n This method provides only part of a temporary-file facility.  To arrange\n for a file created by this method to be deleted automatically, use the\n deleteOnExit() method.\n\n  The prefix argument must be at least three characters\n long.  It is recommended that the prefix be a short, meaningful string\n such as \"hjb\" or \"mail\".  The\n suffix argument may be null, in which case the\n suffix \".tmp\" will be used.\n\n  To create the new file, the prefix and the suffix may first be\n adjusted to fit the limitations of the underlying platform.  If the\n prefix is too long then it will be truncated, but its first three\n characters will always be preserved.  If the suffix is too long then it\n too will be truncated, but if it begins with a period character\n ('.') then the period and the first three characters\n following it will always be preserved.  Once these adjustments have been\n made the name of the new file will be generated by concatenating the\n prefix, five or more internally-generated characters, and the suffix.\n\n  If the directory argument is null then the\n system-dependent default temporary-file directory will be used.  The\n default temporary-file directory is specified by the system property\n java.io.tmpdir.  On UNIX systems the default value of this\n property is typically \"/tmp\" or \"/var/tmp\"; on\n Microsoft Windows systems it is typically \"C:\\\\WINNT\\\\TEMP\".  A different\n value may be given to this system property when the Java virtual machine\n is invoked, but programmatic changes to this property are not guaranteed\n to have any effect upon the temporary directory used by this method."
                },
                {
                  "signature": "public static File createTempFile(String prefix, String suffix) throws IOException",
                  "description": "Creates an empty file in the default temporary-file directory, using\n the given prefix and suffix to generate its name. Invoking this method\n is equivalent to invoking createTempFile(prefix,suffix,null).\n\n  The Files.createTempFile method provides an alternative method to create an\n empty file in the temporary-file directory. Files created by that method\n may have more restrictive access permissions to files created by this\n method and so may be more suited to security-sensitive applications."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(File pathname)",
                  "description": "Compares two abstract pathnames lexicographically.  The ordering\n defined by this method depends upon the underlying system.  On UNIX\n systems, alphabetic case is significant in comparing pathnames; on\n Microsoft Windows systems it is not."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Tests this abstract pathname for equality with the given object.\n Returns true if and only if the argument is not\n null and is an abstract pathname that is the same as this\n abstract pathname.  Whether or not two abstract\n pathnames are equal depends upon the underlying operating system.\n On UNIX systems, alphabetic case is significant in comparing pathnames;\n on Microsoft Windows systems it is not."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Computes a hash code for this abstract pathname.  Because equality of\n abstract pathnames is inherently system-dependent, so is the computation\n of their hash codes.  On UNIX systems, the hash code of an abstract\n pathname is equal to the exclusive or of the hash code\n of its pathname string and the decimal value\n 1234321.  On Microsoft Windows systems, the hash\n code is equal to the exclusive or of the hash code of\n its pathname string converted to lower case and the decimal\n value 1234321.  Locale is not taken into account on\n lowercasing the pathname string."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the pathname string of this abstract pathname.  This is just the\n string returned by the getPath() method."
                }
              ]
            },
            {
              "name": "toPath",
              "overloads": [
                {
                  "signature": "public Path toPath()",
                  "description": "Returns a java.nio.file.Path object constructed from\n this abstract path. The resulting Path is associated with the\n default-filesystem.\n\n  The first invocation of this method works as if invoking it were\n equivalent to evaluating the expression:\n  FileSystems.getDefault().getPath(this.getPath());\n \n Subsequent invocations of this method return the same Path.\n\n  If this abstract pathname is the empty abstract pathname then this\n method returns a Path that may be used to access the current\n user directory."
                }
              ]
            }
          ]
        },
        {
          "name": "FileDescriptor",
          "methods": [
            {
              "name": "FileDescriptor",
              "overloads": [
                {
                  "signature": "public FileDescriptor()",
                  "description": "Constructs an (invalid) FileDescriptor object.\n The fd or handle is set later."
                }
              ]
            },
            {
              "name": "valid",
              "overloads": [
                {
                  "signature": "public boolean valid()",
                  "description": "Tests if this file descriptor object is valid."
                }
              ]
            },
            {
              "name": "sync",
              "overloads": [
                {
                  "signature": "public void sync() throws SyncFailedException",
                  "description": "Force all system buffers to synchronize with the underlying\n device.  This method returns after all modified data and\n attributes of this FileDescriptor have been written to the\n relevant device(s).  In particular, if this FileDescriptor\n refers to a physical storage medium, such as a file in a file\n system, sync will not return until all in-memory modified copies\n of buffers associated with this FileDescriptor have been\n written to the physical medium.\n\n sync is meant to be used by code that requires physical\n storage (such as a file) to be in a known state  For\n example, a class that provided a simple transaction facility\n might use sync to ensure that all changes to a file caused\n by a given transaction were recorded on a storage medium.\n\n sync only affects buffers downstream of this FileDescriptor.  If\n any in-memory buffering is being done by the application (for\n example, by a BufferedOutputStream object), those buffers must\n be flushed into the FileDescriptor (for example, by invoking\n OutputStream.flush) before that data will be affected by sync."
                }
              ]
            }
          ]
        },
        {
          "name": "FileFilter",
          "methods": [
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "boolean accept(File pathname)",
                  "description": "Tests whether or not the specified abstract pathname should be\n included in a pathname list."
                }
              ]
            }
          ]
        },
        {
          "name": "FileInputStream",
          "methods": [
            {
              "name": "FileInputStream",
              "overloads": [
                {
                  "signature": "public FileInputStream(String name) throws FileNotFoundException",
                  "description": "Creates a FileInputStream by\n opening a connection to an actual file,\n the file named by the path name name\n in the file system.  A new FileDescriptor\n object is created to represent this file\n connection.\n \n First, if there is a security\n manager, its checkRead method\n is called with the name argument\n as its argument.\n \n If the named file does not exist, is a directory rather than a regular\n file, or for some other reason cannot be opened for reading then a\n FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileInputStream(File file) throws FileNotFoundException",
                  "description": "Creates a FileInputStream by\n opening a connection to an actual file,\n the file named by the File\n object file in the file system.\n A new FileDescriptor object\n is created to represent this file connection.\n \n First, if there is a security manager,\n its checkRead method  is called\n with the path represented by the file\n argument as its argument.\n \n If the named file does not exist, is a directory rather than a regular\n file, or for some other reason cannot be opened for reading then a\n FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileInputStream(FileDescriptor fdObj)",
                  "description": "Creates a FileInputStream by using the file descriptor\n fdObj, which represents an existing connection to an\n actual file in the file system.\n \n If there is a security manager, its checkRead method is\n called with the file descriptor fdObj as its argument to\n see if it's ok to read the file descriptor. If read access is denied\n to the file descriptor a SecurityException is thrown.\n \n If fdObj is null then a NullPointerException\n is thrown.\n \n This constructor does not throw an exception if fdObj\n is invalid.\n However, if the methods are invoked on the resulting stream to attempt\n I/O on the stream, an IOException is thrown."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data from this input stream. This method blocks\n if no input is yet available."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this input\n stream into an array of bytes. This method blocks until some input\n is available."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. If len is not zero, the method\n blocks until some input is available; otherwise, no\n bytes are read and 0 is returned."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from the\n input stream.\n\n The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. If n is negative, the method\n will try to skip backwards. In case the backing file does not support\n backward skip at its current position, an IOException is\n thrown. The actual number of bytes skipped is returned. If it skips\n forwards, it returns a positive value. If it skips backwards, it\n returns a negative value.\n\n This method may skip more bytes than what are remaining in the\n backing file. This produces no exception and the number of bytes skipped\n may include some number of bytes that were beyond the EOF of the\n backing file. Attempting to read from the stream after skipping past\n the end will result in -1 indicating the end of the file."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of remaining bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. Returns 0 when the file\n position is beyond EOF. The next invocation might be the same thread\n or another thread. A single read or skip of this many bytes will not\n block, but may read or skip fewer bytes.\n\n  In some cases, a non-blocking read (or skip) may appear to be\n blocked when it is merely slow, for example when reading large\n files over slow networks."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this file input stream and releases any system resources\n associated with the stream.\n\n  If this stream has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the FileDescriptor\n object  that represents the connection to\n the actual file in the file system being\n used by this FileInputStream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file input stream.\n\n  The initial position of the returned channel will be equal to the\n number of bytes read from the file so far.  Reading bytes from this\n stream will increment the channel's position.  Changing the channel's\n position, either explicitly or by reading, will change this stream's\n file position."
                }
              ]
            }
          ]
        },
        {
          "name": "FilenameFilter",
          "methods": [
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "boolean accept(File dir, String name)",
                  "description": "Tests if a specified file should be included in a file list."
                }
              ]
            }
          ]
        },
        {
          "name": "FileNotFoundException",
          "methods": [
            {
              "name": "FileNotFoundException",
              "overloads": [
                {
                  "signature": "public FileNotFoundException()",
                  "description": "Constructs a FileNotFoundException with\n null as its error detail message."
                },
                {
                  "signature": "public FileNotFoundException(String s)",
                  "description": "Constructs a FileNotFoundException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "FileOutputStream",
          "methods": [
            {
              "name": "FileOutputStream",
              "overloads": [
                {
                  "signature": "public FileOutputStream(String name) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file with the\n specified name. A new FileDescriptor object is\n created to represent this file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with name as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(String name, boolean append) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file with the specified\n name.  If the second argument is true, then\n bytes will be written to the end of the file rather than the beginning.\n A new FileDescriptor object is created to represent this\n file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with name as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(File file) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file represented by\n the specified File object. A new\n FileDescriptor object is created to represent this\n file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with the path represented by the file\n argument as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(File file, boolean append) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file represented by\n the specified File object. If the second argument is\n true, then bytes will be written to the end of the file\n rather than the beginning. A new FileDescriptor object is\n created to represent this file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with the path represented by the file\n argument as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(FileDescriptor fdObj)",
                  "description": "Creates a file output stream to write to the specified file\n descriptor, which represents an existing connection to an actual\n file in the file system.\n \n First, if there is a security manager, its checkWrite\n method is called with the file descriptor fdObj\n argument as its argument.\n \n If fdObj is null then a NullPointerException\n is thrown.\n \n This constructor does not throw an exception if fdObj\n is invalid.\n However, if the methods are invoked on the resulting stream to attempt\n I/O on the stream, an IOException is thrown."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this file output stream. Implements\n the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this file output stream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this file output stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this file output stream and releases any system resources\n associated with this stream. This file output stream may no longer\n be used for writing bytes.\n\n  If this stream has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the file descriptor associated with this stream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file output stream.\n\n  The initial position of the returned channel will be equal to the\n number of bytes written to the file so far unless this stream is in\n append mode, in which case it will be equal to the size of the file.\n Writing bytes to this stream will increment the channel's position\n accordingly.  Changing the channel's position, either explicitly or by\n writing, will change this stream's file position."
                }
              ]
            }
          ]
        },
        {
          "name": "FilePermission",
          "methods": [
            {
              "name": "FilePermission",
              "overloads": [
                {
                  "signature": "public FilePermission(String path, String actions)",
                  "description": "Creates a new FilePermission object with the specified actions.\n path is the pathname of a file or directory, and actions\n contains a comma-separated list of the desired actions granted on the\n file or directory. Possible actions are\n \"read\", \"write\", \"execute\", \"delete\", and \"readlink\".\n\n A pathname that ends in \"/*\" (where \"/\" is\n the file separator character, File.separatorChar)\n indicates all the files and directories contained in that directory.\n A pathname that ends with \"/-\" indicates (recursively) all files and\n subdirectories contained in that directory. The special pathname\n \"<<ALL FILES>>\" matches any file.\n\n A pathname consisting of a single \"*\" indicates all the files\n in the current directory, while a pathname consisting of a single \"-\"\n indicates all the files in the current directory and\n (recursively) all files and subdirectories contained in the current\n directory.\n\n A pathname containing an empty string represents an empty path."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this FilePermission object \"implies\" the specified permission.\n \n More specifically, this method returns true if:\n \n  p is an instanceof FilePermission,\n  p's actions are a proper subset of this\n object's actions, and\n  p's pathname is implied by this object's\n      pathname. For example, \"/tmp/*\" implies \"/tmp/foo\", since\n      \"/tmp/*\" encompasses all files in the \"/tmp\" directory,\n      including the one named \"foo\".\n \n \n Precisely, a simple pathname implies another simple pathname\n if and only if they are equal. A simple pathname never implies\n a wildcard pathname. A wildcard pathname implies another wildcard\n pathname if and only if all simple pathnames implied by the latter\n are implied by the former. A wildcard pathname implies a simple\n pathname if and only if\n \n     if the wildcard flag is \"*\", the simple pathname's path\n     must be right inside the wildcard pathname's path.\n     if the wildcard flag is \"-\", the simple pathname's path\n     must be recursively inside the wildcard pathname's path.\n \n \n \"<<ALL FILES>>\" implies every other pathname. No pathname,\n except for \"<<ALL FILES>>\" itself, implies\n \"<<ALL FILES>>\"."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two FilePermission objects for equality. Checks that obj is\n a FilePermission, and has the same pathname and actions as this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the \"canonical string representation\" of the actions.\n That is, this method always returns present actions in the following order:\n read, write, execute, delete, readlink. For example, if this FilePermission\n object allows both write and read actions, a call to getActions\n will return the string \"read,write\"."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing FilePermission\n objects.\n \n FilePermission objects must be stored in a manner that allows them\n to be inserted into the collection in any order, but that also enables the\n PermissionCollection implies\n method to be implemented in an efficient (and consistent) manner.\n\n For example, if you have two FilePermissions:\n \n   \"/tmp/-\", \"read\"\n   \"/tmp/scratch/foo\", \"write\"\n \n\n and you are calling the implies method with the FilePermission:\n\n    \"/tmp/scratch/foo\", \"read,write\",\n \n\n then the implies function must\n take into account both the \"/tmp/-\" and \"/tmp/scratch/foo\"\n permissions, so the effective permission is \"read,write\",\n and implies returns true. The \"implies\" semantics for\n FilePermissions are handled properly by the PermissionCollection object\n returned by this newPermissionCollection method."
                }
              ]
            }
          ]
        },
        {
          "name": "FileReader",
          "methods": [
            {
              "name": "FileReader",
              "overloads": [
                {
                  "signature": "public FileReader(String fileName) throws FileNotFoundException",
                  "description": "Creates a new FileReader, given the name of the file to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(File file) throws FileNotFoundException",
                  "description": "Creates a new FileReader, given the File to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(FileDescriptor fd)",
                  "description": "Creates a new FileReader, given the FileDescriptor to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new FileReader, given the name of the file to read\n and the charset."
                },
                {
                  "signature": "public FileReader(File file, Charset charset) throws IOException",
                  "description": "Creates a new FileReader, given the File to read and\n the charset."
                }
              ]
            }
          ]
        },
        {
          "name": "FileWriter",
          "methods": [
            {
              "name": "FileWriter",
              "overloads": [
                {
                  "signature": "public FileWriter(String fileName) throws IOException",
                  "description": "Constructs a FileWriter given a file name, using the platform's\n default charset"
                },
                {
                  "signature": "public FileWriter(String fileName, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given a file name and a boolean indicating\n whether to append the data written, using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(File file) throws IOException",
                  "description": "Constructs a FileWriter given the File to write,\n using the platform's\n default charset"
                },
                {
                  "signature": "public FileWriter(File file, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given the File to write and\n a boolean indicating whether to append the data written, using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(FileDescriptor fd)",
                  "description": "Constructs a FileWriter given a file descriptor,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(String fileName, Charset charset) throws IOException",
                  "description": "Constructs a FileWriter given a file name and\n charset."
                },
                {
                  "signature": "public FileWriter(String fileName, Charset charset, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given a file name,\n charset and a boolean indicating\n whether to append the data written."
                },
                {
                  "signature": "public FileWriter(File file, Charset charset) throws IOException",
                  "description": "Constructs a FileWriter given the File to write and\n charset."
                },
                {
                  "signature": "public FileWriter(File file, Charset charset, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given the File to write,\n charset and a boolean indicating\n whether to append the data written."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterInputStream",
          "methods": [
            {
              "name": "FilterInputStream",
              "overloads": [
                {
                  "signature": "protected FilterInputStream(InputStream in)",
                  "description": "Creates a FilterInputStream\n by assigning the  argument in\n to the field this.in so as\n to remember it for later use."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n \n This method\n simply performs in.read() and returns the result."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this\n input stream into an array of bytes. This method blocks until some\n input is available.\n \n This method simply performs the call\n read(b, 0, b.length) and returns\n the  result. It is important that it does\n not do in.read(b) instead;\n certain subclasses of  FilterInputStream\n depend on the implementation strategy actually\n used."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. If len is not zero, the method\n blocks until some input is available; otherwise, no\n bytes are read and 0 is returned.\n \n This method simply performs in.read(b, off, len)\n and returns the result."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from the\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. The actual number of bytes skipped is\n returned.\n \n This method simply performs in.skip(n)."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n caller of a method for this input stream. The next caller might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method returns the result of in.available()."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n This\n method simply performs in.close()."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent\n call to the reset method repositions this stream at\n the last marked position so that subsequent reads re-read the same bytes.\n \n The readlimit argument tells this input stream to\n allow that many bytes to be read before the mark position gets\n invalidated.\n \n This method simply performs in.mark(readlimit)."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n \n This method\n simply performs in.reset().\n \n Stream marks are intended to be used in\n situations where you need to read ahead a little to see what's in\n the stream. Often this is most easily done by invoking some\n general parser. If the stream is of the type handled by the\n parse, it just chugs along happily. If the stream is not of\n that type, the parser should toss an exception when it fails.\n If this happens within readlimit bytes, it allows the outer\n code to reset the stream and try another parser."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark\n and reset methods.\n This method\n simply performs in.markSupported()."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterOutputStream",
          "methods": [
            {
              "name": "FilterOutputStream",
              "overloads": [
                {
                  "signature": "public FilterOutputStream(OutputStream out)",
                  "description": "Creates an output stream filter built on top of the specified\n underlying output stream."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this output stream.\n \n The write method of FilterOutputStream\n calls the write method of its underlying output stream,\n that is, it performs out.write(b).\n \n Implements the abstract write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes to this output stream.\n \n The write method of FilterOutputStream\n calls its write method of three arguments with the\n arguments b, 0, and\n b.length.\n \n Note that this method does not call the one-argument\n write method of its underlying output stream with\n the single argument b."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified\n byte array starting at offset off to\n this output stream.\n \n The write method of FilterOutputStream\n calls the write method of one argument on each\n byte to output.\n \n Note that this method does not call the write method\n of its underlying output stream with the same arguments. Subclasses\n of FilterOutputStream should provide a more efficient\n implementation of this method."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out to the stream.\n \n The flush method of FilterOutputStream\n calls the flush method of its underlying output stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this output stream and releases any system resources\n associated with the stream.\n \n When not already closed, the close method of \n FilterOutputStream calls its flush method, and then\n calls the close method of its underlying output stream."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterReader",
          "methods": [
            {
              "name": "FilterReader",
              "overloads": [
                {
                  "signature": "protected FilterReader(Reader in)",
                  "description": "Creates a new filtered reader."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters.  This method will block until some characters are\n available, an I/O error occurs, or the end of the stream is reached.\n If the stream is already at its end before this method is invoked,\n then no characters are skipped and zero is returned."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            }
          ]
        },
        {
          "name": "FilterWriter",
          "methods": [
            {
              "name": "FilterWriter",
              "overloads": [
                {
                  "signature": "protected FilterWriter(Writer out)",
                  "description": "Create a new filtered writer."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "Flushable",
          "methods": [
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "void flush() throws IOException",
                  "description": "Flushes this stream by writing any buffered output to the underlying\n stream."
                }
              ]
            }
          ]
        },
        {
          "name": "InputStream",
          "methods": [
            {
              "name": "InputStream",
              "overloads": [
                {
                  "signature": "public InputStream()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "nullInputStream",
              "overloads": [
                {
                  "signature": "public static InputStream nullInputStream()",
                  "description": "Returns a new InputStream that reads no bytes. The returned\n stream is initially open.  The stream is closed by calling the\n close() method.  Subsequent calls to close() have no\n effect.\n\n  While the stream is open, the available(), read(),\n read(byte[]), read(byte[], int, int),\n readAllBytes(), readNBytes(byte[], int, int),\n readNBytes(int), skip(long), skipNBytes(long),\n and transferTo() methods all behave as if end of stream has been\n reached.  After the stream has been closed, these methods all throw\n IOException.\n\n  The markSupported() method returns false.  The\n mark() method does nothing, and the reset() method\n throws IOException."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public abstract int read() throws IOException",
                  "description": "Reads the next byte of data from the input stream. The value byte is\n returned as an int in the range 0 to\n 255. If no byte is available because the end of the stream\n has been reached, the value -1 is returned. This method\n blocks until input data is available, the end of the stream is detected,\n or an exception is thrown.\n\n  A subclass must provide an implementation of this method."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads some number of bytes from the input stream and stores them into\n the buffer array b. The number of bytes actually read is\n returned as an integer.  This method blocks until input data is\n available, end of file is detected, or an exception is thrown.\n\n  If the length of b is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at the\n end of the file, the value -1 is returned; otherwise, at\n least one byte is read and stored into b.\n\n  The first byte read is stored into element b[0], the\n next one into b[1], and so on. The number of bytes read is,\n at most, equal to the length of b. Let k be the\n number of bytes actually read; these bytes will be stored in elements\n b[0] through b[k-1],\n leaving elements b[k] through\n b[b.length-1] unaffected.\n\n  The read(b) method for class InputStream\n has the same effect as:  read(b, 0, b.length)"
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from the input stream into\n an array of bytes.  An attempt is made to read as many as\n len bytes, but a smaller number may be read.\n The number of bytes actually read is returned as an integer.\n\n  This method blocks until input data is available, end of file is\n detected, or an exception is thrown.\n\n  If len is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at end of\n file, the value -1 is returned; otherwise, at least one\n byte is read and stored into b.\n\n  The first byte read is stored into element b[off], the\n next one into b[off+1], and so on. The number of bytes read\n is, at most, equal to len. Let k be the number of\n bytes actually read; these bytes will be stored in elements\n b[off] through b[off+k-1],\n leaving elements b[off+k] through\n b[off+len-1] unaffected.\n\n  In every case, elements b[0] through\n b[off-1] and elements b[off+len] through\n b[b.length-1] are unaffected.\n\n  The read(b, off, len) method\n for class InputStream simply calls the method\n read() repeatedly. If the first such call results in an\n IOException, that exception is returned from the call to\n the read(b, off, len) method.  If\n any subsequent call to read() results in a\n IOException, the exception is caught and treated as if it\n were end of file; the bytes read up to that point are stored into\n b and the number of bytes read before the exception\n occurred is returned. The default implementation of this method blocks\n until the requested amount of input data len has been read,\n end of file is detected, or an exception is thrown. Subclasses are\n encouraged to provide a more efficient implementation of this method."
                }
              ]
            },
            {
              "name": "readAllBytes",
              "overloads": [
                {
                  "signature": "public byte[] readAllBytes() throws IOException",
                  "description": "Reads all remaining bytes from the input stream. This method blocks until\n all remaining bytes have been read and end of stream is detected, or an\n exception is thrown. This method does not close the input stream.\n\n  When this stream reaches end of stream, further invocations of this\n method will return an empty byte array.\n\n  Note that this method is intended for simple cases where it is\n convenient to read all bytes into a byte array. It is not intended for\n reading input streams with large amounts of data.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes have been read. Consequently the input\n stream may not be at end of stream and may be in an inconsistent state.\n It is strongly recommended that the stream be promptly closed if an I/O\n error occurs."
                }
              ]
            },
            {
              "name": "readNBytes",
              "overloads": [
                {
                  "signature": "public byte[] readNBytes(int len) throws IOException",
                  "description": "Reads up to a specified number of bytes from the input stream. This\n method blocks until the requested number of bytes has been read, end\n of stream is detected, or an exception is thrown. This method does not\n close the input stream.\n\n  The length of the returned array equals the number of bytes read\n from the stream. If len is zero, then no bytes are read and\n an empty byte array is returned. Otherwise, up to len bytes\n are read from the stream. Fewer than len bytes may be read if\n end of stream is encountered.\n\n  When this stream reaches end of stream, further invocations of this\n method will return an empty byte array.\n\n  Note that this method is intended for simple cases where it is\n convenient to read the specified number of bytes into a byte array. The\n total amount of memory allocated by this method is proportional to the\n number of bytes read from the stream which is bounded by len.\n Therefore, the method may be safely called with very large values of\n len provided sufficient memory is available.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes have been read. Consequently the input\n stream may not be at end of stream and may be in an inconsistent state.\n It is strongly recommended that the stream be promptly closed if an I/O\n error occurs."
                },
                {
                  "signature": "public int readNBytes(byte[] b, int off, int len) throws IOException",
                  "description": "Reads the requested number of bytes from the input stream into the given\n byte array. This method blocks until len bytes of input data have\n been read, end of stream is detected, or an exception is thrown. The\n number of bytes actually read, possibly zero, is returned. This method\n does not close the input stream.\n\n  In the case where end of stream is reached before len bytes\n have been read, then the actual number of bytes read will be returned.\n When this stream reaches end of stream, further invocations of this\n method will return zero.\n\n  If len is zero, then no bytes are read and 0 is\n returned; otherwise, there is an attempt to read up to len bytes.\n\n  The first byte read is stored into element b[off], the next\n one in to b[off+1], and so on. The number of bytes read is, at\n most, equal to len. Let k be the number of bytes actually\n read; these bytes will be stored in elements b[off] through\n b[off+k-1], leaving elements b[off+k\n ] through b[off+len-1] unaffected.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes of b have been updated with\n data from the input stream. Consequently the input stream and b\n may be in an inconsistent state. It is strongly recommended that the\n stream be promptly closed if an I/O error occurs."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this input\n stream. The skip method may, for a variety of reasons, end\n up skipping over some smaller number of bytes, possibly 0.\n This may result from any of a number of conditions; reaching end of file\n before n bytes have been skipped is only one possibility.\n The actual number of bytes skipped is returned. If n is\n negative, the skip method for class InputStream always\n returns 0, and no bytes are skipped. Subclasses may handle the negative\n value differently.\n\n  The skip method implementation of this class creates a\n byte array and then repeatedly reads into it until n bytes\n have been read or the end of the stream has been reached. Subclasses are\n encouraged to provide a more efficient implementation of this method.\n For instance, the implementation may depend on the ability to seek."
                }
              ]
            },
            {
              "name": "skipNBytes",
              "overloads": [
                {
                  "signature": "public void skipNBytes(long n) throws IOException",
                  "description": "Skips over and discards exactly n bytes of data from this input\n stream.  If n is zero, then no bytes are skipped.\n If n is negative, then no bytes are skipped.\n Subclasses may handle the negative value differently.\n\n  This method blocks until the requested number of bytes has been\n skipped, end of file is reached, or an exception is thrown.\n\n  If end of stream is reached before the stream is at the desired\n position, then an EOFException is thrown.\n\n  If an I/O error occurs, then the input stream may be\n in an inconsistent state. It is strongly recommended that the\n stream be promptly closed if an I/O error occurs."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or skipped\n over) from this input stream without blocking, which may be 0, or 0 when\n end of stream is detected.  The read might be on the same thread or\n another thread.  A single read or skip of this many bytes will not block,\n but may read or skip fewer bytes.\n\n  Note that while some implementations of InputStream will\n return the total number of bytes in the stream, many will not.  It is\n never correct to use the return value of this method to allocate\n a buffer intended to hold all data in this stream.\n\n  A subclass's implementation of this method may choose to throw an\n IOException if this input stream has been closed by invoking the\n close() method.\n\n  The available method of InputStream always returns\n 0.\n\n  This method should be overridden by subclasses."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources associated\n with the stream.\n\n  The close method of InputStream does\n nothing."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent call to\n the reset method repositions this stream at the last marked\n position so that subsequent reads re-read the same bytes.\n\n  The readlimit arguments tells this input stream to\n allow that many bytes to be read before the mark position gets\n invalidated.\n\n  The general contract of mark is that, if the method\n markSupported returns true, the stream somehow\n remembers all the bytes read after the call to mark and\n stands ready to supply those same bytes again if and whenever the method\n reset is called.  However, the stream is not required to\n remember any data at all if more than readlimit bytes are\n read from the stream before reset is called.\n\n  Marking a closed stream should not have any effect on the stream.\n\n  The mark method of InputStream does\n nothing."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n\n  The general contract of reset is:\n\n \n  If the method markSupported returns\n true, then:\n\n      If the method mark has not been called since\n     the stream was created, or the number of bytes read from the stream\n     since mark was last called is larger than the argument\n     to mark at that last call, then an\n     IOException might be thrown.\n\n      If such an IOException is not thrown, then the\n     stream is reset to a state such that all the bytes read since the\n     most recent call to mark (or since the start of the\n     file, if mark has not been called) will be resupplied\n     to subsequent callers of the read method, followed by\n     any bytes that otherwise would have been the next input data as of\n     the time of the call to reset. \n\n  If the method markSupported returns\n false, then:\n\n      The call to reset may throw an\n     IOException.\n\n      If an IOException is not thrown, then the stream\n     is reset to a fixed state that depends on the particular type of the\n     input stream and how it was created. The bytes that will be supplied\n     to subsequent callers of the read method depend on the\n     particular type of the input stream. \n\n The method reset for class InputStream\n does nothing except throw an IOException."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark and\n reset methods. Whether or not mark and\n reset are supported is an invariant property of a\n particular input stream instance. The markSupported method\n of InputStream returns false."
                }
              ]
            },
            {
              "name": "transferTo",
              "overloads": [
                {
                  "signature": "public long transferTo(OutputStream out) throws IOException",
                  "description": "Reads all bytes from this input stream and writes the bytes to the\n given output stream in the order that they are read. On return, this\n input stream will be at end of stream. This method does not close either\n stream.\n \n This method may block indefinitely reading from the input stream, or\n writing to the output stream. The behavior for the case where the input\n and/or output stream is asynchronously closed, or the thread\n interrupted during the transfer, is highly input and output stream\n specific, and therefore not specified.\n \n If an I/O error occurs reading from the input stream or writing to the\n output stream, then it may do so after some bytes have been read or\n written. Consequently the input stream may not be at end of stream and\n one, or both, streams may be in an inconsistent state. It is strongly\n recommended that both streams be promptly closed if an I/O error occurs."
                }
              ]
            }
          ]
        },
        {
          "name": "InputStreamReader",
          "methods": [
            {
              "name": "InputStreamReader",
              "overloads": [
                {
                  "signature": "public InputStreamReader(InputStream in)",
                  "description": "Creates an InputStreamReader that uses the\n default charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException",
                  "description": "Creates an InputStreamReader that uses the named charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, Charset cs)",
                  "description": "Creates an InputStreamReader that uses the given charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, CharsetDecoder dec)",
                  "description": "Creates an InputStreamReader that uses the given charset decoder."
                }
              ]
            },
            {
              "name": "getEncoding",
              "overloads": [
                {
                  "signature": "public String getEncoding()",
                  "description": "Returns the name of the character encoding being used by this stream.\n\n  If the encoding has an historical name then that name is returned;\n otherwise the encoding's canonical name is returned.\n\n  If this instance was created with the InputStreamReader(InputStream, String) constructor then the returned\n name, being unique for the encoding, may differ from the name passed to\n the constructor. This method will return null if the\n stream has been closed."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  An InputStreamReader is\n ready if its input buffer is not empty, or if bytes are available to be\n read from the underlying byte stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            }
          ]
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "InterruptedIOException",
          "methods": [
            {
              "name": "InterruptedIOException",
              "overloads": [
                {
                  "signature": "public InterruptedIOException()",
                  "description": "Constructs an InterruptedIOException with\n null as its error detail message."
                },
                {
                  "signature": "public InterruptedIOException(String s)",
                  "description": "Constructs an InterruptedIOException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidClassException",
          "methods": [
            {
              "name": "InvalidClassException",
              "overloads": [
                {
                  "signature": "public InvalidClassException(String reason)",
                  "description": "Report an InvalidClassException for the reason specified."
                },
                {
                  "signature": "public InvalidClassException(String cname, String reason)",
                  "description": "Constructs an InvalidClassException object."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Produce the message and include the classname, if present."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidObjectException",
          "methods": [
            {
              "name": "InvalidObjectException",
              "overloads": [
                {
                  "signature": "public InvalidObjectException(String reason)",
                  "description": "Constructs an InvalidObjectException."
                }
              ]
            }
          ]
        },
        {
          "name": "IOError",
          "methods": [
            {
              "name": "IOError",
              "overloads": [
                {
                  "signature": "public IOError(Throwable cause)",
                  "description": "Constructs a new instance of IOError with the specified cause. The\n IOError is created with the detail message of\n (cause==null ? null : cause.toString()) (which typically\n contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "IOException",
          "methods": [
            {
              "name": "IOException",
              "overloads": [
                {
                  "signature": "public IOException()",
                  "description": "Constructs an IOException with null\n as its error detail message."
                },
                {
                  "signature": "public IOException(String message)",
                  "description": "Constructs an IOException with the specified detail message."
                },
                {
                  "signature": "public IOException(String message, Throwable cause)",
                  "description": "Constructs an IOException with the specified detail message\n and cause.\n\n  Note that the detail message associated with cause is\n not automatically incorporated into this exception's detail\n message."
                },
                {
                  "signature": "public IOException(Throwable cause)",
                  "description": "Constructs an IOException with the specified cause and a\n detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of cause).\n This constructor is useful for IO exceptions that are little more\n than wrappers for other throwables."
                }
              ]
            }
          ]
        },
        {
          "name": "LineNumberInputStream",
          "methods": [
            {
              "name": "LineNumberInputStream",
              "overloads": [
                {
                  "signature": "public LineNumberInputStream(InputStream in)",
                  "description": "Constructs a newline number input stream that reads its input\n from the specified input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n \n The read method of\n LineNumberInputStream calls the read\n method of the underlying input stream. It checks for carriage\n returns and newline characters in the input, and modifies the\n current line number as appropriate. A carriage-return character or\n a carriage return followed by a newline character are both\n converted into a single newline character.",
                  "deprecated": true
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. This method blocks until some input is available.\n \n The read method of\n LineNumberInputStream repeatedly calls the\n read method of zero arguments to fill in the byte array.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. The actual number of bytes skipped is\n returned.  If n is negative, no bytes are skipped.\n \n The skip method of LineNumberInputStream creates\n a byte array and then repeatedly reads into it until\n n bytes have been read or the end of the stream has\n been reached.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setLineNumber",
              "overloads": [
                {
                  "signature": "public void setLineNumber(int lineNumber)",
                  "description": "Sets the line number to the specified argument.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Returns the current line number.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this input\n stream without blocking.\n \n Note that if the underlying input stream is able to supply\n k input characters without blocking, the\n LineNumberInputStream can guarantee only to provide\n k/2 characters without blocking, because the\n k characters from the underlying input stream might\n consist of k/2 pairs of '\\r' and\n '\\n', which are converted to just\n k/2 '\\n' characters.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent\n call to the reset method repositions this stream at\n the last marked position so that subsequent reads re-read the same bytes.\n \n The mark method of\n LineNumberInputStream remembers the current line\n number in a private variable, and then calls the mark\n method of the underlying input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n \n The reset method of\n LineNumberInputStream resets the line number to be\n the line number at the time the mark method was\n called, and then calls the reset method of the\n underlying input stream.\n \n Stream marks are intended to be used in\n situations where you need to read ahead a little to see what's in\n the stream. Often this is most easily done by invoking some\n general parser. If the stream is of the type handled by the\n parser, it just chugs along happily. If the stream is not of\n that type, the parser should toss an exception when it fails,\n which, if it happens within readlimit bytes, allows the outer\n code to reset the stream and try another parser.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "LineNumberReader",
          "methods": [
            {
              "name": "LineNumberReader",
              "overloads": [
                {
                  "signature": "public LineNumberReader(Reader in)",
                  "description": "Create a new line-numbering reader, using the default input-buffer\n size."
                },
                {
                  "signature": "public LineNumberReader(Reader in, int sz)",
                  "description": "Create a new line-numbering reader, reading characters into a buffer of\n the given size."
                }
              ]
            },
            {
              "name": "setLineNumber",
              "overloads": [
                {
                  "signature": "public void setLineNumber(int lineNumber)",
                  "description": "Set the current line number."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Get the current line number."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Read a single character.  Line terminators are\n compressed into single newline ('\\n') characters.  The current line\n number is incremented whenever a line terminator is read, or when the\n end of the stream is reached and the last character in the stream is\n not a line terminator."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf.\n\n Line terminators are compressed into single newline\n ('\\n') characters.  The current line number is incremented whenever a\n line terminator is read, or when the end of the stream is reached and\n the last character in the stream is not a line terminator."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine() throws IOException",
                  "description": "Read a line of text.  Line terminators are compressed\n into single newline ('\\n') characters. The current line number is\n incremented whenever a line terminator is read, or when the end of the\n stream is reached and the last character in the stream is not a line\n terminator."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Mark the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point, and will also reset\n the line number appropriately."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Reset the stream to the most recent mark."
                }
              ]
            }
          ]
        },
        {
          "name": "NotActiveException",
          "methods": [
            {
              "name": "NotActiveException",
              "overloads": [
                {
                  "signature": "public NotActiveException(String reason)",
                  "description": "Constructor to create a new NotActiveException with the reason given."
                },
                {
                  "signature": "public NotActiveException()",
                  "description": "Constructor to create a new NotActiveException without a reason."
                }
              ]
            }
          ]
        },
        {
          "name": "NotSerializableException",
          "methods": [
            {
              "name": "NotSerializableException",
              "overloads": [
                {
                  "signature": "public NotSerializableException(String classname)",
                  "description": "Constructs a NotSerializableException object with message string."
                },
                {
                  "signature": "public NotSerializableException()",
                  "description": "Constructs a NotSerializableException object."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInput",
          "methods": [
            {
              "name": "readObject",
              "overloads": [
                {
                  "signature": "Object readObject() throws ClassNotFoundException, IOException",
                  "description": "Read and return an object. The class that implements this interface\n defines where the object is \"read\" from."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "int read() throws IOException",
                  "description": "Reads a byte of data. This method will block if no input is\n available."
                },
                {
                  "signature": "int read(byte[] b) throws IOException",
                  "description": "Reads into an array of bytes.  This method will\n block until some input is available."
                },
                {
                  "signature": "int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads into an array of bytes.  This method will\n block until some input is available."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "long skip(long n) throws IOException",
                  "description": "Skips n bytes of input."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "int available() throws IOException",
                  "description": "Returns the number of bytes that can be read\n without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes the input stream. Must be called\n to release any resources associated with\n the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter",
          "methods": [
            {
              "name": "checkInput",
              "overloads": [
                {
                  "signature": "ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo filterInfo)",
                  "description": "Check the class, array length, number of object references, depth,\n stream size, and other available filtering information.\n Implementations of this method check the contents of the object graph being created\n during deserialization. The filter returns Status.ALLOWED,\n Status.REJECTED, or Status.UNDECIDED.\n\n If filterInfo.serialClass() is non-null, there is a class to be checked.\n If serialClass() is null, there is no class and the info contains\n only metrics related to the depth of the graph being deserialized, the number of\n references, and the size of the stream read."
                }
              ]
            },
            {
              "name": "allowFilter",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, ObjectInputFilter.Status otherStatus)",
                  "description": "Returns a filter that returns Status.ALLOWED if the predicate\n on the class is true.\n The filter returns ALLOWED or the otherStatus based on the predicate\n of the non-null class and UNDECIDED if the class is null.\n\n When the filter's checkInput(info) method is invoked,\n the predicate is applied to the info.serialClass(),\n the return Status is:\n \n     UNDECIDED, if the serialClass is null,\n     ALLOWED, if the predicate on the class returns true,\n     Otherwise, return otherStatus.\n \n \n Example, to create a filter that will allow any class loaded from the platform\n or bootstrap classloaders.\n \n     ObjectInputFilter f\n         = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader() ||\n                       cl.getClassLoader() == null, Status.UNDECIDED);"
                }
              ]
            },
            {
              "name": "rejectFilter",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, ObjectInputFilter.Status otherStatus)",
                  "description": "Returns a filter that returns Status.REJECTED if the predicate\n on the class is true.\n The filter returns REJECTED or the otherStatus based on the predicate\n of the non-null class and UNDECIDED if the class is null.\n\n When the filter's checkInput(info) method is invoked,\n the predicate is applied to the serialClass(),\n the return Status is:\n \n     UNDECIDED, if the serialClass is null,\n     REJECTED, if the predicate on the class returns true,\n     Otherwise, return otherStatus.\n \n \n Example, to create a filter that will reject any class loaded from the application classloader.\n \n     ObjectInputFilter f = rejectFilter(cl ->\n          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);"
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter)",
                  "description": "Returns a filter that merges the status of a filter and another filter.\n If another filter is null, the filter is returned.\n Otherwise, a filter is returned to merge the pair of non-null filters.\n\n The filter returned implements the checkInput(FilterInfo) method\n as follows:\n \n     Invoke filter on the FilterInfo to get its status;\n     Return REJECTED if the status is REJECTED;\n     Invoke anotherFilter to get the otherStatus;\n     Return REJECTED if the otherStatus is REJECTED;\n     Return ALLOWED, if either status or otherStatus\n          is ALLOWED, \n     Otherwise, return UNDECIDED"
                }
              ]
            },
            {
              "name": "rejectUndecidedClass",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter)",
                  "description": "Returns a filter that invokes a given filter and maps UNDECIDED to REJECTED\n for classes, with some special cases, and otherwise returns the status.\n If the class is not a primitive class and not an array, the status returned is REJECTED.\n If the class is a primitive class or an array class additional checks are performed;\n see the list below for details.\n\n Object deserialization accepts a class if the filter returns UNDECIDED.\n Adding a filter to reject undecided results for classes that have not been\n either allowed or rejected can prevent classes from slipping through the filter."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter.Config",
          "methods": [
            {
              "name": "getSerialFilter",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter getSerialFilter()",
                  "description": "Returns the static JVM-wide deserialization filter or null if not configured."
                }
              ]
            },
            {
              "name": "setSerialFilter",
              "overloads": [
                {
                  "signature": "public static void setSerialFilter(ObjectInputFilter filter)",
                  "description": "Set the static JVM-wide filter if it has not already been configured or set."
                }
              ]
            },
            {
              "name": "getSerialFilterFactory",
              "overloads": [
                {
                  "signature": "public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory()",
                  "description": "Returns the JVM-wide deserialization filter factory.\n If the filter factory has been set it is returned,\n otherwise, a builtin deserialization filter factory is returned.\n The filter factory provides a filter for every ObjectInputStream when invoked from\n ObjectInputStream constructors\n and when a stream-specific filter is set with\n setObjectInputFilter."
                }
              ]
            },
            {
              "name": "setSerialFilterFactory",
              "overloads": [
                {
                  "signature": "public static void setSerialFilterFactory(BinaryOperator<ObjectInputFilter> filterFactory)",
                  "description": "Set the JVM-wide deserialization filter factory.\n The filter factory can be configured exactly once with one of:\n setting the jdk.serialFilterFactory property on the command line,\n setting the jdk.serialFilterFactory property in the Security\n file, or using this setSerialFilterFactory method.\n The filter factory can be set only before any ObjectInputStream has been\n created to avoid any inconsistency in which filter factory is being used.\n\n The JVM-wide filter factory is invoked when an ObjectInputStream\n is constructed and when the\n stream-specific filter is set.\n The parameters are the current filter and a requested filter and it\n returns the filter to be used for the stream.\n If the current filter is non-null, the filter factory must return a\n non-null filter; this is to prevent unintentional disabling of filtering\n after it has been enabled.\n The factory determines the filter to be used for ObjectInputStream streams based\n on its inputs, any other filters, context, or state that is available.\n The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n See the filter models for examples of composition and delegation."
                }
              ]
            },
            {
              "name": "createFilter",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter createFilter(String pattern)",
                  "description": "Returns an ObjectInputFilter from a string of patterns.\n \n Patterns are separated by \";\" (semicolon). Whitespace is significant and\n is considered part of the pattern.\n If a pattern includes an equals assignment, \"=\" it sets a limit.\n If a limit appears more than once the last value is used.\n \n     maxdepth=value - the maximum depth of a graph\n     maxrefs=value  - the maximum number of internal references\n     maxbytes=value - the maximum number of bytes in the input stream\n     maxarray=value - the maximum array length allowed\n \n \n Other patterns match or reject class or package name\n as returned from Class.getName() and\n if an optional module name is present\n class.getModule().getName().\n Note that for arrays the element type is used in the pattern,\n not the array type.\n \n If the pattern starts with \"!\", the class is rejected if the remaining pattern is matched;\n     otherwise the class is allowed if the pattern matches.\n If the pattern contains \"/\", the non-empty prefix up to the \"/\" is the module name;\n     if the module name matches the module name of the class then\n     the remaining pattern is matched with the class name.\n     If there is no \"/\", the module name is not compared.\n If the pattern ends with \".**\" it matches any class in the package and all subpackages.\n If the pattern ends with \".*\" it matches any class in the package.\n If the pattern ends with \"*\", it matches any class with the pattern as a prefix.\n If the pattern is equal to the class name, it matches.\n Otherwise, the pattern is not matched.\n \n \n The resulting filter performs the limit checks and then\n tries to match the class, if any. If any of the limits are exceeded,\n the filter returns Status.REJECTED.\n If the class is an array type, the class to be matched is the element type.\n Arrays of any number of dimensions are treated the same as the element type.\n For example, a pattern of \"!example.Foo\",\n rejects creation of any instance or array of example.Foo.\n The first pattern that matches, working from left to right, determines\n the Status.ALLOWED\n or Status.REJECTED result.\n If the limits are not exceeded and no pattern matches the class,\n the result is Status.UNDECIDED."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter.FilterInfo",
          "methods": [
            {
              "name": "serialClass",
              "overloads": [
                {
                  "signature": "Class<?> serialClass()",
                  "description": "The class of an object being deserialized.\n For arrays, it is the array type.\n For example, the array class name of a 2 dimensional array of strings is\n \"[[Ljava.lang.String;\".\n To check the array's element type, iteratively use\n Class.getComponentType while the result\n is an array and then check the class.\n The serialClass is null in the case where a new object is not being\n created and to give the filter a chance to check the depth, number of\n references to existing objects, and the stream size."
                }
              ]
            },
            {
              "name": "arrayLength",
              "overloads": [
                {
                  "signature": "long arrayLength()",
                  "description": "The number of array elements when deserializing an array of the class."
                }
              ]
            },
            {
              "name": "depth",
              "overloads": [
                {
                  "signature": "long depth()",
                  "description": "The current depth.\n The depth starts at 1 and increases for each nested object and\n decrements when each nested object returns."
                }
              ]
            },
            {
              "name": "references",
              "overloads": [
                {
                  "signature": "long references()",
                  "description": "The current number of object references."
                }
              ]
            },
            {
              "name": "streamBytes",
              "overloads": [
                {
                  "signature": "long streamBytes()",
                  "description": "The current number of bytes consumed."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputStream",
          "methods": [
            {
              "name": "ObjectInputStream",
              "overloads": [
                {
                  "signature": "public ObjectInputStream(InputStream in) throws IOException",
                  "description": "Creates an ObjectInputStream that reads from the specified InputStream.\n A serialization stream header is read from the stream and verified.\n This constructor will block until the corresponding ObjectOutputStream\n has written and flushed the header.\n\n The constructor initializes the deserialization filter to the filter returned\n by invoking the ObjectInputFilter.Config.getSerialFilterFactory() with null for the current filter\n and the static JVM-wide filter for the requested filter.\n\n If a security manager is installed, this constructor will check for\n the \"enableSubclassImplementation\" SerializablePermission when invoked\n directly or indirectly by the constructor of a subclass which overrides\n the ObjectInputStream.readFields or ObjectInputStream.readUnshared\n methods."
                },
                {
                  "signature": "protected ObjectInputStream() throws IOException, SecurityException",
                  "description": "Provide a way for subclasses that are completely reimplementing\n ObjectInputStream to not have to allocate private data just used by this\n implementation of ObjectInputStream.\n\n The constructor initializes the deserialization filter to the filter returned\n by invoking the ObjectInputFilter.Config.getSerialFilterFactory() with null for the current filter\n and the static JVM-wide filter for the requested filter.\n\n If there is a security manager installed, this method first calls the\n security manager's checkPermission method with the\n SerializablePermission(\"enableSubclassImplementation\")\n permission to ensure it's ok to enable subclassing."
                }
              ]
            },
            {
              "name": "readObject",
              "overloads": [
                {
                  "signature": "public final Object readObject() throws IOException, ClassNotFoundException",
                  "description": "Read an object from the ObjectInputStream.  The class of the object, the\n signature of the class, and the values of the non-transient and\n non-static fields of the class and all of its supertypes are read.\n Default deserializing for a class can be overridden using the writeObject\n and readObject methods.  Objects referenced by this object are read\n transitively so that a complete equivalent graph of objects is\n reconstructed by readObject.\n\n The root object is completely restored when all of its fields and the\n objects it references are completely restored.  At this point the object\n validation callbacks are executed in order based on their registered\n priorities. The callbacks are registered by objects (in the readObject\n special methods) as they are individually restored.\n\n The deserialization filter, when not null, is invoked for\n each object (regular or class) read to reconstruct the root object.\n See setObjectInputFilter for details.\n\n Exceptions are thrown for problems with the InputStream and for\n classes that should not be deserialized.  All exceptions are fatal to\n the InputStream and leave it in an indeterminate state; it is up to the\n caller to ignore or recover the stream state."
                }
              ]
            },
            {
              "name": "readObjectOverride",
              "overloads": [
                {
                  "signature": "protected Object readObjectOverride() throws IOException, ClassNotFoundException",
                  "description": "This method is called by trusted subclasses of ObjectInputStream that\n constructed ObjectInputStream using the protected no-arg constructor.\n The subclass is expected to provide an override method with the modifier\n \"final\"."
                }
              ]
            },
            {
              "name": "readUnshared",
              "overloads": [
                {
                  "signature": "public Object readUnshared() throws IOException, ClassNotFoundException",
                  "description": "Reads an \"unshared\" object from the ObjectInputStream.  This method is\n identical to readObject, except that it prevents subsequent calls to\n readObject and readUnshared from returning additional references to the\n deserialized instance obtained via this call.  Specifically:\n \n   If readUnshared is called to deserialize a back-reference (the\n       stream representation of an object which has been written\n       previously to the stream), an ObjectStreamException will be\n       thrown.\n\n   If readUnshared returns successfully, then any subsequent attempts\n       to deserialize back-references to the stream handle deserialized\n       by readUnshared will cause an ObjectStreamException to be thrown.\n \n Deserializing an object via readUnshared invalidates the stream handle\n associated with the returned object.  Note that this in itself does not\n always guarantee that the reference returned by readUnshared is unique;\n the deserialized object may define a readResolve method which returns an\n object visible to other parties, or readUnshared may return a Class\n object or enum constant obtainable elsewhere in the stream or through\n external means. If the deserialized object defines a readResolve method\n and the invocation of that method returns an array, then readUnshared\n returns a shallow clone of that array; this guarantees that the returned\n array object is unique and cannot be obtained a second time from an\n invocation of readObject or readUnshared on the ObjectInputStream,\n even if the underlying data stream has been manipulated.\n\n The deserialization filter, when not null, is invoked for\n each object (regular or class) read to reconstruct the root object.\n See setObjectInputFilter for details.\n\n ObjectInputStream subclasses which override this method can only be\n constructed in security contexts possessing the\n \"enableSubclassImplementation\" SerializablePermission; any attempt to\n instantiate such a subclass without this permission will cause a\n SecurityException to be thrown."
                }
              ]
            },
            {
              "name": "defaultReadObject",
              "overloads": [
                {
                  "signature": "public void defaultReadObject() throws IOException, ClassNotFoundException",
                  "description": "Read the non-static and non-transient fields of the current class from\n this stream.  This may only be called from the readObject method of the\n class being deserialized. It will throw the NotActiveException if it is\n called otherwise."
                }
              ]
            },
            {
              "name": "readFields",
              "overloads": [
                {
                  "signature": "public ObjectInputStream.GetField readFields() throws IOException, ClassNotFoundException",
                  "description": "Reads the persistent fields from the stream and makes them available by\n name."
                }
              ]
            },
            {
              "name": "registerValidation",
              "overloads": [
                {
                  "signature": "public void registerValidation(ObjectInputValidation obj, int prio) throws NotActiveException, InvalidObjectException",
                  "description": "Register an object to be validated before the graph is returned.  While\n similar to resolveObject these validations are called after the entire\n graph has been reconstituted.  Typically, a readObject method will\n register the object with the stream so that when all of the objects are\n restored a final set of validations can be performed."
                }
              ]
            },
            {
              "name": "resolveClass",
              "overloads": [
                {
                  "signature": "protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException",
                  "description": "Load the local class equivalent of the specified stream class\n description.  Subclasses may implement this method to allow classes to\n be fetched from an alternate source.\n\n The corresponding method in ObjectOutputStream is\n annotateClass.  This method will be invoked only once for\n each unique class in the stream.  This method can be implemented by\n subclasses to use an alternate loading mechanism but must return a\n Class object. Once returned, if the class is not an array\n class, its serialVersionUID is compared to the serialVersionUID of the\n serialized class, and if there is a mismatch, the deserialization fails\n and an InvalidClassException is thrown.\n\n The default implementation of this method in\n ObjectInputStream returns the result of calling\n      Class.forName(desc.getName(), false, loader)\n \n where loader is the first class loader on the current\n thread's stack (starting from the currently executing method) that is\n neither the platform\n class loader nor its ancestor; otherwise, loader is the\n platform class loader. If this call results in a\n ClassNotFoundException and the name of the passed\n ObjectStreamClass instance is the Java language keyword\n for a primitive type or void, then the Class object\n representing that primitive type or void will be returned\n (e.g., an ObjectStreamClass with the name\n \"int\" will be resolved to Integer.TYPE).\n Otherwise, the ClassNotFoundException will be thrown to\n the caller of this method."
                }
              ]
            },
            {
              "name": "resolveProxyClass",
              "overloads": [
                {
                  "signature": "protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException",
                  "description": "Returns a proxy class that implements the interfaces named in a proxy\n class descriptor; subclasses may implement this method to read custom\n data from the stream along with the descriptors for dynamic proxy\n classes, allowing them to use an alternate loading mechanism for the\n interfaces and the proxy class.\n\n This method is called exactly once for each unique proxy class\n descriptor in the stream.\n\n The corresponding method in ObjectOutputStream is\n annotateProxyClass.  For a given subclass of\n ObjectInputStream that overrides this method, the\n annotateProxyClass method in the corresponding subclass of\n ObjectOutputStream must write any data or objects read by\n this method.\n\n The default implementation of this method in\n ObjectInputStream returns the result of calling\n Proxy.getProxyClass with the list of Class\n objects for the interfaces that are named in the interfaces\n parameter.  The Class object for each interface name\n i is the value returned by calling\n      Class.forName(i, false, loader)\n \n where loader is the first class loader on the current\n thread's stack (starting from the currently executing method) that is\n neither the platform\n class loader nor its ancestor; otherwise, loader is the\n platform class loader.\n Unless any of the resolved interfaces are non-public, this same value\n of loader is also the class loader passed to\n Proxy.getProxyClass; if non-public interfaces are present,\n their class loader is passed instead (if more than one non-public\n interface class loader is encountered, an\n IllegalAccessError is thrown).\n If Proxy.getProxyClass throws an\n IllegalArgumentException, resolveProxyClass\n will throw a ClassNotFoundException containing the\n IllegalArgumentException."
                }
              ]
            },
            {
              "name": "resolveObject",
              "overloads": [
                {
                  "signature": "protected Object resolveObject(Object obj) throws IOException",
                  "description": "This method will allow trusted subclasses of ObjectInputStream to\n substitute one object for another during deserialization. Replacing\n objects is disabled until enableResolveObject is called. The\n enableResolveObject method checks that the stream requesting to resolve\n object can be trusted. Every reference to serializable objects is passed\n to resolveObject.  To insure that the private state of objects is not\n unintentionally exposed only trusted streams may use resolveObject.\n\n This method is called after an object has been read but before it is\n returned from readObject.  The default resolveObject method just returns\n the same object.\n\n When a subclass is replacing objects it must insure that the\n substituted object is compatible with every field where the reference\n will be stored.  Objects whose type is not a subclass of the type of the\n field or array element abort the deserialization by raising an exception\n and the object is not be stored.\n\n This method is called only once when each object is first\n encountered.  All subsequent references to the object will be redirected\n to the new object."
                }
              ]
            },
            {
              "name": "enableResolveObject",
              "overloads": [
                {
                  "signature": "protected boolean enableResolveObject(boolean enable) throws SecurityException",
                  "description": "Enables the stream to do replacement of objects read from the stream. When\n enabled, the resolveObject(java.lang.Object) method is called for every object being\n deserialized.\n\n If object replacement is currently not enabled, and\n enable is true, and there is a security manager installed,\n this method first calls the security manager's\n checkPermission method with the\n SerializablePermission(\"enableSubstitution\") permission to\n ensure that the caller is permitted to enable the stream to do replacement\n of objects read from the stream."
                }
              ]
            },
            {
              "name": "readStreamHeader",
              "overloads": [
                {
                  "signature": "protected void readStreamHeader() throws IOException, StreamCorruptedException",
                  "description": "The readStreamHeader method is provided to allow subclasses to read and\n verify their own stream headers. It reads and verifies the magic number\n and version number."
                }
              ]
            },
            {
              "name": "readClassDescriptor",
              "overloads": [
                {
                  "signature": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException",
                  "description": "Read a class descriptor from the serialization stream.  This method is\n called when the ObjectInputStream expects a class descriptor as the next\n item in the serialization stream.  Subclasses of ObjectInputStream may\n override this method to read in class descriptors that have been written\n in non-standard formats (by subclasses of ObjectOutputStream which have\n overridden the writeClassDescriptor method).  By default,\n this method reads class descriptors according to the format defined in\n the Object Serialization specification."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data. This method will block if no input is available."
                },
                {
                  "signature": "public int read(byte[] buf, int off, int len) throws IOException",
                  "description": "Reads into an array of bytes.  This method will block until some input\n is available. Consider using java.io.DataInputStream.readFully to read\n exactly 'length' bytes."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the input stream. Must be called to release any resources\n associated with the stream."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public boolean readBoolean() throws IOException",
                  "description": "Reads in a boolean."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public byte readByte() throws IOException",
                  "description": "Reads an 8 bit byte."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public int readUnsignedByte() throws IOException",
                  "description": "Reads an unsigned 8 bit byte."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public char readChar() throws IOException",
                  "description": "Reads a 16 bit char."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public short readShort() throws IOException",
                  "description": "Reads a 16 bit short."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public int readUnsignedShort() throws IOException",
                  "description": "Reads an unsigned 16 bit short."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public int readInt() throws IOException",
                  "description": "Reads a 32 bit int."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public long readLong() throws IOException",
                  "description": "Reads a 64 bit long."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public float readFloat() throws IOException",
                  "description": "Reads a 32 bit float."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public double readDouble() throws IOException",
                  "description": "Reads a 64 bit double."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public void readFully(byte[] buf) throws IOException",
                  "description": "Reads bytes, blocking until all bytes are read."
                },
                {
                  "signature": "public void readFully(byte[] buf, int off, int len) throws IOException",
                  "description": "Reads bytes, blocking until all bytes are read."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public int skipBytes(int len) throws IOException",
                  "description": "Skips bytes."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "@Deprecated public String readLine() throws IOException",
                  "description": "Reads in a line that has been terminated by a \\n, \\r, \\r\\n or EOF.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public String readUTF() throws IOException",
                  "description": "Reads a String in\n modified UTF-8\n format."
                }
              ]
            },
            {
              "name": "getObjectInputFilter",
              "overloads": [
                {
                  "signature": "public final ObjectInputFilter getObjectInputFilter()",
                  "description": "Returns the deserialization filter for this stream.\n The filter is the result of invoking the\n JVM-wide filter factory\n either by the constructor or the most recent invocation of\n setObjectInputFilter."
                }
              ]
            },
            {
              "name": "setObjectInputFilter",
              "overloads": [
                {
                  "signature": "public final void setObjectInputFilter(ObjectInputFilter filter)",
                  "description": "Set the deserialization filter for the stream.\n\n The deserialization filter is set to the filter returned by invoking the\n JVM-wide filter factory\n with the current filter and the filter parameter.\n The current filter was set in the\n ObjectInputStream constructors by invoking the\n JVM-wide filter factory and may be null.\n setObjectInputFilter(ObjectInputFilter) This method} can be called\n once and only once before reading any objects from the stream;\n for example, by calling readObject() or readUnshared().\n\n It is not permitted to replace a non-null filter with a null filter.\n If the current filter is non-null,\n the value returned from the filter factory must be non-null.\n\n The filter's checkInput method is called\n for each class and reference in the stream.\n The filter can check any or all of the class, the array length, the number\n of references, the depth of the graph, and the size of the input stream.\n The depth is the number of nested readObject\n calls starting with the reading of the root of the graph being deserialized\n and the current object being deserialized.\n The number of references is the cumulative number of objects and references\n to objects already read from the stream including the current object being read.\n The filter is invoked only when reading objects from the stream and not for\n primitives.\n \n If the filter returns Status.REJECTED,\n null or throws a RuntimeException,\n the active readObject or readUnshared\n throws InvalidClassException, otherwise deserialization\n continues uninterrupted."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputStream.GetField",
          "methods": [
            {
              "name": "GetField",
              "overloads": [
                {
                  "signature": "public GetField()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getObjectStreamClass",
              "overloads": [
                {
                  "signature": "public abstract ObjectStreamClass getObjectStreamClass()",
                  "description": "Get the ObjectStreamClass that describes the fields in the stream."
                }
              ]
            },
            {
              "name": "defaulted",
              "overloads": [
                {
                  "signature": "public abstract boolean defaulted(String name) throws IOException",
                  "description": "Return true if the named field is defaulted and has no value in this\n stream."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract boolean get(String name, boolean val) throws IOException",
                  "description": "Get the value of the named boolean field from the persistent field."
                },
                {
                  "signature": "public abstract byte get(String name, byte val) throws IOException",
                  "description": "Get the value of the named byte field from the persistent field."
                },
                {
                  "signature": "public abstract char get(String name, char val) throws IOException",
                  "description": "Get the value of the named char field from the persistent field."
                },
                {
                  "signature": "public abstract short get(String name, short val) throws IOException",
                  "description": "Get the value of the named short field from the persistent field."
                },
                {
                  "signature": "public abstract int get(String name, int val) throws IOException",
                  "description": "Get the value of the named int field from the persistent field."
                },
                {
                  "signature": "public abstract long get(String name, long val) throws IOException",
                  "description": "Get the value of the named long field from the persistent field."
                },
                {
                  "signature": "public abstract float get(String name, float val) throws IOException",
                  "description": "Get the value of the named float field from the persistent field."
                },
                {
                  "signature": "public abstract double get(String name, double val) throws IOException",
                  "description": "Get the value of the named double field from the persistent field."
                },
                {
                  "signature": "public abstract Object get(String name, Object val) throws IOException",
                  "description": "Get the value of the named Object field from the persistent field."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputValidation",
          "methods": [
            {
              "name": "validateObject",
              "overloads": [
                {
                  "signature": "void validateObject() throws InvalidObjectException",
                  "description": "Validates the object."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutput",
          "methods": [
            {
              "name": "writeObject",
              "overloads": [
                {
                  "signature": "void writeObject(Object obj) throws IOException",
                  "description": "Write an object to the underlying storage or stream.  The\n class that implements this interface defines how the object is\n written."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "void write(int b) throws IOException",
                  "description": "Writes a byte. This method will block until the byte is actually\n written."
                },
                {
                  "signature": "void write(byte[] b) throws IOException",
                  "description": "Writes an array of bytes. This method will block until the bytes\n are actually written."
                },
                {
                  "signature": "void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes a sub array of bytes."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "void flush() throws IOException",
                  "description": "Flushes the stream. This will write any buffered\n output bytes."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes the stream. This method must be called\n to release any resources associated with the\n stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutputStream",
          "methods": [
            {
              "name": "ObjectOutputStream",
              "overloads": [
                {
                  "signature": "public ObjectOutputStream(OutputStream out) throws IOException",
                  "description": "Creates an ObjectOutputStream that writes to the specified OutputStream.\n This constructor writes the serialization stream header to the\n underlying stream; callers may wish to flush the stream immediately to\n ensure that constructors for receiving ObjectInputStreams will not block\n when reading the header.\n\n If a security manager is installed, this constructor will check for\n the \"enableSubclassImplementation\" SerializablePermission when invoked\n directly or indirectly by the constructor of a subclass which overrides\n the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n methods."
                },
                {
                  "signature": "protected ObjectOutputStream() throws IOException, SecurityException",
                  "description": "Provide a way for subclasses that are completely reimplementing\n ObjectOutputStream to not have to allocate private data just used by\n this implementation of ObjectOutputStream.\n\n If there is a security manager installed, this method first calls the\n security manager's checkPermission method with a\n SerializablePermission(\"enableSubclassImplementation\")\n permission to ensure it's ok to enable subclassing."
                }
              ]
            },
            {
              "name": "useProtocolVersion",
              "overloads": [
                {
                  "signature": "public void useProtocolVersion(int version) throws IOException",
                  "description": "Specify stream protocol version to use when writing the stream.\n\n This routine provides a hook to enable the current version of\n Serialization to write in a format that is backwards compatible to a\n previous version of the stream format.\n\n Every effort will be made to avoid introducing additional\n backwards incompatibilities; however, sometimes there is no\n other alternative."
                }
              ]
            },
            {
              "name": "writeObject",
              "overloads": [
                {
                  "signature": "public final void writeObject(Object obj) throws IOException",
                  "description": "Write the specified object to the ObjectOutputStream.  The class of the\n object, the signature of the class, and the values of the non-transient\n and non-static fields of the class and all of its supertypes are\n written.  Default serialization for a class can be overridden using the\n writeObject and the readObject methods.  Objects referenced by this\n object are written transitively so that a complete equivalent graph of\n objects can be reconstructed by an ObjectInputStream.\n\n Exceptions are thrown for problems with the OutputStream and for\n classes that should not be serialized.  All exceptions are fatal to the\n OutputStream, which is left in an indeterminate state, and it is up to\n the caller to ignore or recover the stream state."
                }
              ]
            },
            {
              "name": "writeObjectOverride",
              "overloads": [
                {
                  "signature": "protected void writeObjectOverride(Object obj) throws IOException",
                  "description": "Method used by subclasses to override the default writeObject method.\n This method is called by trusted subclasses of ObjectOutputStream that\n constructed ObjectOutputStream using the protected no-arg constructor.\n The subclass is expected to provide an override method with the modifier\n \"final\"."
                }
              ]
            },
            {
              "name": "writeUnshared",
              "overloads": [
                {
                  "signature": "public void writeUnshared(Object obj) throws IOException",
                  "description": "Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n identical to writeObject, except that it always writes the given object\n as a new, unique object in the stream (as opposed to a back-reference\n pointing to a previously serialized instance).  Specifically:\n \n   An object written via writeUnshared is always serialized in the\n       same manner as a newly appearing object (an object that has not\n       been written to the stream yet), regardless of whether or not the\n       object has been written previously.\n\n   If writeObject is used to write an object that has been previously\n       written with writeUnshared, the previous writeUnshared operation\n       is treated as if it were a write of a separate object.  In other\n       words, ObjectOutputStream will never generate back-references to\n       object data written by calls to writeUnshared.\n \n While writing an object via writeUnshared does not in itself guarantee a\n unique reference to the object when it is deserialized, it allows a\n single object to be defined multiple times in a stream, so that multiple\n calls to readUnshared by the receiver will not conflict.  Note that the\n rules described above only apply to the base-level object written with\n writeUnshared, and not to any transitively referenced sub-objects in the\n object graph to be serialized.\n\n ObjectOutputStream subclasses which override this method can only be\n constructed in security contexts possessing the\n \"enableSubclassImplementation\" SerializablePermission; any attempt to\n instantiate such a subclass without this permission will cause a\n SecurityException to be thrown."
                }
              ]
            },
            {
              "name": "defaultWriteObject",
              "overloads": [
                {
                  "signature": "public void defaultWriteObject() throws IOException",
                  "description": "Write the non-static and non-transient fields of the current class to\n this stream.  This may only be called from the writeObject method of the\n class being serialized. It will throw the NotActiveException if it is\n called otherwise."
                }
              ]
            },
            {
              "name": "putFields",
              "overloads": [
                {
                  "signature": "public ObjectOutputStream.PutField putFields() throws IOException",
                  "description": "Retrieve the object used to buffer persistent fields to be written to\n the stream.  The fields will be written to the stream when writeFields\n method is called."
                }
              ]
            },
            {
              "name": "writeFields",
              "overloads": [
                {
                  "signature": "public void writeFields() throws IOException",
                  "description": "Write the buffered fields to the stream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Reset will disregard the state of any objects already written to the\n stream.  The state is reset to be the same as a new ObjectOutputStream.\n The current point in the stream is marked as reset so the corresponding\n ObjectInputStream will be reset at the same point.  Objects previously\n written to the stream will not be referred to as already being in the\n stream.  They will be written to the stream again."
                }
              ]
            },
            {
              "name": "annotateClass",
              "overloads": [
                {
                  "signature": "protected void annotateClass(Class<?> cl) throws IOException",
                  "description": "Subclasses may implement this method to allow class data to be stored in\n the stream. By default this method does nothing.  The corresponding\n method in ObjectInputStream is resolveClass.  This method is called\n exactly once for each unique class in the stream.  The class name and\n signature will have already been written to the stream.  This method may\n make free use of the ObjectOutputStream to save any representation of\n the class it deems suitable (for example, the bytes of the class file).\n The resolveClass method in the corresponding subclass of\n ObjectInputStream must read and use any data or objects written by\n annotateClass."
                }
              ]
            },
            {
              "name": "annotateProxyClass",
              "overloads": [
                {
                  "signature": "protected void annotateProxyClass(Class<?> cl) throws IOException",
                  "description": "Subclasses may implement this method to store custom data in the stream\n along with descriptors for dynamic proxy classes.\n\n This method is called exactly once for each unique proxy class\n descriptor in the stream.  The default implementation of this method in\n ObjectOutputStream does nothing.\n\n The corresponding method in ObjectInputStream is\n resolveProxyClass.  For a given subclass of\n ObjectOutputStream that overrides this method, the\n resolveProxyClass method in the corresponding subclass of\n ObjectInputStream must read any data or objects written by\n annotateProxyClass."
                }
              ]
            },
            {
              "name": "replaceObject",
              "overloads": [
                {
                  "signature": "protected Object replaceObject(Object obj) throws IOException",
                  "description": "This method will allow trusted subclasses of ObjectOutputStream to\n substitute one object for another during serialization. Replacing\n objects is disabled until enableReplaceObject is called. The\n enableReplaceObject method checks that the stream requesting to do\n replacement can be trusted.  The first occurrence of each object written\n into the serialization stream is passed to replaceObject.  Subsequent\n references to the object are replaced by the object returned by the\n original call to replaceObject.  To ensure that the private state of\n objects is not unintentionally exposed, only trusted streams may use\n replaceObject.\n\n The ObjectOutputStream.writeObject method takes a parameter of type\n Object (as opposed to type Serializable) to allow for cases where\n non-serializable objects are replaced by serializable ones.\n\n When a subclass is replacing objects it must insure that either a\n complementary substitution must be made during deserialization or that\n the substituted object is compatible with every field where the\n reference will be stored.  Objects whose type is not a subclass of the\n type of the field or array element abort the serialization by raising an\n exception and the object is not be stored.\n\n This method is called only once when each object is first\n encountered.  All subsequent references to the object will be redirected\n to the new object. This method should return the object to be\n substituted or the original object.\n\n Null can be returned as the object to be substituted, but may cause\n NullReferenceException in classes that contain references to the\n original object since they may be expecting an object instead of\n null."
                }
              ]
            },
            {
              "name": "enableReplaceObject",
              "overloads": [
                {
                  "signature": "protected boolean enableReplaceObject(boolean enable) throws SecurityException",
                  "description": "Enables the stream to do replacement of objects written to the stream.  When\n enabled, the replaceObject(java.lang.Object) method is called for every object being\n serialized.\n\n If object replacement is currently not enabled, and\n enable is true, and there is a security manager installed,\n this method first calls the security manager's\n checkPermission method with the\n SerializablePermission(\"enableSubstitution\") permission to\n ensure that the caller is permitted to enable the stream to do replacement\n of objects written to the stream."
                }
              ]
            },
            {
              "name": "writeStreamHeader",
              "overloads": [
                {
                  "signature": "protected void writeStreamHeader() throws IOException",
                  "description": "The writeStreamHeader method is provided so subclasses can append or\n prepend their own header to the stream.  It writes the magic number and\n version to the stream."
                }
              ]
            },
            {
              "name": "writeClassDescriptor",
              "overloads": [
                {
                  "signature": "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException",
                  "description": "Write the specified class descriptor to the ObjectOutputStream.  Class\n descriptors are used to identify the classes of objects written to the\n stream.  Subclasses of ObjectOutputStream may override this method to\n customize the way in which class descriptors are written to the\n serialization stream.  The corresponding method in ObjectInputStream,\n readClassDescriptor, should then be overridden to\n reconstitute the class descriptor from its custom stream representation.\n By default, this method writes class descriptors according to the format\n defined in the Object Serialization specification.\n\n Note that this method will only be called if the ObjectOutputStream\n is not using the old serialization stream format (set by calling\n ObjectOutputStream's useProtocolVersion method).  If this\n serialization stream is using the old format\n (PROTOCOL_VERSION_1), the class descriptor will be written\n internally in a manner that cannot be overridden or customized."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int val) throws IOException",
                  "description": "Writes a byte. This method will block until the byte is actually\n written."
                },
                {
                  "signature": "public void write(byte[] buf) throws IOException",
                  "description": "Writes an array of bytes. This method will block until the bytes are\n actually written."
                },
                {
                  "signature": "public void write(byte[] buf, int off, int len) throws IOException",
                  "description": "Writes a sub array of bytes."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream. This will write any buffered output bytes and flush\n through to the underlying stream."
                }
              ]
            },
            {
              "name": "drain",
              "overloads": [
                {
                  "signature": "protected void drain() throws IOException",
                  "description": "Drain any buffered data in ObjectOutputStream.  Similar to flush but\n does not propagate the flush to the underlying stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the stream. This method must be called to release any resources\n associated with the stream."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public void writeBoolean(boolean val) throws IOException",
                  "description": "Writes a boolean."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public void writeByte(int val) throws IOException",
                  "description": "Writes an 8 bit byte."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public void writeShort(int val) throws IOException",
                  "description": "Writes a 16 bit short."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public void writeChar(int val) throws IOException",
                  "description": "Writes a 16 bit char."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public void writeInt(int val) throws IOException",
                  "description": "Writes a 32 bit int."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public void writeLong(long val) throws IOException",
                  "description": "Writes a 64 bit long."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public void writeFloat(float val) throws IOException",
                  "description": "Writes a 32 bit float."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public void writeDouble(double val) throws IOException",
                  "description": "Writes a 64 bit double."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(String str) throws IOException",
                  "description": "Writes a String as a sequence of bytes."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public void writeChars(String str) throws IOException",
                  "description": "Writes a String as a sequence of chars."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public void writeUTF(String str) throws IOException",
                  "description": "Primitive data write of this String in\n modified UTF-8\n format.  Note that there is a\n significant difference between writing a String into the stream as\n primitive data or as an Object. A String instance written by writeObject\n is written into the stream as a String initially. Future writeObject()\n calls write references to the string into the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutputStream.PutField",
          "methods": [
            {
              "name": "PutField",
              "overloads": [
                {
                  "signature": "public PutField()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract void put(String name, boolean val)",
                  "description": "Put the value of the named boolean field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, byte val)",
                  "description": "Put the value of the named byte field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, char val)",
                  "description": "Put the value of the named char field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, short val)",
                  "description": "Put the value of the named short field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, int val)",
                  "description": "Put the value of the named int field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, long val)",
                  "description": "Put the value of the named long field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, float val)",
                  "description": "Put the value of the named float field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, double val)",
                  "description": "Put the value of the named double field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, Object val)",
                  "description": "Put the value of the named Object field into the persistent field."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "@Deprecated public abstract void write(ObjectOutput out) throws IOException",
                  "description": "Write the data and fields to the specified ObjectOutput stream,\n which must be the same stream that produced this\n PutField object.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamClass",
          "methods": [
            {
              "name": "lookup",
              "overloads": [
                {
                  "signature": "public static ObjectStreamClass lookup(Class<?> cl)",
                  "description": "Find the descriptor for a class that can be serialized.  Creates an\n ObjectStreamClass instance if one does not exist yet for class. Null is\n returned if the specified class does not implement java.io.Serializable\n or java.io.Externalizable."
                }
              ]
            },
            {
              "name": "lookupAny",
              "overloads": [
                {
                  "signature": "public static ObjectStreamClass lookupAny(Class<?> cl)",
                  "description": "Returns the descriptor for any class, regardless of whether it\n implements Serializable."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the class described by this descriptor.\n This method returns the name of the class in the format that\n is used by the Class.getName() method."
                }
              ]
            },
            {
              "name": "getSerialVersionUID",
              "overloads": [
                {
                  "signature": "public long getSerialVersionUID()",
                  "description": "Return the serialVersionUID for this class.  The serialVersionUID\n defines a set of classes all with the same name that have evolved from a\n common root class and agree to be serialized and deserialized using a\n common format.  NonSerializable classes have a serialVersionUID of 0L."
                }
              ]
            },
            {
              "name": "forClass",
              "overloads": [
                {
                  "signature": "public Class<?> forClass()",
                  "description": "Return the class in the local VM that this version is mapped to.  Null\n is returned if there is no corresponding local class."
                }
              ]
            },
            {
              "name": "getFields",
              "overloads": [
                {
                  "signature": "public ObjectStreamField[] getFields()",
                  "description": "Return an array of the fields of this serializable class."
                }
              ]
            },
            {
              "name": "getField",
              "overloads": [
                {
                  "signature": "public ObjectStreamField getField(String name)",
                  "description": "Get the field of this class by name."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string describing this ObjectStreamClass."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamConstants",
          "methods": []
        },
        {
          "name": "ObjectStreamException",
          "methods": [
            {
              "name": "ObjectStreamException",
              "overloads": [
                {
                  "signature": "protected ObjectStreamException(String message)",
                  "description": "Create an ObjectStreamException with the specified argument."
                },
                {
                  "signature": "protected ObjectStreamException()",
                  "description": "Create an ObjectStreamException."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamField",
          "methods": [
            {
              "name": "ObjectStreamField",
              "overloads": [
                {
                  "signature": "public ObjectStreamField(String name, Class<?> type)",
                  "description": "Create a Serializable field with the specified type.  This field should\n be documented with a serialField tag."
                },
                {
                  "signature": "public ObjectStreamField(String name, Class<?> type, boolean unshared)",
                  "description": "Creates an ObjectStreamField representing a serializable field with the\n given name and type.  If unshared is false, values of the represented\n field are serialized and deserialized in the default manner--if the\n field is non-primitive, object values are serialized and deserialized as\n if they had been written and read by calls to writeObject and\n readObject.  If unshared is true, values of the represented field are\n serialized and deserialized as if they had been written and read by\n calls to writeUnshared and readUnshared."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Get the name of this field."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public Class<?> getType()",
                  "description": "Get the type of the field.  If the type is non-primitive and this\n ObjectStreamField was obtained from a deserialized ObjectStreamClass instance, then Object.class is returned.\n Otherwise, the Class object for the type of the field is\n returned."
                }
              ]
            },
            {
              "name": "getTypeCode",
              "overloads": [
                {
                  "signature": "public char getTypeCode()",
                  "description": "Returns character encoding of field type.  The encoding is as follows:\n  B            byte\n C            char\n D            double\n F            float\n I            int\n J            long\n L            class or interface\n S            short\n Z            boolean\n [            array"
                }
              ]
            },
            {
              "name": "getTypeString",
              "overloads": [
                {
                  "signature": "public String getTypeString()",
                  "description": "Return the JVM type signature."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset()",
                  "description": "Offset of field within instance data."
                }
              ]
            },
            {
              "name": "setOffset",
              "overloads": [
                {
                  "signature": "protected void setOffset(int offset)",
                  "description": "Offset within instance data."
                }
              ]
            },
            {
              "name": "isPrimitive",
              "overloads": [
                {
                  "signature": "public boolean isPrimitive()",
                  "description": "Return true if this field has a primitive type."
                }
              ]
            },
            {
              "name": "isUnshared",
              "overloads": [
                {
                  "signature": "public boolean isUnshared()",
                  "description": "Returns boolean value indicating whether or not the serializable field\n represented by this ObjectStreamField instance is unshared."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Object obj)",
                  "description": "Compare this field with another ObjectStreamField.  Return\n -1 if this is smaller, 0 if equal, 1 if greater.  Types that are\n primitives are \"smaller\" than object types.  If equal, the field names\n are compared."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string that describes this field."
                }
              ]
            }
          ]
        },
        {
          "name": "OptionalDataException",
          "methods": []
        },
        {
          "name": "OutputStream",
          "methods": [
            {
              "name": "OutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "nullOutputStream",
              "overloads": [
                {
                  "signature": "public static OutputStream nullOutputStream()",
                  "description": "Returns a new OutputStream which discards all bytes.  The\n returned stream is initially open.  The stream is closed by calling\n the close() method.  Subsequent calls to close() have\n no effect.\n\n  While the stream is open, the write(int), \n write(byte[]), and write(byte[], int, int) methods do nothing.\n After the stream has been closed, these methods all throw \n IOException.\n\n  The flush() method does nothing."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public abstract void write(int b) throws IOException",
                  "description": "Writes the specified byte to this output stream. The general\n contract for write is that one byte is written\n to the output stream. The byte to be written is the eight\n low-order bits of the argument b. The 24\n high-order bits of b are ignored.\n \n Subclasses of OutputStream must provide an\n implementation for this method."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this output stream. The general contract for write(b)\n is that it should have exactly the same effect as the call\n write(b, 0, b.length)."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this output stream.\n The general contract for write(b, off, len) is that\n some of the bytes in the array b are written to the\n output stream in order; element b[off] is the first\n byte written and b[off+len-1] is the last byte written\n by this operation.\n \n The write method of OutputStream calls\n the write method of one argument on each of the bytes to be\n written out. Subclasses are encouraged to override this method and\n provide a more efficient implementation.\n \n If b is null, a\n NullPointerException is thrown.\n \n If off is negative, or len is negative, or\n off+len is greater than the length of the array\n b, then an IndexOutOfBoundsException is thrown."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out. The general contract of flush is\n that calling it is an indication that, if any bytes previously\n written have been buffered by the implementation of the output\n stream, such bytes should immediately be written to their\n intended destination.\n \n If the intended destination of this stream is an abstraction provided by\n the underlying operating system, for example a file, then flushing the\n stream guarantees only that bytes previously written to the stream are\n passed to the operating system for writing; it does not guarantee that\n they are actually written to a physical device such as a disk drive.\n \n The flush method of OutputStream does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this output stream and releases any system resources\n associated with this stream. The general contract of close\n is that it closes the output stream. A closed stream cannot perform\n output operations and cannot be reopened.\n \n The close method of OutputStream does nothing."
                }
              ]
            }
          ]
        },
        {
          "name": "OutputStreamWriter",
          "methods": [
            {
              "name": "OutputStreamWriter",
              "overloads": [
                {
                  "signature": "public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException",
                  "description": "Creates an OutputStreamWriter that uses the named charset."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out)",
                  "description": "Creates an OutputStreamWriter that uses the default character encoding."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out, Charset cs)",
                  "description": "Creates an OutputStreamWriter that uses the given charset."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out, CharsetEncoder enc)",
                  "description": "Creates an OutputStreamWriter that uses the given charset encoder."
                }
              ]
            },
            {
              "name": "getEncoding",
              "overloads": [
                {
                  "signature": "public String getEncoding()",
                  "description": "Returns the name of the character encoding being used by this stream.\n\n  If the encoding has an historical name then that name is returned;\n otherwise the encoding's canonical name is returned.\n\n  If this instance was created with the OutputStreamWriter(OutputStream, String) constructor then the returned\n name, being unique for the encoding, may differ from the name passed to\n the constructor.  This method may return null if the stream has\n been closed."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "PipedInputStream",
          "methods": [
            {
              "name": "PipedInputStream",
              "overloads": [
                {
                  "signature": "public PipedInputStream(PipedOutputStream src) throws IOException",
                  "description": "Creates a PipedInputStream so\n that it is connected to the piped output\n stream src. Data bytes written\n to src will then be  available\n as input from this stream."
                },
                {
                  "signature": "public PipedInputStream(PipedOutputStream src, int pipeSize) throws IOException",
                  "description": "Creates a PipedInputStream so that it is\n connected to the piped output stream\n src and uses the specified pipe size for\n the pipe's buffer.\n Data bytes written to src will then\n be available as input from this stream."
                },
                {
                  "signature": "public PipedInputStream()",
                  "description": "Creates a PipedInputStream so\n that it is not yet connected.\n It must be connected to a\n PipedOutputStream before being used."
                },
                {
                  "signature": "public PipedInputStream(int pipeSize)",
                  "description": "Creates a PipedInputStream so that it is not yet\n connected and\n uses the specified pipe size for the pipe's buffer.\n It must be connected to a PipedOutputStream before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedOutputStream src) throws IOException",
                  "description": "Causes this piped input stream to be connected\n to the piped  output stream src.\n If this object is already connected to some\n other piped output  stream, an IOException\n is thrown.\n \n If src is an\n unconnected piped output stream and snk\n is an unconnected piped input stream, they\n may be connected by either the call:\n\n snk.connect(src) \n \n or the call:\n\n src.connect(snk) \n \n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "protected void receive(int b) throws IOException",
                  "description": "Receives a byte of data.  This method will block if no input is\n available."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this piped input stream. The\n value byte is returned as an int in the range\n 0 to 255.\n This method blocks until input data is available, the end of the\n stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this piped input\n stream into an array of bytes. Less than len bytes\n will be read if the end of the data stream is reached or if\n len exceeds the pipe's buffer size.\n If len  is zero, then no bytes are read and 0 is returned;\n otherwise, the method blocks until at least 1 byte of input is\n available, end of the stream has been detected, or an exception is\n thrown."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this input\n stream without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped input stream and releases any system resources\n associated with the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedOutputStream",
          "methods": [
            {
              "name": "PipedOutputStream",
              "overloads": [
                {
                  "signature": "public PipedOutputStream(PipedInputStream snk) throws IOException",
                  "description": "Creates a piped output stream connected to the specified piped\n input stream. Data bytes written to this stream will then be\n available as input from snk."
                },
                {
                  "signature": "public PipedOutputStream()",
                  "description": "Creates a piped output stream that is not yet connected to a\n piped input stream. It must be connected to a piped input stream,\n either by the receiver or the sender, before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedInputStream snk) throws IOException",
                  "description": "Connects this piped output stream to a receiver. If this object\n is already connected to some other piped input stream, an\n IOException is thrown.\n \n If snk is an unconnected piped input stream and\n src is an unconnected piped output stream, they may\n be connected by either the call:\n  src.connect(snk)\n or the call:\n  snk.connect(src)\n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to the piped output stream.\n \n Implements the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this piped output stream.\n This method blocks until all the bytes are written to the output\n stream."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out.\n This will notify any readers that bytes are waiting in the pipe."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped output stream and releases any system resources\n associated with this stream. This stream may no longer be used for\n writing bytes."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedReader",
          "methods": [
            {
              "name": "PipedReader",
              "overloads": [
                {
                  "signature": "public PipedReader(PipedWriter src) throws IOException",
                  "description": "Creates a PipedReader so\n that it is connected to the piped writer\n src. Data written to src\n will then be available as input from this stream."
                },
                {
                  "signature": "public PipedReader(PipedWriter src, int pipeSize) throws IOException",
                  "description": "Creates a PipedReader so that it is connected\n to the piped writer src and uses the specified\n pipe size for the pipe's buffer. Data written to src\n will then be  available as input from this stream."
                },
                {
                  "signature": "public PipedReader()",
                  "description": "Creates a PipedReader so\n that it is not yet connected. It must be connected to a PipedWriter\n before being used."
                },
                {
                  "signature": "public PipedReader(int pipeSize)",
                  "description": "Creates a PipedReader so that it is not yet\n connected and uses\n the specified pipe size for the pipe's buffer.\n It must be  connected to a PipedWriter\n before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedWriter src) throws IOException",
                  "description": "Causes this piped reader to be connected\n to the piped  writer src.\n If this object is already connected to some\n other piped writer, an IOException\n is thrown.\n \n If src is an\n unconnected piped writer and snk\n is an unconnected piped reader, they\n may be connected by either the call:\n\n snk.connect(src) \n \n or the call:\n\n src.connect(snk) \n \n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next character of data from this piped stream.\n If no character is available because the end of the stream\n has been reached, the value -1 is returned.\n This method blocks until input data is available, the end of\n the stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf.\n\n  Fewer than len characters will be read if\n len exceeds the pipe's buffer size."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tell whether this stream is ready to be read.  A piped character\n stream is ready if the circular buffer is not empty."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped stream and releases any system resources\n associated with the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedWriter",
          "methods": [
            {
              "name": "PipedWriter",
              "overloads": [
                {
                  "signature": "public PipedWriter(PipedReader snk) throws IOException",
                  "description": "Creates a piped writer connected to the specified piped\n reader. Data characters written to this stream will then be\n available as input from snk."
                },
                {
                  "signature": "public PipedWriter()",
                  "description": "Creates a piped writer that is not yet connected to a\n piped reader. It must be connected to a piped reader,\n either by the receiver or the sender, before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedReader snk) throws IOException",
                  "description": "Connects this piped writer to a receiver. If this object\n is already connected to some other piped reader, an\n IOException is thrown.\n \n If snk is an unconnected piped reader and\n src is an unconnected piped writer, they may\n be connected by either the call:\n  src.connect(snk)\n or the call:\n  snk.connect(src)\n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes the specified char to the piped output stream.\n If a thread was reading data characters from the connected piped input\n stream, but the thread is no longer alive, then an\n IOException is thrown.\n \n Implements the write method of Writer."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes len characters from the specified character array\n starting at offset off to this piped output stream.\n This method blocks until all the characters are written to the output\n stream.\n If a thread was reading data characters from the connected piped input\n stream, but the thread is no longer alive, then an\n IOException is thrown."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output characters\n to be written out.\n This will notify any readers that characters are waiting in the pipe."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped output stream and releases any system resources\n associated with this stream. This stream may no longer be used for\n writing characters."
                }
              ]
            }
          ]
        },
        {
          "name": "PrintStream",
          "methods": [
            {
              "name": "PrintStream",
              "overloads": [
                {
                  "signature": "public PrintStream(OutputStream out)",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified OutputStream. Characters written to the stream are converted\n to bytes using the platform's default character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush)",
                  "description": "Creates a new print stream, with the specified OutputStream and line\n flushing. Characters written to the stream are converted to bytes using\n the platform's default character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush, String encoding) throws UnsupportedEncodingException",
                  "description": "Creates a new print stream, with the specified OutputStream, line\n flushing, and character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush, Charset charset)",
                  "description": "Creates a new print stream, with the specified OutputStream, line\n flushing and charset.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the provided charset."
                },
                {
                  "signature": "public PrintStream(String fileName) throws FileNotFoundException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the\n default charset\n for this instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintStream(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(File file) throws FileNotFoundException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintStream(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(File file, Charset charset) throws IOException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the stream.  This is done by writing any buffered output bytes to\n the underlying output stream and then flushing that stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream.  This is done by flushing the stream and then closing\n the underlying output stream."
                }
              ]
            },
            {
              "name": "checkError",
              "overloads": [
                {
                  "signature": "public boolean checkError()",
                  "description": "Flushes the stream and checks its error state. The internal error state\n is set to true when the underlying output stream throws an\n IOException other than InterruptedIOException,\n and when the setError method is invoked.  If an operation\n on the underlying output stream throws an\n InterruptedIOException, then the PrintStream\n converts the exception back into an interrupt by doing:\n \n     Thread.currentThread().interrupt();\n \n or the equivalent."
                }
              ]
            },
            {
              "name": "setError",
              "overloads": [
                {
                  "signature": "protected void setError()",
                  "description": "Sets the error state of the stream to true.\n\n  This method will cause subsequent invocations of checkError() to return true until\n clearError() is invoked."
                }
              ]
            },
            {
              "name": "clearError",
              "overloads": [
                {
                  "signature": "protected void clearError()",
                  "description": "Clears the internal error state of this stream.\n\n  This method will cause subsequent invocations of checkError() to return false until another write\n operation fails and invokes setError()."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b)",
                  "description": "Writes the specified byte to this stream.  If the byte is a newline and\n automatic flushing is enabled then the flush method will be\n invoked on the underlying output stream.\n\n  Note that the byte is written as given; to write a character that\n will be translated according to the platform's default character\n encoding, use the print(char) or println(char)\n methods."
                },
                {
                  "signature": "public void write(byte[] buf, int off, int len)",
                  "description": "Writes len bytes from the specified byte array starting at\n offset off to this stream.  If automatic flushing is\n enabled then the flush method will be invoked on the underlying\n output stream.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char) or println(char)\n methods."
                },
                {
                  "signature": "public void write(byte[] buf) throws IOException",
                  "description": "Writes all bytes from the specified byte array to this stream. If\n automatic flushing is enabled then the flush method will be\n invoked on the underlying output stream.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char[]) or println(char[])\n methods."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(byte[] buf)",
                  "description": "Writes all bytes from the specified byte array to this stream.\n If automatic flushing is enabled then the flush method\n will be invoked.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char[]) or println(char[])\n methods."
                }
              ]
            },
            {
              "name": "print",
              "overloads": [
                {
                  "signature": "public void print(boolean b)",
                  "description": "Prints a boolean value.  The string produced by String.valueOf(boolean) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(char c)",
                  "description": "Prints a character.  The character is translated into one or more bytes\n according to the character encoding given to the constructor, or the\n platform's default character encoding if none specified. These bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(int i)",
                  "description": "Prints an integer.  The string produced by String.valueOf(int) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(long l)",
                  "description": "Prints a long integer.  The string produced by String.valueOf(long) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(float f)",
                  "description": "Prints a floating-point number.  The string produced by String.valueOf(float) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(double d)",
                  "description": "Prints a double-precision floating-point number.  The string produced by\n String.valueOf(double) is translated into\n bytes according to the platform's default character encoding, and these\n bytes are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char[] s)",
                  "description": "Prints an array of characters.  The characters are converted into bytes\n according to the character encoding given to the constructor, or the\n platform's default character encoding if none specified. These bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(String s)",
                  "description": "Prints a string.  If the argument is null then the string\n \"null\" is printed.  Otherwise, the string's characters are\n converted into bytes according to the character encoding given to the\n constructor, or the platform's default character encoding if none\n specified. These bytes are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(Object obj)",
                  "description": "Prints an object.  The string produced by the String.valueOf(Object) method is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                }
              ]
            },
            {
              "name": "println",
              "overloads": [
                {
                  "signature": "public void println()",
                  "description": "Terminates the current line by writing the line separator string.  The\n line separator string is defined by the system property\n line.separator, and is not necessarily a single newline\n character ('\\n')."
                },
                {
                  "signature": "public void println(boolean x)",
                  "description": "Prints a boolean and then terminate the line.  This method behaves as\n though it invokes print(boolean) and then\n println()."
                },
                {
                  "signature": "public void println(char x)",
                  "description": "Prints a character and then terminate the line.  This method behaves as\n though it invokes print(char) and then\n println()."
                },
                {
                  "signature": "public void println(int x)",
                  "description": "Prints an integer and then terminate the line.  This method behaves as\n though it invokes print(int) and then\n println()."
                },
                {
                  "signature": "public void println(long x)",
                  "description": "Prints a long and then terminate the line.  This method behaves as\n though it invokes print(long) and then\n println()."
                },
                {
                  "signature": "public void println(float x)",
                  "description": "Prints a float and then terminate the line.  This method behaves as\n though it invokes print(float) and then\n println()."
                },
                {
                  "signature": "public void println(double x)",
                  "description": "Prints a double and then terminate the line.  This method behaves as\n though it invokes print(double) and then\n println()."
                },
                {
                  "signature": "public void println(char[] x)",
                  "description": "Prints an array of characters and then terminate the line.  This method\n behaves as though it invokes print(char[]) and\n then println()."
                },
                {
                  "signature": "public void println(String x)",
                  "description": "Prints a String and then terminate the line.  This method behaves as\n though it invokes print(String) and then\n println()."
                },
                {
                  "signature": "public void println(Object x)",
                  "description": "Prints an Object and then terminate the line.  This method calls\n at first String.valueOf(x) to get the printed object's string value,\n then behaves as\n though it invokes print(String) and then\n println()."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public PrintStream printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.\n\n  An invocation of this method of the form\n out.printf(format, args) behaves\n in exactly the same way as the invocation\n\n \n     out.format(format, args)"
                },
                {
                  "signature": "public PrintStream printf(Locale l, String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.\n\n  An invocation of this method of the form\n out.printf(l, format, args) behaves\n in exactly the same way as the invocation\n\n \n     out.format(l, format, args)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public PrintStream format(String format, Object... args)",
                  "description": "Writes a formatted string to this output stream using the specified\n format string and arguments.\n\n  The locale always used is the one returned by Locale.getDefault(Locale.Category) with\n FORMAT category specified,\n regardless of any previous invocations of other formatting methods on\n this object."
                },
                {
                  "signature": "public PrintStream format(Locale l, String format, Object... args)",
                  "description": "Writes a formatted string to this output stream using the specified\n format string and arguments."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public PrintStream append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this output stream.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n \n     out.print(csq.toString())\n \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended.  For instance, invoking then toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public PrintStream append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this output\n stream.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when\n csq is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.print(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public PrintStream append(char c)",
                  "description": "Appends the specified character to this output stream.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n \n     out.print(c)"
                }
              ]
            }
          ]
        },
        {
          "name": "PrintWriter",
          "methods": [
            {
              "name": "PrintWriter",
              "overloads": [
                {
                  "signature": "public PrintWriter(Writer out)",
                  "description": "Creates a new PrintWriter, without automatic line flushing."
                },
                {
                  "signature": "public PrintWriter(Writer out, boolean autoFlush)",
                  "description": "Creates a new PrintWriter."
                },
                {
                  "signature": "public PrintWriter(OutputStream out)",
                  "description": "Creates a new PrintWriter, without automatic line flushing, from an\n existing OutputStream.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will convert characters\n into bytes using the default character encoding."
                },
                {
                  "signature": "public PrintWriter(OutputStream out, boolean autoFlush)",
                  "description": "Creates a new PrintWriter from an existing OutputStream.  This\n convenience constructor creates the necessary intermediate\n OutputStreamWriter, which will convert characters into bytes using the\n default character encoding."
                },
                {
                  "signature": "public PrintWriter(OutputStream out, boolean autoFlush, Charset charset)",
                  "description": "Creates a new PrintWriter from an existing OutputStream.  This\n convenience constructor creates the necessary intermediate\n OutputStreamWriter, which will convert characters into bytes using the\n specified charset."
                },
                {
                  "signature": "public PrintWriter(String fileName) throws FileNotFoundException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintWriter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(File file) throws FileNotFoundException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintWriter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(File file, Charset charset) throws IOException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated\n with it. Closing a previously closed stream has no effect."
                }
              ]
            },
            {
              "name": "checkError",
              "overloads": [
                {
                  "signature": "public boolean checkError()",
                  "description": "Flushes the stream if it's not closed and checks its error state."
                }
              ]
            },
            {
              "name": "setError",
              "overloads": [
                {
                  "signature": "protected void setError()",
                  "description": "Indicates that an error has occurred.\n\n  This method will cause subsequent invocations of checkError() to return true until clearError() is invoked."
                }
              ]
            },
            {
              "name": "clearError",
              "overloads": [
                {
                  "signature": "protected void clearError()",
                  "description": "Clears the error state of this stream.\n\n  This method will cause subsequent invocations of checkError() to return false until another write\n operation fails and invokes setError()."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] buf, int off, int len)",
                  "description": "Writes A Portion of an array of characters."
                },
                {
                  "signature": "public void write(char[] buf)",
                  "description": "Writes an array of characters.  This method cannot be inherited from the\n Writer class because it must suppress I/O exceptions."
                },
                {
                  "signature": "public void write(String s, int off, int len)",
                  "description": "Writes a portion of a string."
                },
                {
                  "signature": "public void write(String s)",
                  "description": "Writes a string.  This method cannot be inherited from the Writer class\n because it must suppress I/O exceptions."
                }
              ]
            },
            {
              "name": "print",
              "overloads": [
                {
                  "signature": "public void print(boolean b)",
                  "description": "Prints a boolean value.  The string produced by String.valueOf(boolean) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char c)",
                  "description": "Prints a character.  The character is translated into one or more bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(int i)",
                  "description": "Prints an integer.  The string produced by String.valueOf(int) is translated into bytes according\n to the platform's default character encoding, and these bytes are\n written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(long l)",
                  "description": "Prints a long integer.  The string produced by String.valueOf(long) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(float f)",
                  "description": "Prints a floating-point number.  The string produced by String.valueOf(float) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(double d)",
                  "description": "Prints a double-precision floating-point number.  The string produced by\n String.valueOf(double) is translated into\n bytes according to the platform's default character encoding, and these\n bytes are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char[] s)",
                  "description": "Prints an array of characters.  The characters are converted into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(String s)",
                  "description": "Prints a string.  If the argument is null then the string\n \"null\" is printed.  Otherwise, the string's characters are\n converted into bytes according to the platform's default character\n encoding, and these bytes are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(Object obj)",
                  "description": "Prints an object.  The string produced by the String.valueOf(Object) method is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                }
              ]
            },
            {
              "name": "println",
              "overloads": [
                {
                  "signature": "public void println()",
                  "description": "Terminates the current line by writing the line separator string.  The\n line separator is System.lineSeparator() and is not necessarily\n a single newline character ('\\n')."
                },
                {
                  "signature": "public void println(boolean x)",
                  "description": "Prints a boolean value and then terminates the line.  This method behaves\n as though it invokes print(boolean) and then\n println()."
                },
                {
                  "signature": "public void println(char x)",
                  "description": "Prints a character and then terminates the line.  This method behaves as\n though it invokes print(char) and then println()."
                },
                {
                  "signature": "public void println(int x)",
                  "description": "Prints an integer and then terminates the line.  This method behaves as\n though it invokes print(int) and then println()."
                },
                {
                  "signature": "public void println(long x)",
                  "description": "Prints a long integer and then terminates the line.  This method behaves\n as though it invokes print(long) and then\n println()."
                },
                {
                  "signature": "public void println(float x)",
                  "description": "Prints a floating-point number and then terminates the line.  This method\n behaves as though it invokes print(float) and then\n println()."
                },
                {
                  "signature": "public void println(double x)",
                  "description": "Prints a double-precision floating-point number and then terminates the\n line.  This method behaves as though it invokes print(double) and then println()."
                },
                {
                  "signature": "public void println(char[] x)",
                  "description": "Prints an array of characters and then terminates the line.  This method\n behaves as though it invokes print(char[]) and then\n println()."
                },
                {
                  "signature": "public void println(String x)",
                  "description": "Prints a String and then terminates the line.  This method behaves as\n though it invokes print(String) and then\n println()."
                },
                {
                  "signature": "public void println(Object x)",
                  "description": "Prints an Object and then terminates the line.  This method calls\n at first String.valueOf(x) to get the printed object's string value,\n then behaves as\n though it invokes print(String) and then\n println()."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public PrintWriter printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.  If automatic flushing is\n enabled, calls to this method will flush the output buffer.\n\n  An invocation of this method of the form\n out.printf(format, args)\n behaves in exactly the same way as the invocation\n\n \n     out.format(format, args)"
                },
                {
                  "signature": "public PrintWriter printf(Locale l, String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.  If automatic flushing is\n enabled, calls to this method will flush the output buffer.\n\n  An invocation of this method of the form\n out.printf(l, format, args)\n behaves in exactly the same way as the invocation\n\n \n     out.format(l, format, args)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public PrintWriter format(String format, Object... args)",
                  "description": "Writes a formatted string to this writer using the specified format\n string and arguments.  If automatic flushing is enabled, calls to this\n method will flush the output buffer.\n\n  The locale always used is the one returned by Locale.getDefault(), regardless of any\n previous invocations of other formatting methods on this object."
                },
                {
                  "signature": "public PrintWriter format(Locale l, String format, Object... args)",
                  "description": "Writes a formatted string to this writer using the specified format\n string and arguments.  If automatic flushing is enabled, calls to this\n method will flush the output buffer."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public PrintWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n \n     out.write(csq.toString())\n \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public PrintWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end)\n when csq is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public PrintWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n \n     out.write(c)"
                }
              ]
            }
          ]
        },
        {
          "name": "PushbackInputStream",
          "methods": [
            {
              "name": "PushbackInputStream",
              "overloads": [
                {
                  "signature": "public PushbackInputStream(InputStream in, int size)",
                  "description": "Creates a PushbackInputStream\n with a pushback buffer of the specified size,\n and saves its argument, the input stream\n in, for later use. Initially,\n the pushback buffer is empty."
                },
                {
                  "signature": "public PushbackInputStream(InputStream in)",
                  "description": "Creates a PushbackInputStream\n with a 1-byte pushback buffer, and saves its argument, the input stream\n in, for later use. Initially,\n the pushback buffer is empty."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n\n  This method returns the most recently pushed-back byte, if there is\n one, and otherwise calls the read method of its underlying\n input stream and returns whatever value that method returns."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream into\n an array of bytes.  This method first reads any pushed-back bytes; after\n that, if fewer than len bytes have been read then it\n reads from the underlying input stream. If len is not zero, the method\n blocks until at least 1 byte of input is available; otherwise, no\n bytes are read and 0 is returned."
                }
              ]
            },
            {
              "name": "unread",
              "overloads": [
                {
                  "signature": "public void unread(int b) throws IOException",
                  "description": "Pushes back a byte by copying it to the front of the pushback buffer.\n After this method returns, the next byte to be read will have the value\n (byte)b."
                },
                {
                  "signature": "public void unread(byte[] b, int off, int len) throws IOException",
                  "description": "Pushes back a portion of an array of bytes by copying it to the front\n of the pushback buffer.  After this method returns, the next byte to be\n read will have the value b[off], the byte after that will\n have the value b[off+1], and so forth."
                },
                {
                  "signature": "public void unread(byte[] b) throws IOException",
                  "description": "Pushes back an array of bytes by copying it to the front of the\n pushback buffer.  After this method returns, the next byte to be read\n will have the value b[0], the byte after that will have the\n value b[1], and so forth."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n\n  The method returns the sum of the number of bytes that have been\n pushed back and the value returned by available."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly zero.  If n is negative, no bytes are skipped.\n\n  The skip method of PushbackInputStream\n first skips over the bytes in the pushback buffer, if any.  It then\n calls the skip method of the underlying input stream if\n more bytes need to be skipped.  The actual number of bytes skipped\n is returned."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark and\n reset methods, which it does not."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream.\n\n  The mark method of PushbackInputStream\n does nothing."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n\n  The method reset for class\n PushbackInputStream does nothing except throw an\n IOException."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n Once the stream has been closed, further read(), unread(),\n available(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "PushbackReader",
          "methods": [
            {
              "name": "PushbackReader",
              "overloads": [
                {
                  "signature": "public PushbackReader(Reader in, int size)",
                  "description": "Creates a new pushback reader with a pushback buffer of the given size."
                },
                {
                  "signature": "public PushbackReader(Reader in)",
                  "description": "Creates a new pushback reader with a one-character pushback buffer."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                }
              ]
            },
            {
              "name": "unread",
              "overloads": [
                {
                  "signature": "public void unread(int c) throws IOException",
                  "description": "Pushes back a single character by copying it to the front of the\n pushback buffer. After this method returns, the next character to be read\n will have the value (char)c."
                },
                {
                  "signature": "public void unread(char[] cbuf, int off, int len) throws IOException",
                  "description": "Pushes back a portion of an array of characters by copying it to the\n front of the pushback buffer.  After this method returns, the next\n character to be read will have the value cbuf[off], the\n character after that will have the value cbuf[off+1], and\n so forth."
                },
                {
                  "signature": "public void unread(char[] cbuf) throws IOException",
                  "description": "Pushes back an array of characters by copying it to the front of the\n pushback buffer.  After this method returns, the next character to be\n read will have the value cbuf[0], the character after that\n will have the value cbuf[1], and so forth."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream. The mark\n for class PushbackReader always throws an exception."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream. The reset method of\n PushbackReader always throws an exception."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does\n not."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the stream and releases any system resources associated with\n it. Once the stream has been closed, further read(),\n unread(), ready(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "RandomAccessFile",
          "methods": [
            {
              "name": "RandomAccessFile",
              "overloads": [
                {
                  "signature": "public RandomAccessFile(String name, String mode) throws FileNotFoundException",
                  "description": "Creates a random access file stream to read from, and optionally\n to write to, a file with the specified name. A new\n FileDescriptor object is created to represent the\n connection to the file.\n\n  The mode argument specifies the access mode with which the\n file is to be opened.  The permitted values and their meanings are as\n specified for the RandomAccessFile(File,String) constructor.\n\n \n If there is a security manager, its checkRead method\n is called with the name argument\n as its argument to see if read access to the file is allowed.\n If the mode allows writing, the security manager's\n checkWrite method\n is also called with the name argument\n as its argument to see if write access to the file is allowed."
                },
                {
                  "signature": "public RandomAccessFile(File file, String mode) throws FileNotFoundException",
                  "description": "Creates a random access file stream to read from, and optionally to\n write to, the file specified by the File argument.  A new FileDescriptor object is created to represent this file connection.\n\n The mode argument specifies the access mode\n in which the file is to be opened.  The permitted values and their\n meanings are:\n\n \n Access mode permitted values and meanings\n \n ValueMeaning\n \n \n \"r\"\n      Open for reading only. Invoking any of the write\n     methods of the resulting object will cause an\n     IOException to be thrown.\n \"rw\"\n      Open for reading and writing.  If the file does not already\n     exist then an attempt will be made to create it.\n \"rws\"\n      Open for reading and writing, as with \"rw\", and also\n     require that every update to the file's content or metadata be\n     written synchronously to the underlying storage device.\n \"rwd\"\n      Open for reading and writing, as with \"rw\", and also\n     require that every update to the file's content be written\n     synchronously to the underlying storage device.\n \n \n\n The \"rws\" and \"rwd\" modes work much like the force(boolean) method of\n the FileChannel class, passing arguments of\n true and false, respectively, except that they always\n apply to every I/O operation and are therefore often more efficient.  If\n the file resides on a local storage device then when an invocation of a\n method of this class returns it is guaranteed that all changes made to\n the file by that invocation will have been written to that device.  This\n is useful for ensuring that critical information is not lost in the\n event of a system crash.  If the file does not reside on a local device\n then no such guarantee is made.\n\n The \"rwd\" mode can be used to reduce the number of I/O\n operations performed.  Using \"rwd\" only requires updates to the\n file's content to be written to storage; using \"rws\" requires\n updates to both the file's content and its metadata to be written, which\n generally requires at least one more low-level I/O operation.\n\n If there is a security manager, its checkRead method is\n called with the pathname of the file argument as its\n argument to see if read access to the file is allowed.  If the mode\n allows writing, the security manager's checkWrite method is\n also called with the path argument to see if write access to the file is\n allowed."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the opaque file descriptor object associated with this\n stream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public final FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file.\n\n  The position of the returned channel will always be equal to\n this object's file-pointer offset as returned by the getFilePointer method.  Changing this object's\n file-pointer offset, whether explicitly or by reading or writing bytes,\n will change the position of the channel, and vice versa.  Changing the\n file's length via this object will change the length seen via the file\n channel, and vice versa."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data from this file. The byte is returned as an\n integer in the range 0 to 255 (0x00-0x0ff). This\n method blocks if no input is yet available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the same\n way as the InputStream.read() method of\n InputStream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this file into an\n array of bytes. This method blocks until at least one byte of input\n is available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the\n same way as the InputStream.read(byte[], int, int) method of\n InputStream."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this file\n into an array of bytes. This method blocks until at least one byte\n of input is available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the\n same way as the InputStream.read(byte[]) method of\n InputStream."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public final void readFully(byte[] b) throws IOException",
                  "description": "Reads b.length bytes from this file into the byte\n array, starting at the current file pointer. This method reads\n repeatedly from the file until the requested number of bytes are\n read. This method blocks until the requested number of bytes are\n read, the end of the stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public final void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "Reads exactly len bytes from this file into the byte\n array, starting at the current file pointer. This method reads\n repeatedly from the file until the requested number of bytes are\n read. This method blocks until the requested number of bytes are\n read, the end of the stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public int skipBytes(int n) throws IOException",
                  "description": "Attempts to skip over n bytes of input discarding the\n skipped bytes.\n \n\n This method may skip over some smaller number of bytes, possibly zero.\n This may result from any of a number of conditions; reaching end of\n file before n bytes have been skipped is only one\n possibility. This method never throws an EOFException.\n The actual number of bytes skipped is returned.  If n\n is negative, no bytes are skipped."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this file. The write starts at\n the current file pointer."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this file, starting at the current file pointer."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this file."
                }
              ]
            },
            {
              "name": "getFilePointer",
              "overloads": [
                {
                  "signature": "public long getFilePointer() throws IOException",
                  "description": "Returns the current offset in this file."
                }
              ]
            },
            {
              "name": "seek",
              "overloads": [
                {
                  "signature": "public void seek(long pos) throws IOException",
                  "description": "Sets the file-pointer offset, measured from the beginning of this\n file, at which the next read or write occurs.  The offset may be\n set beyond the end of the file. Setting the offset beyond the end\n of the file does not change the file length.  The file length will\n change only by writing after the offset has been set beyond the end\n of the file."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public long length() throws IOException",
                  "description": "Returns the length of this file."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(long newLength) throws IOException",
                  "description": "Sets the length of this file.\n\n  If the present length of the file as returned by the\n length method is greater than the newLength\n argument then the file will be truncated.  In this case, if the file\n offset as returned by the getFilePointer method is greater\n than newLength then after this method returns the offset\n will be equal to newLength.\n\n  If the present length of the file as returned by the\n length method is smaller than the newLength\n argument then the file will be extended.  In this case, the contents of\n the extended portion of the file are not defined."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this random access file stream and releases any system\n resources associated with the stream. A closed random access\n file cannot perform input or output operations and cannot be\n reopened.\n\n  If this file has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public final boolean readBoolean() throws IOException",
                  "description": "Reads a boolean from this file. This method reads a\n single byte from the file, starting at the current file pointer.\n A value of 0 represents\n false. Any other value represents true.\n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public final byte readByte() throws IOException",
                  "description": "Reads a signed eight-bit value from this file. This method reads a\n byte from the file, starting from the current file pointer.\n If the byte read is b, where\n 0 <= b <= 255,\n then the result is:\n      (byte)(b)\n \n \n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public final int readUnsignedByte() throws IOException",
                  "description": "Reads an unsigned eight-bit number from this file. This method reads\n a byte from this file, starting at the current file pointer,\n and returns that byte.\n \n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public final short readShort() throws IOException",
                  "description": "Reads a signed 16-bit number from this file. The method reads two\n bytes from this file, starting at the current file pointer.\n If the two bytes read, in order, are\n b1 and b2, where each of the two values is\n between 0 and 255, inclusive, then the\n result is equal to:\n      (short)((b1 << 8) | b2)\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public final int readUnsignedShort() throws IOException",
                  "description": "Reads an unsigned 16-bit number from this file. This method reads\n two bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1 and b2, where\n 0 <= b1, b2 <= 255,\n then the result is equal to:\n      (b1 << 8) | b2\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public final char readChar() throws IOException",
                  "description": "Reads a character from this file. This method reads two\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1 and b2, where\n 0 <= b1, b2 <= 255,\n then the result is equal to:\n      (char)((b1 << 8) | b2)\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public final int readInt() throws IOException",
                  "description": "Reads a signed 32-bit integer from this file. This method reads 4\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are b1,\n b2, b3, and b4, where\n 0 <= b1, b2, b3, b4 <= 255,\n then the result is equal to:\n      (b1 << 24) | (b2 << 16) + (b3 << 8) + b4\n \n \n This method blocks until the four bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public final long readLong() throws IOException",
                  "description": "Reads a signed 64-bit integer from this file. This method reads eight\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1, b2, b3,\n b4, b5, b6,\n b7, and b8, where:\n      0 <= b1, b2, b3, b4, b5, b6, b7, b8 <=255,\n \n \n then the result is equal to:\n      ((long)b1 << 56) + ((long)b2 << 48)\n     + ((long)b3 << 40) + ((long)b4 << 32)\n     + ((long)b5 << 24) + ((long)b6 << 16)\n     + ((long)b7 << 8) + b8\n \n \n This method blocks until the eight bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public final float readFloat() throws IOException",
                  "description": "Reads a float from this file. This method reads an\n int value, starting at the current file pointer,\n as if by the readInt method\n and then converts that int to a float\n using the intBitsToFloat method in class\n Float.\n \n This method blocks until the four bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public final double readDouble() throws IOException",
                  "description": "Reads a double from this file. This method reads a\n long value, starting at the current file pointer,\n as if by the readLong method\n and then converts that long to a double\n using the longBitsToDouble method in\n class Double.\n \n This method blocks until the eight bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public final String readLine() throws IOException",
                  "description": "Reads the next line of text from this file.  This method successively\n reads bytes from the file, starting at the current file pointer,\n until it reaches a line terminator or the end\n of the file.  Each byte is converted into a character by taking the\n byte's value for the lower eight bits of the character and setting the\n high eight bits of the character to zero.  This method does not,\n therefore, support the full Unicode character set.\n\n  A line of text is terminated by a carriage-return character\n ('\\r'), a newline character ('\\n'), a\n carriage-return character immediately followed by a newline character,\n or the end of the file.  Line-terminating characters are discarded and\n are not included as part of the string returned.\n\n  This method blocks until a newline character is read, a carriage\n return and the byte following it are read (to see if it is a newline),\n the end of the file is reached, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public final String readUTF() throws IOException",
                  "description": "Reads in a string from this file. The string has been encoded\n using a\n modified UTF-8\n format.\n \n The first two bytes are read, starting from the current file\n pointer, as if by\n readUnsignedShort. This value gives the number of\n following bytes that are in the encoded string, not\n the length of the resulting string. The following bytes are then\n interpreted as bytes encoding characters in the modified UTF-8 format\n and are converted into characters.\n \n This method blocks until all the bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public final void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean to the file as a one-byte value. The\n value true is written out as the value\n (byte)1; the value false is written out\n as the value (byte)0. The write starts at\n the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public final void writeByte(int v) throws IOException",
                  "description": "Writes a byte to the file as a one-byte value. The\n write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public final void writeShort(int v) throws IOException",
                  "description": "Writes a short to the file as two bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public final void writeChar(int v) throws IOException",
                  "description": "Writes a char to the file as a two-byte value, high\n byte first. The write starts at the current position of the\n file pointer."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public final void writeInt(int v) throws IOException",
                  "description": "Writes an int to the file as four bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public final void writeLong(long v) throws IOException",
                  "description": "Writes a long to the file as eight bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public final void writeFloat(float v) throws IOException",
                  "description": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the file as a\n four-byte quantity, high byte first. The write starts at the\n current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public final void writeDouble(double v) throws IOException",
                  "description": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the file as an\n eight-byte quantity, high byte first. The write starts at the current\n position of the file pointer."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public final void writeBytes(String s) throws IOException",
                  "description": "Writes the string to the file as a sequence of bytes. Each\n character in the string is written out, in sequence, by discarding\n its high eight bits. The write starts at the current position of\n the file pointer."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public final void writeChars(String s) throws IOException",
                  "description": "Writes a string to the file as a sequence of characters. Each\n character is written to the data output stream as if by the\n writeChar method. The write starts at the current\n position of the file pointer."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public final void writeUTF(String str) throws IOException",
                  "description": "Writes a string to the file using\n modified UTF-8\n encoding in a machine-independent manner.\n \n First, two bytes are written to the file, starting at the\n current file pointer, as if by the\n writeShort method giving the number of bytes to\n follow. This value is the number of bytes actually written out,\n not the length of the string. Following the length, each character\n of the string is output, in sequence, using the modified UTF-8 encoding\n for each character."
                }
              ]
            }
          ]
        },
        {
          "name": "Reader",
          "methods": [
            {
              "name": "Reader",
              "overloads": [
                {
                  "signature": "protected Reader()",
                  "description": "Creates a new character-stream reader whose critical sections will\n synchronize on the reader itself."
                },
                {
                  "signature": "protected Reader(Object lock)",
                  "description": "Creates a new character-stream reader whose critical sections will\n synchronize on the given object."
                }
              ]
            },
            {
              "name": "nullReader",
              "overloads": [
                {
                  "signature": "public static Reader nullReader()",
                  "description": "Returns a new Reader that reads no characters. The returned\n stream is initially open.  The stream is closed by calling the\n close() method.  Subsequent calls to close() have no\n effect.\n\n  While the stream is open, the read(), read(char[]),\n read(char[], int, int), read(CharBuffer), \n ready(), skip(long), and transferTo() methods all\n behave as if end of stream has been reached. After the stream has been\n closed, these methods all throw IOException.\n\n  The markSupported() method returns false.  The\n mark() and reset() methods throw an IOException.\n\n  The object used to synchronize operations on the\n returned Reader is not specified."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read(CharBuffer target) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                },
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character.  This method will block until a character is\n available, an I/O error occurs, or the end of the stream is reached.\n\n  Subclasses that intend to support efficient single-character input\n should override this method."
                },
                {
                  "signature": "public int read(char[] cbuf) throws IOException",
                  "description": "Reads characters into an array.  This method will block until some input\n is available, an I/O error occurs, or the end of the stream is reached.\n\n  If the length of cbuf is zero, then no characters are read\n and 0 is returned; otherwise, there is an attempt to read at\n least one character.  If no character is available because the stream is\n at its end, the value -1 is returned; otherwise, at least one\n character is read and stored into cbuf."
                },
                {
                  "signature": "public abstract int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters.  This method will block until some characters are\n available, an I/O error occurs, or the end of the stream is reached.\n If the stream is already at its end before this method is invoked,\n then no characters are skipped and zero is returned."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation. The default\n implementation always returns false. Subclasses should override this\n method."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point.  Not all\n character-input streams support the mark() operation."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream.  If the stream has been marked, then attempt to\n reposition it at the mark.  If the stream has not been marked, then\n attempt to reset it in some way appropriate to the particular stream,\n for example by repositioning it to its starting point.  Not all\n character-input streams support the reset() operation, and some support\n reset() without supporting mark()."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public abstract void close() throws IOException",
                  "description": "Closes the stream and releases any system resources associated with\n it.  Once the stream has been closed, further read(), ready(),\n mark(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            },
            {
              "name": "transferTo",
              "overloads": [
                {
                  "signature": "public long transferTo(Writer out) throws IOException",
                  "description": "Reads all characters from this reader and writes the characters to the\n given writer in the order that they are read. On return, this reader\n will be at end of the stream. This method does not close either reader\n or writer.\n \n This method may block indefinitely reading from the reader, or\n writing to the writer. The behavior for the case where the reader\n and/or writer is asynchronously closed, or the thread\n interrupted during the transfer, is highly reader and writer\n specific, and therefore not specified.\n \n If an I/O error occurs reading from the reader or writing to the\n writer, then it may do so after some characters have been read or\n written. Consequently the reader may not be at end of the stream and\n one, or both, streams may be in an inconsistent state. It is strongly\n recommended that both streams be promptly closed if an I/O error occurs."
                }
              ]
            }
          ]
        },
        {
          "name": "SequenceInputStream",
          "methods": [
            {
              "name": "SequenceInputStream",
              "overloads": [
                {
                  "signature": "public SequenceInputStream(Enumeration<? extends InputStream> e)",
                  "description": "Initializes a newly created SequenceInputStream\n by remembering the argument, which must\n be an Enumeration  that produces\n objects whose run-time type is InputStream.\n The input streams that are  produced by\n the enumeration will be read, in order,\n to provide the bytes to be read  from this\n SequenceInputStream. After\n each input stream from the enumeration\n is exhausted, it is closed by calling its\n close method."
                },
                {
                  "signature": "public SequenceInputStream(InputStream s1, InputStream s2)",
                  "description": "Initializes a newly\n created SequenceInputStream\n by remembering the two arguments, which\n will be read in order, first s1\n and then s2, to provide the\n bytes to be read from this SequenceInputStream."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from the current underlying input stream without\n blocking by the next invocation of a method for the current\n underlying input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method simply calls available of the current underlying\n input stream and returns the result."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The byte is\n returned as an int in the range 0 to\n 255. If no byte is available because the end of the\n stream has been reached, the value -1 is returned.\n This method blocks until input data is available, the end of the\n stream is detected, or an exception is thrown.\n \n This method\n tries to read one character from the current substream. If it\n reaches the end of the stream, it calls the close\n method of the current substream and begins reading from the next\n substream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes.  If len is not zero, the method\n blocks until at least 1 byte of input is available; otherwise, no\n bytes are read and 0 is returned.\n \n The read method of SequenceInputStream\n tries to read the data from the current substream. If it fails to\n read any characters because the substream has reached the end of\n the stream, it calls the close method of the current\n substream and begins reading from the next substream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n A closed SequenceInputStream\n cannot  perform input operations and cannot\n be reopened.\n \n If this stream was created\n from an enumeration, all remaining elements\n are requested from the enumeration and closed\n before the close method returns."
                }
              ]
            }
          ]
        },
        {
          "name": "Serializable",
          "methods": []
        },
        {
          "name": "SerializablePermission",
          "methods": [
            {
              "name": "SerializablePermission",
              "overloads": [
                {
                  "signature": "public SerializablePermission(String name)",
                  "description": "Creates a new SerializablePermission with the specified name.\n The name is the symbolic name of the SerializablePermission, such as\n \"enableSubstitution\", etc."
                },
                {
                  "signature": "public SerializablePermission(String name, String actions)",
                  "description": "Creates a new SerializablePermission object with the specified name.\n The name is the symbolic name of the SerializablePermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "StreamCorruptedException",
          "methods": [
            {
              "name": "StreamCorruptedException",
              "overloads": [
                {
                  "signature": "public StreamCorruptedException(String reason)",
                  "description": "Create a StreamCorruptedException and list a reason why thrown."
                },
                {
                  "signature": "public StreamCorruptedException()",
                  "description": "Create a StreamCorruptedException and list no reason why thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "StreamTokenizer",
          "methods": [
            {
              "name": "StreamTokenizer",
              "overloads": [
                {
                  "signature": "@Deprecated public StreamTokenizer(InputStream is)",
                  "description": "Creates a stream tokenizer that parses the specified input\n stream. The stream tokenizer is initialized to the following\n default state:\n \n All byte values 'A' through 'Z',\n     'a' through 'z', and\n     '\\u00A0' through '\\u00FF' are\n     considered to be alphabetic.\n All byte values '\\u0000' through\n     '\\u0020' are considered to be white space.\n '/' is a comment character.\n Single quote '\\'' and double quote '\"'\n     are string quote characters.\n Numbers are parsed.\n Ends of lines are treated as white space, not as separate tokens.\n C-style and C++-style comments are not recognized.",
                  "deprecated": true
                },
                {
                  "signature": "public StreamTokenizer(Reader r)",
                  "description": "Create a tokenizer that parses the given character stream."
                }
              ]
            },
            {
              "name": "resetSyntax",
              "overloads": [
                {
                  "signature": "public void resetSyntax()",
                  "description": "Resets this tokenizer's syntax table so that all characters are\n \"ordinary.\" See the ordinaryChar method\n for more information on a character being ordinary."
                }
              ]
            },
            {
              "name": "wordChars",
              "overloads": [
                {
                  "signature": "public void wordChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are word constituents. A word token consists of a word constituent\n followed by zero or more word constituents or number constituents."
                }
              ]
            },
            {
              "name": "whitespaceChars",
              "overloads": [
                {
                  "signature": "public void whitespaceChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are white space characters. White space characters serve only to\n separate tokens in the input stream.\n\n Any other attribute settings for the characters in the specified\n range are cleared."
                }
              ]
            },
            {
              "name": "ordinaryChars",
              "overloads": [
                {
                  "signature": "public void ordinaryChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are \"ordinary\" in this tokenizer. See the\n ordinaryChar method for more information on a\n character being ordinary."
                }
              ]
            },
            {
              "name": "ordinaryChar",
              "overloads": [
                {
                  "signature": "public void ordinaryChar(int ch)",
                  "description": "Specifies that the character argument is \"ordinary\"\n in this tokenizer. It removes any special significance the\n character has as a comment character, word component, string\n delimiter, white space, or number character. When such a character\n is encountered by the parser, the parser treats it as a\n single-character token and sets ttype field to the\n character value.\n\n Making a line terminator character \"ordinary\" may interfere\n with the ability of a StreamTokenizer to count\n lines. The lineno method may no longer reflect\n the presence of such terminator characters in its line count."
                }
              ]
            },
            {
              "name": "commentChar",
              "overloads": [
                {
                  "signature": "public void commentChar(int ch)",
                  "description": "Specified that the character argument starts a single-line\n comment. All characters from the comment character to the end of\n the line are ignored by this stream tokenizer.\n\n Any other attribute settings for the specified character are cleared."
                }
              ]
            },
            {
              "name": "quoteChar",
              "overloads": [
                {
                  "signature": "public void quoteChar(int ch)",
                  "description": "Specifies that matching pairs of this character delimit string\n constants in this tokenizer.\n \n When the nextToken method encounters a string\n constant, the ttype field is set to the string\n delimiter and the sval field is set to the body of\n the string.\n \n If a string quote character is encountered, then a string is\n recognized, consisting of all characters after (but not including)\n the string quote character, up to (but not including) the next\n occurrence of that same string quote character, or a line\n terminator, or end of file. The usual escape sequences such as\n \"\\n\" and \"\\t\" are recognized and\n converted to single characters as the string is parsed.\n\n Any other attribute settings for the specified character are cleared."
                }
              ]
            },
            {
              "name": "parseNumbers",
              "overloads": [
                {
                  "signature": "public void parseNumbers()",
                  "description": "Specifies that numbers should be parsed by this tokenizer. The\n syntax table of this tokenizer is modified so that each of the twelve\n characters:\n       0 1 2 3 4 5 6 7 8 9 . -\n \n \n has the \"numeric\" attribute.\n \n When the parser encounters a word token that has the format of a\n double precision floating-point number, it treats the token as a\n number rather than a word, by setting the ttype\n field to the value TT_NUMBER and putting the numeric\n value of the token into the nval field."
                }
              ]
            },
            {
              "name": "eolIsSignificant",
              "overloads": [
                {
                  "signature": "public void eolIsSignificant(boolean flag)",
                  "description": "Determines whether or not ends of line are treated as tokens.\n If the flag argument is true, this tokenizer treats end of lines\n as tokens; the nextToken method returns\n TT_EOL and also sets the ttype field to\n this value when an end of line is read.\n \n A line is a sequence of characters ending with either a\n carriage-return character ('\\r') or a newline\n character ('\\n'). In addition, a carriage-return\n character followed immediately by a newline character is treated\n as a single end-of-line token.\n \n If the flag is false, end-of-line characters are\n treated as white space and serve only to separate tokens."
                }
              ]
            },
            {
              "name": "slashStarComments",
              "overloads": [
                {
                  "signature": "public void slashStarComments(boolean flag)",
                  "description": "Determines whether or not the tokenizer recognizes C-style comments.\n If the flag argument is true, this stream tokenizer\n recognizes C-style comments. All text between successive\n occurrences of /* and */ are discarded.\n \n If the flag argument is false, then C-style comments\n are not treated specially."
                }
              ]
            },
            {
              "name": "slashSlashComments",
              "overloads": [
                {
                  "signature": "public void slashSlashComments(boolean flag)",
                  "description": "Determines whether or not the tokenizer recognizes C++-style comments.\n If the flag argument is true, this stream tokenizer\n recognizes C++-style comments. Any occurrence of two consecutive\n slash characters ('/') is treated as the beginning of\n a comment that extends to the end of the line.\n \n If the flag argument is false, then C++-style\n comments are not treated specially."
                }
              ]
            },
            {
              "name": "lowerCaseMode",
              "overloads": [
                {
                  "signature": "public void lowerCaseMode(boolean fl)",
                  "description": "Determines whether or not word token are automatically lowercased.\n If the flag argument is true, then the value in the\n sval field is lowercased whenever a word token is\n returned (the ttype field has the\n value TT_WORD by the nextToken method\n of this tokenizer.\n \n If the flag argument is false, then the\n sval field is not modified."
                }
              ]
            },
            {
              "name": "nextToken",
              "overloads": [
                {
                  "signature": "public int nextToken() throws IOException",
                  "description": "Parses the next token from the input stream of this tokenizer.\n The type of the next token is returned in the ttype\n field. Additional information about the token may be in the\n nval field or the sval field of this\n tokenizer.\n \n Typical clients of this\n class first set up the syntax tables and then sit in a loop\n calling nextToken to parse successive tokens until TT_EOF\n is returned."
                }
              ]
            },
            {
              "name": "pushBack",
              "overloads": [
                {
                  "signature": "public void pushBack()",
                  "description": "Causes the next call to the nextToken method of this\n tokenizer to return the current value in the ttype\n field, and not to modify the value in the nval or\n sval field."
                }
              ]
            },
            {
              "name": "lineno",
              "overloads": [
                {
                  "signature": "public int lineno()",
                  "description": "Return the current line number."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of the current stream token and\n the line number it occurs on.\n\n The precise string returned is unspecified, although the following\n example can be considered typical:\n\n Token['a'], line 10"
                }
              ]
            }
          ]
        },
        {
          "name": "StringBufferInputStream",
          "methods": [
            {
              "name": "StringBufferInputStream",
              "overloads": [
                {
                  "signature": "public StringBufferInputStream(String s)",
                  "description": "Creates a string input stream to read data from the specified string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read()",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned.\n \n The read method of\n StringBufferInputStream cannot block. It returns the\n low eight bits of the next character in this input stream's buffer.",
                  "deprecated": true
                },
                {
                  "signature": "public int read(byte[] b, int off, int len)",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes.\n \n The read method of\n StringBufferInputStream cannot block. It copies the\n low eight bits from the characters in this input stream's buffer into\n the byte array argument.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n)",
                  "description": "Skips n bytes of input from this input stream. Fewer\n bytes might be skipped if the end of the input stream is reached.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available()",
                  "description": "Returns the number of bytes that can be read from the input\n stream without blocking.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the input stream to begin reading from the first character\n of this input stream's underlying buffer.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "StringReader",
          "methods": [
            {
              "name": "StringReader",
              "overloads": [
                {
                  "signature": "public StringReader(String s)",
                  "description": "Creates a new string reader."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters. If the stream is already at its end before this method\n is invoked, then no characters are skipped and zero is returned.\n\n The n parameter may be negative, even though the\n skip method of the Reader superclass throws\n an exception in this case. Negative values of n cause the\n stream to skip backwards. Negative return values indicate a skip\n backwards. It is not possible to skip backwards past the beginning of\n the string.\n\n If the entire string has been read or skipped, then this method has\n no effect and always returns 0."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark, or to the beginning of the\n string if it has never been marked."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated with\n it. Once the stream has been closed, further read(),\n ready(), mark(), or reset() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "StringWriter",
          "methods": [
            {
              "name": "StringWriter",
              "overloads": [
                {
                  "signature": "public StringWriter()",
                  "description": "Create a new string writer using the default initial string-buffer\n size."
                },
                {
                  "signature": "public StringWriter(int initialSize)",
                  "description": "Create a new string writer using the specified initial string-buffer\n size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Write a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len)",
                  "description": "Write a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str)",
                  "description": "Write a string."
                },
                {
                  "signature": "public void write(String str, int off, int len)",
                  "description": "Write a portion of a string."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public StringWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when csq\n is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public StringWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return the buffer's current value as a string."
                }
              ]
            },
            {
              "name": "getBuffer",
              "overloads": [
                {
                  "signature": "public StringBuffer getBuffer()",
                  "description": "Return the string buffer itself."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flush the stream.\n\n  The flush method of StringWriter does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a StringWriter has no effect. The methods in this\n class can be called after the stream has been closed without generating\n an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "SyncFailedException",
          "methods": [
            {
              "name": "SyncFailedException",
              "overloads": [
                {
                  "signature": "public SyncFailedException(String desc)",
                  "description": "Constructs an SyncFailedException with a detail message.\n A detail message is a String that describes this particular exception."
                }
              ]
            }
          ]
        },
        {
          "name": "UncheckedIOException",
          "methods": [
            {
              "name": "UncheckedIOException",
              "overloads": [
                {
                  "signature": "public UncheckedIOException(String message, IOException cause)",
                  "description": "Constructs an instance of this class."
                },
                {
                  "signature": "public UncheckedIOException(IOException cause)",
                  "description": "Constructs an instance of this class."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public IOException getCause()",
                  "description": "Returns the cause of this exception."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedEncodingException",
          "methods": [
            {
              "name": "UnsupportedEncodingException",
              "overloads": [
                {
                  "signature": "public UnsupportedEncodingException()",
                  "description": "Constructs an UnsupportedEncodingException without a detail message."
                },
                {
                  "signature": "public UnsupportedEncodingException(String s)",
                  "description": "Constructs an UnsupportedEncodingException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UTFDataFormatException",
          "methods": [
            {
              "name": "UTFDataFormatException",
              "overloads": [
                {
                  "signature": "public UTFDataFormatException()",
                  "description": "Constructs a UTFDataFormatException with\n null as its error detail message."
                },
                {
                  "signature": "public UTFDataFormatException(String s)",
                  "description": "Constructs a UTFDataFormatException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "WriteAbortedException",
          "methods": [
            {
              "name": "WriteAbortedException",
              "overloads": [
                {
                  "signature": "public WriteAbortedException(String s, Exception ex)",
                  "description": "Constructs a WriteAbortedException with a string describing\n the exception and the exception causing the abort."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Produce the message and include the message from the nested\n exception, if there is one."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public Throwable getCause()",
                  "description": "Returns the exception that terminated the operation (the cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Writer",
          "methods": [
            {
              "name": "Writer",
              "overloads": [
                {
                  "signature": "protected Writer()",
                  "description": "Creates a new character-stream writer whose critical sections will\n synchronize on the writer itself."
                },
                {
                  "signature": "protected Writer(Object lock)",
                  "description": "Creates a new character-stream writer whose critical sections will\n synchronize on the given object."
                }
              ]
            },
            {
              "name": "nullWriter",
              "overloads": [
                {
                  "signature": "public static Writer nullWriter()",
                  "description": "Returns a new Writer which discards all characters.  The\n returned stream is initially open.  The stream is closed by calling\n the close() method.  Subsequent calls to close() have\n no effect.\n\n  While the stream is open, the append(char), \n append(CharSequence), append(CharSequence, int, int),\n flush(), write(int), write(char[]), and\n write(char[], int, int) methods do nothing. After the stream\n has been closed, these methods all throw IOException.\n\n  The object used to synchronize operations on the\n returned Writer is not specified."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character.  The character to be written is contained in\n the 16 low-order bits of the given integer value; the 16 high-order bits\n are ignored.\n\n  Subclasses that intend to support efficient single-character output\n should override this method."
                },
                {
                  "signature": "public void write(char[] cbuf) throws IOException",
                  "description": "Writes an array of characters."
                },
                {
                  "signature": "public abstract void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str) throws IOException",
                  "description": "Writes a string."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public Writer append(CharSequence csq) throws IOException",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public Writer append(CharSequence csq, int start, int end) throws IOException",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n Appendable.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when csq\n is not null behaves in exactly the\n same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public Writer append(char c) throws IOException",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public abstract void flush() throws IOException",
                  "description": "Flushes the stream.  If the stream has saved any characters from the\n various write() methods in a buffer, write them immediately to their\n intended destination.  Then, if that destination is another character or\n byte stream, flush it.  Thus one flush() invocation will flush all the\n buffers in a chain of Writers and OutputStreams.\n\n  If the intended destination of this stream is an abstraction provided\n by the underlying operating system, for example a file, then flushing the\n stream guarantees only that bytes previously written to the stream are\n passed to the operating system for writing; it does not guarantee that\n they are actually written to a physical device such as a disk drive."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public abstract void close() throws IOException",
                  "description": "Closes the stream, flushing it first. Once the stream has been closed,\n further write() or flush() invocations will cause an IOException to be\n thrown. Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.math",
      "description": "Mathematical operations",
      "classes": [
        {
          "name": "BigDecimal",
          "methods": [
            {
              "name": "BigDecimal",
              "overloads": [
                {
                  "signature": "public BigDecimal(char[] in, int offset, int len)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor, while allowing a sub-array to be specified."
                },
                {
                  "signature": "public BigDecimal(char[] in, int offset, int len, MathContext mc)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor, while allowing a sub-array to be specified and\n with rounding according to the context settings."
                },
                {
                  "signature": "public BigDecimal(char[] in)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor."
                },
                {
                  "signature": "public BigDecimal(char[] in, MathContext mc)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor and with rounding according to the context\n settings."
                },
                {
                  "signature": "public BigDecimal(String val)",
                  "description": "Translates the string representation of a BigDecimal\n into a BigDecimal.  The string representation consists\n of an optional sign, '+' ( '\\u002B') or\n '-' ('\\u002D'), followed by a sequence of\n zero or more decimal digits (\"the integer\"), optionally\n followed by a fraction, optionally followed by an exponent.\n\n The fraction consists of a decimal point followed by zero\n or more decimal digits.  The string must contain at least one\n digit in either the integer or the fraction.  The number formed\n by the sign, the integer and the fraction is referred to as the\n significand.\n\n The exponent consists of the character 'e'\n ('\\u0065') or 'E' ('\\u0045')\n followed by one or more decimal digits.  The value of the\n exponent must lie between -Integer.MAX_VALUE (Integer.MIN_VALUE+1) and Integer.MAX_VALUE, inclusive.\n\n More formally, the strings this constructor accepts are\n described by the following grammar:\n \n \n BigDecimalString:\n Signopt Significand Exponentopt\n Sign:\n +\n -\n Significand:\n IntegerPart . FractionPartopt\n . FractionPart\n IntegerPart\n IntegerPart:\n Digits\n FractionPart:\n Digits\n Exponent:\n ExponentIndicator SignedInteger\n ExponentIndicator:\n e\n E\n SignedInteger:\n Signopt Digits\n Digits:\n Digit\n Digits Digit\n Digit:\n any character for which Character.isDigit(char)\n returns true, including 0, 1, 2 ...\n \n \n\n The scale of the returned BigDecimal will be the\n number of digits in the fraction, or zero if the string\n contains no decimal point, subject to adjustment for any\n exponent; if the string contains an exponent, the exponent is\n subtracted from the scale.  The value of the resulting scale\n must lie between Integer.MIN_VALUE and\n Integer.MAX_VALUE, inclusive.\n\n The character-to-digit mapping is provided by Character.digit(char, int) set to convert to radix 10.  The\n String may not contain any extraneous characters (whitespace,\n for example).\n\n Examples:\n The value of the returned BigDecimal is equal to\n significand  10exponent.\n For each string on the left, the resulting representation\n [BigInteger, scale] is shown on the right.\n  \"0\"            [0,0]\n \"0.00\"         [0,2]\n \"123\"          [123,0]\n \"-123\"         [-123,0]\n \"1.23E3\"       [123,-1]\n \"1.23E+3\"      [123,-1]\n \"12.3E+7\"      [123,-6]\n \"12.0\"         [120,1]\n \"12.3\"         [123,1]\n \"0.00123\"      [123,5]\n \"-1.23E-12\"    [-123,14]\n \"1234.5E-4\"    [12345,5]\n \"0E+7\"         [0,-7]\n \"-0\"           [0,0]"
                },
                {
                  "signature": "public BigDecimal(String val, MathContext mc)",
                  "description": "Translates the string representation of a BigDecimal\n into a BigDecimal, accepting the same strings as the\n BigDecimal(String) constructor, with rounding\n according to the context settings."
                },
                {
                  "signature": "public BigDecimal(double val)",
                  "description": "Translates a double into a BigDecimal which\n is the exact decimal representation of the double's\n binary floating-point value.  The scale of the returned\n BigDecimal is the smallest value such that\n (10scale  val) is an integer.\n \n Notes:\n \n \n The results of this constructor can be somewhat unpredictable.\n One might assume that writing new BigDecimal(0.1) in\n Java creates a BigDecimal which is exactly equal to\n 0.1 (an unscaled value of 1, with a scale of 1), but it is\n actually equal to\n 0.1000000000000000055511151231257827021181583404541015625.\n This is because 0.1 cannot be represented exactly as a\n double (or, for that matter, as a binary fraction of\n any finite length).  Thus, the value that is being passed\n in to the constructor is not exactly equal to 0.1,\n appearances notwithstanding.\n\n \n The String constructor, on the other hand, is\n perfectly predictable: writing new BigDecimal(\"0.1\")\n creates a BigDecimal which is exactly equal to\n 0.1, as one would expect.  Therefore, it is generally\n recommended that the String constructor be used in preference to this one.\n\n \n When a double must be used as a source for a\n BigDecimal, note that this constructor provides an\n exact conversion; it does not give the same result as\n converting the double to a String using the\n Double.toString(double) method and then using the\n BigDecimal(String) constructor.  To get that result,\n use the static valueOf(double) method."
                },
                {
                  "signature": "public BigDecimal(double val, MathContext mc)",
                  "description": "Translates a double into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal is the smallest value such that\n (10scale  val) is an integer.\n\n The results of this constructor can be somewhat unpredictable\n and its use is generally not recommended; see the notes under\n the BigDecimal(double) constructor."
                },
                {
                  "signature": "public BigDecimal(BigInteger val)",
                  "description": "Translates a BigInteger into a BigDecimal.\n The scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(BigInteger val, MathContext mc)",
                  "description": "Translates a BigInteger into a BigDecimal\n rounding according to the context settings.  The scale of the\n BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(BigInteger unscaledVal, int scale)",
                  "description": "Translates a BigInteger unscaled value and an\n int scale into a BigDecimal.  The value of\n the BigDecimal is\n (unscaledVal  10-scale)."
                },
                {
                  "signature": "public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc)",
                  "description": "Translates a BigInteger unscaled value and an\n int scale into a BigDecimal, with rounding\n according to the context settings.  The value of the\n BigDecimal is (unscaledVal \n 10-scale), rounded according to the\n precision and rounding mode settings."
                },
                {
                  "signature": "public BigDecimal(int val)",
                  "description": "Translates an int into a BigDecimal.  The\n scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(int val, MathContext mc)",
                  "description": "Translates an int into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal, before any rounding, is zero."
                },
                {
                  "signature": "public BigDecimal(long val)",
                  "description": "Translates a long into a BigDecimal.  The\n scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(long val, MathContext mc)",
                  "description": "Translates a long into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal, before any rounding, is zero."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static BigDecimal valueOf(long unscaledVal, int scale)",
                  "description": "Translates a long unscaled value and an\n int scale into a BigDecimal."
                },
                {
                  "signature": "public static BigDecimal valueOf(long val)",
                  "description": "Translates a long value into a BigDecimal\n with a scale of zero."
                },
                {
                  "signature": "public static BigDecimal valueOf(double val)",
                  "description": "Translates a double into a BigDecimal, using\n the double's canonical string representation provided\n by the Double.toString(double) method."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public BigDecimal add(BigDecimal augend)",
                  "description": "Returns a BigDecimal whose value is (this +\n augend), and whose scale is max(this.scale(),\n augend.scale())."
                },
                {
                  "signature": "public BigDecimal add(BigDecimal augend, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this + augend),\n with rounding according to the context settings.\n\n If either number is zero and the precision setting is nonzero then\n the other number, rounded if necessary, is used as the result."
                }
              ]
            },
            {
              "name": "subtract",
              "overloads": [
                {
                  "signature": "public BigDecimal subtract(BigDecimal subtrahend)",
                  "description": "Returns a BigDecimal whose value is (this -\n subtrahend), and whose scale is max(this.scale(),\n subtrahend.scale())."
                },
                {
                  "signature": "public BigDecimal subtract(BigDecimal subtrahend, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this - subtrahend),\n with rounding according to the context settings.\n\n If subtrahend is zero then this, rounded if necessary, is used as the\n result.  If this is zero then the result is subtrahend.negate(mc)."
                }
              ]
            },
            {
              "name": "multiply",
              "overloads": [
                {
                  "signature": "public BigDecimal multiply(BigDecimal multiplicand)",
                  "description": "Returns a BigDecimal whose value is (this \n multiplicand), and whose scale is (this.scale() +\n multiplicand.scale())."
                },
                {
                  "signature": "public BigDecimal multiply(BigDecimal multiplicand, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this \n multiplicand), with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "divide",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied."
                },
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal divide(BigDecimal divisor, int roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied."
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose preferred scale is (this.scale() -\n divisor.scale()); if the exact quotient cannot be\n represented (because it has a non-terminating decimal\n expansion) an ArithmeticException is thrown."
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "divideToIntegralValue",
              "overloads": [
                {
                  "signature": "public BigDecimal divideToIntegralValue(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is the integer part\n of the quotient (this / divisor) rounded down.  The\n preferred scale of the result is (this.scale() -\n divisor.scale())."
                },
                {
                  "signature": "public BigDecimal divideToIntegralValue(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is the integer part\n of (this / divisor).  Since the integer part of the\n exact quotient does not depend on the rounding mode, the\n rounding mode does not affect the values returned by this\n method.  The preferred scale of the result is\n (this.scale() - divisor.scale()).  An\n ArithmeticException is thrown if the integer part of\n the exact quotient needs more than mc.precision\n digits."
                }
              ]
            },
            {
              "name": "remainder",
              "overloads": [
                {
                  "signature": "public BigDecimal remainder(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is (this % divisor).\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor).multiply(divisor)).\n Note that this is not the modulo operation (the result can be\n negative)."
                },
                {
                  "signature": "public BigDecimal remainder(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this %\n divisor), with rounding according to the context settings.\n The MathContext settings affect the implicit divide\n used to compute the remainder.  The remainder computation\n itself is by definition exact.  Therefore, the remainder may\n contain more than mc.getPrecision() digits.\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor,\n mc).multiply(divisor)).  Note that this is not the modulo\n operation (the result can be negative)."
                }
              ]
            },
            {
              "name": "divideAndRemainder",
              "overloads": [
                {
                  "signature": "public BigDecimal[] divideAndRemainder(BigDecimal divisor)",
                  "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."
                },
                {
                  "signature": "public BigDecimal[] divideAndRemainder(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands calculated with rounding\n according to the context settings.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public BigDecimal sqrt(MathContext mc)",
                  "description": "Returns an approximation to the square root of this\n with rounding according to the context settings.\n\n The preferred scale of the returned result is equal to\n this.scale()/2. The value of the returned result is\n always within one ulp of the exact decimal value for the\n precision in question.  If the rounding mode is HALF_UP, HALF_DOWN, or HALF_EVEN, the\n result is within one half an ulp of the exact decimal value.\n\n Special case:\n \n  The square root of a number numerically equal to \n ZERO is numerically equal to ZERO with a preferred\n scale according to the general rule above. In particular, for\n ZERO, ZERO.sqrt(mc).equals(ZERO) is true with\n any MathContext as an argument."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public BigDecimal pow(int n)",
                  "description": "Returns a BigDecimal whose value is\n (thisn), The power is computed exactly, to\n unlimited precision.\n\n The parameter n must be in the range 0 through\n 999999999, inclusive.  ZERO.pow(0) returns ONE.\n\n Note that future releases may expand the allowable exponent\n range of this method."
                },
                {
                  "signature": "public BigDecimal pow(int n, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is\n (thisn).  The current implementation uses\n the core algorithm defined in ANSI standard X3.274-1996 with\n rounding according to the context settings.  In general, the\n returned numerical value is within two ulps of the exact\n numerical value for the chosen precision.  Note that future\n releases may use a different algorithm with a decreased\n allowable error bound and increased allowable exponent range.\n\n The X3.274-1996 algorithm is:\n\n \n  An ArithmeticException exception is thrown if\n  \n    abs(n) > 999999999\n    mc.precision == 0 and n < 0\n    mc.precision > 0 and n has more than\n    mc.precision decimal digits\n  \n\n  if n is zero, ONE is returned even if\n this is zero, otherwise\n \n    if n is positive, the result is calculated via\n   the repeated squaring technique into a single accumulator.\n   The individual multiplications with the accumulator use the\n   same math context settings as in mc except for a\n   precision increased to mc.precision + elength + 1\n   where elength is the number of decimal digits in\n   n.\n\n    if n is negative, the result is calculated as if\n   n were positive; this value is then divided into one\n   using the working precision specified above.\n\n    The final value from either the positive or negative case\n   is then rounded to the destination precision."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public BigDecimal abs()",
                  "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, and whose scale is\n this.scale()."
                },
                {
                  "signature": "public BigDecimal abs(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, with rounding according to the\n context settings."
                }
              ]
            },
            {
              "name": "negate",
              "overloads": [
                {
                  "signature": "public BigDecimal negate()",
                  "description": "Returns a BigDecimal whose value is (-this),\n and whose scale is this.scale()."
                },
                {
                  "signature": "public BigDecimal negate(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (-this),\n with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public BigDecimal plus()",
                  "description": "Returns a BigDecimal whose value is (+this), and whose\n scale is this.scale().\n\n This method, which simply returns this BigDecimal\n is included for symmetry with the unary minus method negate()."
                },
                {
                  "signature": "public BigDecimal plus(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (+this),\n with rounding according to the context settings.\n\n The effect of this method is identical to that of the round(MathContext) method."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public int signum()",
                  "description": "Returns the signum function of this BigDecimal."
                }
              ]
            },
            {
              "name": "scale",
              "overloads": [
                {
                  "signature": "public int scale()",
                  "description": "Returns the scale of this BigDecimal.  If zero\n or positive, the scale is the number of digits to the right of\n the decimal point.  If negative, the unscaled value of the\n number is multiplied by ten to the power of the negation of the\n scale.  For example, a scale of -3 means the unscaled\n value is multiplied by 1000."
                }
              ]
            },
            {
              "name": "precision",
              "overloads": [
                {
                  "signature": "public int precision()",
                  "description": "Returns the precision of this BigDecimal.  (The\n precision is the number of digits in the unscaled value.)\n\n The precision of a zero value is 1."
                }
              ]
            },
            {
              "name": "unscaledValue",
              "overloads": [
                {
                  "signature": "public BigInteger unscaledValue()",
                  "description": "Returns a BigInteger whose value is the unscaled\n value of this BigDecimal.  (Computes (this *\n 10this.scale()).)"
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public BigDecimal round(MathContext mc)",
                  "description": "Returns a BigDecimal rounded according to the\n MathContext settings.  If the precision setting is 0 then\n no rounding takes place.\n\n The effect of this method is identical to that of the\n plus(MathContext) method."
                }
              ]
            },
            {
              "name": "setScale",
              "overloads": [
                {
                  "signature": "public BigDecimal setScale(int newScale, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division."
                },
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal setScale(int newScale, int roundingMode)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal setScale(int newScale)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose value is numerically equal to this\n BigDecimal's.  Throws an ArithmeticException\n if this is not possible.\n\n This call is typically used to increase the scale, in which\n case it is guaranteed that there exists a BigDecimal\n of the specified scale and the correct value.  The call can\n also be used to reduce the scale if the caller knows that the\n BigDecimal has sufficiently many zeros at the end of\n its fractional part (i.e., factors of ten in its integer value)\n to allow for the rescaling without changing its value.\n\n This method returns the same result as the two-argument\n versions of setScale, but saves the caller the trouble\n of specifying a rounding mode in cases where it is irrelevant."
                }
              ]
            },
            {
              "name": "movePointLeft",
              "overloads": [
                {
                  "signature": "public BigDecimal movePointLeft(int n)",
                  "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the left.  If\n n is non-negative, the call merely adds n to\n the scale.  If n is negative, the call is equivalent\n to movePointRight(-n).  The BigDecimal\n returned by this call has value (this \n 10-n) and scale max(this.scale()+n,\n 0)."
                }
              ]
            },
            {
              "name": "movePointRight",
              "overloads": [
                {
                  "signature": "public BigDecimal movePointRight(int n)",
                  "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the right.\n If n is non-negative, the call merely subtracts\n n from the scale.  If n is negative, the call\n is equivalent to movePointLeft(-n).  The\n BigDecimal returned by this call has value (this\n  10n) and scale max(this.scale()-n,\n 0)."
                }
              ]
            },
            {
              "name": "scaleByPowerOfTen",
              "overloads": [
                {
                  "signature": "public BigDecimal scaleByPowerOfTen(int n)",
                  "description": "Returns a BigDecimal whose numerical value is equal to\n (this * 10n).  The scale of\n the result is (this.scale() - n)."
                }
              ]
            },
            {
              "name": "stripTrailingZeros",
              "overloads": [
                {
                  "signature": "public BigDecimal stripTrailingZeros()",
                  "description": "Returns a BigDecimal which is numerically equal to\n this one but with any trailing zeros removed from the\n representation.  For example, stripping the trailing zeros from\n the BigDecimal value 600.0, which has\n [BigInteger, scale] components equal to\n [6000, 1], yields 6E2 with [BigInteger,\n scale] components equal to [6, -2].  If\n this BigDecimal is numerically equal to zero, then\n BigDecimal.ZERO is returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(BigDecimal val)",
                  "description": "Compares this BigDecimal numerically with the specified\n BigDecimal.  Two BigDecimal objects that are\n equal in value but have a different scale (like 2.0 and 2.00)\n are considered equal by this method. Such values are in the\n same cohort.\n\n This method is provided in preference to individual methods for\n each of the six boolean comparison operators (<, ==,\n >, >=, !=, <=).  The suggested\n idiom for performing these comparisons is: \n (x.compareTo(y) <op> 0), where\n <op> is one of the six comparison operators."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this BigDecimal with the specified \n Object for equality.  Unlike compareTo, this method considers two BigDecimal\n objects equal only if they are equal in value and\n scale. Therefore 2.0 is not equal to 2.00 when compared by this\n method since the former has [BigInteger, scale]\n components equal to [20, 1] while the latter has components\n equal to [200, 2]."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public BigDecimal min(BigDecimal val)",
                  "description": "Returns the minimum of this BigDecimal and\n val."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public BigDecimal max(BigDecimal val)",
                  "description": "Returns the maximum of this BigDecimal and val."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this BigDecimal.\n The hash code is computed as a function of the unscaled value and the scale of this BigDecimal."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this BigDecimal,\n using scientific notation if an exponent is needed.\n\n A standard canonical string form of the BigDecimal\n is created as though by the following steps: first, the\n absolute value of the unscaled value of the BigDecimal\n is converted to a string in base ten using the characters\n '0' through '9' with no leading zeros (except\n if its value is zero, in which case a single '0'\n character is used).\n\n Next, an adjusted exponent is calculated; this is the\n negated scale, plus the number of characters in the converted\n unscaled value, less one.  That is,\n -scale+(ulength-1), where ulength is the\n length of the absolute value of the unscaled value in decimal\n digits (its precision).\n\n If the scale is greater than or equal to zero and the\n adjusted exponent is greater than or equal to -6, the\n number will be converted to a character form without using\n exponential notation.  In this case, if the scale is zero then\n no decimal point is added and if the scale is positive a\n decimal point will be inserted with the scale specifying the\n number of characters to the right of the decimal point.\n '0' characters are added to the left of the converted\n unscaled value as necessary.  If no character precedes the\n decimal point after this insertion then a conventional\n '0' character is prefixed.\n\n Otherwise (that is, if the scale is negative, or the\n adjusted exponent is less than -6), the number will be\n converted to a character form using exponential notation.  In\n this case, if the converted BigInteger has more than\n one digit a decimal point is inserted after the first digit.\n An exponent in character form is then suffixed to the converted\n unscaled value (perhaps with inserted decimal point); this\n comprises the letter 'E' followed immediately by the\n adjusted exponent converted to a character form.  The latter is\n in base ten, using the characters '0' through\n '9' with no leading zeros, and is always prefixed by a\n sign character '-' ('\\u002D') if the\n adjusted exponent is negative, '+'\n ('\\u002B') otherwise).\n\n Finally, the entire string is prefixed by a minus sign\n character '-' ('\\u002D') if the unscaled\n value is less than zero.  No sign character is prefixed if the\n unscaled value is zero or positive.\n\n Examples:\n For each representation [unscaled value, scale]\n on the left, the resulting string is shown on the right.\n  [123,0]      \"123\"\n [-123,0]     \"-123\"\n [123,-1]     \"1.23E+3\"\n [123,-3]     \"1.23E+5\"\n [123,1]      \"12.3\"\n [123,5]      \"0.00123\"\n [123,10]     \"1.23E-8\"\n [-123,12]    \"-1.23E-10\"\n \n\n Notes:\n \n\n There is a one-to-one mapping between the distinguishable\n BigDecimal values and the result of this conversion.\n That is, every distinguishable BigDecimal value\n (unscaled value and scale) has a unique string representation\n as a result of using toString.  If that string\n representation is converted back to a BigDecimal using\n the BigDecimal(String) constructor, then the original\n value will be recovered.\n\n The string produced for a given number is always the same;\n it is not affected by locale.  This means that it can be used\n as a canonical string representation for exchanging decimal\n data, or as a key for a Hashtable, etc.  Locale-sensitive\n number formatting and parsing is handled by the NumberFormat class and its subclasses.\n\n The toEngineeringString() method may be used for\n presenting numbers with exponents in engineering notation, and the\n setScale method may be used for\n rounding a BigDecimal so it has a known number of digits after\n the decimal point.\n\n The digit-to-character mapping provided by\n Character.forDigit is used."
                }
              ]
            },
            {
              "name": "toEngineeringString",
              "overloads": [
                {
                  "signature": "public String toEngineeringString()",
                  "description": "Returns a string representation of this BigDecimal,\n using engineering notation if an exponent is needed.\n\n Returns a string that represents the BigDecimal as\n described in the toString() method, except that if\n exponential notation is used, the power of ten is adjusted to\n be a multiple of three (engineering notation) such that the\n integer part of nonzero values will be in the range 1 through\n 999.  If exponential notation is used for zero values, a\n decimal point and one or two fractional zero digits are used so\n that the scale of the zero value is preserved.  Note that\n unlike the output of toString(), the output of this\n method is not guaranteed to recover the same [integer,\n scale] pair of this BigDecimal if the output string is\n converting back to a BigDecimal using the string constructor.  The result of this method meets\n the weaker constraint of always producing a numerically equal\n result from applying the string constructor to the method's output."
                }
              ]
            },
            {
              "name": "toPlainString",
              "overloads": [
                {
                  "signature": "public String toPlainString()",
                  "description": "Returns a string representation of this BigDecimal\n without an exponent field.  For values with a positive scale,\n the number of digits to the right of the decimal point is used\n to indicate scale.  For values with a zero or negative scale,\n the resulting string is generated as if the value were\n converted to a numerically equal value with zero scale and as\n if all the trailing zeros of the zero scale value were present\n in the result.\n\n The entire string is prefixed by a minus sign character '-'\n ('\\u002D') if the unscaled value is less than\n zero. No sign character is prefixed if the unscaled value is\n zero or positive.\n\n Note that if the result of this method is passed to the\n string constructor, only the\n numerical value of this BigDecimal will necessarily be\n recovered; the representation of the new BigDecimal\n may have a different scale.  In particular, if this\n BigDecimal has a negative scale, the string resulting\n from this method will have a scale of zero when processed by\n the string constructor.\n\n (This method behaves analogously to the toString\n method in 1.4 and earlier releases.)"
                }
              ]
            },
            {
              "name": "toBigInteger",
              "overloads": [
                {
                  "signature": "public BigInteger toBigInteger()",
                  "description": "Converts this BigDecimal to a BigInteger.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n long as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded.  Note that this\n conversion can lose information about the precision of the\n BigDecimal value.\n \n To have an exception thrown if the conversion is inexact (in\n other words if a nonzero fractional part is discarded), use the\n toBigIntegerExact() method."
                }
              ]
            },
            {
              "name": "toBigIntegerExact",
              "overloads": [
                {
                  "signature": "public BigInteger toBigIntegerExact()",
                  "description": "Converts this BigDecimal to a BigInteger,\n checking for lost information.  An exception is thrown if this\n BigDecimal has a nonzero fractional part."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Converts this BigDecimal to a long.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in a\n long, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal value as well\n as return a result with the opposite sign."
                }
              ]
            },
            {
              "name": "longValueExact",
              "overloads": [
                {
                  "signature": "public long longValueExact()",
                  "description": "Converts this BigDecimal to a long, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n long result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Converts this BigDecimal to an int.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in an\n int, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal\n value as well as return a result with the opposite sign."
                }
              ]
            },
            {
              "name": "intValueExact",
              "overloads": [
                {
                  "signature": "public int intValueExact()",
                  "description": "Converts this BigDecimal to an int, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for an\n int result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "shortValueExact",
              "overloads": [
                {
                  "signature": "public short shortValueExact()",
                  "description": "Converts this BigDecimal to a short, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n short result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "byteValueExact",
              "overloads": [
                {
                  "signature": "public byte byteValueExact()",
                  "description": "Converts this BigDecimal to a byte, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n byte result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Converts this BigDecimal to a float.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigDecimal has too great a\n magnitude to represent as a float, it will be\n converted to Float.NEGATIVE_INFINITY or Float.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Converts this BigDecimal to a double.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigDecimal has too great a\n magnitude represent as a double, it will be\n converted to Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public BigDecimal ulp()",
                  "description": "Returns the size of an ulp, a unit in the last place, of this\n BigDecimal.  An ulp of a nonzero BigDecimal\n value is the positive distance between this value and the\n BigDecimal value next larger in magnitude with the\n same number of digits.  An ulp of a zero value is numerically\n equal to 1 with the scale of this.  The result is\n stored with the same scale as this so the result\n for zero and nonzero values is equal to [1,\n this.scale()]."
                }
              ]
            }
          ]
        },
        {
          "name": "BigInteger",
          "methods": [
            {
              "name": "BigInteger",
              "overloads": [
                {
                  "signature": "public BigInteger(byte[] val, int off, int len)",
                  "description": "Translates a byte sub-array containing the two's-complement binary\n representation of a BigInteger into a BigInteger.  The sub-array is\n specified via an offset into the array and a length.  The sub-array is\n assumed to be in big-endian byte-order: the most significant\n byte is the element at index off.  The val array is\n assumed to be unchanged for the duration of the constructor call.\n\n An IndexOutOfBoundsException is thrown if the length of the array\n val is non-zero and either off is negative, len\n is negative, or off+len is greater than the length of\n val."
                },
                {
                  "signature": "public BigInteger(byte[] val)",
                  "description": "Translates a byte array containing the two's-complement binary\n representation of a BigInteger into a BigInteger.  The input array is\n assumed to be in big-endian byte-order: the most significant\n byte is in the zeroth element.  The val array is assumed to be\n unchanged for the duration of the constructor call."
                },
                {
                  "signature": "public BigInteger(int signum, byte[] magnitude, int off, int len)",
                  "description": "Translates the sign-magnitude representation of a BigInteger into a\n BigInteger.  The sign is represented as an integer signum value: -1 for\n negative, 0 for zero, or 1 for positive.  The magnitude is a sub-array of\n a byte array in big-endian byte-order: the most significant byte\n is the element at index off.  A zero value of the length\n len is permissible, and will result in a BigInteger value of 0,\n whether signum is -1, 0 or 1.  The magnitude array is assumed to\n be unchanged for the duration of the constructor call.\n\n An IndexOutOfBoundsException is thrown if the length of the array\n magnitude is non-zero and either off is negative,\n len is negative, or off+len is greater than the length of\n magnitude."
                },
                {
                  "signature": "public BigInteger(int signum, byte[] magnitude)",
                  "description": "Translates the sign-magnitude representation of a BigInteger into a\n BigInteger.  The sign is represented as an integer signum value: -1 for\n negative, 0 for zero, or 1 for positive.  The magnitude is a byte array\n in big-endian byte-order: the most significant byte is the\n zeroth element.  A zero-length magnitude array is permissible, and will\n result in a BigInteger value of 0, whether signum is -1, 0 or 1.  The\n magnitude array is assumed to be unchanged for the duration of\n the constructor call."
                },
                {
                  "signature": "public BigInteger(String val, int radix)",
                  "description": "Translates the String representation of a BigInteger in the\n specified radix into a BigInteger.  The String representation\n consists of an optional minus or plus sign followed by a\n sequence of one or more digits in the specified radix.  The\n character-to-digit mapping is provided by Character.digit.  The String may\n not contain any extraneous characters (whitespace, for\n example)."
                },
                {
                  "signature": "public BigInteger(String val)",
                  "description": "Translates the decimal String representation of a BigInteger\n into a BigInteger.  The String representation consists of an\n optional minus or plus sign followed by a sequence of one or\n more decimal digits.  The character-to-digit mapping is\n provided by Character.digit.  The String may not contain any extraneous\n characters (whitespace, for example)."
                },
                {
                  "signature": "public BigInteger(int numBits, Random rnd)",
                  "description": "Constructs a randomly generated BigInteger, uniformly distributed over\n the range 0 to (2numBits - 1), inclusive.\n The uniformity of the distribution assumes that a fair source of random\n bits is provided in rnd.  Note that this constructor always\n constructs a non-negative BigInteger."
                },
                {
                  "signature": "public BigInteger(int bitLength, int certainty, Random rnd)",
                  "description": "Constructs a randomly generated positive BigInteger that is probably\n prime, with the specified bitLength."
                }
              ]
            },
            {
              "name": "probablePrime",
              "overloads": [
                {
                  "signature": "public static BigInteger probablePrime(int bitLength, Random rnd)",
                  "description": "Returns a positive BigInteger that is probably prime, with the\n specified bitLength. The probability that a BigInteger returned\n by this method is composite does not exceed 2-100."
                }
              ]
            },
            {
              "name": "nextProbablePrime",
              "overloads": [
                {
                  "signature": "public BigInteger nextProbablePrime()",
                  "description": "Returns the first integer greater than this BigInteger that\n is probably prime.  The probability that the number returned by this\n method is composite does not exceed 2-100. This method will\n never skip over a prime when searching: if it returns p, there\n is no prime q such that this < q < p."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static BigInteger valueOf(long val)",
                  "description": "Returns a BigInteger whose value is equal to that of the\n specified long."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public BigInteger add(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this + val)."
                }
              ]
            },
            {
              "name": "subtract",
              "overloads": [
                {
                  "signature": "public BigInteger subtract(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this - val)."
                }
              ]
            },
            {
              "name": "multiply",
              "overloads": [
                {
                  "signature": "public BigInteger multiply(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this * val)."
                }
              ]
            },
            {
              "name": "divide",
              "overloads": [
                {
                  "signature": "public BigInteger divide(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this / val)."
                }
              ]
            },
            {
              "name": "divideAndRemainder",
              "overloads": [
                {
                  "signature": "public BigInteger[] divideAndRemainder(BigInteger val)",
                  "description": "Returns an array of two BigIntegers containing (this / val)\n followed by (this % val)."
                }
              ]
            },
            {
              "name": "remainder",
              "overloads": [
                {
                  "signature": "public BigInteger remainder(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this % val)."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public BigInteger pow(int exponent)",
                  "description": "Returns a BigInteger whose value is (thisexponent).\n Note that exponent is an integer rather than a BigInteger."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public BigInteger sqrt()",
                  "description": "Returns the integer square root of this BigInteger.  The integer square\n root of the corresponding mathematical integer n is the largest\n mathematical integer s such that s*s <= n.  It is equal\n to the value of floor(sqrt(n)), where sqrt(n) denotes the\n real square root of n treated as a real.  Note that the integer\n square root will be less than the real square root if the latter is not\n representable as an integral value."
                }
              ]
            },
            {
              "name": "sqrtAndRemainder",
              "overloads": [
                {
                  "signature": "public BigInteger[] sqrtAndRemainder()",
                  "description": "Returns an array of two BigIntegers containing the integer square root\n s of this and its remainder this - s*s,\n respectively."
                }
              ]
            },
            {
              "name": "gcd",
              "overloads": [
                {
                  "signature": "public BigInteger gcd(BigInteger val)",
                  "description": "Returns a BigInteger whose value is the greatest common divisor of\n abs(this) and abs(val).  Returns 0 if\n this == 0 && val == 0."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public BigInteger abs()",
                  "description": "Returns a BigInteger whose value is the absolute value of this\n BigInteger."
                }
              ]
            },
            {
              "name": "negate",
              "overloads": [
                {
                  "signature": "public BigInteger negate()",
                  "description": "Returns a BigInteger whose value is (-this)."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public int signum()",
                  "description": "Returns the signum function of this BigInteger."
                }
              ]
            },
            {
              "name": "mod",
              "overloads": [
                {
                  "signature": "public BigInteger mod(BigInteger m)",
                  "description": "Returns a BigInteger whose value is (this mod m).  This method\n differs from remainder in that it always returns a\n non-negative BigInteger."
                }
              ]
            },
            {
              "name": "modPow",
              "overloads": [
                {
                  "signature": "public BigInteger modPow(BigInteger exponent, BigInteger m)",
                  "description": "Returns a BigInteger whose value is\n (thisexponent mod m).  (Unlike pow, this\n method permits negative exponents.)"
                }
              ]
            },
            {
              "name": "modInverse",
              "overloads": [
                {
                  "signature": "public BigInteger modInverse(BigInteger m)",
                  "description": "Returns a BigInteger whose value is (this-1 mod m)."
                }
              ]
            },
            {
              "name": "shiftLeft",
              "overloads": [
                {
                  "signature": "public BigInteger shiftLeft(int n)",
                  "description": "Returns a BigInteger whose value is (this << n).\n The shift distance, n, may be negative, in which case\n this method performs a right shift.\n (Computes floor(this * 2n).)"
                }
              ]
            },
            {
              "name": "shiftRight",
              "overloads": [
                {
                  "signature": "public BigInteger shiftRight(int n)",
                  "description": "Returns a BigInteger whose value is (this >> n).  Sign\n extension is performed.  The shift distance, n, may be\n negative, in which case this method performs a left shift.\n (Computes floor(this / 2n).)"
                }
              ]
            },
            {
              "name": "and",
              "overloads": [
                {
                  "signature": "public BigInteger and(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this & val).  (This\n method returns a negative BigInteger if and only if this and val are\n both negative.)"
                }
              ]
            },
            {
              "name": "or",
              "overloads": [
                {
                  "signature": "public BigInteger or(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this | val).  (This method\n returns a negative BigInteger if and only if either this or val is\n negative.)"
                }
              ]
            },
            {
              "name": "xor",
              "overloads": [
                {
                  "signature": "public BigInteger xor(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this ^ val).  (This method\n returns a negative BigInteger if and only if exactly one of this and\n val are negative.)"
                }
              ]
            },
            {
              "name": "not",
              "overloads": [
                {
                  "signature": "public BigInteger not()",
                  "description": "Returns a BigInteger whose value is (~this).  (This method\n returns a negative value if and only if this BigInteger is\n non-negative.)"
                }
              ]
            },
            {
              "name": "andNot",
              "overloads": [
                {
                  "signature": "public BigInteger andNot(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this & ~val).  This\n method, which is equivalent to and(val.not()), is provided as\n a convenience for masking operations.  (This method returns a negative\n BigInteger if and only if this is negative and val is\n positive.)"
                }
              ]
            },
            {
              "name": "testBit",
              "overloads": [
                {
                  "signature": "public boolean testBit(int n)",
                  "description": "Returns true if and only if the designated bit is set.\n (Computes ((this & (1<<n)) != 0).)"
                }
              ]
            },
            {
              "name": "setBit",
              "overloads": [
                {
                  "signature": "public BigInteger setBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit set.  (Computes (this | (1<<n)).)"
                }
              ]
            },
            {
              "name": "clearBit",
              "overloads": [
                {
                  "signature": "public BigInteger clearBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit cleared.\n (Computes (this & ~(1<<n)).)"
                }
              ]
            },
            {
              "name": "flipBit",
              "overloads": [
                {
                  "signature": "public BigInteger flipBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit flipped.\n (Computes (this ^ (1<<n)).)"
                }
              ]
            },
            {
              "name": "getLowestSetBit",
              "overloads": [
                {
                  "signature": "public int getLowestSetBit()",
                  "description": "Returns the index of the rightmost (lowest-order) one bit in this\n BigInteger (the number of zero bits to the right of the rightmost\n one bit).  Returns -1 if this BigInteger contains no one bits.\n (Computes (this == 0? -1 : log2(this & -this)).)"
                }
              ]
            },
            {
              "name": "bitLength",
              "overloads": [
                {
                  "signature": "public int bitLength()",
                  "description": "Returns the number of bits in the minimal two's-complement\n representation of this BigInteger, excluding a sign bit.\n For positive BigIntegers, this is equivalent to the number of bits in\n the ordinary binary representation.  For zero this method returns\n 0.  (Computes (ceil(log2(this < 0 ? -this : this+1))).)"
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public int bitCount()",
                  "description": "Returns the number of bits in the two's complement representation\n of this BigInteger that differ from its sign bit.  This method is\n useful when implementing bit-vector style sets atop BigIntegers."
                }
              ]
            },
            {
              "name": "isProbablePrime",
              "overloads": [
                {
                  "signature": "public boolean isProbablePrime(int certainty)",
                  "description": "Returns true if this BigInteger is probably prime,\n false if it's definitely composite.  If\n certainty is  0, true is\n returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(BigInteger val)",
                  "description": "Compares this BigInteger with the specified BigInteger.  This\n method is provided in preference to individual methods for each\n of the six boolean comparison operators (<, ==,\n >, >=, !=, <=).  The suggested\n idiom for performing these comparisons is: \n (x.compareTo(y) <op> 0), where\n <op> is one of the six comparison operators."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this BigInteger with the specified Object for equality."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public BigInteger min(BigInteger val)",
                  "description": "Returns the minimum of this BigInteger and val."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public BigInteger max(BigInteger val)",
                  "description": "Returns the maximum of this BigInteger and val."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this BigInteger."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString(int radix)",
                  "description": "Returns the String representation of this BigInteger in the\n given radix.  If the radix is outside the range from Character.MIN_RADIX to Character.MAX_RADIX inclusive,\n it will default to 10 (as is the case for\n Integer.toString).  The digit-to-character mapping\n provided by Character.forDigit is used, and a minus\n sign is prepended if appropriate.  (This representation is\n compatible with the (String,\n int) constructor.)"
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns the decimal String representation of this BigInteger.\n The digit-to-character mapping provided by\n Character.forDigit is used, and a minus sign is\n prepended if appropriate.  (This representation is compatible\n with the (String) constructor, and\n allows for String concatenation with Java's + operator.)"
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public byte[] toByteArray()",
                  "description": "Returns a byte array containing the two's-complement\n representation of this BigInteger.  The byte array will be in\n big-endian byte-order: the most significant byte is in\n the zeroth element.  The array will contain the minimum number\n of bytes required to represent this BigInteger, including at\n least one sign bit, which is (ceil((this.bitLength() +\n 1)/8)).  (This representation is compatible with the\n (byte[]) constructor.)"
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Converts this BigInteger to an int.  This\n conversion is analogous to a\n narrowing primitive conversion from long to\n int as defined in\n The Java Language Specification:\n if this BigInteger is too big to fit in an\n int, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude of the BigInteger value as well as return a\n result with the opposite sign."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Converts this BigInteger to a long.  This\n conversion is analogous to a\n narrowing primitive conversion from long to\n int as defined in\n The Java Language Specification:\n if this BigInteger is too big to fit in a\n long, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude of the BigInteger value as well as return a\n result with the opposite sign."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Converts this BigInteger to a float.  This\n conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigInteger has too great a magnitude\n to represent as a float, it will be converted to\n Float.NEGATIVE_INFINITY or Float.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigInteger value."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Converts this BigInteger to a double.  This\n conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigInteger has too great a magnitude\n to represent as a double, it will be converted to\n Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigInteger value."
                }
              ]
            },
            {
              "name": "longValueExact",
              "overloads": [
                {
                  "signature": "public long longValueExact()",
                  "description": "Converts this BigInteger to a long, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the long type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "intValueExact",
              "overloads": [
                {
                  "signature": "public int intValueExact()",
                  "description": "Converts this BigInteger to an int, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the int type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "shortValueExact",
              "overloads": [
                {
                  "signature": "public short shortValueExact()",
                  "description": "Converts this BigInteger to a short, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the short type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "byteValueExact",
              "overloads": [
                {
                  "signature": "public byte byteValueExact()",
                  "description": "Converts this BigInteger to a byte, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the byte type, then an\n ArithmeticException is thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static RoundingMode[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static RoundingMode valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                },
                {
                  "signature": "public static RoundingMode valueOf(int rm)",
                  "description": "Returns the RoundingMode object corresponding to a\n legacy integer rounding mode constant in BigDecimal."
                }
              ]
            }
          ]
        },
        {
          "name": "MathContext",
          "methods": [
            {
              "name": "MathContext",
              "overloads": [
                {
                  "signature": "public MathContext(int setPrecision)",
                  "description": "Constructs a new MathContext with the specified\n precision and the HALF_UP rounding\n mode."
                },
                {
                  "signature": "public MathContext(int setPrecision, RoundingMode setRoundingMode)",
                  "description": "Constructs a new MathContext with a specified\n precision and rounding mode."
                },
                {
                  "signature": "public MathContext(String val)",
                  "description": "Constructs a new MathContext from a string.\n\n The string must be in the same format as that produced by the\n toString() method.\n\n An IllegalArgumentException is thrown if the precision\n section of the string is out of range (< 0) or the string is\n not in the format created by the toString() method."
                }
              ]
            },
            {
              "name": "getPrecision",
              "overloads": [
                {
                  "signature": "public int getPrecision()",
                  "description": "Returns the precision setting.\n This value is always non-negative."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Returns the roundingMode setting.\n This will be one of\n RoundingMode.CEILING,\n RoundingMode.DOWN,\n RoundingMode.FLOOR,\n RoundingMode.HALF_DOWN,\n RoundingMode.HALF_EVEN,\n RoundingMode.HALF_UP,\n RoundingMode.UNNECESSARY, or\n RoundingMode.UP."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this MathContext with the specified\n Object for equality."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this MathContext."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this MathContext.\n The String returned represents the settings of the\n MathContext object as two space-delimited words\n (separated by a single space character, '\\u0020',\n and with no leading or trailing white space), as follows:\n \n \n The string \"precision=\", immediately followed\n by the value of the precision setting as a numeric string as if\n generated by the Integer.toString\n method.\n\n \n The string \"roundingMode=\", immediately\n followed by the value of the roundingMode setting as a\n word.  This word will be the same as the name of the\n corresponding public constant in the RoundingMode\n enum.\n \n \n For example:\n  precision=9 roundingMode=HALF_UP\n \n\n Additional words may be appended to the result of\n toString in the future if more properties are added to\n this class."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.net",
      "description": "Networking classes",
      "classes": [
        {
          "name": "Authenticator",
          "methods": [
            {
              "name": "Authenticator",
              "overloads": [
                {
                  "signature": "public Authenticator()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(Authenticator a)",
                  "description": "Sets the authenticator that will be used by the networking code\n when a proxy or an HTTP server asks for authentication.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"setDefaultAuthenticator\") permission.\n This may result in a java.lang.SecurityException."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static Authenticator getDefault()",
                  "description": "Gets the default authenticator.\n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException.\n Then the default authenticator, if set, is returned.\n Otherwise, null is returned."
                }
              ]
            },
            {
              "name": "requestPasswordAuthentication",
              "overloads": [
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(InetAddress addr, int port, String protocol, String prompt, String scheme)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(String host, InetAddress addr, int port, String protocol, String prompt, String scheme)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password. This is the preferred method for requesting a password\n because the hostname can be provided in cases where the InetAddress\n is not available.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(Authenticator authenticator, String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask the given authenticator for a password. If the given\n authenticator is null, the authenticator, if any, that has been\n registered with the system using setDefault is used.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                }
              ]
            },
            {
              "name": "requestPasswordAuthenticationInstance",
              "overloads": [
                {
                  "signature": "public PasswordAuthentication requestPasswordAuthenticationInstance(String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask this authenticator for a password."
                }
              ]
            },
            {
              "name": "getRequestingHost",
              "overloads": [
                {
                  "signature": "protected final String getRequestingHost()",
                  "description": "Gets the hostname of the\n site or proxy requesting authentication, or null\n if not available."
                }
              ]
            },
            {
              "name": "getRequestingSite",
              "overloads": [
                {
                  "signature": "protected final InetAddress getRequestingSite()",
                  "description": "Gets the InetAddress of the\n site requesting authorization, or null\n if not available."
                }
              ]
            },
            {
              "name": "getRequestingPort",
              "overloads": [
                {
                  "signature": "protected final int getRequestingPort()",
                  "description": "Gets the port number for the requested connection."
                }
              ]
            },
            {
              "name": "getRequestingProtocol",
              "overloads": [
                {
                  "signature": "protected final String getRequestingProtocol()",
                  "description": "Give the protocol that's requesting the connection.  Often this\n will be based on a URL, but in a future JDK it could be, for\n example, \"SOCKS\" for a password-protected SOCKS5 firewall."
                }
              ]
            },
            {
              "name": "getRequestingPrompt",
              "overloads": [
                {
                  "signature": "protected final String getRequestingPrompt()",
                  "description": "Gets the prompt string given by the requestor."
                }
              ]
            },
            {
              "name": "getRequestingScheme",
              "overloads": [
                {
                  "signature": "protected final String getRequestingScheme()",
                  "description": "Gets the scheme of the requestor (the HTTP scheme\n for an HTTP firewall, for example)."
                }
              ]
            },
            {
              "name": "getPasswordAuthentication",
              "overloads": [
                {
                  "signature": "protected PasswordAuthentication getPasswordAuthentication()",
                  "description": "Called when password authorization is needed.  Subclasses should\n override the default implementation, which returns null."
                }
              ]
            },
            {
              "name": "getRequestingURL",
              "overloads": [
                {
                  "signature": "protected URL getRequestingURL()",
                  "description": "Returns the URL that resulted in this\n request for authentication."
                }
              ]
            },
            {
              "name": "getRequestorType",
              "overloads": [
                {
                  "signature": "protected Authenticator.RequestorType getRequestorType()",
                  "description": "Returns whether the requestor is a Proxy or a Server."
                }
              ]
            }
          ]
        },
        {
          "name": "BindException",
          "methods": [
            {
              "name": "BindException",
              "overloads": [
                {
                  "signature": "public BindException(String msg)",
                  "description": "Constructs a new BindException with the specified detail\n message as to why the bind error occurred.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public BindException()",
                  "description": "Construct a new BindException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "CacheRequest",
          "methods": [
            {
              "name": "CacheRequest",
              "overloads": [
                {
                  "signature": "public CacheRequest()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getBody",
              "overloads": [
                {
                  "signature": "public abstract OutputStream getBody() throws IOException",
                  "description": "Returns an OutputStream to which the response body can be\n written."
                }
              ]
            },
            {
              "name": "abort",
              "overloads": [
                {
                  "signature": "public abstract void abort()",
                  "description": "Aborts the attempt to cache the response. If an IOException is\n encountered while reading the response or writing to the cache,\n the current cache store operation will be abandoned."
                }
              ]
            }
          ]
        },
        {
          "name": "CacheResponse",
          "methods": [
            {
              "name": "CacheResponse",
              "overloads": [
                {
                  "signature": "public CacheResponse()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getHeaders",
              "overloads": [
                {
                  "signature": "public abstract Map<String,List<String>> getHeaders() throws IOException",
                  "description": "Returns the response headers as a Map."
                }
              ]
            },
            {
              "name": "getBody",
              "overloads": [
                {
                  "signature": "public abstract InputStream getBody() throws IOException",
                  "description": "Returns the response body as an InputStream."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Authenticator.RequestorType[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Authenticator.RequestorType valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static StandardProtocolFamily[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static StandardProtocolFamily valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Proxy.Type[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Proxy.Type valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "ConnectException",
          "methods": [
            {
              "name": "ConnectException",
              "overloads": [
                {
                  "signature": "public ConnectException(String msg)",
                  "description": "Constructs a new ConnectException with the specified detail\n message as to why the connect error occurred.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public ConnectException()",
                  "description": "Construct a new ConnectException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "ContentHandler",
          "methods": [
            {
              "name": "ContentHandler",
              "overloads": [
                {
                  "signature": "public ContentHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public abstract Object getContent(URLConnection urlc) throws IOException",
                  "description": "Given a URL connect stream positioned at the beginning of the\n representation of an object, this method reads that stream and\n creates an object from it."
                },
                {
                  "signature": "public Object getContent(URLConnection urlc, Class[] classes) throws IOException",
                  "description": "Given a URL connect stream positioned at the beginning of the\n representation of an object, this method reads that stream and\n creates an object that matches one of the types specified.\n\n The default implementation of this method should call\n getContent(URLConnection)\n and screen the return type for a match of the suggested types."
                }
              ]
            }
          ]
        },
        {
          "name": "ContentHandlerFactory",
          "methods": [
            {
              "name": "createContentHandler",
              "overloads": [
                {
                  "signature": "ContentHandler createContentHandler(String mimetype)",
                  "description": "Creates a new ContentHandler to read an object from\n a URLStreamHandler."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieHandler",
          "methods": [
            {
              "name": "CookieHandler",
              "overloads": [
                {
                  "signature": "public CookieHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static CookieHandler getDefault()",
                  "description": "Gets the system-wide cookie handler."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(CookieHandler cHandler)",
                  "description": "Sets (or unsets) the system-wide cookie handler.\n\n Note: non-standard http protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract Map<String,List<String>> get(URI uri, Map<String,List<String>> requestHeaders) throws IOException",
                  "description": "Gets all the applicable cookies from a cookie cache for the\n specified uri in the request header.\n\n The URI passed as an argument specifies the intended use for\n the cookies. In particular the scheme should reflect whether the cookies\n will be sent over http, https or used in another context like javascript.\n The host part should reflect either the destination of the cookies or\n their origin in the case of javascript.\n It is up to the implementation to take into account the URI and\n the cookies attributes and security settings to determine which ones\n should be returned.\n\n HTTP protocol implementers should make sure that this method is\n called after all request headers related to choosing cookies\n are added, and before the request is sent."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract void put(URI uri, Map<String,List<String>> responseHeaders) throws IOException",
                  "description": "Sets all the applicable cookies, examples are response header\n fields that are named Set-Cookie2, present in the response\n headers into a cookie cache."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieManager",
          "methods": [
            {
              "name": "CookieManager",
              "overloads": [
                {
                  "signature": "public CookieManager()",
                  "description": "Create a new cookie manager.\n\n This constructor will create new cookie manager with default\n cookie store and accept policy. The effect is same as\n CookieManager(null, null)."
                },
                {
                  "signature": "public CookieManager(CookieStore store, CookiePolicy cookiePolicy)",
                  "description": "Create a new cookie manager with specified cookie store and cookie policy."
                }
              ]
            },
            {
              "name": "setCookiePolicy",
              "overloads": [
                {
                  "signature": "public void setCookiePolicy(CookiePolicy cookiePolicy)",
                  "description": "To set the cookie policy of this cookie manager.\n\n  A instance of CookieManager will have\n cookie policy ACCEPT_ORIGINAL_SERVER by default. Users always\n can call this method to set another cookie policy."
                }
              ]
            },
            {
              "name": "getCookieStore",
              "overloads": [
                {
                  "signature": "public CookieStore getCookieStore()",
                  "description": "To retrieve current cookie store."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> get(URI uri, Map<String,List<String>> requestHeaders) throws IOException",
                  "description": "Description copied from class:CookieHandler"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public void put(URI uri, Map<String,List<String>> responseHeaders) throws IOException",
                  "description": "Description copied from class:CookieHandler"
                }
              ]
            }
          ]
        },
        {
          "name": "CookiePolicy",
          "methods": [
            {
              "name": "shouldAccept",
              "overloads": [
                {
                  "signature": "boolean shouldAccept(URI uri, HttpCookie cookie)",
                  "description": "Will be called to see whether or not this cookie should be accepted."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieStore",
          "methods": [
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "void add(URI uri, HttpCookie cookie)",
                  "description": "Adds one HTTP cookie to the store. This is called for every\n incoming HTTP response.\n\n A cookie to store may or may not be associated with an URI. If it\n is not associated with an URI, the cookie's domain and path attribute\n will indicate where it comes from. If it is associated with an URI and\n its domain and path attribute are not specified, given URI will indicate\n where this cookie comes from.\n\n If a cookie corresponding to the given URI already exists,\n then it is replaced with the new one."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "List<HttpCookie> get(URI uri)",
                  "description": "Retrieve cookies associated with given URI, or whose domain matches the\n given URI. Only cookies that have not expired are returned.\n This is called for every outgoing HTTP request."
                }
              ]
            },
            {
              "name": "getCookies",
              "overloads": [
                {
                  "signature": "List<HttpCookie> getCookies()",
                  "description": "Get all not-expired cookies in cookie store."
                }
              ]
            },
            {
              "name": "getURIs",
              "overloads": [
                {
                  "signature": "List<URI> getURIs()",
                  "description": "Get all URIs which identify the cookies in this cookie store."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(URI uri, HttpCookie cookie)",
                  "description": "Remove a cookie from store."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll()",
                  "description": "Remove all cookies in this cookie store."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramPacket",
          "methods": [
            {
              "name": "DatagramPacket",
              "overloads": [
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length)",
                  "description": "Constructs a DatagramPacket for receiving packets of\n length length, specifying an offset into the buffer.\n \n The length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length)",
                  "description": "Constructs a DatagramPacket for receiving packets of\n length length.\n \n The length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)",
                  "description": "Constructs a datagram packet for sending packets of length\n length with offset offset to the\n specified port number on the specified host. The\n length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)",
                  "description": "Constructs a datagram packet for sending packets of length\n length with offset offset to the\n specified port number on the specified host. The\n length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length, InetAddress address, int port)",
                  "description": "Constructs a datagram packet for sending packets of length\n length to the specified port number on the specified\n host. The length argument must be less than or equal\n to buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length, SocketAddress address)",
                  "description": "Constructs a datagram packet for sending packets of length\n length to the specified port number on the specified\n host. The length argument must be less than or equal\n to buf.length."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getAddress()",
                  "description": "Returns the IP address of the machine to which this datagram is being\n sent or from which the datagram was received, or null if not\n set."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number on the remote host to which this datagram is\n being sent or from which the datagram was received, or 0 if not set."
                }
              ]
            },
            {
              "name": "getData",
              "overloads": [
                {
                  "signature": "public byte[] getData()",
                  "description": "Returns the data buffer. The data received or the data to be sent\n starts from the offset in the buffer,\n and runs for length long."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset()",
                  "description": "Returns the offset of the data to be sent or the offset of the\n data received."
                }
              ]
            },
            {
              "name": "getLength",
              "overloads": [
                {
                  "signature": "public int getLength()",
                  "description": "Returns the length of the data to be sent or the length of the\n data received."
                }
              ]
            },
            {
              "name": "setData",
              "overloads": [
                {
                  "signature": "public void setData(byte[] buf, int offset, int length)",
                  "description": "Set the data buffer for this packet. This sets the\n data, length and offset of the packet."
                },
                {
                  "signature": "public void setData(byte[] buf)",
                  "description": "Set the data buffer for this packet. With the offset of\n this DatagramPacket set to 0, and the length set to\n the length of buf."
                }
              ]
            },
            {
              "name": "setAddress",
              "overloads": [
                {
                  "signature": "public void setAddress(InetAddress iaddr)",
                  "description": "Sets the IP address of the machine to which this datagram\n is being sent."
                }
              ]
            },
            {
              "name": "setPort",
              "overloads": [
                {
                  "signature": "public void setPort(int iport)",
                  "description": "Sets the port number on the remote host to which this datagram\n is being sent."
                }
              ]
            },
            {
              "name": "setSocketAddress",
              "overloads": [
                {
                  "signature": "public void setSocketAddress(SocketAddress address)",
                  "description": "Sets the SocketAddress (usually IP address + port number) of the remote\n host to which this datagram is being sent."
                }
              ]
            },
            {
              "name": "getSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getSocketAddress()",
                  "description": "Returns the SocketAddress (usually IP address +\n port number) of the remote host that this packet\n is being sent to or is coming from."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int length)",
                  "description": "Set the length for this packet. The length of the packet is\n the number of bytes from the packet's data buffer that will be\n sent, or the number of bytes of the packet's data buffer that\n will be used for receiving data. The length must be lesser or\n equal to the offset plus the length of the packet's buffer."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocket",
          "methods": [
            {
              "name": "DatagramSocket",
              "overloads": [
                {
                  "signature": "public DatagramSocket() throws SocketException",
                  "description": "Constructs a datagram socket and binds it to any available port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with 0 as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "protected DatagramSocket(DatagramSocketImpl impl)",
                  "description": "Creates an unbound datagram socket with the specified\n DatagramSocketImpl."
                },
                {
                  "signature": "public DatagramSocket(SocketAddress bindaddr) throws SocketException",
                  "description": "Creates a datagram socket, bound to the specified local\n socket address.\n \n If the address is null an unbound socket will be created.\n\n If there is a security manager,\n its checkListen method is first called\n with the port from the socket address\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public DatagramSocket(int port) throws SocketException",
                  "description": "Constructs a datagram socket and binds it to the specified port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public DatagramSocket(int port, InetAddress laddr) throws SocketException",
                  "description": "Creates a datagram socket, bound to the specified local\n address.\n The local port must be between 0 and\n 65535 inclusive. A port number of zero will let the system pick\n up an ephemeral port in a bind operation.\n \n If the IP address is a wildcard\n address, or is null, the socket will be bound to the wildcard\n address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress addr) throws SocketException",
                  "description": "Binds this DatagramSocket to a specific address and port.\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(InetAddress address, int port)",
                  "description": "Connects the socket to a remote address for this socket. When a\n socket is connected to a remote address, packets may only be\n sent to or received from that address. By default a datagram\n socket is not connected. If the socket is already closed,\n then this method has no effect.\n\n  If this socket is not bound then this method will first cause the\n socket to be bound to an address that is assigned automatically,\n as if invoking the bind method with a parameter of\n null. If the remote destination to which the socket is connected\n does not exist, or is otherwise unreachable, and if an ICMP destination\n unreachable packet has been received for that address, then a subsequent\n call to send or receive may throw a PortUnreachableException. Note,\n there is no guarantee that the exception will be thrown.\n\n  If a security manager has been installed then it is invoked to check\n access to the remote address. Specifically, if the given address\n is a multicast address,\n the security manager's checkMulticast method is invoked with the given address.\n Otherwise, the security manager's checkConnect\n and checkAccept methods\n are invoked, with the given address and port, to\n verify that datagrams are permitted to be sent and received\n respectively.\n\n  Care should be taken to ensure that a connected datagram socket\n is not shared with untrusted code. When a socket is connected,\n receive and send will not perform\n any security checks on incoming and outgoing packets, other than\n matching the packet's and the socket's address and port. On a send\n operation, if the packet's address is set and the packet's address\n and the socket's address do not match, an IllegalArgumentException\n will be thrown. A socket connected to a multicast address may only\n be used to send packets. Datagrams in the socket's socket receive buffer, which\n have not been received before invoking\n this method, may be discarded."
                },
                {
                  "signature": "public void connect(SocketAddress addr) throws SocketException",
                  "description": "Connects this socket to a remote socket address (IP address + port number).\n\n  If given an InetSocketAddress, this method\n behaves as if invoking connect(InetAddress,int)\n with the given socket addresses IP address and port number, except that the\n SocketException that may be raised is not wrapped in an\n UncheckedIOException. Datagrams in the socket's socket receive buffer, which\n have not been received before invoking\n this method, may be discarded."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "public void disconnect()",
                  "description": "Disconnects the socket. If the socket is closed or not connected,\n then this method has no effect."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the socket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "isConnected",
              "overloads": [
                {
                  "signature": "public boolean isConnected()",
                  "description": "Returns the connection state of the socket.\n \n If the socket was connected prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the address to which this socket is connected. Returns\n null if the socket is not connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number to which this socket is connected.\n Returns -1 if the socket is not connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getRemoteSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getRemoteSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to."
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "public void send(DatagramPacket p) throws IOException",
                  "description": "Sends a datagram packet from this socket. The\n DatagramPacket includes information indicating the\n data to be sent, its length, the IP address of the remote host,\n and the port number on the remote host.\n\n If there is a security manager, and the socket is not currently\n connected to a remote address, this method first performs some\n security checks. First, if p.getAddress().isMulticastAddress()\n is true, this method calls the\n security manager's checkMulticast method\n with p.getAddress() as its argument.\n If the evaluation of that expression is false,\n this method instead calls the security manager's\n checkConnect method with arguments\n p.getAddress().getHostAddress() and\n p.getPort(). Each call to a security manager method\n could result in a SecurityException if the operation is not allowed."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "public void receive(DatagramPacket p) throws IOException",
                  "description": "Receives a datagram packet from this socket. When this method\n returns, the DatagramPacket's buffer is filled with\n the data received. The datagram packet also contains the sender's\n IP address, and the port number on the sender's machine.\n \n This method blocks until a datagram is received. The\n length field of the datagram packet object contains\n the length of the received message. If the message is longer than\n the packet's length, the message is truncated.\n \n If there is a security manager, and the socket is not currently\n connected to a remote address, a packet cannot be received if the\n security manager's checkAccept method does not allow it.\n Datagrams that are not permitted by the security manager are silently\n discarded."
                }
              ]
            },
            {
              "name": "getLocalAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getLocalAddress()",
                  "description": "Gets the local address to which the socket is bound.\n\n If there is a security manager, its\n checkConnect method is first called\n with the host address and -1\n as its arguments to see if the operation is allowed."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the port number on the local host to which this socket\n is bound."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT with the specified timeout, in\n milliseconds. With this option set to a positive timeout value,\n a call to receive() for this DatagramSocket\n will block for only this amount of time.  If the timeout expires,\n a java.net.SocketTimeoutException is raised, though the\n DatagramSocket is still valid. A timeout of zero is interpreted\n as an infinite timeout.\n The option must be enabled prior to entering the blocking\n operation to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws SocketException",
                  "description": "Retrieve setting for SO_TIMEOUT.  0 returns implies that the\n option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setSendBufferSize",
              "overloads": [
                {
                  "signature": "public void setSendBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_SNDBUF option to the specified value for this\n DatagramSocket. The SO_SNDBUF option is used by the\n network implementation as a hint to size the underlying\n network I/O buffers. The SO_SNDBUF setting may also be used\n by the network implementation to determine the maximum size\n of the packet that can be sent on this socket.\n \n As SO_SNDBUF is a hint, applications that want to verify\n what size the buffer is should call getSendBufferSize().\n \n Increasing the buffer size may allow multiple outgoing packets\n to be queued by the network implementation when the send rate\n is high.\n \n Note: If send(DatagramPacket) is used to send a\n DatagramPacket that is larger than the setting\n of SO_SNDBUF then it is implementation specific if the\n packet is sent or discarded."
                }
              ]
            },
            {
              "name": "getSendBufferSize",
              "overloads": [
                {
                  "signature": "public int getSendBufferSize() throws SocketException",
                  "description": "Get value of the SO_SNDBUF option for this DatagramSocket, that is the\n buffer size, in bytes, used by the platform for output on this DatagramSocket."
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_RCVBUF option to the specified value for this\n DatagramSocket. The SO_RCVBUF option is used by\n the network implementation as a hint to size the underlying\n network I/O buffers. The SO_RCVBUF setting may also be used\n by the network implementation to determine the maximum size\n of the packet that can be received on this socket.\n \n Because SO_RCVBUF is a hint, applications that want to\n verify what size the buffers were set to should call\n getReceiveBufferSize().\n \n Increasing SO_RCVBUF may allow the network implementation\n to buffer multiple packets when packets arrive faster than\n are being received using receive(DatagramPacket).\n \n Note: It is implementation specific if a packet larger\n than SO_RCVBUF can be received."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Get value of the SO_RCVBUF option for this DatagramSocket, that is the\n buffer size, in bytes, used by the platform for input on this DatagramSocket."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR socket option.\n \n For UDP sockets it may be necessary to bind more than one\n socket to the same socket address. This is typically for the\n purpose of receiving multicast packets\n (See MulticastSocket). The\n SO_REUSEADDR socket option allows multiple\n sockets to be bound to the same socket address if the\n SO_REUSEADDR socket option is enabled prior\n to binding the socket using bind(SocketAddress).\n \n Note: This functionality is not supported by all existing platforms,\n so it is implementation specific whether this option will be ignored\n or not. However, if it is not supported then\n getReuseAddress() will always return false.\n \n When a DatagramSocket is created the initial setting\n of SO_REUSEADDR is disabled.\n \n The behaviour when SO_REUSEADDR is enabled or\n disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "setBroadcast",
              "overloads": [
                {
                  "signature": "public void setBroadcast(boolean on) throws SocketException",
                  "description": "Enable/disable SO_BROADCAST.\n\n  Some operating systems may require that the Java virtual machine be\n started with implementation specific privileges to enable this option or\n send broadcast datagrams."
                }
              ]
            },
            {
              "name": "getBroadcast",
              "overloads": [
                {
                  "signature": "public boolean getBroadcast() throws SocketException",
                  "description": "Tests if SO_BROADCAST is enabled."
                }
              ]
            },
            {
              "name": "setTrafficClass",
              "overloads": [
                {
                  "signature": "public void setTrafficClass(int tc) throws SocketException",
                  "description": "Sets traffic class or type-of-service octet in the IP\n datagram header for datagrams sent from this DatagramSocket.\n As the underlying network implementation may ignore this\n value applications should consider it a hint.\n\n  The tc must be in the range 0 <= tc <=\n 255 or an IllegalArgumentException will be thrown.\n Notes:\n For Internet Protocol v4 the value consists of an\n integer, the least significant 8 bits of which\n represent the value of the TOS octet in IP packets sent by\n the socket.\n RFC 1349 defines the TOS values as follows:\n\n \n IPTOS_LOWCOST (0x02)\n IPTOS_RELIABILITY (0x04)\n IPTOS_THROUGHPUT (0x08)\n IPTOS_LOWDELAY (0x10)\n \n The last low order bit is always ignored as this\n corresponds to the MBZ (must be zero) bit.\n \n Setting bits in the precedence field may result in a\n SocketException indicating that the operation is not\n permitted.\n \n for Internet Protocol v6 tc is the value that\n would be placed into the sin6_flowinfo field of the IP header."
                }
              ]
            },
            {
              "name": "getTrafficClass",
              "overloads": [
                {
                  "signature": "public int getTrafficClass() throws SocketException",
                  "description": "Gets traffic class or type-of-service in the IP datagram\n header for packets sent from this DatagramSocket.\n \n As the underlying network implementation may ignore the\n traffic class or type-of-service set using setTrafficClass(int)\n this method may return a different value than was previously\n set using the setTrafficClass(int) method on this\n DatagramSocket."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes this datagram socket.\n \n Any thread currently blocked in receive(java.net.DatagramPacket) upon this socket\n will throw a SocketException.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns whether the socket is closed or not."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public DatagramChannel getChannel()",
                  "description": "Returns the unique DatagramChannel object\n associated with this datagram socket, if any.\n\n  A datagram socket will have a channel if, and only if, the channel\n itself was created via the DatagramChannel.open method."
                }
              ]
            },
            {
              "name": "setDatagramSocketImplFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac) throws IOException",
                  "description": "Sets the datagram socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new datagram socket, the socket\n implementation factory's createDatagramSocketImpl method is\n called to create the actual datagram socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n\n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> DatagramSocket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Joins a multicast group.\n\n  In order to join a multicast group, the caller should specify\n the IP address of the multicast group to join, and the local\n network interface to receive multicast\n packets from.\n \n   The mcastaddr argument indicates the IP address\n   of the multicast group to join. For historical reasons this is\n   specified as a SocketAddress.\n   The default implementation only supports InetSocketAddress and\n   the port information is ignored.\n  \n   The netIf argument specifies the local interface to receive\n       multicast datagram packets, or null to defer to the interface\n       set for outgoing multicast datagrams.\n       If null, and no interface has been set, the behaviour is\n       unspecified: any interface may be selected or the operation may fail\n       with a SocketException.\n  \n \n\n  It is possible to call this method several times to join\n several different multicast groups, or join the same group\n in several different networks. However, if the socket is already a\n member of the group, an IOException will be thrown.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the mcastaddr\n argument as its argument."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave a multicast group on a specified local interface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocketImpl",
          "methods": [
            {
              "name": "DatagramSocketImpl",
              "overloads": [
                {
                  "signature": "public DatagramSocketImpl()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "protected abstract void create() throws SocketException",
                  "description": "Creates a datagram socket."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "protected abstract void bind(int lport, InetAddress laddr) throws SocketException",
                  "description": "Binds a datagram socket to a local port and address."
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "protected abstract void send(DatagramPacket p) throws IOException",
                  "description": "Sends a datagram packet. The packet contains the data and the\n destination address to send the packet to."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "protected void connect(InetAddress address, int port) throws SocketException",
                  "description": "Connects a datagram socket to a remote destination. This associates the remote\n address with the local socket so that datagrams may only be sent to this destination\n and received from this destination. This may be overridden to call a native\n system connect.\n\n If the remote destination to which the socket is connected does not\n exist, or is otherwise unreachable, and if an ICMP destination unreachable\n packet has been received for that address, then a subsequent call to\n send or receive may throw a PortUnreachableException.\n Note, there is no guarantee that the exception will be thrown."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "protected void disconnect()",
                  "description": "Disconnects a datagram socket from its remote destination."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "protected abstract int peek(InetAddress i) throws IOException",
                  "description": "Peek at the packet to see who it is from. Updates the specified InetAddress\n to the address which the packet came from."
                }
              ]
            },
            {
              "name": "peekData",
              "overloads": [
                {
                  "signature": "protected abstract int peekData(DatagramPacket p) throws IOException",
                  "description": "Peek at the packet to see who it is from. The data is copied into the specified\n DatagramPacket. The data is returned,\n but not consumed, so that a subsequent peekData/receive operation\n will see the same data."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "protected abstract void receive(DatagramPacket p) throws IOException",
                  "description": "Receive the datagram packet."
                }
              ]
            },
            {
              "name": "setTTL",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract void setTTL(byte ttl) throws IOException",
                  "description": "Set the TTL (time-to-live) option.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTTL",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract byte getTTL() throws IOException",
                  "description": "Retrieve the TTL (time-to-live) option.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setTimeToLive",
              "overloads": [
                {
                  "signature": "protected abstract void setTimeToLive(int ttl) throws IOException",
                  "description": "Set the TTL (time-to-live) option."
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "protected abstract int getTimeToLive() throws IOException",
                  "description": "Retrieve the TTL (time-to-live) option."
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "protected abstract void join(InetAddress inetaddr) throws IOException",
                  "description": "Join the multicast group."
                }
              ]
            },
            {
              "name": "leave",
              "overloads": [
                {
                  "signature": "protected abstract void leave(InetAddress inetaddr) throws IOException",
                  "description": "Leave the multicast group."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "protected abstract void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Join the multicast group."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "protected abstract void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave the multicast group."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "protected abstract void close()",
                  "description": "Close the socket."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "protected int getLocalPort()",
                  "description": "Gets the local port."
                }
              ]
            },
            {
              "name": "getFileDescriptor",
              "overloads": [
                {
                  "signature": "protected FileDescriptor getFileDescriptor()",
                  "description": "Gets the datagram socket file descriptor."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "protected <T> void setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Called to set a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "protected <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Called to get a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "protected Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of SocketOptions supported by this impl\n and by this impl's socket (DatagramSocket or MulticastSocket)"
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocketImplFactory",
          "methods": [
            {
              "name": "createDatagramSocketImpl",
              "overloads": [
                {
                  "signature": "DatagramSocketImpl createDatagramSocketImpl()",
                  "description": "Creates a new DatagramSocketImpl instance."
                }
              ]
            }
          ]
        },
        {
          "name": "FileNameMap",
          "methods": [
            {
              "name": "getContentTypeFor",
              "overloads": [
                {
                  "signature": "String getContentTypeFor(String fileName)",
                  "description": "Gets the MIME type for the specified file name."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpCookie",
          "methods": [
            {
              "name": "HttpCookie",
              "overloads": [
                {
                  "signature": "public HttpCookie(String name, String value)",
                  "description": "Constructs a cookie with a specified name and value.\n\n  The name must conform to RFC 2965. That means it can contain\n only ASCII alphanumeric characters and cannot contain commas,\n semicolons, or white space or begin with a $ character. The cookie's\n name cannot be changed after creation.\n\n  The value can be anything the server chooses to send. Its\n value is probably of interest only to the server. The cookie's\n value can be changed after creation with the\n setValue method.\n\n  By default, cookies are created according to the RFC 2965\n cookie specification. The version can be changed with the\n setVersion method."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static List<HttpCookie> parse(String header)",
                  "description": "Constructs cookies from set-cookie or set-cookie2 header string.\n RFC 2965 section 3.2.2 set-cookie2 syntax indicates that one header line\n may contain more than one cookie definitions, so this is a static\n utility method instead of another constructor."
                }
              ]
            },
            {
              "name": "hasExpired",
              "overloads": [
                {
                  "signature": "public boolean hasExpired()",
                  "description": "Reports whether this HTTP cookie has expired or not."
                }
              ]
            },
            {
              "name": "setComment",
              "overloads": [
                {
                  "signature": "public void setComment(String purpose)",
                  "description": "Specifies a comment that describes a cookie's purpose.\n The comment is useful if the browser presents the cookie\n to the user. Comments are not supported by Netscape Version 0 cookies."
                }
              ]
            },
            {
              "name": "getComment",
              "overloads": [
                {
                  "signature": "public String getComment()",
                  "description": "Returns the comment describing the purpose of this cookie, or\n null if the cookie has no comment."
                }
              ]
            },
            {
              "name": "setCommentURL",
              "overloads": [
                {
                  "signature": "public void setCommentURL(String purpose)",
                  "description": "Specifies a comment URL that describes a cookie's purpose.\n The comment URL is useful if the browser presents the cookie\n to the user. Comment URL is RFC 2965 only."
                }
              ]
            },
            {
              "name": "getCommentURL",
              "overloads": [
                {
                  "signature": "public String getCommentURL()",
                  "description": "Returns the comment URL describing the purpose of this cookie, or\n null if the cookie has no comment URL."
                }
              ]
            },
            {
              "name": "setDiscard",
              "overloads": [
                {
                  "signature": "public void setDiscard(boolean discard)",
                  "description": "Specify whether user agent should discard the cookie unconditionally.\n This is RFC 2965 only attribute."
                }
              ]
            },
            {
              "name": "getDiscard",
              "overloads": [
                {
                  "signature": "public boolean getDiscard()",
                  "description": "Returns the discard attribute of the cookie"
                }
              ]
            },
            {
              "name": "setPortlist",
              "overloads": [
                {
                  "signature": "public void setPortlist(String ports)",
                  "description": "Specify the portlist of the cookie, which restricts the port(s)\n to which a cookie may be sent back in a Cookie header."
                }
              ]
            },
            {
              "name": "getPortlist",
              "overloads": [
                {
                  "signature": "public String getPortlist()",
                  "description": "Returns the port list attribute of the cookie"
                }
              ]
            },
            {
              "name": "setDomain",
              "overloads": [
                {
                  "signature": "public void setDomain(String pattern)",
                  "description": "Specifies the domain within which this cookie should be presented.\n\n  The form of the domain name is specified by RFC 2965. A domain\n name begins with a dot (.foo.com) and means that\n the cookie is visible to servers in a specified Domain Name System\n (DNS) zone (for example, www.foo.com, but not\n a.b.foo.com). By default, cookies are only returned\n to the server that sent them."
                }
              ]
            },
            {
              "name": "getDomain",
              "overloads": [
                {
                  "signature": "public String getDomain()",
                  "description": "Returns the domain name set for this cookie. The form of the domain name\n is set by RFC 2965."
                }
              ]
            },
            {
              "name": "setMaxAge",
              "overloads": [
                {
                  "signature": "public void setMaxAge(long expiry)",
                  "description": "Sets the maximum age of the cookie in seconds.\n\n  A positive value indicates that the cookie will expire\n after that many seconds have passed. Note that the value is\n the maximum age when the cookie will expire, not the cookie's\n current age.\n\n  A negative value means that the cookie is not stored persistently\n and will be deleted when the Web browser exits. A zero value causes the\n cookie to be deleted."
                }
              ]
            },
            {
              "name": "getMaxAge",
              "overloads": [
                {
                  "signature": "public long getMaxAge()",
                  "description": "Returns the maximum age of the cookie, specified in seconds. By default,\n -1 indicating the cookie will persist until browser shutdown."
                }
              ]
            },
            {
              "name": "setPath",
              "overloads": [
                {
                  "signature": "public void setPath(String uri)",
                  "description": "Specifies a path for the cookie to which the client should return\n the cookie.\n\n  The cookie is visible to all the pages in the directory\n you specify, and all the pages in that directory's subdirectories.\n A cookie's path must include the servlet that set the cookie,\n for example, /catalog, which makes the cookie\n visible to all directories on the server under /catalog.\n\n  Consult RFC 2965 (available on the Internet) for more\n information on setting path names for cookies."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Returns the path on the server to which the browser returns this cookie.\n The cookie is visible to all subpaths on the server."
                }
              ]
            },
            {
              "name": "setSecure",
              "overloads": [
                {
                  "signature": "public void setSecure(boolean flag)",
                  "description": "Indicates whether the cookie should only be sent using a secure protocol,\n such as HTTPS or SSL.\n\n  The default value is false."
                }
              ]
            },
            {
              "name": "getSecure",
              "overloads": [
                {
                  "signature": "public boolean getSecure()",
                  "description": "Returns true if sending this cookie should be restricted to a\n secure protocol, or false if the it can be sent using any\n protocol."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the cookie. The name cannot be changed after\n creation."
                }
              ]
            },
            {
              "name": "setValue",
              "overloads": [
                {
                  "signature": "public void setValue(String newValue)",
                  "description": "Assigns a new value to a cookie after the cookie is created.\n If you use a binary value, you may want to use BASE64 encoding.\n\n  With Version 0 cookies, values should not contain white space,\n brackets, parentheses, equals signs, commas, double quotes, slashes,\n question marks, at signs, colons, and semicolons. Empty values may not\n behave the same way on all browsers."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public String getValue()",
                  "description": "Returns the value of the cookie."
                }
              ]
            },
            {
              "name": "getVersion",
              "overloads": [
                {
                  "signature": "public int getVersion()",
                  "description": "Returns the version of the protocol this cookie complies with. Version 1\n complies with RFC 2965/2109, and version 0 complies with the original\n cookie specification drafted by Netscape. Cookies provided by a browser\n use and identify the browser's cookie version."
                }
              ]
            },
            {
              "name": "setVersion",
              "overloads": [
                {
                  "signature": "public void setVersion(int v)",
                  "description": "Sets the version of the cookie protocol this cookie complies\n with. Version 0 complies with the original Netscape cookie\n specification. Version 1 complies with RFC 2965/2109."
                }
              ]
            },
            {
              "name": "isHttpOnly",
              "overloads": [
                {
                  "signature": "public boolean isHttpOnly()",
                  "description": "Returns true if this cookie contains the HttpOnly\n attribute. This means that the cookie should not be accessible to\n scripting engines, like javascript."
                }
              ]
            },
            {
              "name": "setHttpOnly",
              "overloads": [
                {
                  "signature": "public void setHttpOnly(boolean httpOnly)",
                  "description": "Indicates whether the cookie should be considered HTTP Only. If set to\n true it means the cookie should not be accessible to scripting\n engines like javascript."
                }
              ]
            },
            {
              "name": "domainMatches",
              "overloads": [
                {
                  "signature": "public static boolean domainMatches(String domain, String host)",
                  "description": "The utility method to check whether a host name is in a domain or not.\n\n  This concept is described in the cookie specification.\n To understand the concept, some terminologies need to be defined first:\n \n effective host name = hostname if host name contains dot\n \n or = hostname.local if not\n \n Host A's name domain-matches host B's if:\n \n   their host name strings string-compare equal; or\n   A is a HDN string and has the form NB, where N is a non-empty\n   name string, B has the form .B', and B' is a HDN string.  (So,\n   x.y.com domain-matches .Y.com but not Y.com.)\n \n\n A host isn't in a domain (RFC 2965 sec. 3.3.2) if:\n \n   The value for the Domain attribute contains no embedded dots,\n   and the value is not .local.\n   The effective host name that derives from the request-host does\n   not domain-match the Domain attribute.\n   The request-host is a HDN (not IP address) and has the form HD,\n   where D is the value of the Domain attribute, and H is a string\n   that contains one or more dots.\n \n\n Examples:\n \n   A Set-Cookie2 from request-host y.x.foo.com for Domain=.foo.com\n   would be rejected, because H is y.x and contains a dot.\n   A Set-Cookie2 from request-host x.foo.com for Domain=.foo.com\n   would be accepted.\n   A Set-Cookie2 with Domain=.com or Domain=.com., will always be\n   rejected, because there is no embedded dot.\n   A Set-Cookie2 from request-host example for Domain=.local will\n   be accepted, because the effective host name for the request-\n   host is example.local, and example.local domain-matches .local."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a cookie header string representation of this cookie,\n which is in the format defined by corresponding cookie specification,\n but without the leading \"Cookie:\" token."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Test the equality of two HTTP cookies.\n\n  The result is true only if two cookies come from same domain\n (case-insensitive), have same name (case-insensitive), and have same path\n (case-sensitive)."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this HTTP cookie. The result is the sum of\n hash code value of three significant components of this cookie: name,\n domain, and path. That is, the hash code is the value of the expression:\n \n getName().toLowerCase().hashCode()\n + getDomain().toLowerCase().hashCode()\n + getPath().hashCode()"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Create and return a copy of this object."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpRetryException",
          "methods": [
            {
              "name": "HttpRetryException",
              "overloads": [
                {
                  "signature": "public HttpRetryException(String detail, int code)",
                  "description": "Constructs a new HttpRetryException from the\n specified response code and exception detail message"
                },
                {
                  "signature": "public HttpRetryException(String detail, int code, String location)",
                  "description": "Constructs a new HttpRetryException with detail message\n responseCode and the contents of the Location response header field."
                }
              ]
            },
            {
              "name": "responseCode",
              "overloads": [
                {
                  "signature": "public int responseCode()",
                  "description": "Returns the http response code"
                }
              ]
            },
            {
              "name": "getReason",
              "overloads": [
                {
                  "signature": "public String getReason()",
                  "description": "Returns a string explaining why the http request could\n not be retried."
                }
              ]
            },
            {
              "name": "getLocation",
              "overloads": [
                {
                  "signature": "public String getLocation()",
                  "description": "Returns the value of the Location header field if the\n error resulted from redirection."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpURLConnection",
          "methods": [
            {
              "name": "HttpURLConnection",
              "overloads": [
                {
                  "signature": "protected HttpURLConnection(URL u)",
                  "description": "Constructor for the HttpURLConnection."
                }
              ]
            },
            {
              "name": "setAuthenticator",
              "overloads": [
                {
                  "signature": "public void setAuthenticator(Authenticator auth)",
                  "description": "Supplies an Authenticator to be used\n when authentication is requested through the HTTP protocol for\n this HttpURLConnection.\n If no authenticator is supplied, the\n default\n authenticator will be used."
                }
              ]
            },
            {
              "name": "getHeaderFieldKey",
              "overloads": [
                {
                  "signature": "public String getHeaderFieldKey(int n)",
                  "description": "Returns the key for the nth header field.\n Some implementations may treat the 0th\n header field as special, i.e. as the status line returned by the HTTP\n server. In this case, getHeaderField(0) returns the status\n line, but getHeaderFieldKey(0) returns null."
                }
              ]
            },
            {
              "name": "setFixedLengthStreamingMode",
              "overloads": [
                {
                  "signature": "public void setFixedLengthStreamingMode(int contentLength)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is known in\n advance.\n \n An exception will be thrown if the application\n attempts to write more data than the indicated\n content-length, or if the application closes the OutputStream\n before writing the indicated amount.\n \n When output streaming is enabled, authentication\n and redirection cannot be handled automatically.\n A HttpRetryException will be thrown when reading\n the response if authentication or redirection are required.\n This exception can be queried for the details of the error.\n \n This method must be called before the URLConnection is connected.\n \n NOTE: setFixedLengthStreamingMode(long) is recommended\n instead of this method as it allows larger content lengths to be set."
                },
                {
                  "signature": "public void setFixedLengthStreamingMode(long contentLength)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is known in\n advance.\n\n  An exception will be thrown if the application attempts to write\n more data than the indicated content-length, or if the application\n closes the OutputStream before writing the indicated amount.\n\n  When output streaming is enabled, authentication and redirection\n cannot be handled automatically. A HttpRetryException will\n be thrown when reading the response if authentication or redirection\n are required. This exception can be queried for the details of the\n error.\n\n  This method must be called before the URLConnection is connected.\n\n  The content length set by invoking this method takes precedence\n over any value set by setFixedLengthStreamingMode(int)."
                }
              ]
            },
            {
              "name": "setChunkedStreamingMode",
              "overloads": [
                {
                  "signature": "public void setChunkedStreamingMode(int chunklen)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is not\n known in advance. In this mode, chunked transfer encoding\n is used to send the request body. Note, not all HTTP servers\n support this mode.\n \n When output streaming is enabled, authentication\n and redirection cannot be handled automatically.\n A HttpRetryException will be thrown when reading\n the response if authentication or redirection are required.\n This exception can be queried for the details of the error.\n \n This method must be called before the URLConnection is connected."
                }
              ]
            },
            {
              "name": "getHeaderField",
              "overloads": [
                {
                  "signature": "public String getHeaderField(int n)",
                  "description": "Returns the value for the nth header field.\n Some implementations may treat the 0th\n header field as special, i.e. as the status line returned by the HTTP\n server.\n \n This method can be used in conjunction with the\n getHeaderFieldKey method to iterate through all\n the headers in the message."
                }
              ]
            },
            {
              "name": "setFollowRedirects",
              "overloads": [
                {
                  "signature": "public static void setFollowRedirects(boolean set)",
                  "description": "Sets whether HTTP redirects  (requests with response code 3xx) should\n be automatically followed by this class.  True by default.  Applets\n cannot change this variable.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "getFollowRedirects",
              "overloads": [
                {
                  "signature": "public static boolean getFollowRedirects()",
                  "description": "Returns a boolean indicating\n whether or not HTTP redirects (3xx) should\n be automatically followed."
                }
              ]
            },
            {
              "name": "setInstanceFollowRedirects",
              "overloads": [
                {
                  "signature": "public void setInstanceFollowRedirects(boolean followRedirects)",
                  "description": "Sets whether HTTP redirects (requests with response code 3xx) should\n be automatically followed by this HttpURLConnection\n instance.\n \n The default value comes from followRedirects, which defaults to\n true."
                }
              ]
            },
            {
              "name": "getInstanceFollowRedirects",
              "overloads": [
                {
                  "signature": "public boolean getInstanceFollowRedirects()",
                  "description": "Returns the value of this HttpURLConnection's\n instanceFollowRedirects field."
                }
              ]
            },
            {
              "name": "setRequestMethod",
              "overloads": [
                {
                  "signature": "public void setRequestMethod(String method) throws ProtocolException",
                  "description": "Set the method for the URL request, one of:\n \n  GET\n  POST\n  HEAD\n  OPTIONS\n  PUT\n  DELETE\n  TRACE\n  are legal, subject to protocol restrictions.  The default\n method is GET."
                }
              ]
            },
            {
              "name": "getRequestMethod",
              "overloads": [
                {
                  "signature": "public String getRequestMethod()",
                  "description": "Get the request method."
                }
              ]
            },
            {
              "name": "getResponseCode",
              "overloads": [
                {
                  "signature": "public int getResponseCode() throws IOException",
                  "description": "Gets the status code from an HTTP response message.\n For example, in the case of the following status lines:\n  HTTP/1.0 200 OK\n HTTP/1.0 401 Unauthorized\n \n It will return 200 and 401 respectively.\n Returns -1 if no code can be discerned\n from the response (i.e., the response is not valid HTTP)."
                }
              ]
            },
            {
              "name": "getResponseMessage",
              "overloads": [
                {
                  "signature": "public String getResponseMessage() throws IOException",
                  "description": "Gets the HTTP response message, if any, returned along with the\n response code from a server.  From responses like:\n  HTTP/1.0 200 OK\n HTTP/1.0 404 Not Found\n \n Extracts the Strings \"OK\" and \"Not Found\" respectively.\n Returns null if none could be discerned from the responses\n (the result was not valid HTTP)."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "public abstract void disconnect()",
                  "description": "Indicates that other requests to the server\n are unlikely in the near future. Calling disconnect()\n should not imply that this HttpURLConnection\n instance can be reused for other requests."
                }
              ]
            },
            {
              "name": "usingProxy",
              "overloads": [
                {
                  "signature": "public abstract boolean usingProxy()",
                  "description": "Indicates if the connection is going through a proxy.\n\n This method returns true if the connection is known\n to be going or has gone through proxies, and returns false\n if the connection will never go through a proxy or if\n the use of a proxy cannot be determined."
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission() throws IOException",
                  "description": "Returns a SocketPermission object representing the\n permission necessary to connect to the destination host and port."
                }
              ]
            },
            {
              "name": "getErrorStream",
              "overloads": [
                {
                  "signature": "public InputStream getErrorStream()",
                  "description": "Returns the error stream if the connection failed\n but the server sent useful data nonetheless. The\n typical example is when an HTTP server responds\n with a 404, which will cause a FileNotFoundException\n to be thrown in connect, but the server sent an HTML\n help page with suggestions as to what to do.\n\n This method will not cause a connection to be initiated.  If\n the connection was not connected, or if the server did not have\n an error while connecting or if the server had an error but\n no error data was sent, this method will return null. This is\n the default."
                }
              ]
            }
          ]
        },
        {
          "name": "IDN",
          "methods": [
            {
              "name": "toASCII",
              "overloads": [
                {
                  "signature": "public static String toASCII(String input, int flag)",
                  "description": "Translates a string from Unicode to ASCII Compatible Encoding (ACE),\n as defined by the ToASCII operation of RFC 3490.\n\n ToASCII operation can fail. ToASCII fails if any step of it fails.\n If ToASCII operation fails, an IllegalArgumentException will be thrown.\n In this case, the input string should not be used in an internationalized domain name.\n\n  A label is an individual part of a domain name. The original ToASCII operation,\n as defined in RFC 3490, only operates on a single label. This method can handle\n both label and entire domain name, by assuming that labels in a domain name are\n always separated by dots. The following characters are recognized as dots:\n \\u002E (full stop), \\u3002 (ideographic full stop), \\uFF0E (fullwidth full stop),\n and \\uFF61 (halfwidth ideographic full stop). if dots are\n used as label separators, this method also changes all of them to \\u002E (full stop)\n in output translated string."
                },
                {
                  "signature": "public static String toASCII(String input)",
                  "description": "Translates a string from Unicode to ASCII Compatible Encoding (ACE),\n as defined by the ToASCII operation of RFC 3490.\n\n  This convenience method works as if by invoking the\n two-argument counterpart as follows:\n \n toASCII(input,0);"
                }
              ]
            },
            {
              "name": "toUnicode",
              "overloads": [
                {
                  "signature": "public static String toUnicode(String input, int flag)",
                  "description": "Translates a string from ASCII Compatible Encoding (ACE) to Unicode,\n as defined by the ToUnicode operation of RFC 3490.\n\n ToUnicode never fails. In case of any error, the input string is returned unmodified.\n\n  A label is an individual part of a domain name. The original ToUnicode operation,\n as defined in RFC 3490, only operates on a single label. This method can handle\n both label and entire domain name, by assuming that labels in a domain name are\n always separated by dots. The following characters are recognized as dots:\n \\u002E (full stop), \\u3002 (ideographic full stop), \\uFF0E (fullwidth full stop),\n and \\uFF61 (halfwidth ideographic full stop)."
                },
                {
                  "signature": "public static String toUnicode(String input)",
                  "description": "Translates a string from ASCII Compatible Encoding (ACE) to Unicode,\n as defined by the ToUnicode operation of RFC 3490.\n\n  This convenience method works as if by invoking the\n two-argument counterpart as follows:\n \n toUnicode(input,0);"
                }
              ]
            }
          ]
        },
        {
          "name": "Inet4Address",
          "methods": [
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IP multicast address. IP multicast address is a Class D\n address i.e first four bits of the address are 1110."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress\n object. The result is in network byte order: the highest order\n byte of the address is in getAddress()[0]."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation form."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same IP address as\n this object.\n \n Two instances of InetAddress represent the same IP\n address if the length of the byte arrays returned by\n getAddress is the same for both, and each of the\n array components is the same for the byte arrays."
                }
              ]
            }
          ]
        },
        {
          "name": "Inet6Address",
          "methods": [
            {
              "name": "getByAddress",
              "overloads": [
                {
                  "signature": "public static Inet6Address getByAddress(String host, byte[] addr, NetworkInterface nif) throws UnknownHostException",
                  "description": "Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is\n set to the value corresponding to the given interface for the address\n type specified in addr. The call will fail with an\n UnknownHostException if the given interface does not have a numeric\n scope_id assigned for the given address type (e.g. link-local or site-local).\n See here for a description of IPv6\n scoped addresses."
                },
                {
                  "signature": "public static Inet6Address getByAddress(String host, byte[] addr, int scope_id) throws UnknownHostException",
                  "description": "Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is\n set to the given numeric value. The scope_id is not checked to determine\n if it corresponds to any interface on the system.\n See here for a description of IPv6\n scoped addresses."
                }
              ]
            },
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an IP multicast\n address. 11111111 at the start of the address identifies the\n address as being a multicast address."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress object. The result\n is in network byte order: the highest order byte of the address is in\n getAddress()[0]."
                }
              ]
            },
            {
              "name": "getScopeId",
              "overloads": [
                {
                  "signature": "public int getScopeId()",
                  "description": "Returns the numeric scopeId, if this instance is associated with\n an interface. If no scoped_id is set, the returned value is zero."
                }
              ]
            },
            {
              "name": "getScopedInterface",
              "overloads": [
                {
                  "signature": "public NetworkInterface getScopedInterface()",
                  "description": "Returns the scoped interface, if this instance was created with\n a scoped interface."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation. If the instance\n was created specifying a scope identifier then the scope id is appended\n to the IP address preceded by a \"%\" (per-cent) character. This can be\n either a numeric value or a string, depending on which was used to create\n the instance."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object. The result is \n true if and only if the argument is not null and it represents\n the same IP address as this object.\n\n  Two instances of InetAddress represent the same IP address\n if the length of the byte arrays returned by getAddress is the\n same for both, and each of the array components is the same for the byte\n arrays."
                }
              ]
            },
            {
              "name": "isIPv4CompatibleAddress",
              "overloads": [
                {
                  "signature": "public boolean isIPv4CompatibleAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IPv4 compatible IPv6 address."
                }
              ]
            }
          ]
        },
        {
          "name": "InetAddress",
          "methods": [
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IP multicast address."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "isReachable",
              "overloads": [
                {
                  "signature": "public boolean isReachable(int timeout) throws IOException",
                  "description": "Test whether that address is reachable. Best effort is made by the\n implementation to try to reach the host, but firewalls and server\n configuration may block requests resulting in a unreachable status\n while some specific ports may be accessible.\n A typical implementation will use ICMP ECHO REQUESTs if the\n privilege can be obtained, otherwise it will try to establish\n a TCP connection on port 7 (Echo) of the destination host.\n \n The timeout value, in milliseconds, indicates the maximum amount of time\n the try should take. If the operation times out before getting an\n answer, the host is deemed unreachable. A negative value will result\n in an IllegalArgumentException being thrown."
                },
                {
                  "signature": "public boolean isReachable(NetworkInterface netif, int ttl, int timeout) throws IOException",
                  "description": "Test whether that address is reachable. Best effort is made by the\n implementation to try to reach the host, but firewalls and server\n configuration may block requests resulting in a unreachable status\n while some specific ports may be accessible.\n A typical implementation will use ICMP ECHO REQUESTs if the\n privilege can be obtained, otherwise it will try to establish\n a TCP connection on port 7 (Echo) of the destination host.\n \n The network interface and ttl parameters\n let the caller specify which network interface the test will go through\n and the maximum number of hops the packets should go through.\n A negative value for the ttl will result in an\n IllegalArgumentException being thrown.\n \n The timeout value, in milliseconds, indicates the maximum amount of time\n the try should take. If the operation times out before getting an\n answer, the host is deemed unreachable. A negative value will result\n in an IllegalArgumentException being thrown."
                }
              ]
            },
            {
              "name": "getHostName",
              "overloads": [
                {
                  "signature": "public String getHostName()",
                  "description": "Gets the host name for this IP address.\n\n If this InetAddress was created with a host name,\n this host name will be remembered and returned;\n otherwise, a reverse name lookup will be performed\n and the result will be returned based on the system\n configured name lookup service. If a lookup of the name service\n is required, call\n getCanonicalHostName.\n\n If there is a security manager, its\n checkConnect method is first called\n with the hostname and -1\n as its arguments to see if the operation is allowed.\n If the operation is not allowed, it will return\n the textual representation of the IP address."
                }
              ]
            },
            {
              "name": "getCanonicalHostName",
              "overloads": [
                {
                  "signature": "public String getCanonicalHostName()",
                  "description": "Gets the fully qualified domain name for this IP address.\n Best effort method, meaning we may not be able to return\n the FQDN depending on the underlying system configuration.\n\n If there is a security manager, this method first\n calls its checkConnect method\n with the hostname and -1\n as its arguments to see if the calling code is allowed to know\n the hostname for this IP address, i.e., to connect to the host.\n If the operation is not allowed, it will return\n the textual representation of the IP address."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress\n object. The result is in network byte order: the highest order\n byte of the address is in getAddress()[0]."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same IP address as\n this object.\n \n Two instances of InetAddress represent the same IP\n address if the length of the byte arrays returned by\n getAddress is the same for both, and each of the\n array components is the same for the byte arrays."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this IP address to a String. The\n string returned is of the form: hostname / literal IP\n address.\n\n If the host name is unresolved, no reverse name service lookup\n is performed. The hostname part will be represented by an empty string."
                }
              ]
            },
            {
              "name": "getByAddress",
              "overloads": [
                {
                  "signature": "public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException",
                  "description": "Creates an InetAddress based on the provided host name and IP address.\n No name service is checked for the validity of the address.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its IP\n address.\n  No validity checking is done on the host name either.\n\n  If addr specifies an IPv4 address an instance of Inet4Address\n will be returned; otherwise, an instance of Inet6Address\n will be returned.\n\n  IPv4 address byte array must be 4 bytes long and IPv6 byte array\n must be 16 bytes long"
                },
                {
                  "signature": "public static InetAddress getByAddress(byte[] addr) throws UnknownHostException",
                  "description": "Returns an InetAddress object given the raw IP address .\n The argument is in network byte order: the highest order\n byte of the address is in getAddress()[0].\n\n  This method doesn't block, i.e. no reverse name service lookup\n is performed.\n\n  IPv4 address byte array must be 4 bytes long and IPv6 byte array\n must be 16 bytes long"
                }
              ]
            },
            {
              "name": "getByName",
              "overloads": [
                {
                  "signature": "public static InetAddress getByName(String host) throws UnknownHostException",
                  "description": "Determines the IP address of a host, given the host's name.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its\n IP address. If a literal IP address is supplied, only the\n validity of the address format is checked.\n\n  For host specified in literal IPv6 address,\n either the form defined in RFC 2732 or the literal IPv6 address\n format defined in RFC 2373 is accepted. IPv6 scoped addresses are also\n supported. See here for a description of IPv6\n scoped addresses.\n\n  If the host is null or host.length() is equal\n to zero, then an InetAddress representing an address of the\n loopback interface is returned.\n See RFC3330\n section2 and RFC2373\n section2.5.3.\n\n  If there is a security manager, and host is not null\n or host.length()  is not equal to zero, the security manager's\n checkConnect method is called with the hostname and -1\n as its arguments to determine if the operation is allowed."
                }
              ]
            },
            {
              "name": "getAllByName",
              "overloads": [
                {
                  "signature": "public static InetAddress[] getAllByName(String host) throws UnknownHostException",
                  "description": "Given the name of a host, returns an array of its IP addresses,\n based on the configured name service on the system.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its IP\n address. If a literal IP address is supplied, only the\n validity of the address format is checked.\n\n  For host specified in literal IPv6 address,\n either the form defined in RFC 2732 or the literal IPv6 address\n format defined in RFC 2373 is accepted. A literal IPv6 address may\n also be qualified by appending a scoped zone identifier or scope_id.\n The syntax and usage of scope_ids is described\n here.\n\n  If the host is null or host.length() is equal\n to zero, then an InetAddress representing an address of the\n loopback interface is returned.\n See RFC3330\n section2 and RFC2373\n section2.5.3. \n\n  If there is a security manager, and host is not null\n or host.length()  is not equal to zero, the security manager's\n checkConnect method is called with the hostname and -1\n as its arguments to determine if the operation is allowed."
                }
              ]
            },
            {
              "name": "getLoopbackAddress",
              "overloads": [
                {
                  "signature": "public static InetAddress getLoopbackAddress()",
                  "description": "Returns the loopback address.\n \n The InetAddress returned will represent the IPv4\n loopback address, 127.0.0.1, or the IPv6 loopback\n address, ::1. The IPv4 loopback address returned\n is only one of many in the form 127.*.*.*"
                }
              ]
            },
            {
              "name": "getLocalHost",
              "overloads": [
                {
                  "signature": "public static InetAddress getLocalHost() throws UnknownHostException",
                  "description": "Returns the address of the local host. This is achieved by retrieving\n the name of the host from the system, then resolving that name into\n an InetAddress.\n\n Note: The resolved address may be cached for a short period of time.\n \n\n If there is a security manager, its\n checkConnect method is called\n with the local host name and -1\n as its arguments to see if the operation is allowed.\n If the operation is not allowed, an InetAddress representing\n the loopback address is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "InetSocketAddress",
          "methods": [
            {
              "name": "InetSocketAddress",
              "overloads": [
                {
                  "signature": "public InetSocketAddress(int port)",
                  "description": "Creates a socket address where the IP address is the wildcard address\n and the port number a specified value.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                },
                {
                  "signature": "public InetSocketAddress(InetAddress addr, int port)",
                  "description": "Creates a socket address from an IP address and a port number.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation.\n \n A null address will assign the wildcard address."
                },
                {
                  "signature": "public InetSocketAddress(String hostname, int port)",
                  "description": "Creates a socket address from a hostname and a port number.\n \n An attempt will be made to resolve the hostname into an InetAddress.\n If that attempt fails, the address will be flagged as unresolved.\n \n If there is a security manager, its checkConnect method\n is called with the host name as its argument to check the permission\n to resolve it. This could result in a SecurityException.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                }
              ]
            },
            {
              "name": "createUnresolved",
              "overloads": [
                {
                  "signature": "public static InetSocketAddress createUnresolved(String host, int port)",
                  "description": "Creates an unresolved socket address from a hostname and a port number.\n \n No attempt will be made to resolve the hostname into an InetAddress.\n The address will be flagged as unresolved.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public final int getPort()",
                  "description": "Gets the port number."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public final InetAddress getAddress()",
                  "description": "Gets the InetAddress."
                }
              ]
            },
            {
              "name": "getHostName",
              "overloads": [
                {
                  "signature": "public final String getHostName()",
                  "description": "Gets the hostname.\n Note: This method may trigger a name service reverse lookup if the\n address was created with a literal IP address."
                }
              ]
            },
            {
              "name": "getHostString",
              "overloads": [
                {
                  "signature": "public final String getHostString()",
                  "description": "Returns the hostname, or the String form of the address if it\n doesn't have a hostname (it was created using a literal).\n This has the benefit of not attempting a reverse lookup."
                }
              ]
            },
            {
              "name": "isUnresolved",
              "overloads": [
                {
                  "signature": "public final boolean isUnresolved()",
                  "description": "Checks whether the address has been resolved or not."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this InetSocketAddress.\n This string is constructed by calling InetAddress.toString()\n on the InetAddress and concatenating the port number (with a colon).\n \n If the address is an IPv6 address, the IPv6 literal is enclosed in\n square brackets, for example: \"localhost/[0:0:0:0:0:0:0:1]:80\".\n If the address is unresolved,\n <unresolved> is displayed in place of the address literal, for\n example \"foo/<unresolved>:80\".\n \n To retrieve a string representation of the hostname or the address, use\n getHostString(), rather than parsing the string returned by this\n toString() method."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same address as\n this object.\n \n Two instances of InetSocketAddress represent the same\n address if both the InetAddresses (or hostnames if it is unresolved) and port\n numbers are equal.\n If both addresses are unresolved, then the hostname and the port number\n are compared.\n\n Note: Hostnames are case insensitive. e.g. \"FooBar\" and \"foobar\" are\n considered equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hashcode for this socket address."
                }
              ]
            }
          ]
        },
        {
          "name": "InterfaceAddress",
          "methods": [
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getAddress()",
                  "description": "Returns an InetAddress for this address."
                }
              ]
            },
            {
              "name": "getBroadcast",
              "overloads": [
                {
                  "signature": "public InetAddress getBroadcast()",
                  "description": "Returns an InetAddress for the broadcast address\n for this InterfaceAddress.\n \n Only IPv4 networks have broadcast address therefore, in the case\n of an IPv6 network, null will be returned."
                }
              ]
            },
            {
              "name": "getNetworkPrefixLength",
              "overloads": [
                {
                  "signature": "public short getNetworkPrefixLength()",
                  "description": "Returns the network prefix length for this address. This is also known\n as the subnet mask in the context of IPv4 addresses.\n Typical IPv4 values would be 8 (255.0.0.0), 16 (255.255.0.0)\n or 24 (255.255.255.0). \n Typical IPv6 values would be 128 (::1/128) or 10 (fe80::203:baff:fe27:1243/10)"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same interface address as\n this object.\n \n Two instances of InterfaceAddress represent the same\n address if the InetAddress, the prefix length and the broadcast are\n the same for both."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this Interface address."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this Interface address to a String. The\n string returned is of the form: InetAddress / prefix length [ broadcast address ]."
                }
              ]
            }
          ]
        },
        {
          "name": "JarURLConnection",
          "methods": [
            {
              "name": "JarURLConnection",
              "overloads": [
                {
                  "signature": "protected JarURLConnection(URL url) throws MalformedURLException",
                  "description": "Creates the new JarURLConnection to the specified URL."
                }
              ]
            },
            {
              "name": "getJarFileURL",
              "overloads": [
                {
                  "signature": "public URL getJarFileURL()",
                  "description": "Returns the URL for the Jar file for this connection."
                }
              ]
            },
            {
              "name": "getEntryName",
              "overloads": [
                {
                  "signature": "public String getEntryName()",
                  "description": "Return the entry name for this connection. This method\n returns null if the JAR file URL corresponding to this\n connection points to a JAR file and not a JAR file entry."
                }
              ]
            },
            {
              "name": "getJarFile",
              "overloads": [
                {
                  "signature": "public abstract JarFile getJarFile() throws IOException",
                  "description": "Return the JAR file for this connection."
                }
              ]
            },
            {
              "name": "getManifest",
              "overloads": [
                {
                  "signature": "public Manifest getManifest() throws IOException",
                  "description": "Returns the Manifest for this connection, or null if none."
                }
              ]
            },
            {
              "name": "getJarEntry",
              "overloads": [
                {
                  "signature": "public JarEntry getJarEntry() throws IOException",
                  "description": "Return the JAR entry object for this connection, if any. This\n method returns null if the JAR file URL corresponding to this\n connection points to a JAR file and not a JAR file entry."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "public Attributes getAttributes() throws IOException",
                  "description": "Return the Attributes object for this connection if the URL\n for it points to a JAR file entry, null otherwise."
                }
              ]
            },
            {
              "name": "getMainAttributes",
              "overloads": [
                {
                  "signature": "public Attributes getMainAttributes() throws IOException",
                  "description": "Returns the main Attributes for the JAR file for this\n connection."
                }
              ]
            },
            {
              "name": "getCertificates",
              "overloads": [
                {
                  "signature": "public Certificate[] getCertificates() throws IOException",
                  "description": "Returns the Certificate objects for this connection if the URL\n for it points to a JAR file entry, null otherwise. This method\n can only be called once\n the connection has been completely verified by reading\n from the input stream until the end of the stream has been\n reached. Otherwise, this method will return null"
                }
              ]
            }
          ]
        },
        {
          "name": "MalformedURLException",
          "methods": [
            {
              "name": "MalformedURLException",
              "overloads": [
                {
                  "signature": "public MalformedURLException()",
                  "description": "Constructs a MalformedURLException with no detail message."
                },
                {
                  "signature": "public MalformedURLException(String msg)",
                  "description": "Constructs a MalformedURLException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "MulticastSocket",
          "methods": [
            {
              "name": "MulticastSocket",
              "overloads": [
                {
                  "signature": "public MulticastSocket() throws IOException",
                  "description": "Constructs a multicast socket and binds it to any available port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n \n If there is a security manager, its checkListen method is first\n called with 0 as its argument to ensure the operation is allowed. This\n could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is called to\n enable the SO_REUSEADDR socket option."
                },
                {
                  "signature": "public MulticastSocket(int port) throws IOException",
                  "description": "Constructs a multicast socket and binds it to the specified port\n on the local host machine. The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is\n called to enable the SO_REUSEADDR socket option."
                },
                {
                  "signature": "public MulticastSocket(SocketAddress bindaddr) throws IOException",
                  "description": "Creates a multicast socket, bound to the specified local\n socket address.\n \n If the address is null an unbound socket will be created.\n\n If there is a security manager,\n its checkListen method is first called\n with the SocketAddress port as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is\n called to enable the SO_REUSEADDR socket option."
                }
              ]
            },
            {
              "name": "setTTL",
              "overloads": [
                {
                  "signature": "@Deprecated public void setTTL(byte ttl) throws IOException",
                  "description": "Set the default time-to-live for multicast packets sent out\n on this MulticastSocket in order to control the\n scope of the multicasts.\n\n The ttl is an unsigned 8-bit quantity, and so must be\n in the range 0 <= ttl <= 0xFF .",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setTimeToLive",
              "overloads": [
                {
                  "signature": "public void setTimeToLive(int ttl) throws IOException",
                  "description": "Set the default time-to-live for multicast packets sent out\n on this MulticastSocket in order to control the\n scope of the multicasts.\n\n  The ttl must be in the range  0 <= ttl <=\n 255 or an IllegalArgumentException will be thrown.\n Multicast packets sent with a TTL of 0 are not transmitted\n on the network but may be delivered locally."
                }
              ]
            },
            {
              "name": "getTTL",
              "overloads": [
                {
                  "signature": "@Deprecated public byte getTTL() throws IOException",
                  "description": "Get the default time-to-live for multicast packets sent out on\n the socket.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "public int getTimeToLive() throws IOException",
                  "description": "Get the default time-to-live for multicast packets sent out on\n the socket."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void joinGroup(InetAddress mcastaddr) throws IOException",
                  "description": "Joins a multicast group. Its behavior may be affected by\n setInterface or setNetworkInterface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument.",
                  "deprecated": true
                },
                {
                  "signature": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Joins a multicast group.\n\n  In order to join a multicast group, the caller should specify\n the IP address of the multicast group to join, and the local\n network interface to receive multicast\n packets from.\n \n   The mcastaddr argument indicates the IP address\n   of the multicast group to join. For historical reasons this is\n   specified as a SocketAddress.\n   The default implementation only supports InetSocketAddress and\n   the port information is ignored.\n  \n   The netIf argument specifies the local interface to receive\n       multicast datagram packets, or null to defer to the interface\n       set for outgoing multicast datagrams.\n       If null, and no interface has been set, the behaviour is\n       unspecified: any interface may be selected or the operation may fail\n       with a SocketException.\n  \n \n\n  It is possible to call this method several times to join\n several different multicast groups, or join the same group\n in several different networks. However, if the socket is already a\n member of the group, an IOException will be thrown.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the mcastaddr\n argument as its argument."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void leaveGroup(InetAddress mcastaddr) throws IOException",
                  "description": "Leave a multicast group. Its behavior may be affected by\n setInterface or setNetworkInterface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument.",
                  "deprecated": true
                },
                {
                  "signature": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave a multicast group on a specified local interface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument."
                }
              ]
            },
            {
              "name": "setInterface",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void setInterface(InetAddress inf) throws SocketException",
                  "description": "Set the multicast network interface used by methods\n whose behavior would be affected by the value of the\n network interface. Useful for multihomed hosts.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getInterface",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public InetAddress getInterface() throws SocketException",
                  "description": "Retrieve the address of the network interface used for\n multicast packets.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setNetworkInterface",
              "overloads": [
                {
                  "signature": "public void setNetworkInterface(NetworkInterface netIf) throws SocketException",
                  "description": "Specify the network interface for outgoing multicast datagrams\n sent on this socket."
                }
              ]
            },
            {
              "name": "getNetworkInterface",
              "overloads": [
                {
                  "signature": "public NetworkInterface getNetworkInterface() throws SocketException",
                  "description": "Get the multicast network interface set for outgoing multicast\n datagrams sent from this socket."
                }
              ]
            },
            {
              "name": "setLoopbackMode",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void setLoopbackMode(boolean disable) throws SocketException",
                  "description": "Disable/Enable local loopback of multicast datagrams.\n The option is used by the platform's networking code as a hint\n for setting whether multicast data will be looped back to\n the local socket.\n\n Because this option is a hint, applications that want to\n verify what loopback mode is set to should call\n getLoopbackMode()",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getLoopbackMode",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public boolean getLoopbackMode() throws SocketException",
                  "description": "Get the setting for local loopback of multicast datagrams.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "@Deprecated public void send(DatagramPacket p, byte ttl) throws IOException",
                  "description": "Sends a datagram packet to the destination, with a TTL (time-to-live)\n other than the default for the socket.  This method\n need only be used in instances where a particular TTL is desired;\n otherwise it is preferable to set a TTL once on the socket, and\n use that default TTL for all packets.  This method does not\n  alter the default TTL for the socket. Its behavior may be\n affected by setInterface.\n\n If there is a security manager, this method first performs some\n security checks. First, if p.getAddress().isMulticastAddress()\n is true, this method calls the\n security manager's checkMulticast method\n with p.getAddress() and ttl as its arguments.\n If the evaluation of that expression is false,\n this method instead calls the security manager's\n checkConnect method with arguments\n p.getAddress().getHostAddress() and\n p.getPort(). Each call to a security manager method\n could result in a SecurityException if the operation is not allowed.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "NetPermission",
          "methods": [
            {
              "name": "NetPermission",
              "overloads": [
                {
                  "signature": "public NetPermission(String name)",
                  "description": "Creates a new NetPermission with the specified name.\n The name is the symbolic name of the NetPermission, such as\n \"setDefaultAuthenticator\", etc. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match."
                },
                {
                  "signature": "public NetPermission(String name, String actions)",
                  "description": "Creates a new NetPermission object with the specified name.\n The name is the symbolic name of the NetPermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "NetworkInterface",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Get the name of this network interface."
                }
              ]
            },
            {
              "name": "getInetAddresses",
              "overloads": [
                {
                  "signature": "public Enumeration<InetAddress> getInetAddresses()",
                  "description": "Get an Enumeration with all or a subset of the InetAddresses bound to\n this network interface.\n \n If there is a security manager, its checkConnect\n method is called for each InetAddress. Only InetAddresses where\n the checkConnect doesn't throw a SecurityException\n will be returned in the Enumeration. However, if the caller has the\n NetPermission(\"getNetworkInformation\") permission, then all\n InetAddresses are returned."
                }
              ]
            },
            {
              "name": "inetAddresses",
              "overloads": [
                {
                  "signature": "public Stream<InetAddress> inetAddresses()",
                  "description": "Get a Stream of all or a subset of the InetAddresses bound to this\n network interface.\n \n If there is a security manager, its checkConnect\n method is called for each InetAddress. Only InetAddresses where\n the checkConnect doesn't throw a SecurityException will be\n returned in the Stream. However, if the caller has the\n NetPermission(\"getNetworkInformation\") permission, then all\n InetAddresses are returned."
                }
              ]
            },
            {
              "name": "getInterfaceAddresses",
              "overloads": [
                {
                  "signature": "public List<InterfaceAddress> getInterfaceAddresses()",
                  "description": "Get a List of all or a subset of the InterfaceAddresses\n of this network interface.\n \n If there is a security manager, its checkConnect\n method is called with the InetAddress for each InterfaceAddress.\n Only InterfaceAddresses where the checkConnect doesn't throw\n a SecurityException will be returned in the List."
                }
              ]
            },
            {
              "name": "getSubInterfaces",
              "overloads": [
                {
                  "signature": "public Enumeration<NetworkInterface> getSubInterfaces()",
                  "description": "Get an Enumeration with all the subinterfaces (also known as virtual\n interfaces) attached to this network interface.\n \n For instance eth0:1 will be a subinterface to eth0."
                }
              ]
            },
            {
              "name": "subInterfaces",
              "overloads": [
                {
                  "signature": "public Stream<NetworkInterface> subInterfaces()",
                  "description": "Get a Stream of all subinterfaces (also known as virtual\n interfaces) attached to this network interface."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public NetworkInterface getParent()",
                  "description": "Returns the parent NetworkInterface of this interface if this is\n a subinterface, or null if it is a physical\n (non virtual) interface or has no parent."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Returns the index of this network interface. The index is an integer greater\n or equal to zero, or -1 for unknown. This is a system specific value\n and interfaces with the same name can have different indexes on different\n machines."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName()",
                  "description": "Get the display name of this network interface.\n A display name is a human readable String describing the network\n device."
                }
              ]
            },
            {
              "name": "getByName",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByName(String name) throws SocketException",
                  "description": "Searches for the network interface with the specified name."
                }
              ]
            },
            {
              "name": "getByIndex",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByIndex(int index) throws SocketException",
                  "description": "Get a network interface given its index."
                }
              ]
            },
            {
              "name": "getByInetAddress",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByInetAddress(InetAddress addr) throws SocketException",
                  "description": "Convenience method to search for a network interface that\n has the specified Internet Protocol (IP) address bound to\n it.\n \n If the specified IP address is bound to multiple network\n interfaces it is not defined which network interface is\n returned."
                }
              ]
            },
            {
              "name": "getNetworkInterfaces",
              "overloads": [
                {
                  "signature": "public static Enumeration<NetworkInterface> getNetworkInterfaces() throws SocketException",
                  "description": "Returns an Enumeration of all the interfaces on this machine. The\n Enumeration contains at least one element, possibly representing\n a loopback interface that only supports communication between entities on\n this machine."
                }
              ]
            },
            {
              "name": "networkInterfaces",
              "overloads": [
                {
                  "signature": "public static Stream<NetworkInterface> networkInterfaces() throws SocketException",
                  "description": "Returns a Stream of all the interfaces on this machine.  The\n Stream contains at least one interface, possibly representing a\n loopback interface that only supports communication between entities on\n this machine."
                }
              ]
            },
            {
              "name": "isUp",
              "overloads": [
                {
                  "signature": "public boolean isUp() throws SocketException",
                  "description": "Returns whether a network interface is up and running."
                }
              ]
            },
            {
              "name": "isLoopback",
              "overloads": [
                {
                  "signature": "public boolean isLoopback() throws SocketException",
                  "description": "Returns whether a network interface is a loopback interface."
                }
              ]
            },
            {
              "name": "isPointToPoint",
              "overloads": [
                {
                  "signature": "public boolean isPointToPoint() throws SocketException",
                  "description": "Returns whether a network interface is a point to point interface.\n A typical point to point interface would be a PPP connection through\n a modem."
                }
              ]
            },
            {
              "name": "supportsMulticast",
              "overloads": [
                {
                  "signature": "public boolean supportsMulticast() throws SocketException",
                  "description": "Returns whether a network interface supports multicasting or not."
                }
              ]
            },
            {
              "name": "getHardwareAddress",
              "overloads": [
                {
                  "signature": "public byte[] getHardwareAddress() throws SocketException",
                  "description": "Returns the hardware address (usually MAC) of the interface if it\n has one and if it can be accessed given the current privileges.\n If a security manager is set, then the caller must have\n the permission NetPermission(\"getNetworkInformation\")."
                }
              ]
            },
            {
              "name": "getMTU",
              "overloads": [
                {
                  "signature": "public int getMTU() throws SocketException",
                  "description": "Returns the Maximum Transmission Unit (MTU) of this interface."
                }
              ]
            },
            {
              "name": "isVirtual",
              "overloads": [
                {
                  "signature": "public boolean isVirtual()",
                  "description": "Returns whether this interface is a virtual interface (also called\n subinterface).\n Virtual interfaces are, on some systems, interfaces created as a child\n of a physical interface and given different settings (like address or\n MTU). Usually the name of the interface will the name of the parent\n followed by a colon (:) and a number identifying the child since there\n can be several virtual interfaces attached to a single physical\n interface."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same NetworkInterface\n as this object.\n \n Two instances of NetworkInterface represent the same\n NetworkInterface if both the name and the set of InetAddresses\n bound to the interfaces are equal."
                }
              ]
            }
          ]
        },
        {
          "name": "NoRouteToHostException",
          "methods": [
            {
              "name": "NoRouteToHostException",
              "overloads": [
                {
                  "signature": "public NoRouteToHostException(String msg)",
                  "description": "Constructs a new NoRouteToHostException with the specified detail\n message as to why the remote host cannot be reached.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public NoRouteToHostException()",
                  "description": "Construct a new NoRouteToHostException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "PasswordAuthentication",
          "methods": [
            {
              "name": "PasswordAuthentication",
              "overloads": [
                {
                  "signature": "public PasswordAuthentication(String userName, char[] password)",
                  "description": "Creates a new PasswordAuthentication object from the given\n user name and password.\n\n  Note that the given user password is cloned before it is stored in\n the new PasswordAuthentication object."
                }
              ]
            },
            {
              "name": "getUserName",
              "overloads": [
                {
                  "signature": "public String getUserName()",
                  "description": "Returns the user name."
                }
              ]
            },
            {
              "name": "getPassword",
              "overloads": [
                {
                  "signature": "public char[] getPassword()",
                  "description": "Returns the user password.\n\n  Note that this method returns a reference to the password. It is\n the caller's responsibility to zero out the password information after\n it is no longer needed."
                }
              ]
            }
          ]
        },
        {
          "name": "PortUnreachableException",
          "methods": [
            {
              "name": "PortUnreachableException",
              "overloads": [
                {
                  "signature": "public PortUnreachableException(String msg)",
                  "description": "Constructs a new PortUnreachableException with a\n detail message."
                },
                {
                  "signature": "public PortUnreachableException()",
                  "description": "Construct a new PortUnreachableException with no\n detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "ProtocolException",
          "methods": [
            {
              "name": "ProtocolException",
              "overloads": [
                {
                  "signature": "public ProtocolException(String message)",
                  "description": "Constructs a new ProtocolException with the\n specified detail message."
                },
                {
                  "signature": "public ProtocolException()",
                  "description": "Constructs a new ProtocolException with no detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ProtocolFamily",
          "methods": [
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "String name()",
                  "description": "Returns the name of the protocol family."
                }
              ]
            }
          ]
        },
        {
          "name": "Proxy",
          "methods": [
            {
              "name": "Proxy",
              "overloads": [
                {
                  "signature": "public Proxy(Proxy.Type type, SocketAddress sa)",
                  "description": "Creates an entry representing a PROXY connection.\n Certain combinations are illegal. For instance, for types Http, and\n Socks, a SocketAddress must be provided.\n \n Use the Proxy.NO_PROXY constant\n for representing a direct connection."
                }
              ]
            },
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "public Proxy.Type type()",
                  "description": "Returns the proxy type."
                }
              ]
            },
            {
              "name": "address",
              "overloads": [
                {
                  "signature": "public SocketAddress address()",
                  "description": "Returns the socket address of the proxy, or\n null if its a direct connection."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this Proxy.\n This String is constructed by calling toString() on its type\n and concatenating \" @ \" and the toString() result from its address\n if its type is not DIRECT."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same proxy as\n this object.\n \n Two instances of Proxy represent the same\n address if both the SocketAddresses and type are equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hashcode for this Proxy."
                }
              ]
            }
          ]
        },
        {
          "name": "ProxySelector",
          "methods": [
            {
              "name": "ProxySelector",
              "overloads": [
                {
                  "signature": "public ProxySelector()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static ProxySelector getDefault()",
                  "description": "Gets the system-wide proxy selector."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(ProxySelector ps)",
                  "description": "Sets (or unsets) the system-wide proxy selector.\n\n Note: non-standard protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "select",
              "overloads": [
                {
                  "signature": "public abstract List<Proxy> select(URI uri)",
                  "description": "Selects all the applicable proxies based on the protocol to\n access the resource with and a destination address to access\n the resource at.\n The format of the URI is defined as follow:\n \n http URI for http connections\n https URI for https connections\n socket://host:port\n     for tcp client sockets connections"
                }
              ]
            },
            {
              "name": "connectFailed",
              "overloads": [
                {
                  "signature": "public abstract void connectFailed(URI uri, SocketAddress sa, IOException ioe)",
                  "description": "Called to indicate that a connection could not be established\n to a proxy/socks server. An implementation of this method can\n temporarily remove the proxies or reorder the sequence of\n proxies returned by select(URI), using the address\n and the IOException caught when trying to connect."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static ProxySelector of(InetSocketAddress proxyAddress)",
                  "description": "Returns a ProxySelector which uses the given proxy address for all HTTP\n and HTTPS requests. If proxy is null then proxying is disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "ResponseCache",
          "methods": [
            {
              "name": "ResponseCache",
              "overloads": [
                {
                  "signature": "public ResponseCache()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static ResponseCache getDefault()",
                  "description": "Gets the system-wide response cache."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(ResponseCache responseCache)",
                  "description": "Sets (or unsets) the system-wide cache.\n\n Note: non-standard protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract CacheResponse get(URI uri, String rqstMethod, Map<String,List<String>> rqstHeaders) throws IOException",
                  "description": "Retrieve the cached response based on the requesting uri,\n request method and request headers. Typically this method is\n called by the protocol handler before it sends out the request\n to get the network resource. If a cached response is returned,\n that resource is used instead."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract CacheRequest put(URI uri, URLConnection conn) throws IOException",
                  "description": "The protocol handler calls this method after a resource has\n been retrieved, and the ResponseCache must decide whether or\n not to store the resource in its cache. If the resource is to\n be cached, then put() must return a CacheRequest object which\n contains an OutputStream that the protocol handler will\n use to write the resource into the cache. If the resource is\n not to be cached, then put must return null."
                }
              ]
            }
          ]
        },
        {
          "name": "SecureCacheResponse",
          "methods": [
            {
              "name": "SecureCacheResponse",
              "overloads": [
                {
                  "signature": "public SecureCacheResponse()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getCipherSuite",
              "overloads": [
                {
                  "signature": "public abstract String getCipherSuite()",
                  "description": "Returns the cipher suite in use on the original connection that\n retrieved the network resource."
                }
              ]
            },
            {
              "name": "getLocalCertificateChain",
              "overloads": [
                {
                  "signature": "public abstract List<Certificate> getLocalCertificateChain()",
                  "description": "Returns the certificate chain that were sent to the server during\n handshaking of the original connection that retrieved the\n network resource.  Note: This method is useful only\n when using certificate-based cipher suites."
                }
              ]
            },
            {
              "name": "getServerCertificateChain",
              "overloads": [
                {
                  "signature": "public abstract List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException",
                  "description": "Returns the server's certificate chain, which was established as\n part of defining the session in the original connection that\n retrieved the network resource, from cache.  Note: This method\n can be used only when using certificate-based cipher suites;\n using it with non-certificate-based cipher suites, such as\n Kerberos, will throw an SSLPeerUnverifiedException."
                }
              ]
            },
            {
              "name": "getPeerPrincipal",
              "overloads": [
                {
                  "signature": "public abstract Principal getPeerPrincipal() throws SSLPeerUnverifiedException",
                  "description": "Returns the server's principal which was established as part of\n defining the session during the original connection that\n retrieved the network resource."
                }
              ]
            },
            {
              "name": "getLocalPrincipal",
              "overloads": [
                {
                  "signature": "public abstract Principal getLocalPrincipal()",
                  "description": "Returns the principal that was sent to the server during\n handshaking in the original connection that retrieved the\n network resource."
                }
              ]
            },
            {
              "name": "getSSLSession",
              "overloads": [
                {
                  "signature": "public Optional<SSLSession> getSSLSession()",
                  "description": "Returns an Optional containing the SSLSession in\n use on the original connection that retrieved the network resource.\n Returns an empty Optional if the underlying implementation\n does not support this method."
                }
              ]
            }
          ]
        },
        {
          "name": "ServerSocket",
          "methods": [
            {
              "name": "ServerSocket",
              "overloads": [
                {
                  "signature": "protected ServerSocket(SocketImpl impl)",
                  "description": "Creates a server socket with a user-specified SocketImpl."
                },
                {
                  "signature": "public ServerSocket() throws IOException",
                  "description": "Creates an unbound server socket."
                },
                {
                  "signature": "public ServerSocket(int port) throws IOException",
                  "description": "Creates a server socket, bound to the specified port. A port number\n of 0 means that the port number is automatically\n allocated, typically from an ephemeral port range. This port\n number can then be retrieved by calling getLocalPort.\n \n The maximum queue length for incoming connection indications (a\n request to connect) is set to 50. If a connection\n indication arrives when the queue is full, the connection is refused.\n \n If the application has specified a server socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager,\n its checkListen method is called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public ServerSocket(int port, int backlog) throws IOException",
                  "description": "Creates a server socket and binds it to the specified local port\n number, with the specified backlog.\n A port number of 0 means that the port number is\n automatically allocated, typically from an ephemeral port range.\n This port number can then be retrieved by calling\n getLocalPort.\n \n The maximum queue length for incoming connection indications (a\n request to connect) is set to the backlog parameter. If\n a connection indication arrives when the queue is full, the\n connection is refused.\n \n If the application has specified a server socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager,\n its checkListen method is called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n\n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                },
                {
                  "signature": "public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException",
                  "description": "Create a server with the specified port, listen backlog, and\n local IP address to bind to.  The bindAddr argument\n can be used on a multi-homed host for a ServerSocket that\n will only accept connect requests to one of its addresses.\n If bindAddr is null, it will default accepting\n connections on any/all local addresses.\n The port must be between 0 and 65535, inclusive.\n A port number of 0 means that the port number is\n automatically allocated, typically from an ephemeral port range.\n This port number can then be retrieved by calling\n getLocalPort.\n\n If there is a security manager, this method\n calls its checkListen method\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n\n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress endpoint) throws IOException",
                  "description": "Binds the ServerSocket to a specific address\n (IP address and port number).\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                },
                {
                  "signature": "public void bind(SocketAddress endpoint, int backlog) throws IOException",
                  "description": "Binds the ServerSocket to a specific address\n (IP address and port number).\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket.\n \n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the local address of this server socket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the local address\n after the socket is closed.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n the loopback address is returned."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the port number on which this socket is listening.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the address of the endpoint\n after the socket is closed.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a SocketAddress representing the\n loopback address and the local\n port to which the socket is bound is returned."
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "public Socket accept() throws IOException",
                  "description": "Listens for a connection to be made to this socket and accepts\n it. The method blocks until a connection is made.\n\n A new Socket s is created and, if there\n is a security manager,\n the security manager's checkAccept method is called\n with s.getInetAddress().getHostAddress() and\n s.getPort()\n as its arguments to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "implAccept",
              "overloads": [
                {
                  "signature": "protected final void implAccept(Socket s) throws IOException",
                  "description": "Subclasses of ServerSocket use this method to override accept()\n to return their own subclass of socket.  So a FooServerSocket\n will typically hand this method a newly created, unbound, FooSocket.\n On return from implAccept the FooSocket will be connected to a client.\n\n  The behavior of this method is unspecified when invoked with a\n socket that is not newly created and unbound. Any socket options set\n on the given socket prior to invoking this method may or may not be\n preserved when the connection is accepted. It may not be possible to\n accept a connection when this socket has a SocketImpl of one\n type and the given socket has a SocketImpl of a completely\n different type."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this socket.\n\n Any thread currently blocked in accept() will throw\n a SocketException.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public ServerSocketChannel getChannel()",
                  "description": "Returns the unique ServerSocketChannel object\n associated with this socket, if any.\n\n  A server socket will have a channel if, and only if, the channel\n itself was created via the ServerSocketChannel.open\n method."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the ServerSocket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns the closed state of the ServerSocket."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT with the\n specified timeout, in milliseconds.  With this option set to a positive\n timeout value, a call to accept() for this ServerSocket\n will block for only this amount of time.  If the timeout expires,\n a java.net.SocketTimeoutException is raised, though the\n ServerSocket is still valid. A timeout of zero is interpreted as an\n infinite timeout.\n The option must be enabled prior to entering the blocking\n operation to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws IOException",
                  "description": "Retrieve setting for SO_TIMEOUT.\n 0 returns implies that the option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR\n socket option.\n \n When a TCP connection is closed the connection may remain\n in a timeout state for a period of time after the connection\n is closed (typically known as the TIME_WAIT state\n or 2MSL wait state).\n For applications using a well known socket address or port\n it may not be possible to bind a socket to the required\n SocketAddress if there is a connection in the\n timeout state involving the socket address or port.\n \n Enabling SO_REUSEADDR prior to\n binding the socket using bind(SocketAddress) allows the socket\n to be bound even though a previous connection is in a timeout state.\n \n When a ServerSocket is created the initial setting\n of SO_REUSEADDR is not defined.\n Applications can use getReuseAddress() to determine the initial\n setting of SO_REUSEADDR.\n \n The behaviour when SO_REUSEADDR is\n enabled or disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the implementation address and implementation port of\n this socket as a String.\n \n If there is a security manager set, and this socket is\n bound, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n an InetAddress representing the\n loopback address is returned as\n the implementation address."
                }
              ]
            },
            {
              "name": "setSocketFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setSocketFactory(SocketImplFactory fac) throws IOException",
                  "description": "Sets the server socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new server socket, the socket\n implementation factory's createSocketImpl method is\n called to create the actual socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets a default proposed value for the\n SO_RCVBUF option for sockets\n accepted from this ServerSocket. The value actually set\n in the accepted socket must be determined by calling\n Socket.getReceiveBufferSize() after the socket\n is returned by accept().\n \n The value of SO_RCVBUF is used both to\n set the size of the internal socket receive buffer, and to set the size\n of the TCP receive window that is advertised to the remote peer.\n \n It is possible to change the value subsequently, by calling\n Socket.setReceiveBufferSize(int). However, if the application\n wishes to allow a receive window larger than 64K bytes, as defined by RFC1323\n then the proposed value must be set in the ServerSocket before\n it is bound to a local address. This implies, that the ServerSocket must be\n created with the no-argument constructor, then setReceiveBufferSize() must\n be called and lastly the ServerSocket is bound to an address by calling bind().\n \n Failure to do this will not cause an error, and the buffer size may be set to the\n requested value but the TCP receive window in sockets accepted from\n this ServerSocket will be no larger than 64K bytes."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Gets the value of the SO_RCVBUF option\n for this ServerSocket, that is the proposed buffer size that\n will be used for Sockets accepted from this ServerSocket.\n\n Note, the value actually set in the accepted socket is determined by\n calling Socket.getReceiveBufferSize()."
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this ServerSocket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences.  If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n  Invoking this method after this socket has been bound\n will have no effect. This implies that in order to use this capability\n requires the socket to be created with the no-argument constructor."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> ServerSocket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this server socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            }
          ]
        },
        {
          "name": "Socket",
          "methods": [
            {
              "name": "Socket",
              "overloads": [
                {
                  "signature": "public Socket()",
                  "description": "Creates an unconnected Socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created."
                },
                {
                  "signature": "public Socket(Proxy proxy)",
                  "description": "Creates an unconnected socket, specifying the type of proxy, if any,\n that should be used regardless of any other settings.\n \n If there is a security manager, its checkConnect method\n is called with the proxy host address and port number\n as its arguments. This could result in a SecurityException.\n \n Examples:\n  Socket s = new Socket(Proxy.NO_PROXY); will create\n a plain socket ignoring any other proxy configuration.\n Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(\"socks.mydom.com\", 1080)));\n will create a socket connecting through the specified SOCKS proxy\n server."
                },
                {
                  "signature": "protected Socket(SocketImpl impl) throws SocketException",
                  "description": "Creates an unconnected Socket with a user-specified\n SocketImpl."
                },
                {
                  "signature": "public Socket(String host, int port) throws UnknownHostException, IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number on the named host.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(InetAddress address, int port) throws IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number at the specified IP address.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException",
                  "description": "Creates a socket and connects it to the specified remote host on\n the specified remote port. The Socket will also bind() to the local\n address and port supplied.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n A local port number of zero will let the system pick up a\n free port in the bind operation.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException",
                  "description": "Creates a socket and connects it to the specified remote address on\n the specified remote port. The Socket will also bind() to the local\n address and port supplied.\n \n If the specified local address is null it is the equivalent of\n specifying the address as the AnyLocal address\n (see InetAddress.isAnyLocalAddress()).\n \n A local port number of zero will let the system pick up a\n free port in the bind operation.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "@Deprecated public Socket(String host, int port, boolean stream) throws IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number on the named host.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n If the stream argument is true, this creates a\n stream socket. If the stream argument is false, it\n creates a datagram socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException.\n \n If a UDP socket is used, TCP/IP related socket options will not apply.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated public Socket(InetAddress host, int port, boolean stream) throws IOException",
                  "description": "Creates a socket and connects it to the specified port number at\n the specified IP address.\n \n If the stream argument is true, this creates a\n stream socket. If the stream argument is false, it\n creates a datagram socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n\n If there is a security manager, its\n checkConnect method is called\n with host.getHostAddress() and port\n as its arguments. This could result in a SecurityException.\n \n If UDP socket is used, TCP/IP related socket options will not apply.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(SocketAddress endpoint) throws IOException",
                  "description": "Connects this socket to the server."
                },
                {
                  "signature": "public void connect(SocketAddress endpoint, int timeout) throws IOException",
                  "description": "Connects this socket to the server with a specified timeout value.\n A timeout of zero is interpreted as an infinite timeout. The connection\n will then block until established or an error occurs."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress bindpoint) throws IOException",
                  "description": "Binds the socket to a local address.\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the address to which the socket is connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getLocalAddress()",
                  "description": "Gets the local address to which the socket is bound.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n the loopback address is returned."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the remote port number to which this socket is connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the local port number to which this socket is bound.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the local port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getRemoteSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getRemoteSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to.\n \n If a socket bound to an endpoint represented by an\n InetSocketAddress  is closed,\n then this method will continue to return an InetSocketAddress\n after the socket is closed. In that case the returned\n InetSocketAddress's address is the\n wildcard address\n and its port is the local port that it was bound to.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a SocketAddress representing the\n loopback address and the local\n port to which this socket is bound is returned."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public SocketChannel getChannel()",
                  "description": "Returns the unique SocketChannel\n object associated with this socket, if any.\n\n  A socket will have a channel if, and only if, the channel itself was\n created via the SocketChannel.open or ServerSocketChannel.accept\n methods."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream for this socket.\n\n  If this socket has an associated channel then the resulting input\n stream delegates all of its operations to the channel.  If the channel\n is in non-blocking mode then the input stream's read operations\n will throw an IllegalBlockingModeException.\n\n Under abnormal conditions the underlying connection may be\n broken by the remote host or the network software (for example\n a connection reset in the case of TCP connections). When a\n broken connection is detected by the network software the\n following applies to the returned input stream :-\n\n \n\n   The network software may discard bytes that are buffered\n   by the socket. Bytes that aren't discarded by the network\n   software can be read using read.\n\n   If there are no bytes buffered on the socket, or all\n   buffered bytes have been consumed by\n   read, then all subsequent\n   calls to read will throw an\n   IOException.\n\n   If there are no bytes buffered on the socket, and the\n   socket has not been closed using close, then\n   available will\n   return 0.\n\n \n\n  Closing the returned InputStream\n will close the associated socket."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream for this socket.\n\n  If this socket has an associated channel then the resulting output\n stream delegates all of its operations to the channel.  If the channel\n is in non-blocking mode then the output stream's write\n operations will throw an IllegalBlockingModeException.\n\n  Closing the returned OutputStream\n will close the associated socket."
                }
              ]
            },
            {
              "name": "setTcpNoDelay",
              "overloads": [
                {
                  "signature": "public void setTcpNoDelay(boolean on) throws SocketException",
                  "description": "Enable/disable TCP_NODELAY\n (disable/enable Nagle's algorithm)."
                }
              ]
            },
            {
              "name": "getTcpNoDelay",
              "overloads": [
                {
                  "signature": "public boolean getTcpNoDelay() throws SocketException",
                  "description": "Tests if TCP_NODELAY is enabled."
                }
              ]
            },
            {
              "name": "setSoLinger",
              "overloads": [
                {
                  "signature": "public void setSoLinger(boolean on, int linger) throws SocketException",
                  "description": "Enable/disable SO_LINGER with the\n specified linger time in seconds. The maximum timeout value is platform\n specific.\n\n The setting only affects socket close."
                }
              ]
            },
            {
              "name": "getSoLinger",
              "overloads": [
                {
                  "signature": "public int getSoLinger() throws SocketException",
                  "description": "Returns setting for SO_LINGER.\n -1 returns implies that the\n option is disabled.\n\n The setting only affects socket close."
                }
              ]
            },
            {
              "name": "sendUrgentData",
              "overloads": [
                {
                  "signature": "public void sendUrgentData(int data) throws IOException",
                  "description": "Send one byte of urgent data on the socket. The byte to be sent is the lowest eight\n bits of the data parameter. The urgent byte is\n sent after any preceding writes to the socket OutputStream\n and before any future writes to the OutputStream."
                }
              ]
            },
            {
              "name": "setOOBInline",
              "overloads": [
                {
                  "signature": "public void setOOBInline(boolean on) throws SocketException",
                  "description": "Enable/disable SO_OOBINLINE\n (receipt of TCP urgent data)\n\n By default, this option is disabled and TCP urgent data received on a\n socket is silently discarded. If the user wishes to receive urgent data, then\n this option must be enabled. When enabled, urgent data is received\n inline with normal data.\n \n Note, only limited support is provided for handling incoming urgent\n data. In particular, no notification of incoming urgent data is provided\n and there is no capability to distinguish between normal data and urgent\n data unless provided by a higher level protocol."
                }
              ]
            },
            {
              "name": "getOOBInline",
              "overloads": [
                {
                  "signature": "public boolean getOOBInline() throws SocketException",
                  "description": "Tests if SO_OOBINLINE is enabled."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT\n  with the specified timeout, in milliseconds. With this option set\n  to a positive timeout value, a read() call on the InputStream associated with\n  this Socket will block for only this amount of time.  If the timeout\n  expires, a java.net.SocketTimeoutException is raised, though the\n  Socket is still valid. A timeout of zero is interpreted as an infinite timeout.\n  The option must be enabled prior to entering the blocking operation\n  to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws SocketException",
                  "description": "Returns setting for SO_TIMEOUT.\n 0 returns implies that the option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setSendBufferSize",
              "overloads": [
                {
                  "signature": "public void setSendBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_SNDBUF option to the\n specified value for this Socket.\n The SO_SNDBUF option is used by the\n platform's networking code as a hint for the size to set the underlying\n network I/O buffers.\n\n Because SO_SNDBUF is a hint,\n applications that want to verify what size the buffers were set to\n should call getSendBufferSize()."
                }
              ]
            },
            {
              "name": "getSendBufferSize",
              "overloads": [
                {
                  "signature": "public int getSendBufferSize() throws SocketException",
                  "description": "Get value of the SO_SNDBUF option\n for this Socket, that is the buffer size used by the platform\n for output on this Socket."
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_RCVBUF option to the\n specified value for this Socket. The\n SO_RCVBUF option is\n used by the platform's networking code as a hint for the size to set\n the underlying network I/O buffers.\n\n Increasing the receive buffer size can increase the performance of\n network I/O for high-volume connection, while decreasing it can\n help reduce the backlog of incoming data.\n\n Because SO_RCVBUF is a hint,\n applications that want to verify what size the buffers were set to\n should call getReceiveBufferSize().\n\n The value of SO_RCVBUF is also used\n to set the TCP receive window that is advertised to the remote peer.\n Generally, the window size can be modified at any time when a socket is\n connected. However, if a receive window larger than 64K is required then\n this must be requested before the socket is connected to the\n remote peer. There are two cases to be aware of:\n \n For sockets accepted from a ServerSocket, this must be done by calling\n ServerSocket.setReceiveBufferSize(int) before the ServerSocket\n is bound to a local address.\n For client sockets, setReceiveBufferSize() must be called before\n connecting the socket to its remote peer."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Gets the value of the SO_RCVBUF option\n for this Socket, that is the buffer size used by the platform\n for input on this Socket."
                }
              ]
            },
            {
              "name": "setKeepAlive",
              "overloads": [
                {
                  "signature": "public void setKeepAlive(boolean on) throws SocketException",
                  "description": "Enable/disable SO_KEEPALIVE."
                }
              ]
            },
            {
              "name": "getKeepAlive",
              "overloads": [
                {
                  "signature": "public boolean getKeepAlive() throws SocketException",
                  "description": "Tests if SO_KEEPALIVE is enabled."
                }
              ]
            },
            {
              "name": "setTrafficClass",
              "overloads": [
                {
                  "signature": "public void setTrafficClass(int tc) throws SocketException",
                  "description": "Sets traffic class or type-of-service octet in the IP\n header for packets sent from this Socket.\n As the underlying network implementation may ignore this\n value applications should consider it a hint.\n\n  The tc must be in the range 0 <= tc <=\n 255 or an IllegalArgumentException will be thrown.\n Notes:\n For Internet Protocol v4 the value consists of an\n integer, the least significant 8 bits of which\n represent the value of the TOS octet in IP packets sent by\n the socket.\n RFC 1349 defines the TOS values as follows:\n\n \n IPTOS_LOWCOST (0x02)\n IPTOS_RELIABILITY (0x04)\n IPTOS_THROUGHPUT (0x08)\n IPTOS_LOWDELAY (0x10)\n \n The last low order bit is always ignored as this\n corresponds to the MBZ (must be zero) bit.\n \n Setting bits in the precedence field may result in a\n SocketException indicating that the operation is not\n permitted.\n \n As RFC 1122 section 4.2.4.2 indicates, a compliant TCP\n implementation should, but is not required to, let application\n change the TOS field during the lifetime of a connection.\n So whether the type-of-service field can be changed after the\n TCP connection has been established depends on the implementation\n in the underlying platform. Applications should not assume that\n they can change the TOS field after the connection.\n \n For Internet Protocol v6 tc is the value that\n would be placed into the sin6_flowinfo field of the IP header."
                }
              ]
            },
            {
              "name": "getTrafficClass",
              "overloads": [
                {
                  "signature": "public int getTrafficClass() throws SocketException",
                  "description": "Gets traffic class or type-of-service in the IP header\n for packets sent from this Socket\n \n As the underlying network implementation may ignore the\n traffic class or type-of-service set using setTrafficClass(int)\n this method may return a different value than was previously\n set using the setTrafficClass(int) method on this Socket."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR\n socket option.\n \n When a TCP connection is closed the connection may remain\n in a timeout state for a period of time after the connection\n is closed (typically known as the TIME_WAIT state\n or 2MSL wait state).\n For applications using a well known socket address or port\n it may not be possible to bind a socket to the required\n SocketAddress if there is a connection in the\n timeout state involving the socket address or port.\n \n Enabling SO_REUSEADDR\n prior to binding the socket using bind(SocketAddress) allows\n the socket to be bound even though a previous connection is in a timeout\n state.\n \n When a Socket is created the initial setting\n of SO_REUSEADDR is disabled.\n \n The behaviour when SO_REUSEADDR is\n enabled or disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this socket.\n \n Any thread currently blocked in an I/O operation upon this socket\n will throw a SocketException.\n \n Once a socket has been closed, it is not available for further networking\n use (i.e. can't be reconnected or rebound). A new socket needs to be\n created.\n\n  Closing this socket will also close the socket's\n InputStream and\n OutputStream.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "shutdownInput",
              "overloads": [
                {
                  "signature": "public void shutdownInput() throws IOException",
                  "description": "Places the input stream for this socket at \"end of stream\".\n Any data sent to the input stream side of the socket is acknowledged\n and then silently discarded.\n \n If you read from a socket input stream after invoking this method on the\n socket, the stream's available method will return 0, and its\n read methods will return -1 (end of stream)."
                }
              ]
            },
            {
              "name": "shutdownOutput",
              "overloads": [
                {
                  "signature": "public void shutdownOutput() throws IOException",
                  "description": "Disables the output stream for this socket.\n For a TCP socket, any previously written data will be sent\n followed by TCP's normal connection termination sequence.\n\n If you write to a socket output stream after invoking\n shutdownOutput() on the socket, the stream will throw\n an IOException."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this socket to a String."
                }
              ]
            },
            {
              "name": "isConnected",
              "overloads": [
                {
                  "signature": "public boolean isConnected()",
                  "description": "Returns the connection state of the socket.\n \n Note: Closing a socket doesn't clear its connection state, which means\n this method will return true for a closed socket\n (see isClosed()) if it was successfully connected prior\n to being closed."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the socket.\n \n Note: Closing a socket doesn't clear its binding state, which means\n this method will return true for a closed socket\n (see isClosed()) if it was successfully bound prior\n to being closed."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns the closed state of the socket."
                }
              ]
            },
            {
              "name": "isInputShutdown",
              "overloads": [
                {
                  "signature": "public boolean isInputShutdown()",
                  "description": "Returns whether the read-half of the socket connection is closed."
                }
              ]
            },
            {
              "name": "isOutputShutdown",
              "overloads": [
                {
                  "signature": "public boolean isOutputShutdown()",
                  "description": "Returns whether the write-half of the socket connection is closed."
                }
              ]
            },
            {
              "name": "setSocketImplFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setSocketImplFactory(SocketImplFactory fac) throws IOException",
                  "description": "Sets the client socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new client socket, the socket\n implementation factory's createSocketImpl method is\n called to create the actual socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this socket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences. Negative\n values represent a lower priority than positive values. If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n  Invoking this method after this socket has been connected\n will have no effect."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> Socket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketAddress",
          "methods": [
            {
              "name": "SocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketException",
          "methods": [
            {
              "name": "SocketException",
              "overloads": [
                {
                  "signature": "public SocketException(String msg)",
                  "description": "Constructs a new SocketException with the\n specified detail message."
                },
                {
                  "signature": "public SocketException()",
                  "description": "Constructs a new SocketException with no detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketImpl",
          "methods": [
            {
              "name": "SocketImpl",
              "overloads": [
                {
                  "signature": "public SocketImpl()",
                  "description": "Initialize a new instance of this class"
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "protected abstract void create(boolean stream) throws IOException",
                  "description": "Creates either a stream or a datagram socket."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "protected abstract void connect(String host, int port) throws IOException",
                  "description": "Connects this socket to the specified port on the named host."
                },
                {
                  "signature": "protected abstract void connect(InetAddress address, int port) throws IOException",
                  "description": "Connects this socket to the specified port number on the specified host."
                },
                {
                  "signature": "protected abstract void connect(SocketAddress address, int timeout) throws IOException",
                  "description": "Connects this socket to the specified port number on the specified host.\n A timeout of zero is interpreted as an infinite timeout. The connection\n will then block until established or an error occurs."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "protected abstract void bind(InetAddress host, int port) throws IOException",
                  "description": "Binds this socket to the specified local IP address and port number."
                }
              ]
            },
            {
              "name": "listen",
              "overloads": [
                {
                  "signature": "protected abstract void listen(int backlog) throws IOException",
                  "description": "Sets the maximum queue length for incoming connection indications\n (a request to connect) to the count argument. If a\n connection indication arrives when the queue is full, the\n connection is refused."
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "protected abstract void accept(SocketImpl s) throws IOException",
                  "description": "Accepts a connection."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "protected abstract InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream for this socket."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "protected abstract OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream for this socket."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "protected abstract int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this socket\n without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "protected abstract void close() throws IOException",
                  "description": "Closes this socket."
                }
              ]
            },
            {
              "name": "shutdownInput",
              "overloads": [
                {
                  "signature": "protected void shutdownInput() throws IOException",
                  "description": "Places the input stream for this socket at \"end of stream\".\n Any data sent to this socket is acknowledged and then\n silently discarded.\n\n If you read from a socket input stream after invoking this method on the\n socket, the stream's available method will return 0, and its\n read methods will return -1 (end of stream)."
                }
              ]
            },
            {
              "name": "shutdownOutput",
              "overloads": [
                {
                  "signature": "protected void shutdownOutput() throws IOException",
                  "description": "Disables the output stream for this socket.\n For a TCP socket, any previously written data will be sent\n followed by TCP's normal connection termination sequence.\n\n If you write to a socket output stream after invoking\n shutdownOutput() on the socket, the stream will throw\n an IOException."
                }
              ]
            },
            {
              "name": "getFileDescriptor",
              "overloads": [
                {
                  "signature": "protected FileDescriptor getFileDescriptor()",
                  "description": "Returns the value of this socket's fd field."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "protected InetAddress getInetAddress()",
                  "description": "Returns the value of this socket's address field."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "protected int getPort()",
                  "description": "Returns the value of this socket's port field."
                }
              ]
            },
            {
              "name": "supportsUrgentData",
              "overloads": [
                {
                  "signature": "protected boolean supportsUrgentData()",
                  "description": "Returns whether or not this SocketImpl supports sending\n urgent data. By default, false is returned\n unless the method is overridden in a sub-class"
                }
              ]
            },
            {
              "name": "sendUrgentData",
              "overloads": [
                {
                  "signature": "protected abstract void sendUrgentData(int data) throws IOException",
                  "description": "Send one byte of urgent data on the socket.\n The byte to be sent is the low eight bits of the parameter"
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "protected int getLocalPort()",
                  "description": "Returns the value of this socket's localport field."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the address and port of this socket as a String."
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "protected void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this socket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences. Negative\n values represent a lower priority than positive values. If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n By default, this method does nothing, unless it is overridden in\n a sub-class."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "protected <T> void setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Called to set a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "protected <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Called to get a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "protected Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of SocketOptions supported by this impl\n and by this impl's socket (Socket or ServerSocket)"
                }
              ]
            }
          ]
        },
        {
          "name": "SocketImplFactory",
          "methods": [
            {
              "name": "createSocketImpl",
              "overloads": [
                {
                  "signature": "SocketImpl createSocketImpl()",
                  "description": "Creates a new SocketImpl instance."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketOption<T>",
          "methods": [
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "String name()",
                  "description": "Returns the name of the socket option."
                }
              ]
            },
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "Class<T> type()",
                  "description": "Returns the type of the socket option value."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketOptions",
          "methods": [
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "void setOption(int optID, Object value) throws SocketException",
                  "description": "Enable/disable the option specified by optID.  If the option\n is to be enabled, and it takes an option-specific \"value\",  this is\n passed in value.  The actual type of value is option-specific,\n and it is an error to pass something that isn't of the expected type:\n  SocketImpl s;\n ...\n s.setOption(SO_LINGER, new Integer(10));\n    // OK - set SO_LINGER w/ timeout of 10 sec.\n s.setOption(SO_LINGER, new Double(10));\n    // ERROR - expects java.lang.Integer\n\n If the requested option is binary, it can be set using this method by\n a java.lang.Boolean:\n  s.setOption(TCP_NODELAY, Boolean.TRUE);\n    // OK - enables TCP_NODELAY, a binary option\n \n \n Any option can be disabled using this method with a Boolean.FALSE:\n  s.setOption(TCP_NODELAY, Boolean.FALSE);\n    // OK - disables TCP_NODELAY\n s.setOption(SO_LINGER, Boolean.FALSE);\n    // OK - disables SO_LINGER\n \n \n For an option that has a notion of on and off, and requires\n a non-boolean parameter, setting its value to anything other than\n Boolean.FALSE implicitly enables it.\n \n Throws SocketException if the option is unrecognized,\n the socket is closed, or some low-level error occurred"
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "Object getOption(int optID) throws SocketException",
                  "description": "Fetch the value of an option.\n Binary options will return java.lang.Boolean.TRUE\n if enabled, java.lang.Boolean.FALSE if disabled, e.g.:\n  SocketImpl s;\n ...\n Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY));\n if (noDelay.booleanValue()) {\n     // true if TCP_NODELAY is enabled...\n ...\n }\n \n \n For options that take a particular type as a parameter,\n getOption(int) will return the parameter's value, else\n it will return java.lang.Boolean.FALSE:\n  Object o = s.getOption(SO_LINGER);\n if (o instanceof Integer) {\n     System.out.print(\"Linger time is \" + ((Integer)o).intValue());\n } else {\n   // the true type of o is java.lang.Boolean.FALSE;\n }"
                }
              ]
            }
          ]
        },
        {
          "name": "SocketPermission",
          "methods": [
            {
              "name": "SocketPermission",
              "overloads": [
                {
                  "signature": "public SocketPermission(String host, String action)",
                  "description": "Creates a new SocketPermission object with the specified actions.\n The host is expressed as a DNS name, or as a numerical IP address.\n Optionally, a port or a portrange may be supplied (separated\n from the DNS name or IP address by a colon).\n \n To specify the local machine, use \"localhost\" as the host.\n Also note: An empty host String (\"\") is equivalent to \"localhost\".\n \n The actions parameter contains a comma-separated list of the\n actions granted for the specified host (and port(s)). Possible actions are\n \"connect\", \"listen\", \"accept\", \"resolve\", or\n any combination of those. \"resolve\" is automatically added\n when any of the other three are specified.\n \n Examples of SocketPermission instantiation are the following:\n     nr = new SocketPermission(\"www.example.com\", \"connect\");\n    nr = new SocketPermission(\"www.example.com:80\", \"connect\");\n    nr = new SocketPermission(\"*.example.com\", \"connect\");\n    nr = new SocketPermission(\"*.edu\", \"resolve\");\n    nr = new SocketPermission(\"204.160.241.0\", \"connect\");\n    nr = new SocketPermission(\"localhost:1024-65535\", \"listen\");\n    nr = new SocketPermission(\"204.160.241.0:1024-65535\", \"connect\");"
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this socket permission object \"implies\" the\n specified permission.\n \n More specifically, this method first ensures that all of the following\n are true (and returns false if any of them are not):\n \n  p is an instanceof SocketPermission,\n  p's actions are a proper subset of this\n object's actions, and\n  p's port range is included in this port range. Note:\n port range is ignored when p only contains the action, 'resolve'.\n \n\n Then implies checks each of the following, in order,\n and for each returns true if the stated condition is true:\n \n  If this object was initialized with a single IP address and one of p's\n IP addresses is equal to this object's IP address.\n If this object is a wildcard domain (such as *.example.com), and\n p's canonical name (the name without any preceding *)\n ends with this object's canonical host name. For example, *.example.com\n implies *.foo.example.com.\n If this object was not initialized with a single IP address, and one of this\n object's IP addresses equals one of p's IP addresses.\n If this canonical name equals p's canonical name.\n \n\n If none of the above are true, implies returns false."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two SocketPermission objects for equality."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions.\n Always returns present actions in the following order:\n connect, listen, accept, resolve."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing SocketPermission\n objects.\n \n SocketPermission objects must be stored in a manner that allows them\n to be inserted into the collection in any order, but that also enables the\n PermissionCollection implies\n method to be implemented in an efficient (and consistent) manner."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketTimeoutException",
          "methods": [
            {
              "name": "SocketTimeoutException",
              "overloads": [
                {
                  "signature": "public SocketTimeoutException(String msg)",
                  "description": "Constructs a new SocketTimeoutException with a detail\n message."
                },
                {
                  "signature": "public SocketTimeoutException()",
                  "description": "Construct a new SocketTimeoutException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "StandardSocketOptions",
          "methods": []
        },
        {
          "name": "UnixDomainSocketAddress",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static UnixDomainSocketAddress of(String pathname)",
                  "description": "Creates a UnixDomainSocketAddress from the given path string."
                },
                {
                  "signature": "public static UnixDomainSocketAddress of(Path path)",
                  "description": "Creates a UnixDomainSocketAddress for the given path."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public Path getPath()",
                  "description": "Returns this address's path."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this UnixDomainSocketAddress"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares this address with another object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this UnixDomainSocketAddress."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownHostException",
          "methods": [
            {
              "name": "UnknownHostException",
              "overloads": [
                {
                  "signature": "public UnknownHostException(String message)",
                  "description": "Constructs a new UnknownHostException with the\n specified detail message."
                },
                {
                  "signature": "public UnknownHostException()",
                  "description": "Constructs a new UnknownHostException with no detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownServiceException",
          "methods": [
            {
              "name": "UnknownServiceException",
              "overloads": [
                {
                  "signature": "public UnknownServiceException()",
                  "description": "Constructs a new UnknownServiceException with no\n detail message."
                },
                {
                  "signature": "public UnknownServiceException(String msg)",
                  "description": "Constructs a new UnknownServiceException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "URI",
          "methods": [
            {
              "name": "URI",
              "overloads": [
                {
                  "signature": "public URI(String str) throws URISyntaxException",
                  "description": "Constructs a URI by parsing the given string.\n\n  This constructor parses the given string exactly as specified by the\n grammar in RFC2396,\n AppendixA, except for the following deviations: \n\n \n\n    An empty authority component is permitted as long as it is\n   followed by a non-empty path, a query component, or a fragment\n   component.  This allows the parsing of URIs such as\n   \"file:///foo/bar\", which seems to be the intent of\n   RFC2396 although the grammar does not permit it.  If the\n   authority component is empty then the user-information, host, and port\n   components are undefined. \n\n    Empty relative paths are permitted; this seems to be the\n   intent of RFC2396 although the grammar does not permit it.  The\n   primary consequence of this deviation is that a standalone fragment\n   such as \"#foo\" parses as a relative URI with an empty path\n   and the given fragment, and can be usefully resolved against a base URI.\n\n    IPv4 addresses in host components are parsed rigorously, as\n   specified by RFC2732: Each\n   element of a dotted-quad address must contain no more than three\n   decimal digits.  Each element is further constrained to have a value\n   no greater than 255. \n\n     Hostnames in host components that comprise only a single\n   domain label are permitted to start with an alphanum\n   character. This seems to be the intent of RFC2396\n   section3.2.2 although the grammar does not permit it. The\n   consequence of this deviation is that the authority component of a\n   hierarchical URI such as s://123, will parse as a server-based\n   authority. \n\n    IPv6 addresses are permitted for the host component.  An IPv6\n   address must be enclosed in square brackets ('[' and\n   ']') as specified by RFC2732.  The\n   IPv6 address itself must parse according to RFC2373.  IPv6\n   addresses are further constrained to describe no more than sixteen\n   bytes of address information, a constraint implicit in RFC2373\n   but not expressible in the grammar. \n\n    Characters in the other category are permitted wherever\n   RFC2396 permits escaped octets, that is, in the\n   user-information, path, query, and fragment components, as well as in\n   the authority component if the authority is registry-based.  This\n   allows URIs to contain Unicode characters beyond those in the US-ASCII\n   character set."
                },
                {
                  "signature": "public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  If a scheme is given then the path, if also given, must either be\n empty or begin with a slash character ('/').  Otherwise a\n component of the new URI may be left undefined by passing null\n for the corresponding parameter or, in the case of the port\n parameter, by passing -1.\n\n  This constructor first builds a URI string from the given components\n according to the rules specified in RFC2396,\n section5.2, step7: \n\n \n\n    Initially, the result string is empty. \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If user information, a host, or a port are given then the\n   string \"//\" is appended.  \n\n    If user information is given then it is appended, followed by\n   a commercial-at character ('@').  Any character not in the\n   unreserved, punct, escaped, or other\n   categories is quoted.  \n\n    If a host is given then it is appended.  If the host is a\n   literal IPv6 address but is not enclosed in square brackets\n   ('[' and ']') then the square brackets are added.\n   \n\n    If a port number is given then a colon character\n   (':') is appended, followed by the port number in decimal.\n   \n\n    If a path is given then it is appended.  Any character not in\n   the unreserved, punct, escaped, or other\n   categories, and not equal to the slash character ('/') or the\n   commercial-at character ('@'), is quoted.  \n\n    If a query is given then a question-mark character\n   ('?') is appended, followed by the query.  Any character that\n   is not a legal URI character is quoted.\n   \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended, followed by the fragment.  Any character\n   that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
                },
                {
                  "signature": "public URI(String scheme, String authority, String path, String query, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  If a scheme is given then the path, if also given, must either be\n empty or begin with a slash character ('/').  Otherwise a\n component of the new URI may be left undefined by passing null\n for the corresponding parameter.\n\n  This constructor first builds a URI string from the given components\n according to the rules specified in RFC2396,\n section5.2, step7: \n\n \n\n    Initially, the result string is empty.  \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If an authority is given then the string \"//\" is\n   appended, followed by the authority.  If the authority contains a\n   literal IPv6 address then the address must be enclosed in square\n   brackets ('[' and ']').  Any character not in the\n   unreserved, punct, escaped, or other\n   categories, and not equal to the commercial-at character\n   ('@'), is quoted.  \n\n    If a path is given then it is appended.  Any character not in\n   the unreserved, punct, escaped, or other\n   categories, and not equal to the slash character ('/') or the\n   commercial-at character ('@'), is quoted.  \n\n    If a query is given then a question-mark character\n   ('?') is appended, followed by the query.  Any character that\n   is not a legal URI character is quoted.\n   \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended, followed by the fragment.  Any character\n   that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
                },
                {
                  "signature": "public URI(String scheme, String host, String path, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  A component may be left undefined by passing null.\n\n  This convenience constructor works as if by invoking the\n seven-argument constructor as follows:\n\n \n new URI(scheme, null, host, -1, path, null, fragment);"
                },
                {
                  "signature": "public URI(String scheme, String ssp, String fragment) throws URISyntaxException",
                  "description": "Constructs a URI from the given components.\n\n  A component may be left undefined by passing null.\n\n  This constructor first builds a URI in string form using the given\n components as follows:  \n\n \n\n    Initially, the result string is empty.  \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If a scheme-specific part is given then it is appended.  Any\n   character that is not a legal URI character\n   is quoted.  \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended to the string, followed by the fragment.\n   Any character that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed in order to create the new\n URI instance as if by invoking the URI(String) constructor;\n this may cause a URISyntaxException to be thrown."
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "public static URI create(String str)",
                  "description": "Creates a URI by parsing the given string.\n\n  This convenience factory method works as if by invoking the URI(String) constructor; any URISyntaxException thrown by the\n constructor is caught and wrapped in a new IllegalArgumentException object, which is then thrown.\n\n  This method is provided for use in situations where it is known that\n the given string is a legal URI, for example for URI constants declared\n within a program, and so it would be considered a programming error\n for the string not to parse as such.  The constructors, which throw\n URISyntaxException directly, should be used in situations where a\n URI is being constructed from user input or from some other source that\n may be prone to errors."
                }
              ]
            },
            {
              "name": "parseServerAuthority",
              "overloads": [
                {
                  "signature": "public URI parseServerAuthority() throws URISyntaxException",
                  "description": "Attempts to parse this URI's authority component, if defined, into\n user-information, host, and port components.\n\n  If this URI's authority component has already been recognized as\n being server-based then it will already have been parsed into\n user-information, host, and port components.  In this case, or if this\n URI has no authority component, this method simply returns this URI.\n\n  Otherwise this method attempts once more to parse the authority\n component into user-information, host, and port components, and throws\n an exception describing why the authority component could not be parsed\n in that way.\n\n  This method is provided because the generic URI syntax specified in\n RFC2396\n cannot always distinguish a malformed server-based authority from a\n legitimate registry-based authority.  It must therefore treat some\n instances of the former as instances of the latter.  The authority\n component in the URI string \"//foo:bar\", for example, is not a\n legal server-based authority but it is legal as a registry-based\n authority.\n\n  In many common situations, for example when working URIs that are\n known to be either URNs or URLs, the hierarchical URIs being used will\n always be server-based.  They therefore must either be parsed as such or\n treated as an error.  In these cases a statement such as\n\n \n URI u = new URI(str).parseServerAuthority();\n \n\n  can be used to ensure that u always refers to a URI that, if\n it has an authority component, has a server-based authority with proper\n user-information, host, and port components.  Invoking this method also\n ensures that if the authority could not be parsed in that way then an\n appropriate diagnostic message can be issued based upon the exception\n that is thrown."
                }
              ]
            },
            {
              "name": "normalize",
              "overloads": [
                {
                  "signature": "public URI normalize()",
                  "description": "Normalizes this URI's path.\n\n  If this URI is opaque, or if its path is already in normal form,\n then this URI is returned.  Otherwise a new URI is constructed that is\n identical to this URI except that its path is computed by normalizing\n this URI's path in a manner consistent with RFC2396,\n section5.2, step6, sub-stepsc throughf; that is:\n \n\n \n\n    All \".\" segments are removed. \n\n    If a \"..\" segment is preceded by a non-\"..\"\n   segment then both of these segments are removed.  This step is\n   repeated until it is no longer applicable. \n\n    If the path is relative, and if its first segment contains a\n   colon character (':'), then a \".\" segment is\n   prepended.  This prevents a relative URI with a path such as\n   \"a:b/c/d\" from later being re-parsed as an opaque URI with a\n   scheme of \"a\" and a scheme-specific part of \"b/c/d\".\n   (Deviation from RFC2396) \n\n \n\n  A normalized path will begin with one or more \"..\" segments\n if there were insufficient non-\"..\" segments preceding them to\n allow their removal.  A normalized path will begin with a \".\"\n segment if one was inserted by step 3 above.  Otherwise, a normalized\n path will not contain any \".\" or \"..\" segments."
                }
              ]
            },
            {
              "name": "resolve",
              "overloads": [
                {
                  "signature": "public URI resolve(URI uri)",
                  "description": "Resolves the given URI against this URI.\n\n  If the given URI is already absolute, or if this URI is opaque, then\n the given URI is returned.\n\n  If the given URI's fragment component is\n defined, its path component is empty, and its scheme, authority, and\n query components are undefined, then a URI with the given fragment but\n with all other components equal to those of this URI is returned.  This\n allows a URI representing a standalone fragment reference, such as\n \"#foo\", to be usefully resolved against a base URI.\n\n  Otherwise this method constructs a new hierarchical URI in a manner\n consistent with RFC2396,\n section5.2; that is: \n\n \n\n    A new URI is constructed with this URI's scheme and the given\n   URI's query and fragment components. \n\n    If the given URI has an authority component then the new URI's\n   authority and path are taken from the given URI. \n\n    Otherwise the new URI's authority component is copied from\n   this URI, and its path is computed as follows: \n\n   \n\n      If the given URI's path is absolute then the new URI's path\n     is taken from the given URI. \n\n      Otherwise the given URI's path is relative, and so the new\n     URI's path is computed by resolving the path of the given URI\n     against the path of this URI.  This is done by concatenating all but\n     the last segment of this URI's path, if any, with the given URI's\n     path and then normalizing the result as if by invoking the normalize method. \n\n   \n\n \n\n  The result of this method is absolute if, and only if, either this\n URI is absolute or the given URI is absolute."
                },
                {
                  "signature": "public URI resolve(String str)",
                  "description": "Constructs a new URI by parsing the given string and then resolving it\n against this URI.\n\n  This convenience method works as if invoking it were equivalent to\n evaluating the expression resolve(URI.create(str))."
                }
              ]
            },
            {
              "name": "relativize",
              "overloads": [
                {
                  "signature": "public URI relativize(URI uri)",
                  "description": "Relativizes the given URI against this URI.\n\n  The relativization of the given URI against this URI is computed as\n follows: \n\n \n\n    If either this URI or the given URI are opaque, or if the\n   scheme and authority components of the two URIs are not identical, or\n   if the path of this URI is not a prefix of the path of the given URI,\n   then the given URI is returned. \n\n    Otherwise a new relative hierarchical URI is constructed with\n   query and fragment components taken from the given URI and with a path\n   component computed by removing this URI's path from the beginning of\n   the given URI's path."
                }
              ]
            },
            {
              "name": "toURL",
              "overloads": [
                {
                  "signature": "public URL toURL() throws MalformedURLException",
                  "description": "Constructs a URL from this URI.\n\n  This convenience method works as if invoking it were equivalent to\n evaluating the expression new URL(this.toString()) after\n first checking that this URI is absolute."
                }
              ]
            },
            {
              "name": "getScheme",
              "overloads": [
                {
                  "signature": "public String getScheme()",
                  "description": "Returns the scheme component of this URI.\n\n  The scheme component of a URI, if defined, only contains characters\n in the alphanum category and in the string \"-.+\".  A\n scheme always starts with an alpha character. \n\n The scheme component of a URI cannot contain escaped octets, hence this\n method does not perform any decoding."
                }
              ]
            },
            {
              "name": "isAbsolute",
              "overloads": [
                {
                  "signature": "public boolean isAbsolute()",
                  "description": "Tells whether or not this URI is absolute.\n\n  A URI is absolute if, and only if, it has a scheme component."
                }
              ]
            },
            {
              "name": "isOpaque",
              "overloads": [
                {
                  "signature": "public boolean isOpaque()",
                  "description": "Tells whether or not this URI is opaque.\n\n  A URI is opaque if, and only if, it is absolute and its\n scheme-specific part does not begin with a slash character ('/').\n An opaque URI has a scheme, a scheme-specific part, and possibly\n a fragment; all other components are undefined."
                }
              ]
            },
            {
              "name": "getRawSchemeSpecificPart",
              "overloads": [
                {
                  "signature": "public String getRawSchemeSpecificPart()",
                  "description": "Returns the raw scheme-specific part of this URI.  The scheme-specific\n part is never undefined, though it may be empty.\n\n  The scheme-specific part of a URI only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getSchemeSpecificPart",
              "overloads": [
                {
                  "signature": "public String getSchemeSpecificPart()",
                  "description": "Returns the decoded scheme-specific part of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawSchemeSpecificPart method\n except that all sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawAuthority",
              "overloads": [
                {
                  "signature": "public String getRawAuthority()",
                  "description": "Returns the raw authority component of this URI.\n\n  The authority component of a URI, if defined, only contains the\n commercial-at character ('@') and characters in the\n unreserved, punct, escaped, and other\n categories.  If the authority is server-based then it is further\n constrained to have valid user-information, host, and port\n components."
                }
              ]
            },
            {
              "name": "getAuthority",
              "overloads": [
                {
                  "signature": "public String getAuthority()",
                  "description": "Returns the decoded authority component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawAuthority method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawUserInfo",
              "overloads": [
                {
                  "signature": "public String getRawUserInfo()",
                  "description": "Returns the raw user-information component of this URI.\n\n  The user-information component of a URI, if defined, only contains\n characters in the unreserved, punct, escaped, and\n other categories."
                }
              ]
            },
            {
              "name": "getUserInfo",
              "overloads": [
                {
                  "signature": "public String getUserInfo()",
                  "description": "Returns the decoded user-information component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawUserInfo method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getHost",
              "overloads": [
                {
                  "signature": "public String getHost()",
                  "description": "Returns the host component of this URI.\n\n  The host component of a URI, if defined, will have one of the\n following forms: \n\n \n\n    A domain name consisting of one or more labels\n   separated by period characters ('.'), optionally followed by\n   a period character.  Each label consists of alphanum characters\n   as well as hyphen characters ('-'), though hyphens never\n   occur as the first or last characters in a label. The rightmost\n   label of a domain name consisting of two or more labels, begins\n   with an alpha character. \n\n    A dotted-quad IPv4 address of the form\n   digit+.digit+.digit+.digit+,\n   where no digit sequence is longer than three characters and no\n   sequence has a value larger than 255. \n\n    An IPv6 address enclosed in square brackets ('[' and\n   ']') and consisting of hexadecimal digits, colon characters\n   (':'), and possibly an embedded IPv4 address.  The full\n   syntax of IPv6 addresses is specified in RFC2373: IPv6\n   Addressing Architecture.  \n\n \n\n The host component of a URI cannot contain escaped octets, hence this\n method does not perform any decoding."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number of this URI.\n\n  The port component of a URI, if defined, is a non-negative\n integer."
                }
              ]
            },
            {
              "name": "getRawPath",
              "overloads": [
                {
                  "signature": "public String getRawPath()",
                  "description": "Returns the raw path component of this URI.\n\n  The path component of a URI, if defined, only contains the slash\n character ('/'), the commercial-at character ('@'),\n and characters in the unreserved, punct, escaped,\n and other categories."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Returns the decoded path component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawPath method except that all sequences of\n escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawQuery",
              "overloads": [
                {
                  "signature": "public String getRawQuery()",
                  "description": "Returns the raw query component of this URI.\n\n  The query component of a URI, if defined, only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getQuery",
              "overloads": [
                {
                  "signature": "public String getQuery()",
                  "description": "Returns the decoded query component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawQuery method except that all sequences of\n escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawFragment",
              "overloads": [
                {
                  "signature": "public String getRawFragment()",
                  "description": "Returns the raw fragment component of this URI.\n\n  The fragment component of a URI, if defined, only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getFragment",
              "overloads": [
                {
                  "signature": "public String getFragment()",
                  "description": "Returns the decoded fragment component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawFragment method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tests this URI for equality with another object.\n\n  If the given object is not a URI then this method immediately\n returns false.\n\n  For two URIs to be considered equal requires that either both are\n opaque or both are hierarchical.  Their schemes must either both be\n undefined or else be equal without regard to case. Their fragments\n must either both be undefined or else be equal.\n\n  For two opaque URIs to be considered equal, their scheme-specific\n parts must be equal.\n\n  For two hierarchical URIs to be considered equal, their paths must\n be equal and their queries must either both be undefined or else be\n equal.  Their authorities must either both be undefined, or both be\n registry-based, or both be server-based.  If their authorities are\n defined and are registry-based, then they must be equal.  If their\n authorities are defined and are server-based, then their hosts must be\n equal without regard to case, their port numbers must be equal, and\n their user-information components must be equal.\n\n  When testing the user-information, path, query, fragment, authority,\n or scheme-specific parts of two URIs for equality, the raw forms rather\n than the encoded forms of these components are compared and the\n hexadecimal digits of escaped octets are compared without regard to\n case.\n\n  This method satisfies the general contract of the Object.equals method."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash-code value for this URI.  The hash code is based upon all\n of the URI's components, and satisfies the general contract of the\n Object.hashCode method."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(URI that)",
                  "description": "Compares this URI to another object, which must be a URI.\n\n  When comparing corresponding components of two URIs, if one\n component is undefined but the other is defined then the first is\n considered to be less than the second.  Unless otherwise noted, string\n components are ordered according to their natural, case-sensitive\n ordering as defined by the String.compareTo method.  String components that are subject to\n encoding are compared by comparing their raw forms rather than their\n encoded forms and the hexadecimal digits of escaped octets are compared\n without regard to case.\n\n  The ordering of URIs is defined as follows: \n\n \n\n    Two URIs with different schemes are ordered according the\n   ordering of their schemes, without regard to case. \n\n    A hierarchical URI is considered to be less than an opaque URI\n   with an identical scheme. \n\n    Two opaque URIs with identical schemes are ordered according\n   to the ordering of their scheme-specific parts. \n\n    Two opaque URIs with identical schemes and scheme-specific\n   parts are ordered according to the ordering of their\n   fragments. \n\n    Two hierarchical URIs with identical schemes are ordered\n   according to the ordering of their authority components: \n\n   \n\n      If both authority components are server-based then the URIs\n     are ordered according to their user-information components; if these\n     components are identical then the URIs are ordered according to the\n     ordering of their hosts, without regard to case; if the hosts are\n     identical then the URIs are ordered according to the ordering of\n     their ports. \n\n      If one or both authority components are registry-based then\n     the URIs are ordered according to the ordering of their authority\n     components. \n\n   \n\n    Finally, two hierarchical URIs with identical schemes and\n   authority components are ordered according to the ordering of their\n   paths; if their paths are identical then they are ordered according to\n   the ordering of their queries; if the queries are identical then they\n   are ordered according to the order of their fragments. \n\n \n\n  This method satisfies the general contract of the Comparable.compareTo\n method."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the content of this URI as a string.\n\n  If this URI was created by invoking one of the constructors in this\n class then a string equivalent to the original input string, or to the\n string computed from the originally-given components, as appropriate, is\n returned.  Otherwise this URI was created by normalization, resolution,\n or relativization, and so a string is constructed from this URI's\n components according to the rules specified in RFC2396,\n section5.2, step7."
                }
              ]
            },
            {
              "name": "toASCIIString",
              "overloads": [
                {
                  "signature": "public String toASCIIString()",
                  "description": "Returns the content of this URI as a US-ASCII string.\n\n  If this URI does not contain any characters in the other\n category then an invocation of this method will return the same value as\n an invocation of the toString method.  Otherwise\n this method works as if by invoking that method and then encoding the result."
                }
              ]
            }
          ]
        },
        {
          "name": "URISyntaxException",
          "methods": [
            {
              "name": "URISyntaxException",
              "overloads": [
                {
                  "signature": "public URISyntaxException(String input, String reason, int index)",
                  "description": "Constructs an instance from the given input string, reason, and error\n index."
                },
                {
                  "signature": "public URISyntaxException(String input, String reason)",
                  "description": "Constructs an instance from the given input string and reason.  The\n resulting object will have an error index of -1."
                }
              ]
            },
            {
              "name": "getInput",
              "overloads": [
                {
                  "signature": "public String getInput()",
                  "description": "Returns the input string."
                }
              ]
            },
            {
              "name": "getReason",
              "overloads": [
                {
                  "signature": "public String getReason()",
                  "description": "Returns a string explaining why the input string could not be parsed."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Returns an index into the input string of the position at which the\n parse error occurred, or -1 if this position is not known."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns a string describing the parse error.  The resulting string\n consists of the reason string followed by a colon character\n (':'), a space, and the input string.  If the error index is\n defined then the string \" at index \" followed by the index, in\n decimal, is inserted after the reason string and before the colon\n character."
                }
              ]
            }
          ]
        },
        {
          "name": "URL",
          "methods": [
            {
              "name": "URL",
              "overloads": [
                {
                  "signature": "public URL(String protocol, String host, int port, String file) throws MalformedURLException",
                  "description": "Creates a URL object from the specified\n protocol, host, port\n number, and file.\n\n host can be expressed as a host name or a literal\n IP address. If IPv6 literal address is used, it should be\n enclosed in square brackets ('[' and ']'), as\n specified by RFC2732;\n However, the literal IPv6 address format defined in RFC2373: IP\n Version 6 Addressing Architecture is also accepted.\n\n Specifying a port number of -1\n indicates that the URL should use the default port for the\n protocol.\n\n If this is the first URL object being created with the specified\n protocol, a stream protocol handler object, an instance of\n class URLStreamHandler, is created for that protocol:\n \n If the application has previously set up an instance of\n     URLStreamHandlerFactory as the stream handler factory,\n     then the createURLStreamHandler method of that instance\n     is called with the protocol string as an argument to create the\n     stream protocol handler.\n If no URLStreamHandlerFactory has yet been set up,\n     or if the factory's createURLStreamHandler method\n     returns null, then the ServiceLoader mechanism is used to locate URLStreamHandlerProvider\n     implementations using the system class\n     loader. The order that providers are located is implementation\n     specific, and an implementation is free to cache the located\n     providers. A ServiceConfigurationError, Error or RuntimeException\n     thrown from the createURLStreamHandler, if encountered, will\n     be propagated to the calling thread. The \n     createURLStreamHandler method of each provider, if instantiated, is\n     invoked, with the protocol string, until a provider returns non-null,\n     or all providers have been exhausted.\n If the previous step fails to find a protocol handler, the\n     constructor reads the value of the system property:\n     java.protocol.handler.pkgs\n     If the value of that system property is not null,\n     it is interpreted as a list of packages separated by a vertical\n     slash character '|'. The constructor tries to load\n     the class named:\n     \n         <package>.<protocol>.Handler\n     \n     where <package> is replaced by the name of the package\n     and <protocol> is replaced by the name of the protocol.\n     If this class does not exist, or if the class exists but it is not\n     a subclass of URLStreamHandler, then the next package\n     in the list is tried.\n If the previous step fails to find a protocol handler, then the\n     constructor tries to load a built-in protocol handler.\n     If this class does not exist, or if the class exists but it is not a\n     subclass of URLStreamHandler, then a\n     MalformedURLException is thrown.\n \n\n Protocol handlers for the following protocols are guaranteed\n to exist on the search path:\n \n http\n https\n file\n jar\n \n Protocol handlers for additional protocols may also be  available.\n Some protocol handlers, for example those used for loading platform\n classes or classes on the class path, may not be overridden. The details\n of such restrictions, and when those restrictions apply (during\n initialization of the runtime for example), are implementation specific\n and therefore not specified\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String protocol, String host, String file) throws MalformedURLException",
                  "description": "Creates a URL from the specified protocol\n name, host name, and file name. The\n default port for the specified protocol is used.\n \n This constructor is equivalent to the four-argument\n constructor with the only difference of using the\n default port for the specified protocol.\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String protocol, String host, int port, String file, URLStreamHandler handler) throws MalformedURLException",
                  "description": "Creates a URL object from the specified\n protocol, host, port\n number, file, and handler. Specifying\n a port number of -1 indicates that\n the URL should use the default port for the protocol. Specifying\n a handler of null indicates that the URL\n should use a default stream handler for the protocol, as outlined\n for:\n     URL(java.lang.String, java.lang.String, int, java.lang.String)\n\n If the handler is not null and there is a security manager,\n the security manager's checkPermission\n method is called with a\n NetPermission(\"specifyStreamHandler\") permission.\n This may result in a SecurityException.\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String spec) throws MalformedURLException",
                  "description": "Creates a URL object from the String\n representation.\n \n This constructor is equivalent to a call to the two-argument\n constructor with a null first argument."
                },
                {
                  "signature": "public URL(URL context, String spec) throws MalformedURLException",
                  "description": "Creates a URL by parsing the given spec within a specified context.\n\n The new URL is created from the given context URL and the spec\n argument as described in\n RFC2396 \"Uniform Resource Identifiers : Generic * Syntax\" :\n           <scheme>://<authority><path>?<query>#<fragment>\n \n The reference is parsed into the scheme, authority, path, query and\n fragment parts. If the path component is empty and the scheme,\n authority, and query components are undefined, then the new URL is a\n reference to the current document. Otherwise, the fragment and query\n parts present in the spec are used in the new URL.\n \n If the scheme component is defined in the given spec and does not match\n the scheme of the context, then the new URL is created as an absolute\n URL based on the spec alone. Otherwise the scheme component is inherited\n from the context URL.\n \n If the authority component is present in the spec then the spec is\n treated as absolute and the spec authority and path will replace the\n context authority and path. If the authority component is absent in the\n spec then the authority of the new URL will be inherited from the\n context.\n \n If the spec's path component begins with a slash character\n \"/\" then the\n path is treated as absolute and the spec path replaces the context path.\n \n Otherwise, the path is treated as a relative path and is appended to the\n context path, as described in RFC2396. Also, in this case,\n the path is canonicalized through the removal of directory\n changes made by occurrences of \"..\" and \".\".\n \n For a more detailed description of URL parsing, refer to RFC2396."
                },
                {
                  "signature": "public URL(URL context, String spec, URLStreamHandler handler) throws MalformedURLException",
                  "description": "Creates a URL by parsing the given spec with the specified handler\n within a specified context. If the handler is null, the parsing\n occurs as with the two argument constructor."
                }
              ]
            },
            {
              "name": "getQuery",
              "overloads": [
                {
                  "signature": "public String getQuery()",
                  "description": "Gets the query part of this URL."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Gets the path part of this URL."
                }
              ]
            },
            {
              "name": "getUserInfo",
              "overloads": [
                {
                  "signature": "public String getUserInfo()",
                  "description": "Gets the userInfo part of this URL."
                }
              ]
            },
            {
              "name": "getAuthority",
              "overloads": [
                {
                  "signature": "public String getAuthority()",
                  "description": "Gets the authority part of this URL."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Gets the port number of this URL."
                }
              ]
            },
            {
              "name": "getDefaultPort",
              "overloads": [
                {
                  "signature": "public int getDefaultPort()",
                  "description": "Gets the default port number of the protocol associated\n with this URL. If the URL scheme or the URLStreamHandler\n for the URL do not define a default port number,\n then -1 is returned."
                }
              ]
            },
            {
              "name": "getProtocol",
              "overloads": [
                {
                  "signature": "public String getProtocol()",
                  "description": "Gets the protocol name of this URL."
                }
              ]
            },
            {
              "name": "getHost",
              "overloads": [
                {
                  "signature": "public String getHost()",
                  "description": "Gets the host name of this URL, if applicable.\n The format of the host conforms to RFC 2732, i.e. for a\n literal IPv6 address, this method will return the IPv6 address\n enclosed in square brackets ('[' and ']')."
                }
              ]
            },
            {
              "name": "getFile",
              "overloads": [
                {
                  "signature": "public String getFile()",
                  "description": "Gets the file name of this URL.\n The returned file portion will be\n the same as getPath(), plus the concatenation of\n the value of getQuery(), if any. If there is\n no query portion, this method and getPath() will\n return identical results."
                }
              ]
            },
            {
              "name": "getRef",
              "overloads": [
                {
                  "signature": "public String getRef()",
                  "description": "Gets the anchor (also known as the \"reference\") of this\n URL."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this URL for equality with another object.\n\n If the given object is not a URL then this method immediately returns\n false.\n\n Two URL objects are equal if they have the same protocol, reference\n equivalent hosts, have the same port number on the host, and the same\n file and fragment of the file.\n\n Two hosts are considered equivalent if both host names can be resolved\n into the same IP addresses; else if either host name can't be\n resolved, the host names must be equal without regard to case; or both\n host names equal to null.\n\n Since hosts comparison requires name resolution, this operation is a\n blocking operation. \n\n Note: The defined behavior for equals is known to\n be inconsistent with virtual hosting in HTTP."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Creates an integer suitable for hash table indexing.\n\n The hash code is based upon all the URL components relevant for URL\n comparison. As such, this operation is a blocking operation."
                }
              ]
            },
            {
              "name": "sameFile",
              "overloads": [
                {
                  "signature": "public boolean sameFile(URL other)",
                  "description": "Compares two URLs, excluding the fragment component.\n\n Returns true if this URL and the\n other argument are equal without taking the\n fragment component into consideration."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this URL. The\n string is created by calling the toExternalForm\n method of the stream protocol handler for this object."
                }
              ]
            },
            {
              "name": "toExternalForm",
              "overloads": [
                {
                  "signature": "public String toExternalForm()",
                  "description": "Constructs a string representation of this URL. The\n string is created by calling the toExternalForm\n method of the stream protocol handler for this object."
                }
              ]
            },
            {
              "name": "toURI",
              "overloads": [
                {
                  "signature": "public URI toURI() throws URISyntaxException",
                  "description": "Returns a URI equivalent to this URL.\n This method functions in the same way as new URI (this.toString()).\n Note, any URL instance that complies with RFC 2396 can be converted\n to a URI. However, some URLs that are not strictly in compliance\n can not be converted to a URI."
                }
              ]
            },
            {
              "name": "openConnection",
              "overloads": [
                {
                  "signature": "public URLConnection openConnection() throws IOException",
                  "description": "Returns a URLConnection instance that\n represents a connection to the remote object referred to by the\n URL.\n\n A new instance of URLConnection is\n created every time when invoking the\n URLStreamHandler.openConnection(URL) method of the protocol handler for\n this URL.\n\n It should be noted that a URLConnection instance does not establish\n the actual network connection on creation. This will happen only when\n calling URLConnection.connect().\n\n If for the URL's protocol (such as HTTP or JAR), there\n exists a public, specialized URLConnection subclass belonging\n to one of the following packages or one of their subpackages:\n java.lang, java.io, java.util, java.net, the connection\n returned will be of that subclass. For example, for HTTP an\n HttpURLConnection will be returned, and for JAR a\n JarURLConnection will be returned."
                },
                {
                  "signature": "public URLConnection openConnection(Proxy proxy) throws IOException",
                  "description": "Same as openConnection(), except that the connection will be\n made through the specified proxy; Protocol handlers that do not\n support proxying will ignore the proxy parameter and make a\n normal connection.\n\n Invoking this method preempts the system's default\n ProxySelector settings."
                }
              ]
            },
            {
              "name": "openStream",
              "overloads": [
                {
                  "signature": "public final InputStream openStream() throws IOException",
                  "description": "Opens a connection to this URL and returns an\n InputStream for reading from that connection. This\n method is a shorthand for:\n      openConnection().getInputStream()"
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public final Object getContent() throws IOException",
                  "description": "Gets the contents of this URL. This method is a shorthand for:\n      openConnection().getContent()"
                },
                {
                  "signature": "public final Object getContent(Class<?>[] classes) throws IOException",
                  "description": "Gets the contents of this URL. This method is a shorthand for:\n      openConnection().getContent(classes)"
                }
              ]
            },
            {
              "name": "setURLStreamHandlerFactory",
              "overloads": [
                {
                  "signature": "public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)",
                  "description": "Sets an application's URLStreamHandlerFactory.\n This method can be called at most once in a given Java Virtual\n Machine.\n\n The URLStreamHandlerFactory instance is used to\nconstruct a stream protocol handler from a protocol name.\n\n  If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            }
          ]
        },
        {
          "name": "URLClassLoader",
          "methods": [
            {
              "name": "URLClassLoader",
              "overloads": [
                {
                  "signature": "public URLClassLoader(URL[] urls, ClassLoader parent)",
                  "description": "Constructs a new URLClassLoader for the given URLs. The URLs will be\n searched in the order specified for classes and resources after first\n searching in the specified parent class loader.  Any jar:\n scheme URL is assumed to refer to a JAR file.  Any file: scheme\n URL that ends with a '/' is assumed to refer to a directory.  Otherwise,\n the URL is assumed to refer to a JAR file which will be downloaded and\n opened as needed.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(URL[] urls)",
                  "description": "Constructs a new URLClassLoader for the specified URLs using the\n default delegation parent ClassLoader. The URLs will\n be searched in the order specified for classes and resources after\n first searching in the parent class loader. Any URL that ends with\n a '/' is assumed to refer to a directory. Otherwise, the URL is\n assumed to refer to a JAR file which will be downloaded and opened\n as needed.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)",
                  "description": "Constructs a new URLClassLoader for the specified URLs, parent\n class loader, and URLStreamHandlerFactory. The parent argument\n will be used as the parent class loader for delegation. The\n factory argument will be used as the stream handler factory to\n obtain protocol handlers when creating new jar URLs.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(String name, URL[] urls, ClassLoader parent)",
                  "description": "Constructs a new named URLClassLoader for the specified URLs.\n The URLs will be searched in the order specified for classes\n and resources after first searching in the specified parent class loader.\n Any URL that ends with a '/' is assumed to refer to a directory.\n Otherwise, the URL is assumed to refer to a JAR file which will be\n downloaded and opened as needed."
                },
                {
                  "signature": "public URLClassLoader(String name, URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)",
                  "description": "Constructs a new named URLClassLoader for the specified URLs,\n parent class loader, and URLStreamHandlerFactory.\n The parent argument will be used as the parent class loader for delegation.\n The factory argument will be used as the stream handler factory to\n obtain protocol handlers when creating new jar URLs."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Returns an input stream for reading the specified resource.\n If this loader is closed, then any resources opened by this method\n will be closed.\n\n  The search order is described in the documentation for ClassLoader.getResource(String)."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this URLClassLoader, so that it can no longer be used to load\n new classes or resources that are defined by this loader.\n Classes and resources defined by any of this loader's parents in the\n delegation hierarchy are still accessible. Also, any classes or resources\n that are already loaded, are still accessible.\n \n In the case of jar: and file: URLs, it also closes any files\n that were opened by it. If another thread is loading a\n class when the close method is invoked, then the result of\n that load is undefined.\n \n The method makes a best effort attempt to close all opened files,\n by catching IOExceptions internally. Unchecked exceptions\n and errors are not caught. Calling close on an already closed\n loader has no effect."
                }
              ]
            },
            {
              "name": "addURL",
              "overloads": [
                {
                  "signature": "protected void addURL(URL url)",
                  "description": "Appends the specified URL to the list of URLs to search for\n classes and resources.\n \n If the URL specified is null or is already in the\n list of URLs, or if this loader is closed, then invoking this\n method has no effect."
                }
              ]
            },
            {
              "name": "getURLs",
              "overloads": [
                {
                  "signature": "public URL[] getURLs()",
                  "description": "Returns the search path of URLs for loading classes and resources.\n This includes the original list of URLs specified to the constructor,\n along with any URLs subsequently appended by the addURL() method."
                }
              ]
            },
            {
              "name": "findClass",
              "overloads": [
                {
                  "signature": "protected Class<?> findClass(String name) throws ClassNotFoundException",
                  "description": "Finds and loads the class with the specified name from the URL search\n path. Any URLs referring to JAR files are loaded and opened as needed\n until the class is found."
                }
              ]
            },
            {
              "name": "definePackage",
              "overloads": [
                {
                  "signature": "protected Package definePackage(String name, Manifest man, URL url)",
                  "description": "Defines a new package by name in this URLClassLoader.\n The attributes contained in the specified Manifest\n will be used to obtain package version and sealing information.\n For sealed packages, the additional URL specifies the code source URL\n from which the package was loaded."
                }
              ]
            },
            {
              "name": "findResource",
              "overloads": [
                {
                  "signature": "public URL findResource(String name)",
                  "description": "Finds the resource with the specified name on the URL search path."
                }
              ]
            },
            {
              "name": "findResources",
              "overloads": [
                {
                  "signature": "public Enumeration<URL> findResources(String name) throws IOException",
                  "description": "Returns an Enumeration of URLs representing all of the resources\n on the URL search path having the specified name."
                }
              ]
            },
            {
              "name": "getPermissions",
              "overloads": [
                {
                  "signature": "protected PermissionCollection getPermissions(CodeSource codesource)",
                  "description": "Returns the permissions for the given codesource object.\n The implementation of this method first calls super.getPermissions\n and then adds permissions based on the URL of the codesource.\n \n If the protocol of this URL is \"jar\", then the permission granted\n is based on the permission that is required by the URL of the Jar\n file.\n \n If the protocol is \"file\" and there is an authority component, then\n permission to connect to and accept connections from that authority\n may be granted. If the protocol is \"file\"\n and the path specifies a file, then permission to read that\n file is granted. If protocol is \"file\" and the path is\n a directory, permission is granted to read all files\n and (recursively) all files and subdirectories contained in\n that directory.\n \n If the protocol is not \"file\", then permission\n to connect to and accept connections from the URL's host is granted."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "public static URLClassLoader newInstance(URL[] urls, ClassLoader parent)",
                  "description": "Creates a new instance of URLClassLoader for the specified\n URLs and parent class loader. If a security manager is\n installed, the loadClass method of the URLClassLoader\n returned by this method will invoke the\n SecurityManager.checkPackageAccess method before\n loading the class."
                },
                {
                  "signature": "public static URLClassLoader newInstance(URL[] urls)",
                  "description": "Creates a new instance of URLClassLoader for the specified\n URLs and default parent class loader. If a security manager is\n installed, the loadClass method of the URLClassLoader\n returned by this method will invoke the\n SecurityManager.checkPackageAccess before\n loading the class."
                }
              ]
            }
          ]
        },
        {
          "name": "URLConnection",
          "methods": [
            {
              "name": "URLConnection",
              "overloads": [
                {
                  "signature": "protected URLConnection(URL url)",
                  "description": "Constructs a URL connection to the specified URL. A connection to\n the object referenced by the URL is not created."
                }
              ]
            },
            {
              "name": "getFileNameMap",
              "overloads": [
                {
                  "signature": "public static FileNameMap getFileNameMap()",
                  "description": "Loads filename map (a mimetable) from a data file. It will\n first try to load the user-specific table, defined\n by \"content.types.user.table\" property. If that fails,\n it tries to load the default built-in table."
                }
              ]
            },
            {
              "name": "setFileNameMap",
              "overloads": [
                {
                  "signature": "public static void setFileNameMap(FileNameMap map)",
                  "description": "Sets the FileNameMap.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public abstract void connect() throws IOException",
                  "description": "Opens a communications link to the resource referenced by this\n URL, if such a connection has not already been established.\n \n If the connect method is called when the connection\n has already been opened (indicated by the connected\n field having the value true), the call is ignored.\n \n URLConnection objects go through two phases: first they are\n created, then they are connected.  After being created, and\n before being connected, various options can be specified\n (e.g., doInput and UseCaches).  After connecting, it is an\n error to try to set them.  Operations that depend on being\n connected, like getContentLength, will implicitly perform the\n connection, if necessary."
                }
              ]
            },
            {
              "name": "setConnectTimeout",
              "overloads": [
                {
                  "signature": "public void setConnectTimeout(int timeout)",
                  "description": "Sets a specified timeout value, in milliseconds, to be used\n when opening a communications link to the resource referenced\n by this URLConnection.  If the timeout expires before the\n connection can be established, a\n java.net.SocketTimeoutException is raised. A timeout of zero is\n interpreted as an infinite timeout.\n\n  Some non-standard implementation of this method may ignore\n the specified timeout. To see the connect timeout set, please\n call getConnectTimeout()."
                }
              ]
            },
            {
              "name": "getConnectTimeout",
              "overloads": [
                {
                  "signature": "public int getConnectTimeout()",
                  "description": "Returns setting for connect timeout.\n \n 0 return implies that the option is disabled\n (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setReadTimeout",
              "overloads": [
                {
                  "signature": "public void setReadTimeout(int timeout)",
                  "description": "Sets the read timeout to a specified timeout, in\n milliseconds. A non-zero value specifies the timeout when\n reading from Input stream when a connection is established to a\n resource. If the timeout expires before there is data available\n for read, a java.net.SocketTimeoutException is raised. A\n timeout of zero is interpreted as an infinite timeout.\n\n  Some non-standard implementation of this method ignores the\n specified timeout. To see the read timeout set, please call\n getReadTimeout()."
                }
              ]
            },
            {
              "name": "getReadTimeout",
              "overloads": [
                {
                  "signature": "public int getReadTimeout()",
                  "description": "Returns setting for read timeout. 0 return implies that the\n option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "getURL",
              "overloads": [
                {
                  "signature": "public URL getURL()",
                  "description": "Returns the value of this URLConnection's URL\n field."
                }
              ]
            },
            {
              "name": "getContentLength",
              "overloads": [
                {
                  "signature": "public int getContentLength()",
                  "description": "Returns the value of the content-length header field.\n \n Note: getContentLengthLong()\n should be preferred over this method, since it returns a long\n instead and is therefore more portable."
                }
              ]
            },
            {
              "name": "getContentLengthLong",
              "overloads": [
                {
                  "signature": "public long getContentLengthLong()",
                  "description": "Returns the value of the content-length header field as a\n long."
                }
              ]
            },
            {
              "name": "getContentType",
              "overloads": [
                {
                  "signature": "public String getContentType()",
                  "description": "Returns the value of the content-type header field."
                }
              ]
            },
            {
              "name": "getContentEncoding",
              "overloads": [
                {
                  "signature": "public String getContentEncoding()",
                  "description": "Returns the value of the content-encoding header field."
                }
              ]
            },
            {
              "name": "getExpiration",
              "overloads": [
                {
                  "signature": "public long getExpiration()",
                  "description": "Returns the value of the expires header field."
                }
              ]
            },
            {
              "name": "getDate",
              "overloads": [
                {
                  "signature": "public long getDate()",
                  "description": "Returns the value of the date header field."
                }
              ]
            },
            {
              "name": "getLastModified",
              "overloads": [
                {
                  "signature": "public long getLastModified()",
                  "description": "Returns the value of the last-modified header field.\n The result is the number of milliseconds since January 1, 1970 GMT."
                }
              ]
            },
            {
              "name": "getHeaderField",
              "overloads": [
                {
                  "signature": "public String getHeaderField(String name)",
                  "description": "Returns the value of the named header field.\n \n If called on a connection that sets the same header multiple times\n with possibly different values, only the last value is returned."
                },
                {
                  "signature": "public String getHeaderField(int n)",
                  "description": "Returns the value for the nth header field.\n It returns null if there are fewer than\n n+1 fields.\n \n This method can be used in conjunction with the\n getHeaderFieldKey method to iterate through all\n the headers in the message."
                }
              ]
            },
            {
              "name": "getHeaderFields",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> getHeaderFields()",
                  "description": "Returns an unmodifiable Map of the header fields.\n The Map keys are Strings that represent the\n response-header field names. Each Map value is an\n unmodifiable List of Strings that represents\n the corresponding field values."
                }
              ]
            },
            {
              "name": "getHeaderFieldInt",
              "overloads": [
                {
                  "signature": "public int getHeaderFieldInt(String name, int Default)",
                  "description": "Returns the value of the named field parsed as a number.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldLong",
              "overloads": [
                {
                  "signature": "public long getHeaderFieldLong(String name, long Default)",
                  "description": "Returns the value of the named field parsed as a number.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldDate",
              "overloads": [
                {
                  "signature": "public long getHeaderFieldDate(String name, long Default)",
                  "description": "Returns the value of the named field parsed as date.\n The result is the number of milliseconds since January 1, 1970 GMT\n represented by the named field.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldKey",
              "overloads": [
                {
                  "signature": "public String getHeaderFieldKey(int n)",
                  "description": "Returns the key for the nth header field.\n Some implementations may treat the 0th\n header field as special, in which case, getHeaderField(0)\n may return some value, but getHeaderFieldKey(0) returns null.\n For n > 0  it returns null if there are fewer than n+1 fields."
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public Object getContent() throws IOException",
                  "description": "Retrieves the contents of this URL connection.\n \n This method first determines the content type of the object by\n calling the getContentType method. If this is\n the first time that the application has seen that specific content\n type, a content handler for that content type is created.\n  This is done as follows:\n \n If the application has set up a content handler factory instance\n     using the setContentHandlerFactory method, the\n     createContentHandler method of that instance is called\n     with the content type as an argument; the result is a content\n     handler for that content type.\n If no ContentHandlerFactory has yet been set up,\n     or if the factory's createContentHandler method\n     returns null, then the ServiceLoader mechanism is used to locate ContentHandlerFactory\n     implementations using the system class\n     loader. The order that factories are located is implementation\n     specific, and an implementation is free to cache the located\n     factories. A ServiceConfigurationError, Error or RuntimeException\n     thrown from the createContentHandler, if encountered, will\n     be propagated to the calling thread. The \n     createContentHandler method of each factory, if instantiated, is\n     invoked, with the content type, until a factory returns non-null,\n     or all factories have been exhausted.\n Failing that, this method tries to load a content handler\n     class as defined by ContentHandler.\n     If the class does not exist, or is not a subclass of \n     ContentHandler, then an UnknownServiceException is thrown."
                },
                {
                  "signature": "public Object getContent(Class<?>[] classes) throws IOException",
                  "description": "Retrieves the contents of this URL connection."
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission() throws IOException",
                  "description": "Returns a permission object representing the permission\n necessary to make the connection represented by this\n object. This method returns null if no permission is\n required to make the connection. By default, this method\n returns java.security.AllPermission. Subclasses\n should override this method and return the permission\n that best represents the permission required to make\n a connection to the URL. For example, a URLConnection\n representing a file: URL would return a\n java.io.FilePermission object.\n\n The permission returned may dependent upon the state of the\n connection. For example, the permission before connecting may be\n different from that after connecting. For example, an HTTP\n sever, say foo.com, may redirect the connection to a different\n host, say bar.com. Before connecting the permission returned by\n the connection will represent the permission needed to connect\n to foo.com, while the permission returned after connecting will\n be to bar.com.\n\n Permissions are generally used for two purposes: to protect\n caches of objects obtained through URLConnections, and to check\n the right of a recipient to learn about a particular URL. In\n the first case, the permission should be obtained\n after the object has been obtained. For example, in an\n HTTP connection, this will represent the permission to connect\n to the host from which the data was ultimately fetched. In the\n second case, the permission should be obtained and tested\n before connecting."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream that reads from this open connection.\n\n A SocketTimeoutException can be thrown when reading from the\n returned input stream if the read timeout expires before data\n is available for read."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream that writes to this connection."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String representation of this URL connection."
                }
              ]
            },
            {
              "name": "setDoInput",
              "overloads": [
                {
                  "signature": "public void setDoInput(boolean doinput)",
                  "description": "Sets the value of the doInput field for this\n URLConnection to the specified value.\n \n A URL connection can be used for input and/or output.  Set the doInput\n flag to true if you intend to use the URL connection for input,\n false if not.  The default is true."
                }
              ]
            },
            {
              "name": "getDoInput",
              "overloads": [
                {
                  "signature": "public boolean getDoInput()",
                  "description": "Returns the value of this URLConnection's\n doInput flag."
                }
              ]
            },
            {
              "name": "setDoOutput",
              "overloads": [
                {
                  "signature": "public void setDoOutput(boolean dooutput)",
                  "description": "Sets the value of the doOutput field for this\n URLConnection to the specified value.\n \n A URL connection can be used for input and/or output.  Set the doOutput\n flag to true if you intend to use the URL connection for output,\n false if not.  The default is false."
                }
              ]
            },
            {
              "name": "getDoOutput",
              "overloads": [
                {
                  "signature": "public boolean getDoOutput()",
                  "description": "Returns the value of this URLConnection's\n doOutput flag."
                }
              ]
            },
            {
              "name": "setAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public void setAllowUserInteraction(boolean allowuserinteraction)",
                  "description": "Set the value of the allowUserInteraction field of\n this URLConnection."
                }
              ]
            },
            {
              "name": "getAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public boolean getAllowUserInteraction()",
                  "description": "Returns the value of the allowUserInteraction field for\n this object."
                }
              ]
            },
            {
              "name": "setDefaultAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public static void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction)",
                  "description": "Sets the default value of the\n allowUserInteraction field for all future\n URLConnection objects to the specified value."
                }
              ]
            },
            {
              "name": "getDefaultAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public static boolean getDefaultAllowUserInteraction()",
                  "description": "Returns the default value of the allowUserInteraction\n field.\n \n This default is \"sticky\", being a part of the static state of all\n URLConnections.  This flag applies to the next, and all following\n URLConnections that are created."
                }
              ]
            },
            {
              "name": "setUseCaches",
              "overloads": [
                {
                  "signature": "public void setUseCaches(boolean usecaches)",
                  "description": "Sets the value of the useCaches field of this\n URLConnection to the specified value.\n \n Some protocols do caching of documents.  Occasionally, it is important\n to be able to \"tunnel through\" and ignore the caches (e.g., the\n \"reload\" button in a browser).  If the UseCaches flag on a connection\n is true, the connection is allowed to use whatever caches it can.\n  If false, caches are to be ignored.\n  The default value comes from defaultUseCaches, which defaults to\n true. A default value can also be set per-protocol using\n setDefaultUseCaches(String,boolean)."
                }
              ]
            },
            {
              "name": "getUseCaches",
              "overloads": [
                {
                  "signature": "public boolean getUseCaches()",
                  "description": "Returns the value of this URLConnection's\n useCaches field."
                }
              ]
            },
            {
              "name": "setIfModifiedSince",
              "overloads": [
                {
                  "signature": "public void setIfModifiedSince(long ifmodifiedsince)",
                  "description": "Sets the value of the ifModifiedSince field of\n this URLConnection to the specified value."
                }
              ]
            },
            {
              "name": "getIfModifiedSince",
              "overloads": [
                {
                  "signature": "public long getIfModifiedSince()",
                  "description": "Returns the value of this object's ifModifiedSince field."
                }
              ]
            },
            {
              "name": "getDefaultUseCaches",
              "overloads": [
                {
                  "signature": "public boolean getDefaultUseCaches()",
                  "description": "Returns the default value of a URLConnection's\n useCaches flag.\n \n This default is \"sticky\", being a part of the static state of all\n URLConnections.  This flag applies to the next, and all following\n URLConnections that are created. This default value can be over-ridden\n per protocol using setDefaultUseCaches(String,boolean)"
                },
                {
                  "signature": "public static boolean getDefaultUseCaches(String protocol)",
                  "description": "Returns the default value of the useCaches flag for the given protocol. If\n setDefaultUseCaches(String,boolean) was called for the given protocol,\n then that value is returned. Otherwise, if setDefaultUseCaches(boolean)\n was called, then that value is returned. If neither method was called,\n the return value is true. The protocol name is case insensitive."
                }
              ]
            },
            {
              "name": "setDefaultUseCaches",
              "overloads": [
                {
                  "signature": "public void setDefaultUseCaches(boolean defaultusecaches)",
                  "description": "Sets the default value of the useCaches field to the\n specified value. This default value can be over-ridden\n per protocol using setDefaultUseCaches(String,boolean)"
                },
                {
                  "signature": "public static void setDefaultUseCaches(String protocol, boolean defaultVal)",
                  "description": "Sets the default value of the useCaches field for the named\n protocol to the given value. This value overrides any default setting\n set by setDefaultUseCaches(boolean) for the given protocol.\n Successive calls to this method change the setting and affect the\n default value for all future connections of that protocol. The protocol\n name is case insensitive."
                }
              ]
            },
            {
              "name": "setRequestProperty",
              "overloads": [
                {
                  "signature": "public void setRequestProperty(String key, String value)",
                  "description": "Sets the general request property. If a property with the key already\n exists, overwrite its value with the new value.\n\n  NOTE: HTTP requires all request properties which can\n legally have multiple instances with the same key\n to use a comma-separated list syntax which enables multiple\n properties to be appended into a single property."
                }
              ]
            },
            {
              "name": "addRequestProperty",
              "overloads": [
                {
                  "signature": "public void addRequestProperty(String key, String value)",
                  "description": "Adds a general request property specified by a\n key-value pair.  This method will not overwrite\n existing values associated with the same key."
                }
              ]
            },
            {
              "name": "getRequestProperty",
              "overloads": [
                {
                  "signature": "public String getRequestProperty(String key)",
                  "description": "Returns the value of the named general request property for this\n connection."
                }
              ]
            },
            {
              "name": "getRequestProperties",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> getRequestProperties()",
                  "description": "Returns an unmodifiable Map of general request\n properties for this connection. The Map keys\n are Strings that represent the request-header\n field names. Each Map value is a unmodifiable List\n of Strings that represents the corresponding\n field values."
                }
              ]
            },
            {
              "name": "setDefaultRequestProperty",
              "overloads": [
                {
                  "signature": "@Deprecated public static void setDefaultRequestProperty(String key, String value)",
                  "description": "Sets the default value of a general request property. When a\n URLConnection is created, it is initialized with\n these properties.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDefaultRequestProperty",
              "overloads": [
                {
                  "signature": "@Deprecated public static String getDefaultRequestProperty(String key)",
                  "description": "Returns the value of the default request property. Default request\n properties are set for every connection.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setContentHandlerFactory",
              "overloads": [
                {
                  "signature": "public static void setContentHandlerFactory(ContentHandlerFactory fac)",
                  "description": "Sets the ContentHandlerFactory of an\n application. It can be called at most once by an application.\n \n The ContentHandlerFactory instance is used to\n construct a content handler from a content type.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "guessContentTypeFromName",
              "overloads": [
                {
                  "signature": "public static String guessContentTypeFromName(String fname)",
                  "description": "Tries to determine the content type of an object, based\n on the specified \"file\" component of a URL.\n This is a convenience method that can be used by\n subclasses that override the getContentType method."
                }
              ]
            },
            {
              "name": "guessContentTypeFromStream",
              "overloads": [
                {
                  "signature": "public static String guessContentTypeFromStream(InputStream is) throws IOException",
                  "description": "Tries to determine the type of an input stream based on the\n characters at the beginning of the input stream. This method can\n be used by subclasses that override the\n getContentType method.\n \n Ideally, this routine would not be needed. But many\n http servers return the incorrect content type; in\n addition, there are many nonstandard extensions. Direct inspection\n of the bytes to determine the content type is often more accurate\n than believing the content type claimed by the http server."
                }
              ]
            }
          ]
        },
        {
          "name": "URLDecoder",
          "methods": [
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "@Deprecated public static String decode(String s)",
                  "description": "Decodes a x-www-form-urlencoded string.\n The platform's default encoding is used to determine what characters\n are represented by any consecutive sequences of the form\n \"%xy\".",
                  "deprecated": true
                },
                {
                  "signature": "public static String decode(String s, String enc) throws UnsupportedEncodingException",
                  "description": "Decodes an application/x-www-form-urlencoded string using\n a specific encoding scheme.\n\n \n This method behaves the same as decode(java.lang.String,java.nio.charset.Charset)\n except that it will look up the charset\n using the given encoding name."
                },
                {
                  "signature": "public static String decode(String s, Charset charset)",
                  "description": "Decodes an application/x-www-form-urlencoded string using\n a specific Charset.\n The supplied charset is used to determine\n what characters are represented by any consecutive sequences of the\n form \"%xy\".\n \n Note: The \n World Wide Web Consortium Recommendation states that\n UTF-8 should be used. Not doing so may introduce\n incompatibilities."
                }
              ]
            }
          ]
        },
        {
          "name": "URLEncoder",
          "methods": [
            {
              "name": "encode",
              "overloads": [
                {
                  "signature": "@Deprecated public static String encode(String s)",
                  "description": "Translates a string into x-www-form-urlencoded\n format. This method uses the platform's default encoding\n as the encoding scheme to obtain the bytes for unsafe characters.",
                  "deprecated": true
                },
                {
                  "signature": "public static String encode(String s, String enc) throws UnsupportedEncodingException",
                  "description": "Translates a string into application/x-www-form-urlencoded\n format using a specific encoding scheme.\n \n This method behaves the same as encode(String s, Charset charset)\n except that it will look up the charset\n using the given encoding name."
                },
                {
                  "signature": "public static String encode(String s, Charset charset)",
                  "description": "Translates a string into application/x-www-form-urlencoded\n format using a specific Charset.\n This method uses the supplied charset to obtain the bytes for unsafe\n characters.\n \n Note: The \n World Wide Web Consortium Recommendation states that\n UTF-8 should be used. Not doing so may introduce incompatibilities."
                }
              ]
            }
          ]
        },
        {
          "name": "URLPermission",
          "methods": [
            {
              "name": "URLPermission",
              "overloads": [
                {
                  "signature": "public URLPermission(String url, String actions)",
                  "description": "Creates a new URLPermission from a url string and which permits the given\n request methods and user-settable request headers.\n The name of the permission is the url string it was created with. Only the scheme,\n authority and path components of the url are used internally. Any fragment or query\n components are ignored. The permissions action string is as specified above."
                },
                {
                  "signature": "public URLPermission(String url)",
                  "description": "Creates a URLPermission with the given url string and unrestricted\n methods and request headers by invoking the two argument\n constructor as follows: URLPermission(url, \"*:*\")"
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the normalized method list and request\n header list, in the form:\n       \"method-names : header-names\"\n \n \n where method-names is the list of methods separated by commas\n and header-names is the list of permitted headers separated by commas.\n There is no white space in the returned String. If header-names is empty\n then the colon separator may not be present."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this URLPermission implies the given permission.\n Specifically, the following checks are done as if in the\n following sequence:\n \n if 'p' is not an instance of URLPermission return false\n if any of p's methods are not in this's method list, and if\n     this's method list is not equal to \"*\", then return false.\n if any of p's headers are not in this's request header list, and if\n     this's request header list is not equal to \"*\", then return false.\n if this's url scheme is not equal to p's url scheme return false\n if the scheme specific part of this's url is '*' return true\n if the set of hosts defined by p's url hostrange is not a subset of\n     this's url hostrange then return false. For example, \"*.foo.example.com\"\n     is a subset of \"*.example.com\". \"foo.bar.example.com\" is not\n     a subset of \"*.foo.example.com\"\n if the portrange defined by p's url is not a subset of the\n     portrange defined by this's url then return false.\n if the path or paths specified by p's url are contained in the\n     set of paths specified by this's url, then return true\n otherwise, return false\n \n Some examples of how paths are matched are shown below:\n \n Examples of Path Matching\n \n this's pathp's pathmatch\n \n \n /a/b/a/byes\n /a/b/*/a/b/cyes\n   /a/b/c/dno\n   /a/b/c/-no\n /a/b/-/a/b/c/dyes\n   /a/b/c/d/eyes\n   /a/b/c/*yes"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object p)",
                  "description": "Returns true if, this.getActions().equals(p.getActions())\n and p's url equals this's url.  Returns false otherwise."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode calculated from the hashcode of the\n actions String and the url string."
                }
              ]
            }
          ]
        },
        {
          "name": "URLStreamHandler",
          "methods": [
            {
              "name": "URLStreamHandler",
              "overloads": [
                {
                  "signature": "public URLStreamHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "openConnection",
              "overloads": [
                {
                  "signature": "protected abstract URLConnection openConnection(URL u) throws IOException",
                  "description": "Opens a connection to the object referenced by the\n URL argument.\n This method should be overridden by a subclass.\n\n If for the handler's protocol (such as HTTP or JAR), there\n exists a public, specialized URLConnection subclass belonging\n to one of the following packages or one of their subpackages:\n java.lang, java.io, java.util, java.net, the connection\n returned will be of that subclass. For example, for HTTP an\n HttpURLConnection will be returned, and for JAR a\n JarURLConnection will be returned."
                },
                {
                  "signature": "protected URLConnection openConnection(URL u, Proxy p) throws IOException",
                  "description": "Same as openConnection(URL), except that the connection will be\n made through the specified proxy; Protocol handlers that do not\n support proxying will ignore the proxy parameter and make a\n normal connection.\n\n  Calling this method preempts the system's default\n ProxySelector settings."
                }
              ]
            },
            {
              "name": "parseURL",
              "overloads": [
                {
                  "signature": "protected void parseURL(URL u, String spec, int start, int limit)",
                  "description": "Parses the string representation of a URL into a\n URL object.\n \n If there is any inherited context, then it has already been\n copied into the URL argument.\n \n The parseURL method of URLStreamHandler\n parses the string representation as if it were an\n http specification. Most URL protocol families have a\n similar parsing. A stream protocol handler for a protocol that has\n a different syntax must override this routine."
                }
              ]
            },
            {
              "name": "getDefaultPort",
              "overloads": [
                {
                  "signature": "protected int getDefaultPort()",
                  "description": "Returns the default port for a URL parsed by this handler. This method\n is meant to be overridden by handlers with default port numbers."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "protected boolean equals(URL u1, URL u2)",
                  "description": "Provides the default equals calculation. May be overridden by handlers\n for other protocols that have different requirements for equals().\n This method requires that none of its arguments is null. This is\n guaranteed by the fact that it is only called by java.net.URL class."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "protected int hashCode(URL u)",
                  "description": "Provides the default hash calculation. May be overridden by handlers for\n other protocols that have different requirements for hashCode\n calculation."
                }
              ]
            },
            {
              "name": "sameFile",
              "overloads": [
                {
                  "signature": "protected boolean sameFile(URL u1, URL u2)",
                  "description": "Compare two urls to see whether they refer to the same file,\n i.e., having the same protocol, host, port, and path.\n This method requires that none of its arguments is null. This is\n guaranteed by the fact that it is only called indirectly\n by java.net.URL class."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "protected InetAddress getHostAddress(URL u)",
                  "description": "Get the IP address of our host. An empty host field or a DNS failure\n will result in a null return."
                }
              ]
            },
            {
              "name": "hostsEqual",
              "overloads": [
                {
                  "signature": "protected boolean hostsEqual(URL u1, URL u2)",
                  "description": "Compares the host components of two URLs."
                }
              ]
            },
            {
              "name": "toExternalForm",
              "overloads": [
                {
                  "signature": "protected String toExternalForm(URL u)",
                  "description": "Converts a URL of a specific protocol to a\n String."
                }
              ]
            },
            {
              "name": "setURL",
              "overloads": [
                {
                  "signature": "protected void setURL(URL u, String protocol, String host, int port, String authority, String userInfo, String path, String query, String ref)",
                  "description": "Sets the fields of the URL argument to the indicated values.\n Only classes derived from URLStreamHandler are able\n to use this method to set the values of the URL fields."
                },
                {
                  "signature": "@Deprecated protected void setURL(URL u, String protocol, String host, int port, String file, String ref)",
                  "description": "Sets the fields of the URL argument to the indicated values.\n Only classes derived from URLStreamHandler are able\n to use this method to set the values of the URL fields.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "URLStreamHandlerFactory",
          "methods": [
            {
              "name": "createURLStreamHandler",
              "overloads": [
                {
                  "signature": "URLStreamHandler createURLStreamHandler(String protocol)",
                  "description": "Creates a new URLStreamHandler instance with the specified\n protocol."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.nio",
      "description": "New I/O (NIO) classes",
      "classes": [
        {
          "name": "Buffer",
          "methods": [
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public final int capacity()",
                  "description": "Returns this buffer's capacity."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final int position()",
                  "description": "Returns this buffer's position."
                },
                {
                  "signature": "public Buffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final int limit()",
                  "description": "Returns this buffer's limit."
                },
                {
                  "signature": "public Buffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public Buffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public Buffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public Buffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public Buffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public Buffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "remaining",
              "overloads": [
                {
                  "signature": "public final int remaining()",
                  "description": "Returns the number of elements between the current position and the\n limit."
                }
              ]
            },
            {
              "name": "hasRemaining",
              "overloads": [
                {
                  "signature": "public final boolean hasRemaining()",
                  "description": "Tells whether there are any elements between the current position and\n the limit."
                }
              ]
            },
            {
              "name": "isReadOnly",
              "overloads": [
                {
                  "signature": "public abstract boolean isReadOnly()",
                  "description": "Tells whether or not this buffer is read-only."
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public abstract boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public abstract Object array()",
                  "description": "Returns the array that backs this\n buffer(optional operation).\n\n  This method is intended to allow array-backed buffers to be\n passed to native code more efficiently. Concrete subclasses\n provide more strongly-typed return values for this method.\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public abstract int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this buffer is\n direct."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract Buffer slice()",
                  "description": "Creates a new buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of elements remaining in this buffer, its mark will be\n undefined. The new buffer will be direct if, and only if, this buffer is\n direct, and it will be read-only if, and only if, this buffer is\n read-only."
                },
                {
                  "signature": "public abstract Buffer slice(int index, int length)",
                  "description": "Creates a new buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined. The new buffer will\n be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract Buffer duplicate()",
                  "description": "Creates a new buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position and mark values will be\n identical to those of this buffer. The new buffer will be direct if, and\n only if, this buffer is direct, and it will be read-only if, and only if,\n this buffer is read-only."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferOverflowException",
          "methods": [
            {
              "name": "BufferOverflowException",
              "overloads": [
                {
                  "signature": "public BufferOverflowException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferUnderflowException",
          "methods": [
            {
              "name": "BufferUnderflowException",
              "overloads": [
                {
                  "signature": "public BufferUnderflowException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteBuffer",
          "methods": [
            {
              "name": "allocateDirect",
              "overloads": [
                {
                  "signature": "public static ByteBuffer allocateDirect(int capacity)",
                  "description": "Allocates a new direct byte buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n BIG_ENDIAN.  Whether or not it has a\n backing array is unspecified."
                }
              ]
            },
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static ByteBuffer allocate(int capacity)",
                  "description": "Allocates a new byte buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static ByteBuffer wrap(byte[] array, int offset, int length)",
                  "description": "Wraps a byte array into a buffer.\n\n  The new buffer will be backed by the given byte array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static ByteBuffer wrap(byte[] array)",
                  "description": "Wraps a byte array into a buffer.\n\n  The new buffer will be backed by the given byte array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer slice()",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract ByteBuffer slice(int index, int length)",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer duplicate()",
                  "description": "Creates a new byte buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only byte buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract byte get()",
                  "description": "Relative get method.  Reads the byte at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract byte get(int index)",
                  "description": "Absolute get method.  Reads the byte at the given\n index."
                },
                {
                  "signature": "public ByteBuffer get(byte[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  If there are fewer bytes remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n bytes are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length bytes from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient bytes in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public ByteBuffer get(byte[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public ByteBuffer get(int index, byte[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length bytes from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public ByteBuffer get(int index, byte[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer put(byte b)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given byte into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract ByteBuffer put(int index, byte b)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given byte into this buffer at the given\n index."
                },
                {
                  "signature": "public ByteBuffer put(ByteBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the bytes remaining in the given source\n buffer into this buffer.  If there are more bytes remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no bytes are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() bytes from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length bytes into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ByteBuffer put(byte[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers bytes into this buffer from the given\n source array.  If there are more bytes to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n bytes are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length bytes from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final ByteBuffer put(byte[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n byte array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public ByteBuffer put(int index, byte[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length bytes from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public ByteBuffer put(int index, byte[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies bytes into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible byte\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final byte[] array()",
                  "description": "Returns the byte array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public ByteBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public ByteBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public ByteBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public ByteBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public ByteBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public ByteBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public ByteBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The bytes between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n byte at index p=position() is copied\n to index zero, the byte at index p+1 is copied\n to index one, and so forth until the byte at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of bytes copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method. \n\n\n\n  Invoke this method after writing data from a buffer in case the\n write was incomplete.  The following loop, for example, copies bytes\n from one channel to another via the buffer buf:\n\n \n   buf.clear();          // Prepare buffer for use\n   while (in.read(buf) >= 0 || buf.position != 0) {\n       buf.flip();\n       out.write(buf);\n       buf.compact();    // In case of partial write\n   }"
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this byte buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a byte buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two byte buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A byte buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ByteBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two byte buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of byte elements are compared as if by invoking\n Byte.compare(byte,byte).\n\n\n  A byte buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(ByteBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public final ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order is used when reading or writing multibyte values, and\n when creating buffers that are views of this byte buffer.  The order of\n a newly-created byte buffer is always BIG_ENDIAN."
                },
                {
                  "signature": "public final ByteBuffer order(ByteOrder bo)",
                  "description": "Modifies this buffer's byte order."
                }
              ]
            },
            {
              "name": "alignmentOffset",
              "overloads": [
                {
                  "signature": "public final int alignmentOffset(int index, int unitSize)",
                  "description": "Returns the memory address, pointing to the byte at the given index,\n modulo the given unit size.\n\n  The return value is non-negative in the range of 0\n (inclusive) up to unitSize (exclusive), with zero indicating\n that the address of the byte at the index is aligned for the unit size,\n and a positive value that the address is misaligned for the unit size.\n If the address of the byte at the index is misaligned, the return value\n represents how much the index should be adjusted to locate a byte at an\n aligned address.  Specifically, the index should either be decremented by\n the return value if the latter is not greater than index, or be\n incremented by the unit size minus the return value.  Therefore given\n  int value = alignmentOffset(index, unitSize)\n then the identities\n  alignmentOffset(index - value, unitSize) == 0, value  index\n and\n  alignmentOffset(index + (unitSize - value), unitSize) == 0\n must hold."
                }
              ]
            },
            {
              "name": "alignedSlice",
              "overloads": [
                {
                  "signature": "public final ByteBuffer alignedSlice(int unitSize)",
                  "description": "Creates a new byte buffer whose content is a shared and aligned\n subsequence of this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position rounded up to the index of the nearest aligned byte for the\n given unit size, and end at this buffer's limit rounded down to the index\n of the nearest aligned byte for the given unit size.\n If rounding results in out-of-bound values then the new buffer's capacity\n and limit will be zero.  If rounding is within bounds the following\n expressions will be true for a new buffer nb and unit size\n unitSize:\n \n nb.alignmentOffset(0, unitSize) == 0\n nb.alignmentOffset(nb.limit(), unitSize) == 0\n \n\n  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer or fewer subject to\n alignment, its mark will be undefined, and its byte order will be\n BIG_ENDIAN.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getChar",
              "overloads": [
                {
                  "signature": "public abstract char getChar()",
                  "description": "Relative get method for reading a char value.\n\n  Reads the next two bytes at this buffer's current position,\n composing them into a char value according to the current byte order,\n and then increments the position by two."
                },
                {
                  "signature": "public abstract char getChar(int index)",
                  "description": "Absolute get method for reading a char value.\n\n  Reads two bytes at the given index, composing them into a\n char value according to the current byte order."
                }
              ]
            },
            {
              "name": "putChar",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putChar(char value)",
                  "description": "Relative put method for writing a char\n value(optional operation).\n\n  Writes two bytes containing the given char value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by two."
                },
                {
                  "signature": "public abstract ByteBuffer putChar(int index, char value)",
                  "description": "Absolute put method for writing a char\n value(optional operation).\n\n  Writes two bytes containing the given char value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asCharBuffer",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer asCharBuffer()",
                  "description": "Creates a view of this byte buffer as a char buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n two, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getShort",
              "overloads": [
                {
                  "signature": "public abstract short getShort()",
                  "description": "Relative get method for reading a short value.\n\n  Reads the next two bytes at this buffer's current position,\n composing them into a short value according to the current byte order,\n and then increments the position by two."
                },
                {
                  "signature": "public abstract short getShort(int index)",
                  "description": "Absolute get method for reading a short value.\n\n  Reads two bytes at the given index, composing them into a\n short value according to the current byte order."
                }
              ]
            },
            {
              "name": "putShort",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putShort(short value)",
                  "description": "Relative put method for writing a short\n value(optional operation).\n\n  Writes two bytes containing the given short value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by two."
                },
                {
                  "signature": "public abstract ByteBuffer putShort(int index, short value)",
                  "description": "Absolute put method for writing a short\n value(optional operation).\n\n  Writes two bytes containing the given short value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asShortBuffer",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer asShortBuffer()",
                  "description": "Creates a view of this byte buffer as a short buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n two, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getInt",
              "overloads": [
                {
                  "signature": "public abstract int getInt()",
                  "description": "Relative get method for reading an int value.\n\n  Reads the next four bytes at this buffer's current position,\n composing them into an int value according to the current byte order,\n and then increments the position by four."
                },
                {
                  "signature": "public abstract int getInt(int index)",
                  "description": "Absolute get method for reading an int value.\n\n  Reads four bytes at the given index, composing them into a\n int value according to the current byte order."
                }
              ]
            },
            {
              "name": "putInt",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putInt(int value)",
                  "description": "Relative put method for writing an int\n value(optional operation).\n\n  Writes four bytes containing the given int value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by four."
                },
                {
                  "signature": "public abstract ByteBuffer putInt(int index, int value)",
                  "description": "Absolute put method for writing an int\n value(optional operation).\n\n  Writes four bytes containing the given int value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asIntBuffer",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer asIntBuffer()",
                  "description": "Creates a view of this byte buffer as an int buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n four, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public abstract long getLong()",
                  "description": "Relative get method for reading a long value.\n\n  Reads the next eight bytes at this buffer's current position,\n composing them into a long value according to the current byte order,\n and then increments the position by eight."
                },
                {
                  "signature": "public abstract long getLong(int index)",
                  "description": "Absolute get method for reading a long value.\n\n  Reads eight bytes at the given index, composing them into a\n long value according to the current byte order."
                }
              ]
            },
            {
              "name": "putLong",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putLong(long value)",
                  "description": "Relative put method for writing a long\n value(optional operation).\n\n  Writes eight bytes containing the given long value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by eight."
                },
                {
                  "signature": "public abstract ByteBuffer putLong(int index, long value)",
                  "description": "Absolute put method for writing a long\n value(optional operation).\n\n  Writes eight bytes containing the given long value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asLongBuffer",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer asLongBuffer()",
                  "description": "Creates a view of this byte buffer as a long buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n eight, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getFloat",
              "overloads": [
                {
                  "signature": "public abstract float getFloat()",
                  "description": "Relative get method for reading a float value.\n\n  Reads the next four bytes at this buffer's current position,\n composing them into a float value according to the current byte order,\n and then increments the position by four."
                },
                {
                  "signature": "public abstract float getFloat(int index)",
                  "description": "Absolute get method for reading a float value.\n\n  Reads four bytes at the given index, composing them into a\n float value according to the current byte order."
                }
              ]
            },
            {
              "name": "putFloat",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putFloat(float value)",
                  "description": "Relative put method for writing a float\n value(optional operation).\n\n  Writes four bytes containing the given float value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by four."
                },
                {
                  "signature": "public abstract ByteBuffer putFloat(int index, float value)",
                  "description": "Absolute put method for writing a float\n value(optional operation).\n\n  Writes four bytes containing the given float value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asFloatBuffer",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer asFloatBuffer()",
                  "description": "Creates a view of this byte buffer as a float buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n four, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getDouble",
              "overloads": [
                {
                  "signature": "public abstract double getDouble()",
                  "description": "Relative get method for reading a double value.\n\n  Reads the next eight bytes at this buffer's current position,\n composing them into a double value according to the current byte order,\n and then increments the position by eight."
                },
                {
                  "signature": "public abstract double getDouble(int index)",
                  "description": "Absolute get method for reading a double value.\n\n  Reads eight bytes at the given index, composing them into a\n double value according to the current byte order."
                }
              ]
            },
            {
              "name": "putDouble",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putDouble(double value)",
                  "description": "Relative put method for writing a double\n value(optional operation).\n\n  Writes eight bytes containing the given double value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by eight."
                },
                {
                  "signature": "public abstract ByteBuffer putDouble(int index, double value)",
                  "description": "Absolute put method for writing a double\n value(optional operation).\n\n  Writes eight bytes containing the given double value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asDoubleBuffer",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer asDoubleBuffer()",
                  "description": "Creates a view of this byte buffer as a double buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n eight, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteOrder",
          "methods": [
            {
              "name": "nativeOrder",
              "overloads": [
                {
                  "signature": "public static ByteOrder nativeOrder()",
                  "description": "Retrieves the native byte order of the underlying platform.\n\n  This method is defined so that performance-sensitive Java code can\n allocate direct buffers with the same byte order as the hardware.\n Native code libraries are often more efficient when such buffers are\n used."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string describing this object.\n\n  This method returns the string\n \"BIG_ENDIAN\" for BIG_ENDIAN and\n \"LITTLE_ENDIAN\" for LITTLE_ENDIAN."
                }
              ]
            }
          ]
        },
        {
          "name": "CharBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static CharBuffer allocate(int capacity)",
                  "description": "Allocates a new char buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static CharBuffer wrap(char[] array, int offset, int length)",
                  "description": "Wraps a char array into a buffer.\n\n  The new buffer will be backed by the given char array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static CharBuffer wrap(char[] array)",
                  "description": "Wraps a char array into a buffer.\n\n  The new buffer will be backed by the given char array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                },
                {
                  "signature": "public static CharBuffer wrap(CharSequence csq, int start, int end)",
                  "description": "Wraps a character sequence into a buffer.\n\n  The content of the new, read-only buffer will be the content of the\n given character sequence.  The buffer's capacity will be\n csq.length(), its position will be start, its limit\n will be end, and its mark will be undefined."
                },
                {
                  "signature": "public static CharBuffer wrap(CharSequence csq)",
                  "description": "Wraps a character sequence into a buffer.\n\n  The content of the new, read-only buffer will be the content of the\n given character sequence.  The new buffer's capacity and limit will be\n csq.length(), its position will be zero, and its mark will be\n undefined."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read(CharBuffer target) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer slice()",
                  "description": "Creates a new char buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of chars remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract CharBuffer slice(int index, int length)",
                  "description": "Creates a new char buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer duplicate()",
                  "description": "Creates a new char buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only char buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract char get()",
                  "description": "Relative get method.  Reads the char at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract char get(int index)",
                  "description": "Absolute get method.  Reads the char at the given\n index."
                },
                {
                  "signature": "public CharBuffer get(char[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  If there are fewer chars remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n chars are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length chars from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient chars in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public CharBuffer get(char[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public CharBuffer get(int index, char[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length chars from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public CharBuffer get(int index, char[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer put(char c)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given char into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract CharBuffer put(int index, char c)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given char into this buffer at the given\n index."
                },
                {
                  "signature": "public CharBuffer put(CharBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the chars remaining in the given source\n buffer into this buffer.  If there are more chars remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no chars are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() chars from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public CharBuffer put(int index, CharBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length chars into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public CharBuffer put(char[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers chars into this buffer from the given\n source array.  If there are more chars to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n chars are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length chars from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final CharBuffer put(char[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n char array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public CharBuffer put(int index, char[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length chars from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public CharBuffer put(int index, char[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies chars into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                },
                {
                  "signature": "public CharBuffer put(String src, int start, int end)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers chars from the given string into this\n buffer.  If there are more chars to be copied from the string than\n remain in this buffer, that is, if\n end-start>remaining(),\n then no chars are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=end-start chars\n from the given string into this buffer, starting at the given\n start index and at the current position of this buffer.  The\n position of this buffer is then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src,start,end) has exactly the same effect\n as the loop\n\n \n     for (int i = start; i < end; i++)\n         dst.put(src.charAt(i));\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final CharBuffer put(String src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source string\n into this buffer.  An invocation of this method of the form\n dst.put(s) behaves in exactly the same way as the invocation\n\n      dst.put(s, 0, s.length())"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible char\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final char[] array()",
                  "description": "Returns the char array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final CharBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final CharBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final CharBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final CharBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final CharBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final CharBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final CharBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The chars between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n char at index p=position() is copied\n to index zero, the char at index p+1 is copied\n to index one, and so forth until the char at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of chars copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this char buffer is direct."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a char buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two char buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A char buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(CharBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two char buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of char elements are compared as if by invoking\n Character.compare(char,char).\n\n\n  A char buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(CharBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string containing the characters in this buffer.\n\n  The first character of the resulting string will be the character at\n this buffer's position, while the last character will be the character\n at index limit()-1.  Invoking this method does not\n change the buffer's position."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public final int length()",
                  "description": "Returns the length of this character buffer.\n\n  When viewed as a character sequence, the length of a character\n buffer is simply the number of characters between the position\n (inclusive) and the limit (exclusive); that is, it is equivalent to\n remaining()."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public final boolean isEmpty()",
                  "description": "Returns true if this character buffer is empty."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public final char charAt(int index)",
                  "description": "Reads the character at the given index relative to the current\n position."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer subSequence(int start, int end)",
                  "description": "Creates a new character buffer that represents the specified subsequence\n of this buffer, relative to the current position.\n\n  The new buffer will share this buffer's content; that is, if the\n content of this buffer is mutable then modifications to one buffer will\n cause the other to be modified.  The new buffer's capacity will be that\n of this buffer, its position will be\n position()+start, its limit will be\n position()+end, and its byte order\n will be identical to that of this buffer. The new buffer will be direct\n if, and only if, this buffer is direct, and it will be read-only\n if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public CharBuffer append(CharSequence csq)",
                  "description": "Appends the specified character sequence  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(csq)\n behaves in exactly the same way as the invocation\n\n      dst.put(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended.  For instance, invoking the toString method of a character buffer will return a subsequence whose\n content depends upon the buffer's position and limit."
                },
                {
                  "signature": "public CharBuffer append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the  specified character sequence  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(csq, start,\n end) when csq is not null, behaves in exactly the\n same way as the invocation\n\n      dst.put(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public CharBuffer append(char c)",
                  "description": "Appends the specified char  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(c)\n behaves in exactly the same way as the invocation\n\n      dst.put(c)"
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a char buffer created by allocation or by\n wrapping an existing char array is the native order of the underlying\n hardware.  The byte order of a char buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "DoubleBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static DoubleBuffer allocate(int capacity)",
                  "description": "Allocates a new double buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static DoubleBuffer wrap(double[] array, int offset, int length)",
                  "description": "Wraps a double array into a buffer.\n\n  The new buffer will be backed by the given double array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static DoubleBuffer wrap(double[] array)",
                  "description": "Wraps a double array into a buffer.\n\n  The new buffer will be backed by the given double array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer slice()",
                  "description": "Creates a new double buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of doubles remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract DoubleBuffer slice(int index, int length)",
                  "description": "Creates a new double buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer duplicate()",
                  "description": "Creates a new double buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only double buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract double get()",
                  "description": "Relative get method.  Reads the double at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract double get(int index)",
                  "description": "Absolute get method.  Reads the double at the given\n index."
                },
                {
                  "signature": "public DoubleBuffer get(double[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  If there are fewer doubles remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n doubles are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length doubles from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient doubles in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public DoubleBuffer get(double[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public DoubleBuffer get(int index, double[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length doubles from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public DoubleBuffer get(int index, double[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer put(double d)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given double into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract DoubleBuffer put(int index, double d)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given double into this buffer at the given\n index."
                },
                {
                  "signature": "public DoubleBuffer put(DoubleBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the doubles remaining in the given source\n buffer into this buffer.  If there are more doubles remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no doubles are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() doubles from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public DoubleBuffer put(int index, DoubleBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length doubles into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public DoubleBuffer put(double[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers doubles into this buffer from the given\n source array.  If there are more doubles to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n doubles are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length doubles from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final DoubleBuffer put(double[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n double array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public DoubleBuffer put(int index, double[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length doubles from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public DoubleBuffer put(int index, double[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies doubles into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible double\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final double[] array()",
                  "description": "Returns the double array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The doubles between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n double at index p=position() is copied\n to index zero, the double at index p+1 is copied\n to index one, and so forth until the double at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of doubles copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this double buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a double buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two double buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n   This method considers two double elements a and b\n   to be equal if\n   (a == b) || (Double.isNaN(a) && Double.isNaN(b)).\n   The values -0.0 and +0.0 are considered to be\n   equal, unlike Double.equals(Object).\n\n   \n\n \n\n  A double buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(DoubleBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two double buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n Pairs of double elements are compared as if by invoking\n Double.compare(double,double), except that\n -0.0 and 0.0 are considered to be equal.\n Double.NaN is considered by this method to be equal\n to itself and greater than all other double values\n (including Double.POSITIVE_INFINITY).\n\n\n\n\n\n  A double buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(DoubleBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a double buffer created by allocation or by\n wrapping an existing double array is the native order of the underlying\n hardware.  The byte order of a double buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "FloatBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static FloatBuffer allocate(int capacity)",
                  "description": "Allocates a new float buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static FloatBuffer wrap(float[] array, int offset, int length)",
                  "description": "Wraps a float array into a buffer.\n\n  The new buffer will be backed by the given float array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static FloatBuffer wrap(float[] array)",
                  "description": "Wraps a float array into a buffer.\n\n  The new buffer will be backed by the given float array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer slice()",
                  "description": "Creates a new float buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of floats remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract FloatBuffer slice(int index, int length)",
                  "description": "Creates a new float buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer duplicate()",
                  "description": "Creates a new float buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only float buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract float get()",
                  "description": "Relative get method.  Reads the float at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract float get(int index)",
                  "description": "Absolute get method.  Reads the float at the given\n index."
                },
                {
                  "signature": "public FloatBuffer get(float[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  If there are fewer floats remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n floats are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length floats from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient floats in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public FloatBuffer get(float[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public FloatBuffer get(int index, float[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length floats from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public FloatBuffer get(int index, float[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer put(float f)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given float into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract FloatBuffer put(int index, float f)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given float into this buffer at the given\n index."
                },
                {
                  "signature": "public FloatBuffer put(FloatBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the floats remaining in the given source\n buffer into this buffer.  If there are more floats remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no floats are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() floats from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public FloatBuffer put(int index, FloatBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length floats into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public FloatBuffer put(float[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers floats into this buffer from the given\n source array.  If there are more floats to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n floats are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length floats from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final FloatBuffer put(float[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n float array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public FloatBuffer put(int index, float[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length floats from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public FloatBuffer put(int index, float[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies floats into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible float\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final float[] array()",
                  "description": "Returns the float array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final FloatBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final FloatBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final FloatBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final FloatBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final FloatBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final FloatBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final FloatBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The floats between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n float at index p=position() is copied\n to index zero, the float at index p+1 is copied\n to index one, and so forth until the float at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of floats copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this float buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a float buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two float buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n   This method considers two float elements a and b\n   to be equal if\n   (a == b) || (Float.isNaN(a) && Float.isNaN(b)).\n   The values -0.0 and +0.0 are considered to be\n   equal, unlike Float.equals(Object).\n\n   \n\n \n\n  A float buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(FloatBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two float buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n Pairs of float elements are compared as if by invoking\n Float.compare(float,float), except that\n -0.0 and 0.0 are considered to be equal.\n Float.NaN is considered by this method to be equal\n to itself and greater than all other float values\n (including Float.POSITIVE_INFINITY).\n\n\n\n\n\n  A float buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(FloatBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a float buffer created by allocation or by\n wrapping an existing float array is the native order of the underlying\n hardware.  The byte order of a float buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "IntBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static IntBuffer allocate(int capacity)",
                  "description": "Allocates a new int buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static IntBuffer wrap(int[] array, int offset, int length)",
                  "description": "Wraps an int array into a buffer.\n\n  The new buffer will be backed by the given int array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static IntBuffer wrap(int[] array)",
                  "description": "Wraps an int array into a buffer.\n\n  The new buffer will be backed by the given int array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer slice()",
                  "description": "Creates a new int buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of ints remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract IntBuffer slice(int index, int length)",
                  "description": "Creates a new int buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer duplicate()",
                  "description": "Creates a new int buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only int buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract int get()",
                  "description": "Relative get method.  Reads the int at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract int get(int index)",
                  "description": "Absolute get method.  Reads the int at the given\n index."
                },
                {
                  "signature": "public IntBuffer get(int[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  If there are fewer ints remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n ints are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length ints from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient ints in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public IntBuffer get(int[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public IntBuffer get(int index, int[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length ints from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public IntBuffer get(int index, int[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer put(int i)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given int into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract IntBuffer put(int index, int i)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given int into this buffer at the given\n index."
                },
                {
                  "signature": "public IntBuffer put(IntBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the ints remaining in the given source\n buffer into this buffer.  If there are more ints remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no ints are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() ints from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public IntBuffer put(int index, IntBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length ints into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public IntBuffer put(int[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers ints into this buffer from the given\n source array.  If there are more ints to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n ints are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length ints from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final IntBuffer put(int[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n int array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public IntBuffer put(int index, int[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length ints from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public IntBuffer put(int index, int[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies ints into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible int\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final int[] array()",
                  "description": "Returns the int array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final IntBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final IntBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final IntBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final IntBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final IntBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final IntBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final IntBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The ints between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n int at index p=position() is copied\n to index zero, the int at index p+1 is copied\n to index one, and so forth until the int at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of ints copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this int buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a int buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two int buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A int buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(IntBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two int buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of int elements are compared as if by invoking\n Integer.compare(int,int).\n\n\n  A int buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(IntBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of an int buffer created by allocation or by\n wrapping an existing int array is the native order of the underlying\n hardware.  The byte order of an int buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidMarkException",
          "methods": [
            {
              "name": "InvalidMarkException",
              "overloads": [
                {
                  "signature": "public InvalidMarkException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "LongBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static LongBuffer allocate(int capacity)",
                  "description": "Allocates a new long buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static LongBuffer wrap(long[] array, int offset, int length)",
                  "description": "Wraps a long array into a buffer.\n\n  The new buffer will be backed by the given long array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static LongBuffer wrap(long[] array)",
                  "description": "Wraps a long array into a buffer.\n\n  The new buffer will be backed by the given long array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer slice()",
                  "description": "Creates a new long buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of longs remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract LongBuffer slice(int index, int length)",
                  "description": "Creates a new long buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer duplicate()",
                  "description": "Creates a new long buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only long buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract long get()",
                  "description": "Relative get method.  Reads the long at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract long get(int index)",
                  "description": "Absolute get method.  Reads the long at the given\n index."
                },
                {
                  "signature": "public LongBuffer get(long[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  If there are fewer longs remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n longs are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length longs from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient longs in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public LongBuffer get(long[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public LongBuffer get(int index, long[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length longs from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public LongBuffer get(int index, long[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer put(long l)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given long into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract LongBuffer put(int index, long l)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given long into this buffer at the given\n index."
                },
                {
                  "signature": "public LongBuffer put(LongBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the longs remaining in the given source\n buffer into this buffer.  If there are more longs remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no longs are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() longs from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public LongBuffer put(int index, LongBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length longs into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public LongBuffer put(long[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers longs into this buffer from the given\n source array.  If there are more longs to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n longs are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length longs from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final LongBuffer put(long[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n long array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public LongBuffer put(int index, long[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length longs from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public LongBuffer put(int index, long[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies longs into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible long\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final long[] array()",
                  "description": "Returns the long array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final LongBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final LongBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final LongBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final LongBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final LongBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final LongBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final LongBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The longs between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n long at index p=position() is copied\n to index zero, the long at index p+1 is copied\n to index one, and so forth until the long at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of longs copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this long buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a long buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two long buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A long buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(LongBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two long buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of long elements are compared as if by invoking\n Long.compare(long,long).\n\n\n  A long buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(LongBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a long buffer created by allocation or by\n wrapping an existing long array is the native order of the underlying\n hardware.  The byte order of a long buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "MappedByteBuffer",
          "methods": [
            {
              "name": "isLoaded",
              "overloads": [
                {
                  "signature": "public final boolean isLoaded()",
                  "description": "Tells whether or not this buffer's content is resident in physical\n memory.\n\n  A return value of true implies that it is highly likely\n that all of the data in this buffer is resident in physical memory and\n may therefore be accessed without incurring any virtual-memory page\n faults or I/O operations.  A return value of false does not\n necessarily imply that the buffer's content is not resident in physical\n memory.\n\n  The returned value is a hint, rather than a guarantee, because the\n underlying operating system may have paged out some of the buffer's data\n by the time that an invocation of this method returns."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer load()",
                  "description": "Loads this buffer's content into physical memory.\n\n  This method makes a best effort to ensure that, when it returns,\n this buffer's content is resident in physical memory.  Invoking this\n method may cause some number of page faults and I/O operations to\n occur."
                }
              ]
            },
            {
              "name": "force",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer force()",
                  "description": "Forces any changes made to this buffer's content to be written to the\n storage device containing the mapped file.  The region starts at index\n zero in this buffer and is capacity() bytes.  An invocation of\n this method behaves in exactly the same way as the invocation\n force(0,capacity()).\n\n  If the file mapped into this buffer resides on a local storage\n device then when this method returns it is guaranteed that all changes\n made to the buffer since it was created, or since this method was last\n invoked, will have been written to that device.\n\n  If the file does not reside on a local device then no such guarantee\n is made.\n\n  If this buffer was not mapped in read/write mode (FileChannel.MapMode.READ_WRITE) then\n invoking this method may have no effect. In particular, the\n method has no effect for buffers mapped in read-only or private\n mapping modes. This method may or may not have an effect for\n implementation-specific mapping modes."
                },
                {
                  "signature": "public final MappedByteBuffer force(int index, int length)",
                  "description": "Forces any changes made to a region of this buffer's content to\n be written to the storage device containing the mapped\n file. The region starts at the given index in this\n buffer and is length bytes.\n\n  If the file mapped into this buffer resides on a local\n storage device then when this method returns it is guaranteed\n that all changes made to the selected region buffer since it\n was created, or since this method was last invoked, will have\n been written to that device. The force operation is free to\n write bytes that lie outside the specified region, for example\n to ensure that data blocks of some device-specific granularity\n are transferred in their entirety.\n\n  If the file does not reside on a local device then no such\n guarantee is made.\n\n  If this buffer was not mapped in read/write mode (FileChannel.MapMode.READ_WRITE) then\n invoking this method may have no effect. In particular, the\n method has no effect for buffers mapped in read-only or private\n mapping modes. This method may or may not have an effect for\n implementation-specific mapping modes."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer slice()",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only.  \n\n  Reading bytes into physical memory by invoking load() on the\n returned buffer, or writing bytes to the storage device by invoking\n force() on the returned buffer, will only act on the sub-range\n of this buffer that the returned buffer represents, namely\n [position(),limit())."
                },
                {
                  "signature": "public abstract MappedByteBuffer slice(int index, int length)",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only. \n\n  Reading bytes into physical memory by invoking load() on the\n returned buffer, or writing bytes to the storage device by invoking\n force() on the returned buffer, will only act on the sub-range\n of this buffer that the returned buffer represents, namely\n [index,index+length), where index and length are\n assumed to satisfy the preconditions."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer duplicate()",
                  "description": "Creates a new byte buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The bytes between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n byte at index p=position() is copied\n to index zero, the byte at index p+1 is copied\n to index one, and so forth until the byte at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of bytes copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method. \n\n\n\n  Invoke this method after writing data from a buffer in case the\n write was incomplete.  The following loop, for example, copies bytes\n from one channel to another via the buffer buf:\n\n \n   buf.clear();          // Prepare buffer for use\n   while (in.read(buf) >= 0 || buf.position != 0) {\n       buf.flip();\n       out.write(buf);\n       buf.compact();    // In case of partial write\n   }"
                }
              ]
            }
          ]
        },
        {
          "name": "ReadOnlyBufferException",
          "methods": [
            {
              "name": "ReadOnlyBufferException",
              "overloads": [
                {
                  "signature": "public ReadOnlyBufferException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "ShortBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static ShortBuffer allocate(int capacity)",
                  "description": "Allocates a new short buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static ShortBuffer wrap(short[] array, int offset, int length)",
                  "description": "Wraps a short array into a buffer.\n\n  The new buffer will be backed by the given short array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static ShortBuffer wrap(short[] array)",
                  "description": "Wraps a short array into a buffer.\n\n  The new buffer will be backed by the given short array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer slice()",
                  "description": "Creates a new short buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of shorts remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract ShortBuffer slice(int index, int length)",
                  "description": "Creates a new short buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer duplicate()",
                  "description": "Creates a new short buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only short buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract short get()",
                  "description": "Relative get method.  Reads the short at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract short get(int index)",
                  "description": "Absolute get method.  Reads the short at the given\n index."
                },
                {
                  "signature": "public ShortBuffer get(short[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  If there are fewer shorts remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n shorts are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length shorts from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient shorts in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public ShortBuffer get(short[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public ShortBuffer get(int index, short[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length shorts from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public ShortBuffer get(int index, short[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer put(short s)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given short into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract ShortBuffer put(int index, short s)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given short into this buffer at the given\n index."
                },
                {
                  "signature": "public ShortBuffer put(ShortBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the shorts remaining in the given source\n buffer into this buffer.  If there are more shorts remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no shorts are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() shorts from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ShortBuffer put(int index, ShortBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length shorts into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ShortBuffer put(short[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers shorts into this buffer from the given\n source array.  If there are more shorts to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n shorts are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length shorts from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final ShortBuffer put(short[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n short array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public ShortBuffer put(int index, short[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length shorts from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public ShortBuffer put(int index, short[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies shorts into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible short\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final short[] array()",
                  "description": "Returns the short array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final ShortBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final ShortBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final ShortBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final ShortBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final ShortBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final ShortBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final ShortBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The shorts between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n short at index p=position() is copied\n to index zero, the short at index p+1 is copied\n to index one, and so forth until the short at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of shorts copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this short buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a short buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two short buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A short buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ShortBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two short buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of short elements are compared as if by invoking\n Short.compare(short,short).\n\n\n  A short buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(ShortBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a short buffer created by allocation or by\n wrapping an existing short array is the native order of the underlying\n hardware.  The byte order of a short buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.text",
      "description": "Text formatting and parsing",
      "classes": [
        {
          "name": "BreakIterator",
          "methods": [
            {
              "name": "BreakIterator",
              "overloads": [
                {
                  "signature": "protected BreakIterator()",
                  "description": "Constructor. BreakIterator is stateless and has no default behavior."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Create a copy of this iterator"
                }
              ]
            },
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "public abstract int first()",
                  "description": "Returns the first boundary. The iterator's current position is set\n to the first text boundary."
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "public abstract int last()",
                  "description": "Returns the last boundary. The iterator's current position is set\n to the last text boundary."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "public abstract int next(int n)",
                  "description": "Returns the nth boundary from the current boundary. If either\n the first or last text boundary has been reached, it returns\n BreakIterator.DONE and the current position is set to either\n the first or last text boundary depending on which one is reached. Otherwise,\n the iterator's current position is set to the new boundary.\n For example, if the iterator's current position is the mth text boundary\n and three more boundaries exist from the current boundary to the last text\n boundary, the next(2) call will return m + 2. The new text position is set\n to the (m + 2)th text boundary. A next(4) call would return\n BreakIterator.DONE and the last text boundary would become the\n new text position."
                },
                {
                  "signature": "public abstract int next()",
                  "description": "Returns the boundary following the current boundary. If the current boundary\n is the last text boundary, it returns BreakIterator.DONE and\n the iterator's current position is unchanged. Otherwise, the iterator's\n current position is set to the boundary following the current boundary."
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "public abstract int previous()",
                  "description": "Returns the boundary preceding the current boundary. If the current boundary\n is the first text boundary, it returns BreakIterator.DONE and\n the iterator's current position is unchanged. Otherwise, the iterator's\n current position is set to the boundary preceding the current boundary."
                }
              ]
            },
            {
              "name": "following",
              "overloads": [
                {
                  "signature": "public abstract int following(int offset)",
                  "description": "Returns the first boundary following the specified character offset. If the\n specified offset is equal to the last text boundary, it returns\n BreakIterator.DONE and the iterator's current position is unchanged.\n Otherwise, the iterator's current position is set to the returned boundary.\n The value returned is always greater than the offset or the value\n BreakIterator.DONE."
                }
              ]
            },
            {
              "name": "preceding",
              "overloads": [
                {
                  "signature": "public int preceding(int offset)",
                  "description": "Returns the last boundary preceding the specified character offset. If the\n specified offset is equal to the first text boundary, it returns\n BreakIterator.DONE and the iterator's current position is unchanged.\n Otherwise, the iterator's current position is set to the returned boundary.\n The value returned is always less than the offset or the value\n BreakIterator.DONE."
                }
              ]
            },
            {
              "name": "isBoundary",
              "overloads": [
                {
                  "signature": "public boolean isBoundary(int offset)",
                  "description": "Returns true if the specified character offset is a text boundary."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "public abstract int current()",
                  "description": "Returns character index of the text boundary that was most\n recently returned by next(), next(int), previous(), first(), last(),\n following(int) or preceding(int). If any of these methods returns\n BreakIterator.DONE because either first or last text boundary\n has been reached, it returns the first or last text boundary depending on\n which one is reached."
                }
              ]
            },
            {
              "name": "getText",
              "overloads": [
                {
                  "signature": "public abstract CharacterIterator getText()",
                  "description": "Get the text being scanned"
                }
              ]
            },
            {
              "name": "setText",
              "overloads": [
                {
                  "signature": "public void setText(String newText)",
                  "description": "Set a new text string to be scanned.  The current scan\n position is reset to first()."
                },
                {
                  "signature": "public abstract void setText(CharacterIterator newText)",
                  "description": "Set a new text for scanning.  The current scan\n position is reset to first()."
                }
              ]
            },
            {
              "name": "getWordInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getWordInstance()",
                  "description": "Returns a new BreakIterator instance\n for word breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getWordInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for word breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getLineInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getLineInstance()",
                  "description": "Returns a new BreakIterator instance\n for line breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getLineInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for line breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getCharacterInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getCharacterInstance()",
                  "description": "Returns a new BreakIterator instance\n for character breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getCharacterInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for character breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getSentenceInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getSentenceInstance()",
                  "description": "Returns a new BreakIterator instance\n for sentence breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getSentenceInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for sentence breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n BreakIteratorProvider implementations.\n It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            }
          ]
        },
        {
          "name": "Collator",
          "methods": [
            {
              "name": "Collator",
              "overloads": [
                {
                  "signature": "protected Collator()",
                  "description": "Default constructor.  This constructor is\n protected so subclasses can get access to it. Users typically create\n a Collator sub-class by calling the factory method getInstance."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Collator getInstance()",
                  "description": "Gets the Collator for the current default locale.\n The default locale is determined by java.util.Locale.getDefault."
                },
                {
                  "signature": "public static Collator getInstance(Locale desiredLocale)",
                  "description": "Gets the Collator for the desired locale."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public abstract int compare(String source, String target)",
                  "description": "Compares the source string to the target string according to the\n collation rules for this Collator.  Returns an integer less than,\n equal to or greater than zero depending on whether the source String is\n less than, equal to or greater than the target string.  See the Collator\n class description for an example of use.\n \n For a one time comparison, this method has the best performance. If a\n given String will be involved in multiple comparisons, CollationKey.compareTo\n has the best performance. See the Collator class description for an example\n using CollationKeys."
                },
                {
                  "signature": "public int compare(Object o1, Object o2)",
                  "description": "Compares its two arguments for order.  Returns a negative integer,\n zero, or a positive integer as the first argument is less than, equal\n to, or greater than the second.\n \n This implementation merely returns\n   compare((String)o1, (String)o2) ."
                }
              ]
            },
            {
              "name": "getCollationKey",
              "overloads": [
                {
                  "signature": "public abstract CollationKey getCollationKey(String source)",
                  "description": "Transforms the String into a series of bits that can be compared bitwise\n to other CollationKeys. CollationKeys provide better performance than\n Collator.compare when Strings are involved in multiple comparisons.\n See the Collator class description for an example using CollationKeys."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(String source, String target)",
                  "description": "Convenience method for comparing the equality of two strings based on\n this Collator's collation rules."
                },
                {
                  "signature": "public boolean equals(Object that)",
                  "description": "Compares the equality of two Collators."
                }
              ]
            },
            {
              "name": "getStrength",
              "overloads": [
                {
                  "signature": "public int getStrength()",
                  "description": "Returns this Collator's strength property.  The strength property determines\n the minimum level of difference considered significant during comparison.\n See the Collator class description for an example of use."
                }
              ]
            },
            {
              "name": "setStrength",
              "overloads": [
                {
                  "signature": "public void setStrength(int newStrength)",
                  "description": "Sets this Collator's strength property.  The strength property determines\n the minimum level of difference considered significant during comparison.\n See the Collator class description for an example of use."
                }
              ]
            },
            {
              "name": "getDecomposition",
              "overloads": [
                {
                  "signature": "public int getDecomposition()",
                  "description": "Get the decomposition mode of this Collator. Decomposition mode\n determines how Unicode composed characters are handled. Adjusting\n decomposition mode allows the user to select between faster and more\n complete collation behavior.\n The three values for decomposition mode are:\n \n NO_DECOMPOSITION,\n CANONICAL_DECOMPOSITION\n FULL_DECOMPOSITION.\n \n See the documentation for these three constants for a description\n of their meaning."
                }
              ]
            },
            {
              "name": "setDecomposition",
              "overloads": [
                {
                  "signature": "public void setDecomposition(int decompositionMode)",
                  "description": "Set the decomposition mode of this Collator. See getDecomposition\n for a description of decomposition mode."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported\n by the Java runtime and by installed\n CollatorProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public abstract int hashCode()",
                  "description": "Generates the hash code for this Collator."
                }
              ]
            }
          ]
        },
        {
          "name": "DateFormat",
          "methods": [
            {
              "name": "DateFormat",
              "overloads": [
                {
                  "signature": "protected DateFormat()",
                  "description": "Create a new date format."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition fieldPosition)",
                  "description": "Formats the given Object into a date-time string. The formatted\n string is appended to the given StringBuffer."
                },
                {
                  "signature": "public abstract StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
                  "description": "Formats a Date into a date-time string. The formatted\n string is appended to the given StringBuffer."
                },
                {
                  "signature": "public final String format(Date date)",
                  "description": "Formats a Date into a date-time string."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Date parse(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce a date.\n The method may not use the entire text of the given string.\n \n See the parse(String, ParsePosition) method for more information\n on date parsing."
                },
                {
                  "signature": "public abstract Date parse(String source, ParsePosition pos)",
                  "description": "Parse a date/time string according to the given parse position.  For\n example, a time text \"07/10/96 4:5 PM, PDT\" will be parsed into a Date\n that is equivalent to Date(837039900000L).\n\n  By default, parsing is lenient: If the input is not in the form used\n by this object's format method but can still be parsed as a date, then\n the parse succeeds.  Clients may insist on strict adherence to the\n format by calling setLenient(false).\n\n This parsing operation uses the calendar to produce\n a Date. As a result, the calendar's date-time\n fields and the TimeZone value may have been\n overwritten, depending on subclass implementations. Any \n TimeZone value that has previously been set by a call to\n setTimeZone may need\n to be restored for further operations."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Date.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n date is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n See the parse(String, ParsePosition) method for more information\n on date parsing."
                }
              ]
            },
            {
              "name": "getTimeInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getTimeInstance()",
                  "description": "Gets the time formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getTimeInstance(DEFAULT,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getTimeInstance(int style)",
                  "description": "Gets the time formatter with the given formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getTimeInstance(style,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getTimeInstance(int style, Locale aLocale)",
                  "description": "Gets the time formatter with the given formatting style\n for the given locale."
                }
              ]
            },
            {
              "name": "getDateInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getDateInstance()",
                  "description": "Gets the date formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateInstance(DEFAULT,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateInstance(int style)",
                  "description": "Gets the date formatter with the given formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateInstance(style,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateInstance(int style, Locale aLocale)",
                  "description": "Gets the date formatter with the given formatting style\n for the given locale."
                }
              ]
            },
            {
              "name": "getDateTimeInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getDateTimeInstance()",
                  "description": "Gets the date/time formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateTimeInstance(DEFAULT,\n     DEFAULT, Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle)",
                  "description": "Gets the date/time formatter with the given date and time\n formatting styles for the default FORMAT locale.\n This is equivalent to calling\n getDateTimeInstance(dateStyle,\n     timeStyle, Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)",
                  "description": "Gets the date/time formatter with the given formatting styles\n for the given locale."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getInstance()",
                  "description": "Get a default date/time formatter that uses the SHORT style for both the\n date and the time."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n DateFormatProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "setCalendar",
              "overloads": [
                {
                  "signature": "public void setCalendar(Calendar newCalendar)",
                  "description": "Set the calendar to be used by this date format.  Initially, the default\n calendar for the specified or default locale is used.\n\n Any TimeZone and leniency values that have previously been set are\n overwritten by newCalendar's values."
                }
              ]
            },
            {
              "name": "getCalendar",
              "overloads": [
                {
                  "signature": "public Calendar getCalendar()",
                  "description": "Gets the calendar associated with this date/time formatter."
                }
              ]
            },
            {
              "name": "setNumberFormat",
              "overloads": [
                {
                  "signature": "public void setNumberFormat(NumberFormat newNumberFormat)",
                  "description": "Allows you to set the number formatter."
                }
              ]
            },
            {
              "name": "getNumberFormat",
              "overloads": [
                {
                  "signature": "public NumberFormat getNumberFormat()",
                  "description": "Gets the number formatter which this date/time formatter uses to\n format and parse a time."
                }
              ]
            },
            {
              "name": "setTimeZone",
              "overloads": [
                {
                  "signature": "public void setTimeZone(TimeZone zone)",
                  "description": "Sets the time zone for the calendar of this DateFormat object.\n This method is equivalent to the following call.\n \n getCalendar().setTimeZone(zone)\n \n\n The TimeZone set by this method is overwritten by a\n setCalendar call.\n\n The TimeZone set by this method may be overwritten as\n a result of a call to the parse method."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone getTimeZone()",
                  "description": "Gets the time zone.\n This method is equivalent to the following call.\n \n getCalendar().getTimeZone()"
                }
              ]
            },
            {
              "name": "setLenient",
              "overloads": [
                {
                  "signature": "public void setLenient(boolean lenient)",
                  "description": "Specify whether or not date/time parsing is to be lenient.  With\n lenient parsing, the parser may use heuristics to interpret inputs that\n do not precisely match this object's format.  With strict parsing,\n inputs must match this object's format.\n\n This method is equivalent to the following call.\n \n getCalendar().setLenient(lenient)\n \n\n This leniency value is overwritten by a call to setCalendar()."
                }
              ]
            },
            {
              "name": "isLenient",
              "overloads": [
                {
                  "signature": "public boolean isLenient()",
                  "description": "Tell whether date/time parsing is to be lenient.\n This method is equivalent to the following call.\n \n getCalendar().isLenient()"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Overrides hashCode"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            }
          ]
        },
        {
          "name": "DateFormatSymbols",
          "methods": [
            {
              "name": "DateFormatSymbols",
              "overloads": [
                {
                  "signature": "public DateFormatSymbols()",
                  "description": "Construct a DateFormatSymbols object by loading format data from\n resources for the default FORMAT\n locale. This constructor can only\n construct instances for the locales supported by the Java\n runtime environment, not for those supported by installed\n DateFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n This is equivalent to calling\n DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public DateFormatSymbols(Locale locale)",
                  "description": "Construct a DateFormatSymbols object by loading format data from\n resources for the given locale. This constructor can only\n construct instances for the locales supported by the Java\n runtime environment, not for those supported by installed\n DateFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the\n Java runtime and by installed\n DateFormatSymbolsProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormatSymbols getInstance()",
                  "description": "Gets the DateFormatSymbols instance for the default\n locale.  This method provides access to DateFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DateFormatSymbolsProvider\n implementations.\n This is equivalent to calling getInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormatSymbols getInstance(Locale locale)",
                  "description": "Gets the DateFormatSymbols instance for the specified\n locale.  This method provides access to DateFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DateFormatSymbolsProvider\n implementations."
                }
              ]
            },
            {
              "name": "getEras",
              "overloads": [
                {
                  "signature": "public String[] getEras()",
                  "description": "Gets era strings. For example: \"AD\" and \"BC\"."
                }
              ]
            },
            {
              "name": "setEras",
              "overloads": [
                {
                  "signature": "public void setEras(String[] newEras)",
                  "description": "Sets era strings. For example: \"AD\" and \"BC\"."
                }
              ]
            },
            {
              "name": "getMonths",
              "overloads": [
                {
                  "signature": "public String[] getMonths()",
                  "description": "Gets month strings. For example: \"January\", \"February\", etc.\n An array with either 12 or 13 elements will be returned depending\n on whether or not Calendar.UNDECIMBER\n is supported. Use\n Calendar.JANUARY,\n Calendar.FEBRUARY,\n etc. to index the result array.\n\n If the language requires different forms for formatting and\n stand-alone usages, this method returns month names in the\n formatting form. For example, the preferred month name for\n January in the Czech language is ledna in the\n formatting form, while it is leden in the stand-alone\n form. This method returns \"ledna\" in this case. Refer\n to the \n Calendar Elements in the Unicode Locale Data Markup Language\n (LDML) specification for more details."
                }
              ]
            },
            {
              "name": "setMonths",
              "overloads": [
                {
                  "signature": "public void setMonths(String[] newMonths)",
                  "description": "Sets month strings. For example: \"January\", \"February\", etc."
                }
              ]
            },
            {
              "name": "getShortMonths",
              "overloads": [
                {
                  "signature": "public String[] getShortMonths()",
                  "description": "Gets short month strings. For example: \"Jan\", \"Feb\", etc.\n An array with either 12 or 13 elements will be returned depending\n on whether or not Calendar.UNDECIMBER\n is supported. Use\n Calendar.JANUARY,\n Calendar.FEBRUARY,\n etc. to index the result array.\n\n If the language requires different forms for formatting and\n stand-alone usages, this method returns short month names in\n the formatting form. For example, the preferred abbreviation\n for January in the Catalan language is de gen. in the\n formatting form, while it is gen. in the stand-alone\n form. This method returns \"de gen.\" in this case. Refer\n to the \n Calendar Elements in the Unicode Locale Data Markup Language\n (LDML) specification for more details."
                }
              ]
            },
            {
              "name": "setShortMonths",
              "overloads": [
                {
                  "signature": "public void setShortMonths(String[] newShortMonths)",
                  "description": "Sets short month strings. For example: \"Jan\", \"Feb\", etc."
                }
              ]
            },
            {
              "name": "getWeekdays",
              "overloads": [
                {
                  "signature": "public String[] getWeekdays()",
                  "description": "Gets weekday strings. For example: \"Sunday\", \"Monday\", etc."
                }
              ]
            },
            {
              "name": "setWeekdays",
              "overloads": [
                {
                  "signature": "public void setWeekdays(String[] newWeekdays)",
                  "description": "Sets weekday strings. For example: \"Sunday\", \"Monday\", etc."
                }
              ]
            },
            {
              "name": "getShortWeekdays",
              "overloads": [
                {
                  "signature": "public String[] getShortWeekdays()",
                  "description": "Gets short weekday strings. For example: \"Sun\", \"Mon\", etc."
                }
              ]
            },
            {
              "name": "setShortWeekdays",
              "overloads": [
                {
                  "signature": "public void setShortWeekdays(String[] newShortWeekdays)",
                  "description": "Sets short weekday strings. For example: \"Sun\", \"Mon\", etc."
                }
              ]
            },
            {
              "name": "getAmPmStrings",
              "overloads": [
                {
                  "signature": "public String[] getAmPmStrings()",
                  "description": "Gets ampm strings. For example: \"AM\" and \"PM\"."
                }
              ]
            },
            {
              "name": "setAmPmStrings",
              "overloads": [
                {
                  "signature": "public void setAmPmStrings(String[] newAmpms)",
                  "description": "Sets ampm strings. For example: \"AM\" and \"PM\"."
                }
              ]
            },
            {
              "name": "getZoneStrings",
              "overloads": [
                {
                  "signature": "public String[][] getZoneStrings()",
                  "description": "Gets time zone strings.  Use of this method is discouraged; use\n TimeZone.getDisplayName()\n instead.\n \n The value returned is a\n two-dimensional array of strings of size n by m,\n where m is at least 5.  Each of the n rows is an\n entry containing the localized names for a single TimeZone.\n Each such row contains (with i ranging from\n 0..n-1):\n \n zoneStrings[i][0] - time zone ID\n zoneStrings[i][1] - long name of zone in standard\n time\n zoneStrings[i][2] - short name of zone in\n standard time\n zoneStrings[i][3] - long name of zone in daylight\n saving time\n zoneStrings[i][4] - short name of zone in daylight\n saving time\n \n The zone ID is not localized; it's one of the valid IDs of\n the TimeZone class that are not\n custom IDs.\n All other entries are localized names.  If a zone does not implement\n daylight saving time, the daylight saving time names should not be used.\n \n If setZoneStrings has been called\n on this DateFormatSymbols instance, then the strings\n provided by that call are returned. Otherwise, the returned array\n contains names provided by the Java runtime and by installed\n TimeZoneNameProvider\n implementations."
                }
              ]
            },
            {
              "name": "setZoneStrings",
              "overloads": [
                {
                  "signature": "public void setZoneStrings(String[][] newZoneStrings)",
                  "description": "Sets time zone strings.  The argument must be a\n two-dimensional array of strings of size n by m,\n where m is at least 5.  Each of the n rows is an\n entry containing the localized names for a single TimeZone.\n Each such row contains (with i ranging from\n 0..n-1):\n \n zoneStrings[i][0] - time zone ID\n zoneStrings[i][1] - long name of zone in standard\n time\n zoneStrings[i][2] - short name of zone in\n standard time\n zoneStrings[i][3] - long name of zone in daylight\n saving time\n zoneStrings[i][4] - short name of zone in daylight\n saving time\n \n The zone ID is not localized; it's one of the valid IDs of\n the TimeZone class that are not\n custom IDs.\n All other entries are localized names."
                }
              ]
            },
            {
              "name": "getLocalPatternChars",
              "overloads": [
                {
                  "signature": "public String getLocalPatternChars()",
                  "description": "Gets localized date-time pattern characters. For example: 'u', 't', etc."
                }
              ]
            },
            {
              "name": "setLocalPatternChars",
              "overloads": [
                {
                  "signature": "public void setLocalPatternChars(String newLocalPatternChars)",
                  "description": "Sets localized date-time pattern characters. For example: 'u', 't', etc."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode.\n Generates a hash code for the DateFormatSymbols object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Override equals"
                }
              ]
            }
          ]
        },
        {
          "name": "DecimalFormatSymbols",
          "methods": [
            {
              "name": "DecimalFormatSymbols",
              "overloads": [
                {
                  "signature": "public DecimalFormatSymbols()",
                  "description": "Create a DecimalFormatSymbols object for the default\n FORMAT locale.\n This constructor can only construct instances for the locales\n supported by the Java runtime environment, not for those\n supported by installed\n DecimalFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n This is equivalent to calling\n DecimalFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public DecimalFormatSymbols(Locale locale)",
                  "description": "Create a DecimalFormatSymbols object for the given locale.\n This constructor can only construct instances for the locales\n supported by the Java runtime environment, not for those\n supported by installed\n DecimalFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n If the specified locale contains the Locale.UNICODE_LOCALE_EXTENSION\n for the numbering system, the instance is initialized with the specified numbering\n system if the JRE implementation supports it. For example,\n  NumberFormat.getNumberInstance(Locale.forLanguageTag(\"th-TH-u-nu-thai\"))\n \n This may return a NumberFormat instance with the Thai numbering system,\n instead of the Latin numbering system."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n DecimalFormatSymbolsProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DecimalFormatSymbols getInstance()",
                  "description": "Gets the DecimalFormatSymbols instance for the default\n locale.  This method provides access to DecimalFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DecimalFormatSymbolsProvider implementations.\n This is equivalent to calling\n getInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DecimalFormatSymbols getInstance(Locale locale)",
                  "description": "Gets the DecimalFormatSymbols instance for the specified\n locale.  This method provides access to DecimalFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DecimalFormatSymbolsProvider implementations.\n If the specified locale contains the Locale.UNICODE_LOCALE_EXTENSION\n for the numbering system, the instance is initialized with the specified numbering\n system if the JRE implementation supports it. For example,\n  NumberFormat.getNumberInstance(Locale.forLanguageTag(\"th-TH-u-nu-thai\"))\n \n This may return a NumberFormat instance with the Thai numbering system,\n instead of the Latin numbering system."
                }
              ]
            },
            {
              "name": "getZeroDigit",
              "overloads": [
                {
                  "signature": "public char getZeroDigit()",
                  "description": "Gets the character used for zero. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setZeroDigit",
              "overloads": [
                {
                  "signature": "public void setZeroDigit(char zeroDigit)",
                  "description": "Sets the character used for zero. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getGroupingSeparator",
              "overloads": [
                {
                  "signature": "public char getGroupingSeparator()",
                  "description": "Gets the character used for grouping separator. Different for French, etc."
                }
              ]
            },
            {
              "name": "setGroupingSeparator",
              "overloads": [
                {
                  "signature": "public void setGroupingSeparator(char groupingSeparator)",
                  "description": "Sets the character used for grouping separator. Different for French, etc."
                }
              ]
            },
            {
              "name": "getDecimalSeparator",
              "overloads": [
                {
                  "signature": "public char getDecimalSeparator()",
                  "description": "Gets the character used for decimal sign. Different for French, etc."
                }
              ]
            },
            {
              "name": "setDecimalSeparator",
              "overloads": [
                {
                  "signature": "public void setDecimalSeparator(char decimalSeparator)",
                  "description": "Sets the character used for decimal sign. Different for French, etc."
                }
              ]
            },
            {
              "name": "getPerMill",
              "overloads": [
                {
                  "signature": "public char getPerMill()",
                  "description": "Gets the character used for per mille sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setPerMill",
              "overloads": [
                {
                  "signature": "public void setPerMill(char perMill)",
                  "description": "Sets the character used for per mille sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getPercent",
              "overloads": [
                {
                  "signature": "public char getPercent()",
                  "description": "Gets the character used for percent sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setPercent",
              "overloads": [
                {
                  "signature": "public void setPercent(char percent)",
                  "description": "Sets the character used for percent sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getDigit",
              "overloads": [
                {
                  "signature": "public char getDigit()",
                  "description": "Gets the character used for a digit in a pattern."
                }
              ]
            },
            {
              "name": "setDigit",
              "overloads": [
                {
                  "signature": "public void setDigit(char digit)",
                  "description": "Sets the character used for a digit in a pattern."
                }
              ]
            },
            {
              "name": "getPatternSeparator",
              "overloads": [
                {
                  "signature": "public char getPatternSeparator()",
                  "description": "Gets the character used to separate positive and negative subpatterns\n in a pattern."
                }
              ]
            },
            {
              "name": "setPatternSeparator",
              "overloads": [
                {
                  "signature": "public void setPatternSeparator(char patternSeparator)",
                  "description": "Sets the character used to separate positive and negative subpatterns\n in a pattern."
                }
              ]
            },
            {
              "name": "getInfinity",
              "overloads": [
                {
                  "signature": "public String getInfinity()",
                  "description": "Gets the string used to represent infinity. Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "setInfinity",
              "overloads": [
                {
                  "signature": "public void setInfinity(String infinity)",
                  "description": "Sets the string used to represent infinity. Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "getNaN",
              "overloads": [
                {
                  "signature": "public String getNaN()",
                  "description": "Gets the string used to represent \"not a number\". Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "setNaN",
              "overloads": [
                {
                  "signature": "public void setNaN(String NaN)",
                  "description": "Sets the string used to represent \"not a number\". Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "getMinusSign",
              "overloads": [
                {
                  "signature": "public char getMinusSign()",
                  "description": "Gets the character used to represent minus sign. If no explicit\n negative format is specified, one is formed by prefixing\n minusSign to the positive format."
                }
              ]
            },
            {
              "name": "setMinusSign",
              "overloads": [
                {
                  "signature": "public void setMinusSign(char minusSign)",
                  "description": "Sets the character used to represent minus sign. If no explicit\n negative format is specified, one is formed by prefixing\n minusSign to the positive format."
                }
              ]
            },
            {
              "name": "getCurrencySymbol",
              "overloads": [
                {
                  "signature": "public String getCurrencySymbol()",
                  "description": "Returns the currency symbol for the currency of these\n DecimalFormatSymbols in their locale."
                }
              ]
            },
            {
              "name": "setCurrencySymbol",
              "overloads": [
                {
                  "signature": "public void setCurrencySymbol(String currency)",
                  "description": "Sets the currency symbol for the currency of these\n DecimalFormatSymbols in their locale."
                }
              ]
            },
            {
              "name": "getInternationalCurrencySymbol",
              "overloads": [
                {
                  "signature": "public String getInternationalCurrencySymbol()",
                  "description": "Returns the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols."
                }
              ]
            },
            {
              "name": "setInternationalCurrencySymbol",
              "overloads": [
                {
                  "signature": "public void setInternationalCurrencySymbol(String currencyCode)",
                  "description": "Sets the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols.\n If the currency code is valid (as defined by\n Currency.getInstance),\n this also sets the currency attribute to the corresponding Currency\n instance and the currency symbol attribute to the currency's symbol\n in the DecimalFormatSymbols' locale. If the currency code is not valid,\n then the currency attribute is set to null and the currency symbol\n attribute is not modified."
                }
              ]
            },
            {
              "name": "getCurrency",
              "overloads": [
                {
                  "signature": "public Currency getCurrency()",
                  "description": "Gets the currency of these DecimalFormatSymbols. May be null if the\n currency symbol attribute was previously set to a value that's not\n a valid ISO 4217 currency code."
                }
              ]
            },
            {
              "name": "setCurrency",
              "overloads": [
                {
                  "signature": "public void setCurrency(Currency currency)",
                  "description": "Sets the currency of these DecimalFormatSymbols.\n This also sets the currency symbol attribute to the currency's symbol\n in the DecimalFormatSymbols' locale, and the international currency\n symbol attribute to the currency's ISO 4217 currency code."
                }
              ]
            },
            {
              "name": "getMonetaryDecimalSeparator",
              "overloads": [
                {
                  "signature": "public char getMonetaryDecimalSeparator()",
                  "description": "Returns the monetary decimal separator."
                }
              ]
            },
            {
              "name": "setMonetaryDecimalSeparator",
              "overloads": [
                {
                  "signature": "public void setMonetaryDecimalSeparator(char sep)",
                  "description": "Sets the monetary decimal separator."
                }
              ]
            },
            {
              "name": "getExponentSeparator",
              "overloads": [
                {
                  "signature": "public String getExponentSeparator()",
                  "description": "Returns the string used to separate the mantissa from the exponent.\n Examples: \"x10^\" for 1.23x10^4, \"E\" for 1.23E4."
                }
              ]
            },
            {
              "name": "setExponentSeparator",
              "overloads": [
                {
                  "signature": "public void setExponentSeparator(String exp)",
                  "description": "Sets the string used to separate the mantissa from the exponent.\n Examples: \"x10^\" for 1.23x10^4, \"E\" for 1.23E4."
                }
              ]
            },
            {
              "name": "getMonetaryGroupingSeparator",
              "overloads": [
                {
                  "signature": "public char getMonetaryGroupingSeparator()",
                  "description": "Gets the character used for grouping separator for currencies.\n May be different from grouping separator in some locales,\n e.g, German in Austria."
                }
              ]
            },
            {
              "name": "setMonetaryGroupingSeparator",
              "overloads": [
                {
                  "signature": "public void setMonetaryGroupingSeparator(char monetaryGroupingSeparator)",
                  "description": "Sets the character used for grouping separator for currencies.\n Invocation of this method will not affect the normal\n grouping separator."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Standard override."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Override equals."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode."
                }
              ]
            }
          ]
        },
        {
          "name": "NumberFormat",
          "methods": [
            {
              "name": "NumberFormat",
              "overloads": [
                {
                  "signature": "protected NumberFormat()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Formats a number and appends the resulting text to the given string\n buffer.\n The number can be of any subclass of Number.\n \n This implementation extracts the number's value using\n Number.longValue() for all integral type values that\n can be converted to long without loss of information,\n including BigInteger values with a\n bit length of less than 64,\n and Number.doubleValue() for all other types. It\n then calls\n format(long,java.lang.StringBuffer,java.text.FieldPosition)\n or format(double,java.lang.StringBuffer,java.text.FieldPosition).\n This may result in loss of magnitude information and precision for\n BigInteger and BigDecimal values."
                },
                {
                  "signature": "public final String format(double number)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public final String format(long number)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Specialization of format."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public final Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Number.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n number is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n See the parse(String, ParsePosition) method for more information\n on number parsing."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public abstract Number parse(String source, ParsePosition parsePosition)",
                  "description": "Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n Long.MAX_VALUE] and with no decimals), otherwise a Double.\n If IntegerOnly is set, will stop at a decimal\n point (or equivalent; e.g., for rational numbers \"1 2/3\", will stop\n after the 1).\n Does not throw an exception; if no object can be parsed, index is\n unchanged!"
                },
                {
                  "signature": "public Number parse(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce a number.\n The method may not use the entire text of the given string.\n \n See the parse(String, ParsePosition) method for more information\n on number parsing."
                }
              ]
            },
            {
              "name": "isParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public boolean isParseIntegerOnly()",
                  "description": "Returns true if this format will parse numbers as integers only.\n For example in the English locale, with ParseIntegerOnly true, the\n string \"1234.\" would be parsed as the integer value 1234 and parsing\n would stop at the \".\" character.  Of course, the exact format accepted\n by the parse operation is locale dependent and determined by sub-classes\n of NumberFormat."
                }
              ]
            },
            {
              "name": "setParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public void setParseIntegerOnly(boolean value)",
                  "description": "Sets whether or not numbers should be parsed as integers only."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getInstance()",
                  "description": "Returns a general-purpose number format for the current default\n FORMAT locale.\n This is the same as calling\n getNumberInstance()."
                },
                {
                  "signature": "public static NumberFormat getInstance(Locale inLocale)",
                  "description": "Returns a general-purpose number format for the specified locale.\n This is the same as calling\n getNumberInstance(inLocale)."
                }
              ]
            },
            {
              "name": "getNumberInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getNumberInstance()",
                  "description": "Returns a general-purpose number format for the current default\n FORMAT locale.\n This is equivalent to calling\n getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getNumberInstance(Locale inLocale)",
                  "description": "Returns a general-purpose number format for the specified locale."
                }
              ]
            },
            {
              "name": "getIntegerInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getIntegerInstance()",
                  "description": "Returns an integer number format for the current default\n FORMAT locale. The\n returned number format is configured to round floating point numbers\n to the nearest integer using half-even rounding (see RoundingMode.HALF_EVEN) for formatting,\n and to parse only the integer part of an input string (see isParseIntegerOnly).\n This is equivalent to calling\n getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getIntegerInstance(Locale inLocale)",
                  "description": "Returns an integer number format for the specified locale. The\n returned number format is configured to round floating point numbers\n to the nearest integer using half-even rounding (see RoundingMode.HALF_EVEN) for formatting,\n and to parse only the integer part of an input string (see isParseIntegerOnly)."
                }
              ]
            },
            {
              "name": "getCurrencyInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getCurrencyInstance()",
                  "description": "Returns a currency format for the current default\n FORMAT locale.\n This is equivalent to calling\n getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getCurrencyInstance(Locale inLocale)",
                  "description": "Returns a currency format for the specified locale.\n\n If the specified locale contains the \"cf\" (\n \n currency format style)\n Unicode extension,\n the returned currency format uses the style if it is available.\n Otherwise, the style uses the default \"standard\" currency format.\n For example, if the style designates \"account\", negative\n currency amounts use a pair of parentheses in some locales."
                }
              ]
            },
            {
              "name": "getPercentInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getPercentInstance()",
                  "description": "Returns a percentage format for the current default\n FORMAT locale.\n This is equivalent to calling\n getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getPercentInstance(Locale inLocale)",
                  "description": "Returns a percentage format for the specified locale."
                }
              ]
            },
            {
              "name": "getCompactNumberInstance",
              "overloads": [
                {
                  "signature": "public static NumberFormat getCompactNumberInstance()",
                  "description": "Returns a compact number format for the default\n FORMAT locale with\n \"SHORT\" format style."
                },
                {
                  "signature": "public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)",
                  "description": "Returns a compact number format for the specified locale\n and formatStyle."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n NumberFormatProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Overrides hashCode."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable."
                }
              ]
            },
            {
              "name": "isGroupingUsed",
              "overloads": [
                {
                  "signature": "public boolean isGroupingUsed()",
                  "description": "Returns true if grouping is used in this format. For example, in the\n English locale, with grouping on, the number 1234567 might be formatted\n as \"1,234,567\". The grouping separator as well as the size of each group\n is locale dependent and is determined by sub-classes of NumberFormat."
                }
              ]
            },
            {
              "name": "setGroupingUsed",
              "overloads": [
                {
                  "signature": "public void setGroupingUsed(boolean newValue)",
                  "description": "Set whether or not grouping will be used in this format."
                }
              ]
            },
            {
              "name": "getMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumIntegerDigits()",
                  "description": "Returns the maximum number of digits allowed in the integer portion of a\n number."
                }
              ]
            },
            {
              "name": "setMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumIntegerDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the integer portion of a\n number. maximumIntegerDigits must be  minimumIntegerDigits.  If the\n new value for maximumIntegerDigits is less than the current value\n of minimumIntegerDigits, then minimumIntegerDigits will also be set to\n the new value."
                }
              ]
            },
            {
              "name": "getMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumIntegerDigits()",
                  "description": "Returns the minimum number of digits allowed in the integer portion of a\n number."
                }
              ]
            },
            {
              "name": "setMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumIntegerDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the integer portion of a\n number. minimumIntegerDigits must be  maximumIntegerDigits.  If the\n new value for minimumIntegerDigits exceeds the current value\n of maximumIntegerDigits, then maximumIntegerDigits will also be set to\n the new value"
                }
              ]
            },
            {
              "name": "getMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumFractionDigits()",
                  "description": "Returns the maximum number of digits allowed in the fraction portion of a\n number."
                }
              ]
            },
            {
              "name": "setMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumFractionDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the fraction portion of a\n number. maximumFractionDigits must be  minimumFractionDigits.  If the\n new value for maximumFractionDigits is less than the current value\n of minimumFractionDigits, then minimumFractionDigits will also be set to\n the new value."
                }
              ]
            },
            {
              "name": "getMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumFractionDigits()",
                  "description": "Returns the minimum number of digits allowed in the fraction portion of a\n number."
                }
              ]
            },
            {
              "name": "setMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumFractionDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the fraction portion of a\n number. minimumFractionDigits must be  maximumFractionDigits.  If the\n new value for minimumFractionDigits exceeds the current value\n of maximumFractionDigits, then maximumFractionDigits will also be set to\n the new value"
                }
              ]
            },
            {
              "name": "getCurrency",
              "overloads": [
                {
                  "signature": "public Currency getCurrency()",
                  "description": "Gets the currency used by this number format when formatting\n currency values. The initial value is derived in a locale dependent\n way. The returned value may be null if no valid\n currency could be determined and no currency has been set using\n setCurrency.\n \n The default implementation throws\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "setCurrency",
              "overloads": [
                {
                  "signature": "public void setCurrency(Currency currency)",
                  "description": "Sets the currency used by this number format when formatting\n currency values. This does not update the minimum or maximum\n number of fraction digits used by the number format.\n \n The default implementation throws\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Gets the RoundingMode used in this NumberFormat.\n The default implementation of this method in NumberFormat\n always throws UnsupportedOperationException.\n Subclasses which handle different rounding modes should override\n this method."
                }
              ]
            },
            {
              "name": "setRoundingMode",
              "overloads": [
                {
                  "signature": "public void setRoundingMode(RoundingMode roundingMode)",
                  "description": "Sets the RoundingMode used in this NumberFormat.\n The default implementation of this method in NumberFormat always\n throws UnsupportedOperationException.\n Subclasses which handle different rounding modes should override\n this method."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.time",
      "description": "Date and time API",
      "classes": []
    },
    {
      "package": "java.security",
      "description": "Security framework",
      "classes": [
        {
          "name": "AccessControlContext",
          "methods": [
            {
              "name": "AccessControlContext",
              "overloads": [
                {
                  "signature": "public AccessControlContext(ProtectionDomain[] context)",
                  "description": "Create an AccessControlContext with the given array of ProtectionDomains.\n Context must not be null. Duplicate domains will be removed from the\n context.",
                  "deprecated": true
                },
                {
                  "signature": "public AccessControlContext(AccessControlContext acc, DomainCombiner combiner)",
                  "description": "Create a new AccessControlContext with the given\n AccessControlContext and DomainCombiner.\n This constructor associates the provided\n DomainCombiner with the provided\n AccessControlContext.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDomainCombiner",
              "overloads": [
                {
                  "signature": "public DomainCombiner getDomainCombiner()",
                  "description": "Get the DomainCombiner associated with this\n AccessControlContext.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public void checkPermission(Permission perm) throws AccessControlException",
                  "description": "Determines whether the access request indicated by the\n specified permission should be allowed or denied, based on\n the security policy currently in effect, and the context in\n this object. The request is allowed only if every ProtectionDomain\n in the context implies the permission. Otherwise the request is\n denied.\n\n \n This method quietly returns if the access request\n is permitted, or throws a suitable AccessControlException otherwise.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two AccessControlContext objects for equality.\n Checks that obj is\n an AccessControlContext and has the same set of ProtectionDomains\n as this context.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this context. The hash code\n is computed by exclusive or-ing the hash code of all the protection\n domains in the context together.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AccessControlException",
          "methods": [
            {
              "name": "AccessControlException",
              "overloads": [
                {
                  "signature": "public AccessControlException(String s)",
                  "description": "Constructs an AccessControlException with the\n specified, detailed message.",
                  "deprecated": true
                },
                {
                  "signature": "public AccessControlException(String s, Permission p)",
                  "description": "Constructs an AccessControlException with the\n specified, detailed message, and the requested permission that caused\n the exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission()",
                  "description": "Gets the Permission object associated with this exception, or\n null if there was no corresponding Permission object.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AccessController",
          "methods": [
            {
              "name": "doPrivileged",
              "overloads": [
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified AccessControlContext.\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context, Permission... perms)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action, AccessControlContext context) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext.  The action is performed with the\n intersection of the permissions possessed by the caller's\n protection domain, and those possessed by the domains represented by the\n specified AccessControlContext.\n \n If the action's run method throws an unchecked\n exception, it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action, AccessControlContext context, Permission... perms) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "doPrivilegedWithCombiner",
              "overloads": [
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action, AccessControlContext context, Permission... perms)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action, AccessControlContext context, Permission... perms) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getContext",
              "overloads": [
                {
                  "signature": "public static AccessControlContext getContext()",
                  "description": "This method takes a \"snapshot\" of the current calling context, which\n includes the current Thread's inherited AccessControlContext and any\n limited privilege scope, and places it in an AccessControlContext object.\n This context may then be checked at a later point, possibly in another thread.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public static void checkPermission(Permission perm) throws AccessControlException",
                  "description": "Determines whether the access request indicated by the\n specified permission should be allowed or denied, based on\n the current AccessControlContext and security policy.\n This method quietly returns if the access request\n is permitted, or throws an AccessControlException otherwise. The\n getPermission method of the AccessControlException returns the\n perm Permission object instance.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmConstraints",
          "methods": [
            {
              "name": "permits",
              "overloads": [
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, String algorithm, AlgorithmParameters parameters)",
                  "description": "Determines whether an algorithm is granted permission for the\n specified cryptographic primitives."
                },
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, Key key)",
                  "description": "Determines whether a key is granted permission for the specified\n cryptographic primitives.\n \n This method is usually used to check key size and key usage."
                },
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, String algorithm, Key key, AlgorithmParameters parameters)",
                  "description": "Determines whether an algorithm and the corresponding key are granted\n permission for the specified cryptographic primitives."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameterGenerator",
          "methods": [
            {
              "name": "AlgorithmParameterGenerator",
              "overloads": [
                {
                  "signature": "protected AlgorithmParameterGenerator(AlgorithmParameterGeneratorSpi paramGenSpi, Provider provider, String algorithm)",
                  "description": "Creates an AlgorithmParameterGenerator object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns the standard name of the algorithm this parameter\n generator is associated with."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this algorithm parameter generator object."
                }
              ]
            },
            {
              "name": "init",
              "overloads": [
                {
                  "signature": "public final void init(int size)",
                  "description": "Initializes this parameter generator for a certain size.\n To create the parameters, the SecureRandom\n implementation of the highest-priority installed provider is used as\n the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)"
                },
                {
                  "signature": "public final void init(int size, SecureRandom random)",
                  "description": "Initializes this parameter generator for a certain size and source\n of randomness."
                },
                {
                  "signature": "public final void init(AlgorithmParameterSpec genParamSpec) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values.\n To generate the parameters, the SecureRandom\n implementation of the highest-priority installed provider is used as\n the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)"
                },
                {
                  "signature": "public final void init(AlgorithmParameterSpec genParamSpec, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values."
                }
              ]
            },
            {
              "name": "generateParameters",
              "overloads": [
                {
                  "signature": "public final AlgorithmParameters generateParameters()",
                  "description": "Generates the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameterGeneratorSpi",
          "methods": [
            {
              "name": "AlgorithmParameterGeneratorSpi",
              "overloads": [
                {
                  "signature": "public AlgorithmParameterGeneratorSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineInit",
              "overloads": [
                {
                  "signature": "protected abstract void engineInit(int size, SecureRandom random)",
                  "description": "Initializes this parameter generator for a certain size\n and source of randomness."
                },
                {
                  "signature": "protected abstract void engineInit(AlgorithmParameterSpec genParamSpec, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of\n algorithm-specific parameter generation values."
                }
              ]
            },
            {
              "name": "engineGenerateParameters",
              "overloads": [
                {
                  "signature": "protected abstract AlgorithmParameters engineGenerateParameters()",
                  "description": "Generates the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameters",
          "methods": [
            {
              "name": "AlgorithmParameters",
              "overloads": [
                {
                  "signature": "protected AlgorithmParameters(AlgorithmParametersSpi paramSpi, Provider provider, String algorithm)",
                  "description": "Creates an AlgorithmParameters object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns the name of the algorithm associated with this parameter object."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n  The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                },
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                },
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list.\n\n The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this parameter object."
                }
              ]
            },
            {
              "name": "init",
              "overloads": [
                {
                  "signature": "public final void init(AlgorithmParameterSpec paramSpec) throws InvalidParameterSpecException",
                  "description": "Initializes this parameter object using the parameters\n specified in paramSpec."
                },
                {
                  "signature": "public final void init(byte[] params) throws IOException",
                  "description": "Imports the specified parameters and decodes them according to the\n primary decoding format for parameters. The primary decoding\n format for parameters is ASN.1, if an ASN.1 specification for this type\n of parameters exists."
                },
                {
                  "signature": "public final void init(byte[] params, String format) throws IOException",
                  "description": "Imports the parameters from params and decodes them\n according to the specified decoding scheme.\n If format is null, the\n primary decoding format for parameters is used. The primary decoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "getParameterSpec",
              "overloads": [
                {
                  "signature": "public final <T extends AlgorithmParameterSpec> T getParameterSpec(Class<T> paramSpec) throws InvalidParameterSpecException",
                  "description": "Returns a (transparent) specification of this parameter object.\n paramSpec identifies the specification class in which\n the parameters should be returned. It could, for example, be\n DSAParameterSpec.class, to indicate that the\n parameters should be returned in an instance of the\n DSAParameterSpec class."
                }
              ]
            },
            {
              "name": "getEncoded",
              "overloads": [
                {
                  "signature": "public final byte[] getEncoded() throws IOException",
                  "description": "Returns the parameters in their primary encoding format.\n The primary encoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "public final byte[] getEncoded(String format) throws IOException",
                  "description": "Returns the parameters encoded in the specified scheme.\n If format is null, the\n primary encoding format for parameters is used. The primary encoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns a formatted string describing the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParametersSpi",
          "methods": [
            {
              "name": "AlgorithmParametersSpi",
              "overloads": [
                {
                  "signature": "public AlgorithmParametersSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineInit",
              "overloads": [
                {
                  "signature": "protected abstract void engineInit(AlgorithmParameterSpec paramSpec) throws InvalidParameterSpecException",
                  "description": "Initializes this parameters object using the parameters\n specified in paramSpec."
                },
                {
                  "signature": "protected abstract void engineInit(byte[] params) throws IOException",
                  "description": "Imports the specified parameters and decodes them\n according to the primary decoding format for parameters.\n The primary decoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "protected abstract void engineInit(byte[] params, String format) throws IOException",
                  "description": "Imports the parameters from params and\n decodes them according to the specified decoding format.\n If format is null, the\n primary decoding format for parameters is used. The primary decoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "engineGetParameterSpec",
              "overloads": [
                {
                  "signature": "protected abstract <T extends AlgorithmParameterSpec> T engineGetParameterSpec(Class<T> paramSpec) throws InvalidParameterSpecException",
                  "description": "Returns a (transparent) specification of this parameters\n object.\n paramSpec identifies the specification class in which\n the parameters should be returned. It could, for example, be\n DSAParameterSpec.class, to indicate that the\n parameters should be returned in an instance of the\n DSAParameterSpec class."
                }
              ]
            },
            {
              "name": "engineGetEncoded",
              "overloads": [
                {
                  "signature": "protected abstract byte[] engineGetEncoded() throws IOException",
                  "description": "Returns the parameters in their primary encoding format.\n The primary encoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "protected abstract byte[] engineGetEncoded(String format) throws IOException",
                  "description": "Returns the parameters encoded in the specified format.\n If format is null, the\n primary encoding format for parameters is used. The primary encoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "engineToString",
              "overloads": [
                {
                  "signature": "protected abstract String engineToString()",
                  "description": "Returns a formatted string describing the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AllPermission",
          "methods": [
            {
              "name": "AllPermission",
              "overloads": [
                {
                  "signature": "public AllPermission()",
                  "description": "Creates a new AllPermission object."
                },
                {
                  "signature": "public AllPermission(String name, String actions)",
                  "description": "Creates a new AllPermission object. This\n constructor exists for use by the Policy object\n to instantiate new Permission objects."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if the specified permission is \"implied\" by\n this object. This method always returns true."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two AllPermission objects for equality. Two AllPermission\n objects are always equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing AllPermission\n objects."
                }
              ]
            }
          ]
        },
        {
          "name": "AuthProvider",
          "methods": [
            {
              "name": "AuthProvider",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected AuthProvider(String name, double version, String info)",
                  "description": "Constructs a provider with the specified name, version number,\n and information.",
                  "deprecated": true
                },
                {
                  "signature": "protected AuthProvider(String name, String versionStr, String info)",
                  "description": "Constructs a provider with the specified name, version string,\n and information."
                }
              ]
            },
            {
              "name": "login",
              "overloads": [
                {
                  "signature": "public abstract void login(Subject subject, CallbackHandler handler) throws LoginException",
                  "description": "Log in to this provider.\n\n  The provider relies on a CallbackHandler\n to obtain authentication information from the caller\n (a PIN, for example).  If the caller passes a null\n handler to this method, the provider uses the handler set in the\n setCallbackHandler method.\n If no handler was set in that method, the provider queries the\n auth.login.defaultCallbackHandler security property\n for the fully qualified class name of a default handler implementation.\n If the security property is not set,\n the provider is assumed to have alternative means\n for obtaining authentication information."
                }
              ]
            },
            {
              "name": "logout",
              "overloads": [
                {
                  "signature": "public abstract void logout() throws LoginException",
                  "description": "Log out from this provider."
                }
              ]
            },
            {
              "name": "setCallbackHandler",
              "overloads": [
                {
                  "signature": "public abstract void setCallbackHandler(CallbackHandler handler)",
                  "description": "Set a CallbackHandler.\n\n  The provider uses this handler if one is not passed to the\n login method.  The provider also uses this handler\n if it invokes login on behalf of callers.\n In either case if a handler is not set via this method,\n the provider queries the\n auth.login.defaultCallbackHandler security property\n for the fully qualified class name of a default handler implementation.\n If the security property is not set,\n the provider is assumed to have alternative means\n for obtaining authentication information."
                }
              ]
            }
          ]
        },
        {
          "name": "BasicPermission",
          "methods": [
            {
              "name": "BasicPermission",
              "overloads": [
                {
                  "signature": "public BasicPermission(String name)",
                  "description": "Creates a new BasicPermission with the specified name.\n Name is the symbolic name of the permission, such as\n \"setFactory\",\n \"print.queueJob\", or \"topLevelWindow\", etc."
                },
                {
                  "signature": "public BasicPermission(String name, String actions)",
                  "description": "Creates a new BasicPermission object with the specified name.\n The name is the symbolic name of the BasicPermission, and the\n actions String is currently unused."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if the specified permission is \"implied\" by\n this object.\n \n More specifically, this method returns true if:\n \n  p's class is the same as this object's class, and\n  p's name equals or (in the case of wildcards)\n      is implied by this object's\n      name. For example, \"a.b.*\" implies \"a.b.c\"."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two BasicPermission objects for equality.\n Checks that obj's class is the same as this object's class\n and has the same name as this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object.\n The hash code used is the hash code of the name, that is,\n getName().hashCode(), where getName is\n from the Permission superclass."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions,\n which currently is the empty string \"\", since there are no actions for\n a BasicPermission."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing BasicPermission\n objects.\n\n BasicPermission objects must be stored in a manner that allows them\n to be inserted in any order, but that also enables the\n PermissionCollection implies method\n to be implemented in an efficient (and consistent) manner."
                }
              ]
            }
          ]
        },
        {
          "name": "Provider",
          "methods": [
            {
              "name": "Provider",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected Provider(String name, double version, String info)",
                  "description": "Constructs a provider with the specified name, version number,\n and information. Calling this constructor is equivalent to call the\n Provider(String, String, String) with name\n name, Double.toString(version), and info.",
                  "deprecated": true
                },
                {
                  "signature": "protected Provider(String name, String versionStr, String info)",
                  "description": "Constructs a provider with the specified name, version string,\n and information.\n\n The version string contains a version number optionally followed\n by other information separated by one of the characters of '+', '-'.\n\n The format for the version number is:\n\n      ^[0-9]+(\\.[0-9]+)*\n \n\n In order to return the version number in a double, when there are\n more than two components (separated by '.' as defined above), only\n the first two components are retained. The resulting string is then\n passed to Double.valueOf(String) to generate version number,\n i.e. getVersion().\n If the conversion failed, value 0 will be used."
                }
              ]
            },
            {
              "name": "configure",
              "overloads": [
                {
                  "signature": "public Provider configure(String configArg)",
                  "description": "Apply the supplied configuration argument to this provider instance\n and return the configured provider. Note that if this provider cannot\n be configured in-place, a new provider will be created and returned.\n Therefore, callers should always use the returned provider."
                }
              ]
            },
            {
              "name": "isConfigured",
              "overloads": [
                {
                  "signature": "public boolean isConfigured()",
                  "description": "Check if this provider instance has been configured."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of this provider."
                }
              ]
            },
            {
              "name": "getVersion",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public double getVersion()",
                  "description": "Returns the version number for this provider.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getVersionStr",
              "overloads": [
                {
                  "signature": "public String getVersionStr()",
                  "description": "Returns the version string for this provider."
                }
              ]
            },
            {
              "name": "getInfo",
              "overloads": [
                {
                  "signature": "public String getInfo()",
                  "description": "Returns a human-readable description of the provider and its\n services.  This may return an HTML page, with relevant links."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string with the name and the version string\n of this provider."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Clears this provider so that it no longer contains the properties\n used to look up facilities implemented by the provider.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"clearProviderProperties.\"+name\n (where name is the provider name) to see if it's ok to clear\n this provider."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public void load(InputStream inStream) throws IOException",
                  "description": "Reads a property list (key and element pairs) from the input stream."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<?,?> t)",
                  "description": "Copies all of the mappings from the specified Map to this provider.\n These mappings will replace any properties that this provider had\n for any of the keys currently in the specified Map."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<Object,Object>> entrySet()",
                  "description": "Returns an unmodifiable Set view of the property entries contained\n in this Provider."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<Object> keySet()",
                  "description": "Returns an unmodifiable Set view of the property keys contained in\n this provider."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<Object> values()",
                  "description": "Returns an unmodifiable Collection view of the property values\n contained in this provider."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public Object put(Object key, Object value)",
                  "description": "Sets the key property to have the specified\n value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "putIfAbsent",
              "overloads": [
                {
                  "signature": "public Object putIfAbsent(Object key, Object value)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public Object remove(Object key)",
                  "description": "Removes the key property (and its corresponding\n value).\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"removeProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to remove this\n provider's properties."
                },
                {
                  "signature": "public boolean remove(Object key, Object value)",
                  "description": "Removes the entry for the specified key only if it is currently\n mapped to the specified value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"removeProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to remove this\n provider's properties."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public boolean replace(Object key, Object oldValue, Object newValue)",
                  "description": "Replaces the entry for the specified key only if currently\n mapped to the specified value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                },
                {
                  "signature": "public Object replace(Object key, Object value)",
                  "description": "Replaces the entry for the specified key only if it is\n currently mapped to some value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public void replaceAll(BiFunction<? super Object,? super Object,? extends Object> function)",
                  "description": "Replaces each entry's value with the result of invoking the given\n function on that entry, in the order entries are returned by an entry\n set iterator, until all entries have been processed or the function\n throws an exception.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "public Object compute(Object key, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its\n current mapped value (or null if there is no current\n mapping).\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "public Object computeIfAbsent(Object key, Function<? super Object,? extends Object> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or\n is mapped to null), attempts to compute its value using\n the given mapping function and enters it into this map unless\n null.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "public Object computeIfPresent(Object key, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public Object merge(Object key, Object value, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given value. Otherwise,\n replaces the value with the results of the given remapping function,\n or removes if the result is null. This method may be of use when\n combining multiple mapped values for a key.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "getOrDefault",
              "overloads": [
                {
                  "signature": "public Object getOrDefault(Object key, Object defaultValue)",
                  "description": "Description copied from interface:Map"
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(BiConsumer<? super Object,? super Object> action)",
                  "description": "Description copied from interface:Map"
                }
              ]
            },
            {
              "name": "getService",
              "overloads": [
                {
                  "signature": "public Provider.Service getService(String type, String algorithm)",
                  "description": "Get the service describing this Provider's implementation of the\n specified type of this algorithm or alias. If no such\n implementation exists, this method returns null. If there are two\n matching services, one added to this provider using\n putService() and one added via put(),\n the service added via putService() is returned."
                }
              ]
            },
            {
              "name": "getServices",
              "overloads": [
                {
                  "signature": "public Set<Provider.Service> getServices()",
                  "description": "Get an unmodifiable Set of all services supported by\n this Provider."
                }
              ]
            },
            {
              "name": "putService",
              "overloads": [
                {
                  "signature": "protected void putService(Provider.Service s)",
                  "description": "Add a service. If a service of the same type with the same algorithm\n name exists and it was added using putService(),\n it is replaced by the new service.\n This method also places information about this service\n in the provider's Hashtable values in the format described in the\n Java Cryptography Architecture (JCA) Reference Guide.\n\n Also, if there is a security manager, its\n checkSecurityAccess method is called with the string\n \"putProviderProperty.\"+name, where name is\n the provider name, to see if it's ok to set this provider's property\n values. If the default implementation of checkSecurityAccess\n is used (that is, that method is not overridden), then this results in\n a call to the security manager's checkPermission method with\n a SecurityPermission(\"putProviderProperty.\"+name)\n permission."
                }
              ]
            },
            {
              "name": "removeService",
              "overloads": [
                {
                  "signature": "protected void removeService(Provider.Service s)",
                  "description": "Remove a service previously added using\n putService(). The specified service is removed from\n this provider. It will no longer be returned by\n getService() and its information will be removed\n from this provider's Hashtable.\n\n Also, if there is a security manager, its\n checkSecurityAccess method is called with the string\n \"removeProviderProperty.\"+name, where name is\n the provider name, to see if it's ok to remove this provider's\n properties. If the default implementation of\n checkSecurityAccess is used (that is, that method is not\n overridden), then this results in a call to the security manager's\n checkPermission method with a\n SecurityPermission(\"removeProviderProperty.\"+name)\n permission."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}