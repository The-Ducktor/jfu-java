{
  "packages": [
    {
      "package": "java.lang",
      "description": "Core Java language classes",
      "classes": [
        {
          "name": "AbstractMethodError",
          "methods": [
            {
              "name": "AbstractMethodError",
              "overloads": [
                {
                  "signature": "public AbstractMethodError()",
                  "description": "Constructs an AbstractMethodError with no detail  message."
                },
                {
                  "signature": "public AbstractMethodError(String s)",
                  "description": "Constructs an AbstractMethodError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Appendable",
          "methods": [
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "Appendable append(CharSequence csq) throws IOException",
                  "description": "Appends the specified character sequence to this Appendable.\n\n  Depending on which class implements the character sequence\n csq, the entire sequence may not be appended.  For\n instance, if csq is a CharBuffer then\n the subsequence to append is defined by the buffer's position and limit."
                },
                {
                  "signature": "Appendable append(CharSequence csq, int start, int end) throws IOException",
                  "description": "Appends a subsequence of the specified character sequence to this\n Appendable.\n\n  An invocation of this method of the form out.append(csq, start, end)\n when csq is not null, behaves in\n exactly the same way as the invocation\n\n      out.append(csq.subSequence(start, end))"
                },
                {
                  "signature": "Appendable append(char c) throws IOException",
                  "description": "Appends the specified character to this Appendable."
                }
              ]
            }
          ]
        },
        {
          "name": "ArithmeticException",
          "methods": [
            {
              "name": "ArithmeticException",
              "overloads": [
                {
                  "signature": "public ArithmeticException()",
                  "description": "Constructs an ArithmeticException with no detail\n message."
                },
                {
                  "signature": "public ArithmeticException(String s)",
                  "description": "Constructs an ArithmeticException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayIndexOutOfBoundsException",
          "methods": [
            {
              "name": "ArrayIndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public ArrayIndexOutOfBoundsException()",
                  "description": "Constructs an ArrayIndexOutOfBoundsException with no detail\n message."
                },
                {
                  "signature": "public ArrayIndexOutOfBoundsException(String s)",
                  "description": "Constructs an ArrayIndexOutOfBoundsException class with the\n specified detail message."
                },
                {
                  "signature": "public ArrayIndexOutOfBoundsException(int index)",
                  "description": "Constructs a new ArrayIndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayStoreException",
          "methods": [
            {
              "name": "ArrayStoreException",
              "overloads": [
                {
                  "signature": "public ArrayStoreException()",
                  "description": "Constructs an ArrayStoreException with no detail message."
                },
                {
                  "signature": "public ArrayStoreException(String s)",
                  "description": "Constructs an ArrayStoreException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "AssertionError",
          "methods": [
            {
              "name": "AssertionError",
              "overloads": [
                {
                  "signature": "public AssertionError()",
                  "description": "Constructs an AssertionError with no detail message."
                },
                {
                  "signature": "public AssertionError(Object detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified object, which is converted to a string as\n defined in section 5.1.11 of\n The Java Language Specification.\n\n If the specified object is an instance of Throwable, it\n becomes the cause of the newly constructed assertion error."
                },
                {
                  "signature": "public AssertionError(boolean detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified boolean, which is converted to\n a string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(char detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified char, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(int detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified int, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(long detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified long, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(float detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified float, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(double detailMessage)",
                  "description": "Constructs an AssertionError with its detail message derived\n from the specified double, which is converted to a\n string as defined in section 5.1.11 of\n The Java Language Specification."
                },
                {
                  "signature": "public AssertionError(String message, Throwable cause)",
                  "description": "Constructs a new AssertionError with the specified\n detail message and cause.\n\n Note that the detail message associated with\n cause is not automatically incorporated in\n this error's detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "AutoCloseable",
          "methods": [
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws Exception",
                  "description": "Closes this resource, relinquishing any underlying resources.\n This method is invoked automatically on objects managed by the\n try-with-resources statement."
                }
              ]
            }
          ]
        },
        {
          "name": "Boolean",
          "methods": [
            {
              "name": "Boolean",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Boolean(boolean value)",
                  "description": "Allocates a Boolean object representing the\n value argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Boolean(String s)",
                  "description": "Allocates a Boolean object representing the value\n true if the string argument is not null\n and is equal, ignoring case, to the string \"true\".\n Otherwise, allocates a Boolean object representing the\n value false.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "parseBoolean",
              "overloads": [
                {
                  "signature": "public static boolean parseBoolean(String s)",
                  "description": "Parses the string argument as a boolean.  The boolean\n returned represents the value true if the string argument\n is not null and is equal, ignoring case, to the string\n \"true\".\n Otherwise, a false value is returned, including for a null\n argument.\n Example: Boolean.parseBoolean(\"True\") returns true.\n Example: Boolean.parseBoolean(\"yes\") returns false."
                }
              ]
            },
            {
              "name": "booleanValue",
              "overloads": [
                {
                  "signature": "public boolean booleanValue()",
                  "description": "Returns the value of this Boolean object as a boolean\n primitive."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Boolean valueOf(boolean b)",
                  "description": "Returns a Boolean instance representing the specified\n boolean value.  If the specified boolean value\n is true, this method returns Boolean.TRUE;\n if it is false, this method returns Boolean.FALSE.\n If a new Boolean instance is not required, this method\n should generally be used in preference to the constructor\n Boolean(boolean), as this method is likely to yield\n significantly better space and time performance."
                },
                {
                  "signature": "public static Boolean valueOf(String s)",
                  "description": "Returns a Boolean with a value represented by the\n specified string.  The Boolean returned represents a\n true value if the string argument is not null\n and is equal, ignoring case, to the string \"true\".\n Otherwise, a false value is returned, including for a null\n argument."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(boolean b)",
                  "description": "Returns a String object representing the specified\n boolean.  If the specified boolean is true, then\n the string \"true\" will be returned, otherwise the\n string \"false\" will be returned."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this Boolean's\n value.  If this object represents the value true,\n a string equal to \"true\" is returned. Otherwise, a\n string equal to \"false\" is returned."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Boolean object."
                },
                {
                  "signature": "public static int hashCode(boolean value)",
                  "description": "Returns a hash code for a boolean value; compatible with\n Boolean.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if and only if the argument is not\n null and is a Boolean object that\n represents the same boolean value as this object."
                }
              ]
            },
            {
              "name": "getBoolean",
              "overloads": [
                {
                  "signature": "public static boolean getBoolean(String name)",
                  "description": "Returns true if and only if the system property named\n by the argument exists and is equal to, ignoring case, the\n string \"true\".\n A system property is accessible through getProperty, a\n method defined by the System class.   If there is no\n property with the specified name, or if the specified name is\n empty or null, then false is returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Boolean b)",
                  "description": "Compares this Boolean instance with another."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(boolean x, boolean y)",
                  "description": "Compares two boolean values.\n The value returned is identical to what would be returned by:\n     Boolean.valueOf(x).compareTo(Boolean.valueOf(y))"
                }
              ]
            },
            {
              "name": "logicalAnd",
              "overloads": [
                {
                  "signature": "public static boolean logicalAnd(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical AND operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "logicalOr",
              "overloads": [
                {
                  "signature": "public static boolean logicalOr(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical OR operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "logicalXor",
              "overloads": [
                {
                  "signature": "public static boolean logicalXor(boolean a, boolean b)",
                  "description": "Returns the result of applying the logical XOR operator to the\n specified boolean operands."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Boolean>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            }
          ]
        },
        {
          "name": "BootstrapMethodError",
          "methods": [
            {
              "name": "BootstrapMethodError",
              "overloads": [
                {
                  "signature": "public BootstrapMethodError()",
                  "description": "Constructs a BootstrapMethodError with no detail message."
                },
                {
                  "signature": "public BootstrapMethodError(String s)",
                  "description": "Constructs a BootstrapMethodError with the specified\n detail message."
                },
                {
                  "signature": "public BootstrapMethodError(String s, Throwable cause)",
                  "description": "Constructs a BootstrapMethodError with the specified\n detail message and cause."
                },
                {
                  "signature": "public BootstrapMethodError(Throwable cause)",
                  "description": "Constructs a BootstrapMethodError with the specified\n cause."
                }
              ]
            }
          ]
        },
        {
          "name": "Byte",
          "methods": [
            {
              "name": "Byte",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Byte(byte value)",
                  "description": "Constructs a newly allocated Byte object that\n represents the specified byte value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Byte(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Byte object that\n represents the byte value indicated by the\n String parameter. The string is converted to a\n byte value in exactly the manner used by the\n parseByte method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(byte b)",
                  "description": "Returns a new String object representing the\n specified byte. The radix is assumed to be 10."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Byte's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the byte value were given as an argument to the\n toString(byte) method."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Byte>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Byte valueOf(byte b)",
                  "description": "Returns a Byte instance representing the specified\n byte value.\n If a new Byte instance is not required, this method\n should generally be used in preference to the constructor\n Byte(byte), as this method is likely to yield\n significantly better space and time performance since\n all byte values are cached."
                },
                {
                  "signature": "public static Byte valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Byte object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed byte in\n the radix specified by the second argument, exactly as if the\n argument were given to the parseByte(java.lang.String, int) method. The result is a Byte object that\n represents the byte value specified by the string.\n\n  In other words, this method returns a Byte object\n equal to the value of:\n\n \n new Byte(Byte.parseByte(s, radix))"
                },
                {
                  "signature": "public static Byte valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Byte object holding the value\n given by the specified String. The argument is\n interpreted as representing a signed decimal byte,\n exactly as if the argument were given to the parseByte(java.lang.String) method. The result is a\n Byte object that represents the byte\n value specified by the string.\n\n  In other words, this method returns a Byte object\n equal to the value of:\n\n \n new Byte(Byte.parseByte(s))"
                }
              ]
            },
            {
              "name": "parseByte",
              "overloads": [
                {
                  "signature": "public static byte parseByte(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed byte in the\n radix specified by the second argument. The characters in the\n string must all be digits, of the specified radix (as\n determined by whether Character.digit(char, int) returns a nonnegative value) except that the first\n character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value.  The resulting byte value is\n returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n  The first argument is null or is a string of\n length zero.\n\n  The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n  Any character of the string is not a digit of the\n specified radix, except that the first character may be a minus\n sign '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n  The value represented by the string is not a value of type\n byte."
                },
                {
                  "signature": "public static byte parseByte(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal \n byte. The characters in the string must all be decimal digits,\n except that the first character may be an ASCII minus sign\n '-' ('\\u002D') to indicate a negative\n value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting byte value is returned, exactly as if the\n argument and the radix 10 were given as arguments to the parseByte(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Byte decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Byte.\n Accepts decimal, hexadecimal, and octal numbers given by\n the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Byte.parseByte method with the indicated radix (10, 16, or 8).\n This sequence of characters must represent a positive value or\n a NumberFormatException will be thrown.  The result is\n negated if first character of the specified String is\n the minus sign.  No whitespace characters are permitted in the\n String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Byte as a\n byte."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Byte as a short after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Byte as an int after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Byte as a long after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Byte as a float after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Byte as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Byte; equal to the result\n of invoking intValue()."
                },
                {
                  "signature": "public static int hashCode(byte value)",
                  "description": "Returns a hash code for a byte value; compatible with\n Byte.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Byte object that\n contains the same byte value as this object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Byte anotherByte)",
                  "description": "Compares two Byte objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(byte x, byte y)",
                  "description": "Compares two byte values numerically.\n The value returned is identical to what would be returned by:\n     Byte.valueOf(x).compareTo(Byte.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(byte x, byte y)",
                  "description": "Compares two byte values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "toUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int toUnsignedInt(byte x)",
                  "description": "Converts the argument to an int by an unsigned\n conversion.  In an unsigned conversion to an int, the\n high-order 24 bits of the int are zero and the\n low-order 8 bits are equal to the bits of the byte argument.\n\n Consequently, zero and positive byte values are mapped\n to a numerically equal int value and negative \n byte values are mapped to an int value equal to the\n input plus 28."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(byte x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 56 bits of the long are zero and the\n low-order 8 bits are equal to the bits of the byte argument.\n\n Consequently, zero and positive byte values are mapped\n to a numerically equal long value and negative \n byte values are mapped to a long value equal to the\n input plus 28."
                }
              ]
            }
          ]
        },
        {
          "name": "Character",
          "methods": [
            {
              "name": "Character",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Character(char value)",
                  "description": "Constructs a newly allocated Character object that\n represents the specified char value.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Character>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Character valueOf(char c)",
                  "description": "Returns a Character instance representing the specified\n char value.\n If a new Character instance is not required, this method\n should generally be used in preference to the constructor\n Character(char), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range \n '\\u0000' to '\\u007F', inclusive, and may\n cache other values outside of this range."
                }
              ]
            },
            {
              "name": "charValue",
              "overloads": [
                {
                  "signature": "public char charValue()",
                  "description": "Returns the value of this Character object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Character; equal to the result\n of invoking charValue()."
                },
                {
                  "signature": "public static int hashCode(char value)",
                  "description": "Returns a hash code for a char value; compatible with\n Character.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is not\n null and is a Character object that\n represents the same char value as this object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Character's value.  The result is a string of\n length 1 whose sole component is the primitive\n char value represented by this\n Character object."
                },
                {
                  "signature": "public static String toString(char c)",
                  "description": "Returns a String object representing the\n specified char.  The result is a string of length\n 1 consisting solely of the specified char."
                },
                {
                  "signature": "public static String toString(int codePoint)",
                  "description": "Returns a String object representing the\n specified character (Unicode code point).  The result is a string of\n length 1 or 2, consisting solely of the specified codePoint."
                }
              ]
            },
            {
              "name": "isValidCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isValidCodePoint(int codePoint)",
                  "description": "Determines whether the specified code point is a valid\n \n Unicode code point value."
                }
              ]
            },
            {
              "name": "isBmpCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isBmpCodePoint(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is in the Basic Multilingual Plane (BMP).\n Such code points can be represented using a single char."
                }
              ]
            },
            {
              "name": "isSupplementaryCodePoint",
              "overloads": [
                {
                  "signature": "public static boolean isSupplementaryCodePoint(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is in the supplementary character range."
                }
              ]
            },
            {
              "name": "isHighSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isHighSurrogate(char ch)",
                  "description": "Determines if the given char value is a\n \n Unicode high-surrogate code unit\n (also known as leading-surrogate code unit).\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding."
                }
              ]
            },
            {
              "name": "isLowSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isLowSurrogate(char ch)",
                  "description": "Determines if the given char value is a\n \n Unicode low-surrogate code unit\n (also known as trailing-surrogate code unit).\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding."
                }
              ]
            },
            {
              "name": "isSurrogate",
              "overloads": [
                {
                  "signature": "public static boolean isSurrogate(char ch)",
                  "description": "Determines if the given char value is a Unicode\n surrogate code unit.\n\n Such values do not represent characters by themselves,\n but are used in the representation of\n supplementary characters\n in the UTF-16 encoding.\n\n A char value is a surrogate code unit if and only if it is either\n a low-surrogate code unit or\n a high-surrogate code unit."
                }
              ]
            },
            {
              "name": "isSurrogatePair",
              "overloads": [
                {
                  "signature": "public static boolean isSurrogatePair(char high, char low)",
                  "description": "Determines whether the specified pair of char\n values is a valid\n \n Unicode surrogate pair.\n\n This method is equivalent to the expression:\n \n isHighSurrogate(high) && isLowSurrogate(low)"
                }
              ]
            },
            {
              "name": "charCount",
              "overloads": [
                {
                  "signature": "public static int charCount(int codePoint)",
                  "description": "Determines the number of char values needed to\n represent the specified character (Unicode code point). If the\n specified character is equal to or greater than 0x10000, then\n the method returns 2. Otherwise, the method returns 1.\n\n This method doesn't validate the specified character to be a\n valid Unicode code point. The caller must validate the\n character value using isValidCodePoint\n if necessary."
                }
              ]
            },
            {
              "name": "toCodePoint",
              "overloads": [
                {
                  "signature": "public static int toCodePoint(char high, char low)",
                  "description": "Converts the specified surrogate pair to its supplementary code\n point value. This method does not validate the specified\n surrogate pair. The caller must validate it using isSurrogatePair if necessary."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public static int codePointAt(CharSequence seq, int index)",
                  "description": "Returns the code point at the given index of the\n CharSequence. If the char value at\n the given index in the CharSequence is in the\n high-surrogate range, the following index is less than the\n length of the CharSequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                },
                {
                  "signature": "public static int codePointAt(char[] a, int index)",
                  "description": "Returns the code point at the given index of the\n char array. If the char value at\n the given index in the char array is in the\n high-surrogate range, the following index is less than the\n length of the char array, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                },
                {
                  "signature": "public static int codePointAt(char[] a, int index, int limit)",
                  "description": "Returns the code point at the given index of the\n char array, where only array elements with\n index less than limit can be used. If\n the char value at the given index in the\n char array is in the high-surrogate range, the\n following index is less than the limit, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public static int codePointBefore(CharSequence seq, int index)",
                  "description": "Returns the code point preceding the given index of the\n CharSequence. If the char value at\n (index - 1) in the CharSequence is in\n the low-surrogate range, (index - 2) is not\n negative, and the char value at (index - 2)\n in the CharSequence is in the\n high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                },
                {
                  "signature": "public static int codePointBefore(char[] a, int index)",
                  "description": "Returns the code point preceding the given index of the\n char array. If the char value at\n (index - 1) in the char array is in\n the low-surrogate range, (index - 2) is not\n negative, and the char value at (index - 2)\n in the char array is in the\n high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                },
                {
                  "signature": "public static int codePointBefore(char[] a, int index, int start)",
                  "description": "Returns the code point preceding the given index of the\n char array, where only array elements with\n index greater than or equal to start\n can be used. If the char value at (index - 1)\n in the char array is in the\n low-surrogate range, (index - 2) is not less than\n start, and the char value at\n (index - 2) in the char array is in\n the high-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at (index - 1) is\n returned."
                }
              ]
            },
            {
              "name": "highSurrogate",
              "overloads": [
                {
                  "signature": "public static char highSurrogate(int codePoint)",
                  "description": "Returns the leading surrogate (a\n \n high surrogate code unit) of the\n \n surrogate pair\n representing the specified supplementary character (Unicode\n code point) in the UTF-16 encoding.  If the specified character\n is not a\n supplementary character,\n an unspecified char is returned.\n\n If\n isSupplementaryCodePoint(x)\n is true, then\n isHighSurrogate(highSurrogate(x)) and\n toCodePoint(highSurrogate(x), lowSurrogate(x)) == x\n are also always true."
                }
              ]
            },
            {
              "name": "lowSurrogate",
              "overloads": [
                {
                  "signature": "public static char lowSurrogate(int codePoint)",
                  "description": "Returns the trailing surrogate (a\n \n low surrogate code unit) of the\n \n surrogate pair\n representing the specified supplementary character (Unicode\n code point) in the UTF-16 encoding.  If the specified character\n is not a\n supplementary character,\n an unspecified char is returned.\n\n If\n isSupplementaryCodePoint(x)\n is true, then\n isLowSurrogate(lowSurrogate(x)) and\n toCodePoint(highSurrogate(x), lowSurrogate(x)) == x\n are also always true."
                }
              ]
            },
            {
              "name": "toChars",
              "overloads": [
                {
                  "signature": "public static int toChars(int codePoint, char[] dst, int dstIndex)",
                  "description": "Converts the specified character (Unicode code point) to its\n UTF-16 representation. If the specified code point is a BMP\n (Basic Multilingual Plane or Plane 0) value, the same value is\n stored in dst[dstIndex], and 1 is returned. If the\n specified code point is a supplementary character, its\n surrogate values are stored in dst[dstIndex]\n (high-surrogate) and dst[dstIndex+1]\n (low-surrogate), and 2 is returned."
                },
                {
                  "signature": "public static char[] toChars(int codePoint)",
                  "description": "Converts the specified character (Unicode code point) to its\n UTF-16 representation stored in a char array. If\n the specified code point is a BMP (Basic Multilingual Plane or\n Plane 0) value, the resulting char array has\n the same value as codePoint. If the specified code\n point is a supplementary code point, the resulting\n char array has the corresponding surrogate pair."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the text range of\n the specified char sequence. The text range begins at the\n specified beginIndex and extends to the\n char at index endIndex - 1. Thus the\n length (in chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n the text range count as one code point each."
                },
                {
                  "signature": "public static int codePointCount(char[] a, int offset, int count)",
                  "description": "Returns the number of Unicode code points in a subarray of the\n char array argument. The offset\n argument is the index of the first char of the\n subarray and the count argument specifies the\n length of the subarray in chars. Unpaired\n surrogates within the subarray count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)",
                  "description": "Returns the index within the given char sequence that is offset\n from the given index by codePointOffset\n code points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                },
                {
                  "signature": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)",
                  "description": "Returns the index within the given char subarray\n that is offset from the given index by\n codePointOffset code points. The\n start and count arguments specify a\n subarray of the char array. Unpaired surrogates\n within the text range given by index and\n codePointOffset count as one code point each."
                }
              ]
            },
            {
              "name": "isLowerCase",
              "overloads": [
                {
                  "signature": "public static boolean isLowerCase(char ch)",
                  "description": "Determines if the specified character is a lowercase character.\n \n A character is lowercase if its general category type, provided\n by Character.getType(ch), is\n LOWERCASE_LETTER, or it has contributory property\n Other_Lowercase as defined by the Unicode Standard.\n \n The following are examples of lowercase characters:\n  a b c d e f g h i j k l m n o p q r s t u v w x y z\n '\\u00DF' '\\u00E0' '\\u00E1' '\\u00E2' '\\u00E3' '\\u00E4' '\\u00E5' '\\u00E6'\n '\\u00E7' '\\u00E8' '\\u00E9' '\\u00EA' '\\u00EB' '\\u00EC' '\\u00ED' '\\u00EE'\n '\\u00EF' '\\u00F0' '\\u00F1' '\\u00F2' '\\u00F3' '\\u00F4' '\\u00F5' '\\u00F6'\n '\\u00F8' '\\u00F9' '\\u00FA' '\\u00FB' '\\u00FC' '\\u00FD' '\\u00FE' '\\u00FF'\n \n  Many other Unicode characters are lowercase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLowerCase(int) method."
                },
                {
                  "signature": "public static boolean isLowerCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a\n lowercase character.\n \n A character is lowercase if its general category type, provided\n by getType(codePoint), is\n LOWERCASE_LETTER, or it has contributory property\n Other_Lowercase as defined by the Unicode Standard.\n \n The following are examples of lowercase characters:\n  a b c d e f g h i j k l m n o p q r s t u v w x y z\n '\\u00DF' '\\u00E0' '\\u00E1' '\\u00E2' '\\u00E3' '\\u00E4' '\\u00E5' '\\u00E6'\n '\\u00E7' '\\u00E8' '\\u00E9' '\\u00EA' '\\u00EB' '\\u00EC' '\\u00ED' '\\u00EE'\n '\\u00EF' '\\u00F0' '\\u00F1' '\\u00F2' '\\u00F3' '\\u00F4' '\\u00F5' '\\u00F6'\n '\\u00F8' '\\u00F9' '\\u00FA' '\\u00FB' '\\u00FC' '\\u00FD' '\\u00FE' '\\u00FF'\n \n  Many other Unicode characters are lowercase too."
                }
              ]
            },
            {
              "name": "isUpperCase",
              "overloads": [
                {
                  "signature": "public static boolean isUpperCase(char ch)",
                  "description": "Determines if the specified character is an uppercase character.\n \n A character is uppercase if its general category type, provided by\n Character.getType(ch), is UPPERCASE_LETTER.\n or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n \n The following are examples of uppercase characters:\n  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n '\\u00C0' '\\u00C1' '\\u00C2' '\\u00C3' '\\u00C4' '\\u00C5' '\\u00C6' '\\u00C7'\n '\\u00C8' '\\u00C9' '\\u00CA' '\\u00CB' '\\u00CC' '\\u00CD' '\\u00CE' '\\u00CF'\n '\\u00D0' '\\u00D1' '\\u00D2' '\\u00D3' '\\u00D4' '\\u00D5' '\\u00D6' '\\u00D8'\n '\\u00D9' '\\u00DA' '\\u00DB' '\\u00DC' '\\u00DD' '\\u00DE'\n \n  Many other Unicode characters are uppercase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUpperCase(int) method."
                },
                {
                  "signature": "public static boolean isUpperCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is an uppercase character.\n \n A character is uppercase if its general category type, provided by\n getType(codePoint), is UPPERCASE_LETTER,\n or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n \n The following are examples of uppercase characters:\n  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n '\\u00C0' '\\u00C1' '\\u00C2' '\\u00C3' '\\u00C4' '\\u00C5' '\\u00C6' '\\u00C7'\n '\\u00C8' '\\u00C9' '\\u00CA' '\\u00CB' '\\u00CC' '\\u00CD' '\\u00CE' '\\u00CF'\n '\\u00D0' '\\u00D1' '\\u00D2' '\\u00D3' '\\u00D4' '\\u00D5' '\\u00D6' '\\u00D8'\n '\\u00D9' '\\u00DA' '\\u00DB' '\\u00DC' '\\u00DD' '\\u00DE'\n \n  Many other Unicode characters are uppercase too."
                }
              ]
            },
            {
              "name": "isTitleCase",
              "overloads": [
                {
                  "signature": "public static boolean isTitleCase(char ch)",
                  "description": "Determines if the specified character is a titlecase character.\n \n A character is a titlecase character if its general\n category type, provided by Character.getType(ch),\n is TITLECASE_LETTER.\n \n Some characters look like pairs of Latin letters. For example, there\n is an uppercase letter that looks like \"LJ\" and has a corresponding\n lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\n is the appropriate form to use when rendering a word in lowercase\n with initial capitals, as for a book title.\n \n These are some of the Unicode characters for which this method returns\n true:\n \n LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON\n LATIN CAPITAL LETTER L WITH SMALL LETTER J\n LATIN CAPITAL LETTER N WITH SMALL LETTER J\n LATIN CAPITAL LETTER D WITH SMALL LETTER Z\n \n  Many other Unicode characters are titlecase too.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isTitleCase(int) method."
                },
                {
                  "signature": "public static boolean isTitleCase(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a titlecase character.\n \n A character is a titlecase character if its general\n category type, provided by getType(codePoint),\n is TITLECASE_LETTER.\n \n Some characters look like pairs of Latin letters. For example, there\n is an uppercase letter that looks like \"LJ\" and has a corresponding\n lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\n is the appropriate form to use when rendering a word in lowercase\n with initial capitals, as for a book title.\n \n These are some of the Unicode characters for which this method returns\n true:\n \n LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON\n LATIN CAPITAL LETTER L WITH SMALL LETTER J\n LATIN CAPITAL LETTER N WITH SMALL LETTER J\n LATIN CAPITAL LETTER D WITH SMALL LETTER Z\n \n  Many other Unicode characters are titlecase too."
                }
              ]
            },
            {
              "name": "isDigit",
              "overloads": [
                {
                  "signature": "public static boolean isDigit(char ch)",
                  "description": "Determines if the specified character is a digit.\n \n A character is a digit if its general category type, provided\n by Character.getType(ch), is\n DECIMAL_DIGIT_NUMBER.\n \n Some Unicode character ranges that contain digits:\n \n '\\u0030' through '\\u0039',\n     ISO-LATIN-1 digits ('0' through '9')\n '\\u0660' through '\\u0669',\n     Arabic-Indic digits\n '\\u06F0' through '\\u06F9',\n     Extended Arabic-Indic digits\n '\\u0966' through '\\u096F',\n     Devanagari digits\n '\\uFF10' through '\\uFF19',\n     Fullwidth digits\n \n\n Many other character ranges contain digits as well.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isDigit(int) method."
                },
                {
                  "signature": "public static boolean isDigit(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a digit.\n \n A character is a digit if its general category type, provided\n by getType(codePoint), is\n DECIMAL_DIGIT_NUMBER.\n \n Some Unicode character ranges that contain digits:\n \n '\\u0030' through '\\u0039',\n     ISO-LATIN-1 digits ('0' through '9')\n '\\u0660' through '\\u0669',\n     Arabic-Indic digits\n '\\u06F0' through '\\u06F9',\n     Extended Arabic-Indic digits\n '\\u0966' through '\\u096F',\n     Devanagari digits\n '\\uFF10' through '\\uFF19',\n     Fullwidth digits\n \n\n Many other character ranges contain digits as well."
                }
              ]
            },
            {
              "name": "isDefined",
              "overloads": [
                {
                  "signature": "public static boolean isDefined(char ch)",
                  "description": "Determines if a character is defined in Unicode.\n \n A character is defined if at least one of the following is true:\n \n It has an entry in the UnicodeData file.\n It has a value in a range defined by the UnicodeData file.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isDefined(int) method."
                },
                {
                  "signature": "public static boolean isDefined(int codePoint)",
                  "description": "Determines if a character (Unicode code point) is defined in Unicode.\n \n A character is defined if at least one of the following is true:\n \n It has an entry in the UnicodeData file.\n It has a value in a range defined by the UnicodeData file."
                }
              ]
            },
            {
              "name": "isLetter",
              "overloads": [
                {
                  "signature": "public static boolean isLetter(char ch)",
                  "description": "Determines if the specified character is a letter.\n \n A character is considered to be a letter if its general\n category type, provided by Character.getType(ch),\n is any of the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n \n\n Not all letters have case. Many characters are\n letters but are neither uppercase nor lowercase nor titlecase.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLetter(int) method."
                },
                {
                  "signature": "public static boolean isLetter(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a letter.\n \n A character is considered to be a letter if its general\n category type, provided by getType(codePoint),\n is any of the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n \n\n Not all letters have case. Many characters are\n letters but are neither uppercase nor lowercase nor titlecase."
                }
              ]
            },
            {
              "name": "isLetterOrDigit",
              "overloads": [
                {
                  "signature": "public static boolean isLetterOrDigit(char ch)",
                  "description": "Determines if the specified character is a letter or digit.\n \n A character is considered to be a letter or digit if either\n Character.isLetter(char ch) or\n Character.isDigit(char ch) returns\n true for the character.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isLetterOrDigit(int) method."
                },
                {
                  "signature": "public static boolean isLetterOrDigit(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a letter or digit.\n \n A character is considered to be a letter or digit if either\n isLetter(codePoint) or\n isDigit(codePoint) returns\n true for the character."
                }
              ]
            },
            {
              "name": "isJavaLetter",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isJavaLetter(char ch)",
                  "description": "Determines if the specified character is permissible as the first\n character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns LETTER_NUMBER\n  ch is a currency symbol (such as '$')\n  ch is a connecting punctuation character (such as '_').",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isJavaLetterOrDigit",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isJavaLetterOrDigit(char ch)",
                  "description": "Determines if the specified character may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if and only if one\n of the following conditions is true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for the character.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isAlphabetic",
              "overloads": [
                {
                  "signature": "public static boolean isAlphabetic(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is alphabetic.\n \n A character is considered to be alphabetic if its general category type,\n provided by getType(codePoint), is any of\n the following:\n \n  UPPERCASE_LETTER\n  LOWERCASE_LETTER\n  TITLECASE_LETTER\n  MODIFIER_LETTER\n  OTHER_LETTER\n  LETTER_NUMBER\n \n or it has contributory property Other_Alphabetic as defined by the\n Unicode Standard."
                }
              ]
            },
            {
              "name": "isIdeographic",
              "overloads": [
                {
                  "signature": "public static boolean isIdeographic(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a CJKV\n (Chinese, Japanese, Korean and Vietnamese) ideograph, as defined by\n the Unicode Standard."
                }
              ]
            },
            {
              "name": "isJavaIdentifierStart",
              "overloads": [
                {
                  "signature": "public static boolean isJavaIdentifierStart(char ch)",
                  "description": "Determines if the specified character is\n permissible as the first character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns LETTER_NUMBER\n  ch is a currency symbol (such as '$')\n  ch is a connecting punctuation character (such as '_').\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isJavaIdentifierStart(int) method."
                },
                {
                  "signature": "public static boolean isJavaIdentifierStart(int codePoint)",
                  "description": "Determines if the character (Unicode code point) is\n permissible as the first character in a Java identifier.\n \n A character may start a Java identifier if and only if\n one of the following conditions is true:\n \n  isLetter(codePoint)\n      returns true\n  getType(codePoint)\n      returns LETTER_NUMBER\n  the referenced character is a currency symbol (such as '$')\n  the referenced character is a connecting punctuation character\n      (such as '_')."
                }
              ]
            },
            {
              "name": "isJavaIdentifierPart",
              "overloads": [
                {
                  "signature": "public static boolean isJavaIdentifierPart(char ch)",
                  "description": "Determines if the specified character may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if any of the following\n conditions are true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for the character\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isJavaIdentifierPart(int) method."
                },
                {
                  "signature": "public static boolean isJavaIdentifierPart(int codePoint)",
                  "description": "Determines if the character (Unicode code point) may be part of a Java\n identifier as other than the first character.\n \n A character may be part of a Java identifier if any of the following\n conditions are true:\n \n   it is a letter\n   it is a currency symbol (such as '$')\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable(codePoint) returns true for\n the code point"
                }
              ]
            },
            {
              "name": "isUnicodeIdentifierStart",
              "overloads": [
                {
                  "signature": "public static boolean isUnicodeIdentifierStart(char ch)",
                  "description": "Determines if the specified character is permissible as the\n first character in a Unicode identifier.\n \n A character may start a Unicode identifier if and only if\n one of the following conditions is true:\n \n  isLetter(ch) returns true\n  getType(ch) returns\n      LETTER_NUMBER.\n  it is an \n      Other_ID_Start character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Start := ID_Start + 'VERTICAL TILDE' (U+2E2F)\n \n 'VERTICAL TILDE' is added to Start for backward\n compatibility.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUnicodeIdentifierStart(int) method."
                },
                {
                  "signature": "public static boolean isUnicodeIdentifierStart(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is permissible as the\n first character in a Unicode identifier.\n \n A character may start a Unicode identifier if and only if\n one of the following conditions is true:\n \n  isLetter(codePoint)\n      returns true\n  getType(codePoint)\n      returns LETTER_NUMBER.\n  it is an \n      Other_ID_Start character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Start := ID_Start + 'VERTICAL TILDE' (U+2E2F)\n \n 'VERTICAL TILDE' is added to Start for backward\n compatibility."
                }
              ]
            },
            {
              "name": "isUnicodeIdentifierPart",
              "overloads": [
                {
                  "signature": "public static boolean isUnicodeIdentifierPart(char ch)",
                  "description": "Determines if the specified character may be part of a Unicode\n identifier as other than the first character.\n \n A character may be part of a Unicode identifier if and only if\n one of the following statements is true:\n \n   it is a letter\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for this character.\n  it is an \n      Other_ID_Start character.\n  it is an \n      Other_ID_Continue character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Continue := Start + ID_Continue + ignorable\n Medial := empty\n ignorable := isIdentifierIgnorable(char) returns true for the character\n \n ignorable is added to Continue for backward\n compatibility.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isUnicodeIdentifierPart(int) method."
                },
                {
                  "signature": "public static boolean isUnicodeIdentifierPart(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) may be part of a Unicode\n identifier as other than the first character.\n \n A character may be part of a Unicode identifier if and only if\n one of the following statements is true:\n \n   it is a letter\n   it is a connecting punctuation character (such as '_')\n   it is a digit\n   it is a numeric letter (such as a Roman numeral character)\n   it is a combining mark\n   it is a non-spacing mark\n  isIdentifierIgnorable returns\n true for this character.\n  it is an \n      Other_ID_Start character.\n  it is an \n      Other_ID_Continue character.\n \n \n This method conforms to \n UAX31-R1: Default Identifiers requirement of the Unicode Standard,\n with the following profile of UAX31:\n  Continue := Start + ID_Continue + ignorable\n Medial := empty\n ignorable := isIdentifierIgnorable(int) returns true for the character\n \n ignorable is added to Continue for backward\n compatibility."
                }
              ]
            },
            {
              "name": "isIdentifierIgnorable",
              "overloads": [
                {
                  "signature": "public static boolean isIdentifierIgnorable(char ch)",
                  "description": "Determines if the specified character should be regarded as\n an ignorable character in a Java identifier or a Unicode identifier.\n \n The following Unicode characters are ignorable in a Java identifier\n or a Unicode identifier:\n \n ISO control characters that are not whitespace\n \n '\\u0000' through '\\u0008'\n '\\u000E' through '\\u001B'\n '\\u007F' through '\\u009F'\n \n\n all characters that have the FORMAT general\n category value\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isIdentifierIgnorable(int) method."
                },
                {
                  "signature": "public static boolean isIdentifierIgnorable(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) should be regarded as\n an ignorable character in a Java identifier or a Unicode identifier.\n \n The following Unicode characters are ignorable in a Java identifier\n or a Unicode identifier:\n \n ISO control characters that are not whitespace\n \n '\\u0000' through '\\u0008'\n '\\u000E' through '\\u001B'\n '\\u007F' through '\\u009F'\n \n\n all characters that have the FORMAT general\n category value"
                }
              ]
            },
            {
              "name": "toLowerCase",
              "overloads": [
                {
                  "signature": "public static char toLowerCase(char ch)",
                  "description": "Converts the character argument to lowercase using case\n mapping information from the UnicodeData file.\n \n Note that\n Character.isLowerCase(Character.toLowerCase(ch))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toLowerCase() should be used to map\n characters to lowercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toLowerCase(int) method."
                },
                {
                  "signature": "public static int toLowerCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to\n lowercase using case mapping information from the UnicodeData\n file.\n\n  Note that\n Character.isLowerCase(Character.toLowerCase(codePoint))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toLowerCase() should be used to map\n characters to lowercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot."
                }
              ]
            },
            {
              "name": "toUpperCase",
              "overloads": [
                {
                  "signature": "public static char toUpperCase(char ch)",
                  "description": "Converts the character argument to uppercase using case mapping\n information from the UnicodeData file.\n \n Note that\n Character.isUpperCase(Character.toUpperCase(ch))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toUpperCase() should be used to map\n characters to uppercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toUpperCase(int) method."
                },
                {
                  "signature": "public static int toUpperCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to\n uppercase using case mapping information from the UnicodeData\n file.\n\n Note that\n Character.isUpperCase(Character.toUpperCase(codePoint))\n does not always return true for some ranges of\n characters, particularly those that are symbols or ideographs.\n\n In general, String.toUpperCase() should be used to map\n characters to uppercase. String case mapping methods\n have several benefits over Character case mapping methods.\n String case mapping methods can perform locale-sensitive\n mappings, context-sensitive mappings, and 1:M character mappings, whereas\n the Character case mapping methods cannot."
                }
              ]
            },
            {
              "name": "toTitleCase",
              "overloads": [
                {
                  "signature": "public static char toTitleCase(char ch)",
                  "description": "Converts the character argument to titlecase using case mapping\n information from the UnicodeData file. If a character has no\n explicit titlecase mapping and is not itself a titlecase char\n according to UnicodeData, then the uppercase mapping is\n returned as an equivalent titlecase mapping. If the\n char argument is already a titlecase\n char, the same char value will be\n returned.\n \n Note that\n Character.isTitleCase(Character.toTitleCase(ch))\n does not always return true for some ranges of\n characters.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the toTitleCase(int) method."
                },
                {
                  "signature": "public static int toTitleCase(int codePoint)",
                  "description": "Converts the character (Unicode code point) argument to titlecase using case mapping\n information from the UnicodeData file. If a character has no\n explicit titlecase mapping and is not itself a titlecase char\n according to UnicodeData, then the uppercase mapping is\n returned as an equivalent titlecase mapping. If the\n character argument is already a titlecase\n character, the same character value will be\n returned.\n\n Note that\n Character.isTitleCase(Character.toTitleCase(codePoint))\n does not always return true for some ranges of\n characters."
                }
              ]
            },
            {
              "name": "digit",
              "overloads": [
                {
                  "signature": "public static int digit(char ch, int radix)",
                  "description": "Returns the numeric value of the character ch in the\n specified radix.\n \n If the radix is not in the range MIN_RADIX \n radix  MAX_RADIX or if the\n value of ch is not a valid digit in the specified\n radix, -1 is returned. A character is a valid digit\n if at least one of the following is true:\n \n The method isDigit is true of the character\n     and the Unicode decimal digit value of the character (or its\n     single-character decomposition) is less than the specified radix.\n     In this case the decimal digit value is returned.\n The character is one of the uppercase Latin letters\n     'A' through 'Z' and its code is less than\n     radix + 'A' - 10.\n     In this case, ch - 'A' + 10\n     is returned.\n The character is one of the lowercase Latin letters\n     'a' through 'z' and its code is less than\n     radix + 'a' - 10.\n     In this case, ch - 'a' + 10\n     is returned.\n The character is one of the fullwidth uppercase Latin letters A\n     ('\\uFF21') through Z ('\\uFF3A')\n     and its code is less than\n     radix + '\\uFF21' - 10.\n     In this case, ch - '\\uFF21' + 10\n     is returned.\n The character is one of the fullwidth lowercase Latin letters a\n     ('\\uFF41') through z ('\\uFF5A')\n     and its code is less than\n     radix + '\\uFF41' - 10.\n     In this case, ch - '\\uFF41' + 10\n     is returned.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the digit(int, int) method."
                },
                {
                  "signature": "public static int digit(int codePoint, int radix)",
                  "description": "Returns the numeric value of the specified character (Unicode\n code point) in the specified radix.\n\n If the radix is not in the range MIN_RADIX \n radix  MAX_RADIX or if the\n character is not a valid digit in the specified\n radix, -1 is returned. A character is a valid digit\n if at least one of the following is true:\n \n The method isDigit(codePoint) is true of the character\n     and the Unicode decimal digit value of the character (or its\n     single-character decomposition) is less than the specified radix.\n     In this case the decimal digit value is returned.\n The character is one of the uppercase Latin letters\n     'A' through 'Z' and its code is less than\n     radix + 'A' - 10.\n     In this case, codePoint - 'A' + 10\n     is returned.\n The character is one of the lowercase Latin letters\n     'a' through 'z' and its code is less than\n     radix + 'a' - 10.\n     In this case, codePoint - 'a' + 10\n     is returned.\n The character is one of the fullwidth uppercase Latin letters A\n     ('\\uFF21') through Z ('\\uFF3A')\n     and its code is less than\n     radix + '\\uFF21' - 10.\n     In this case,\n     codePoint - '\\uFF21' + 10\n     is returned.\n The character is one of the fullwidth lowercase Latin letters a\n     ('\\uFF41') through z ('\\uFF5A')\n     and its code is less than\n     radix + '\\uFF41'- 10.\n     In this case,\n     codePoint - '\\uFF41' + 10\n     is returned."
                }
              ]
            },
            {
              "name": "getNumericValue",
              "overloads": [
                {
                  "signature": "public static int getNumericValue(char ch)",
                  "description": "Returns the int value that the specified Unicode\n character represents. For example, the character\n '\\u216C' (the roman numeral fifty) will return\n an int with a value of 50.\n \n The letters A-Z in their uppercase ('\\u0041' through\n '\\u005A'), lowercase\n ('\\u0061' through '\\u007A'), and\n full width variant ('\\uFF21' through\n '\\uFF3A' and '\\uFF41' through\n '\\uFF5A') forms have numeric values from 10\n through 35. This is independent of the Unicode specification,\n which does not assign numeric values to these char\n values.\n \n If the character does not have a numeric value, then -1 is returned.\n If the character has a numeric value that cannot be represented as a\n nonnegative integer (for example, a fractional value), then -2\n is returned.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getNumericValue(int) method."
                },
                {
                  "signature": "public static int getNumericValue(int codePoint)",
                  "description": "Returns the int value that the specified\n character (Unicode code point) represents. For example, the character\n '\\u216C' (the Roman numeral fifty) will return\n an int with a value of 50.\n \n The letters A-Z in their uppercase ('\\u0041' through\n '\\u005A'), lowercase\n ('\\u0061' through '\\u007A'), and\n full width variant ('\\uFF21' through\n '\\uFF3A' and '\\uFF41' through\n '\\uFF5A') forms have numeric values from 10\n through 35. This is independent of the Unicode specification,\n which does not assign numeric values to these char\n values.\n \n If the character does not have a numeric value, then -1 is returned.\n If the character has a numeric value that cannot be represented as a\n nonnegative integer (for example, a fractional value), then -2\n is returned."
                }
              ]
            },
            {
              "name": "isSpace",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public static boolean isSpace(char ch)",
                  "description": "Determines if the specified character is ISO-LATIN-1 white space.\n This method returns true for the following five\n characters only:\n \n truechars\n \n Character\n     Code\n     Name\n \n \n '\\t'            U+0009\n     HORIZONTAL TABULATION\n '\\n'            U+000A\n     NEW LINE\n '\\f'            U+000C\n     FORM FEED\n '\\r'            U+000D\n     CARRIAGE RETURN\n ' '  U+0020\n     SPACE",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isSpaceChar",
              "overloads": [
                {
                  "signature": "public static boolean isSpaceChar(char ch)",
                  "description": "Determines if the specified character is a Unicode space character.\n A character is considered to be a space character if and only if\n it is specified to be a space character by the Unicode Standard. This\n method returns true if the character's general category type is any of\n the following:\n \n  SPACE_SEPARATOR\n  LINE_SEPARATOR\n  PARAGRAPH_SEPARATOR\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isSpaceChar(int) method."
                },
                {
                  "signature": "public static boolean isSpaceChar(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is a\n Unicode space character.  A character is considered to be a\n space character if and only if it is specified to be a space\n character by the Unicode Standard. This method returns true if\n the character's general category type is any of the following:\n\n \n  SPACE_SEPARATOR\n  LINE_SEPARATOR\n  PARAGRAPH_SEPARATOR"
                }
              ]
            },
            {
              "name": "isWhitespace",
              "overloads": [
                {
                  "signature": "public static boolean isWhitespace(char ch)",
                  "description": "Determines if the specified character is white space according to Java.\n A character is a Java whitespace character if and only if it satisfies\n one of the following criteria:\n \n  It is a Unicode space character (SPACE_SEPARATOR,\n      LINE_SEPARATOR, or PARAGRAPH_SEPARATOR)\n      but is not also a non-breaking space ('\\u00A0',\n      '\\u2007', '\\u202F').\n  It is '\\t', U+0009 HORIZONTAL TABULATION.\n  It is '\\n', U+000A LINE FEED.\n  It is '\\u000B', U+000B VERTICAL TABULATION.\n  It is '\\f', U+000C FORM FEED.\n  It is '\\r', U+000D CARRIAGE RETURN.\n  It is '\\u001C', U+001C FILE SEPARATOR.\n  It is '\\u001D', U+001D GROUP SEPARATOR.\n  It is '\\u001E', U+001E RECORD SEPARATOR.\n  It is '\\u001F', U+001F UNIT SEPARATOR.\n \n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isWhitespace(int) method."
                },
                {
                  "signature": "public static boolean isWhitespace(int codePoint)",
                  "description": "Determines if the specified character (Unicode code point) is\n white space according to Java.  A character is a Java\n whitespace character if and only if it satisfies one of the\n following criteria:\n \n  It is a Unicode space character (SPACE_SEPARATOR,\n      LINE_SEPARATOR, or PARAGRAPH_SEPARATOR)\n      but is not also a non-breaking space ('\\u00A0',\n      '\\u2007', '\\u202F').\n  It is '\\t', U+0009 HORIZONTAL TABULATION.\n  It is '\\n', U+000A LINE FEED.\n  It is '\\u000B', U+000B VERTICAL TABULATION.\n  It is '\\f', U+000C FORM FEED.\n  It is '\\r', U+000D CARRIAGE RETURN.\n  It is '\\u001C', U+001C FILE SEPARATOR.\n  It is '\\u001D', U+001D GROUP SEPARATOR.\n  It is '\\u001E', U+001E RECORD SEPARATOR.\n  It is '\\u001F', U+001F UNIT SEPARATOR."
                }
              ]
            },
            {
              "name": "isISOControl",
              "overloads": [
                {
                  "signature": "public static boolean isISOControl(char ch)",
                  "description": "Determines if the specified character is an ISO control\n character.  A character is considered to be an ISO control\n character if its code is in the range '\\u0000'\n through '\\u001F' or in the range\n '\\u007F' through '\\u009F'.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isISOControl(int) method."
                },
                {
                  "signature": "public static boolean isISOControl(int codePoint)",
                  "description": "Determines if the referenced character (Unicode code point) is an ISO control\n character.  A character is considered to be an ISO control\n character if its code is in the range '\\u0000'\n through '\\u001F' or in the range\n '\\u007F' through '\\u009F'."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public static int getType(char ch)",
                  "description": "Returns a value indicating a character's general category.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getType(int) method."
                },
                {
                  "signature": "public static int getType(int codePoint)",
                  "description": "Returns a value indicating a character's general category."
                }
              ]
            },
            {
              "name": "forDigit",
              "overloads": [
                {
                  "signature": "public static char forDigit(int digit, int radix)",
                  "description": "Determines the character representation for a specific digit in\n the specified radix. If the value of radix is not a\n valid radix, or the value of digit is not a valid\n digit in the specified radix, the null character\n ('\\u0000') is returned.\n \n The radix argument is valid if it is greater than or\n equal to MIN_RADIX and less than or equal to\n MAX_RADIX. The digit argument is valid if\n 0 <= digit < radix.\n \n If the digit is less than 10, then\n '0' + digit is returned. Otherwise, the value\n 'a' + digit - 10 is returned."
                }
              ]
            },
            {
              "name": "getDirectionality",
              "overloads": [
                {
                  "signature": "public static byte getDirectionality(char ch)",
                  "description": "Returns the Unicode directionality property for the given\n character.  Character directionality is used to calculate the\n visual ordering of text. The directionality value of undefined\n char values is DIRECTIONALITY_UNDEFINED.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the getDirectionality(int) method."
                },
                {
                  "signature": "public static byte getDirectionality(int codePoint)",
                  "description": "Returns the Unicode directionality property for the given\n character (Unicode code point).  Character directionality is\n used to calculate the visual ordering of text. The\n directionality value of undefined character is DIRECTIONALITY_UNDEFINED."
                }
              ]
            },
            {
              "name": "isMirrored",
              "overloads": [
                {
                  "signature": "public static boolean isMirrored(char ch)",
                  "description": "Determines whether the character is mirrored according to the\n Unicode specification.  Mirrored characters should have their\n glyphs horizontally mirrored when displayed in text that is\n right-to-left.  For example, '\\u0028' LEFT\n PARENTHESIS is semantically defined to be an opening\n parenthesis.  This will appear as a \"(\" in text that is\n left-to-right but as a \")\" in text that is right-to-left.\n\n Note: This method cannot handle  supplementary characters. To support\n all Unicode characters, including supplementary characters, use\n the isMirrored(int) method."
                },
                {
                  "signature": "public static boolean isMirrored(int codePoint)",
                  "description": "Determines whether the specified character (Unicode code point)\n is mirrored according to the Unicode specification.  Mirrored\n characters should have their glyphs horizontally mirrored when\n displayed in text that is right-to-left.  For example,\n '\\u0028' LEFT PARENTHESIS is semantically\n defined to be an opening parenthesis.  This will appear\n as a \"(\" in text that is left-to-right but as a \")\" in text\n that is right-to-left."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Character anotherCharacter)",
                  "description": "Compares two Character objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(char x, char y)",
                  "description": "Compares two char values numerically.\n The value returned is identical to what would be returned by:\n     Character.valueOf(x).compareTo(Character.valueOf(y))"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static char reverseBytes(char ch)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n specified char value."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public static String getName(int codePoint)",
                  "description": "Returns the Unicode name of the specified character\n codePoint, or null if the code point is\n unassigned.\n \n Note: if the specified character is not assigned a name by\n the UnicodeData file (part of the Unicode Character\n Database maintained by the Unicode Consortium), the returned\n name is the same as the result of expression:\n\n \n     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     + \" \"\n     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);"
                }
              ]
            },
            {
              "name": "codePointOf",
              "overloads": [
                {
                  "signature": "public static int codePointOf(String name)",
                  "description": "Returns the code point value of the Unicode character specified by\n the given Unicode character name.\n \n Note: if a character is not assigned a name by the UnicodeData\n file (part of the Unicode Character Database maintained by the Unicode\n Consortium), its name is defined as the result of expression:\n\n \n     Character.UnicodeBlock.of(codePoint).toString().replace('_', ' ')\n     + \" \"\n     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\n\n \n \n The name matching is case insensitive, with any leading and\n trailing whitespace character removed."
                }
              ]
            }
          ]
        },
        {
          "name": "Character.Subset",
          "methods": [
            {
              "name": "Subset",
              "overloads": [
                {
                  "signature": "protected Subset(String name)",
                  "description": "Constructs a new Subset instance."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares two Subset objects for equality.\n This method returns true if and only if\n this and the argument refer to the same\n object; since this method is final, this\n guarantee holds for all subclasses."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns the standard hash code as defined by the\n Object.hashCode() method.  This method\n is final in order to ensure that the\n equals and hashCode methods will\n be consistent in all subclasses."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns the name of this subset."
                }
              ]
            }
          ]
        },
        {
          "name": "Character.UnicodeBlock",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeBlock of(char c)",
                  "description": "Returns the object representing the Unicode block containing the\n given character, or null if the character is not a\n member of a defined block.\n\n Note: This method cannot handle\n  supplementary\n characters.  To support all Unicode characters, including\n supplementary characters, use the of(int) method."
                },
                {
                  "signature": "public static Character.UnicodeBlock of(int codePoint)",
                  "description": "Returns the object representing the Unicode block\n containing the given character (Unicode code point), or\n null if the character is not a member of a\n defined block."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static final Character.UnicodeBlock forName(String blockName)",
                  "description": "Returns the UnicodeBlock with the given name. Block\n names are determined by The Unicode Standard. The file\n Blocks-<version>.txt defines blocks for a particular\n version of the standard. The Character class specifies\n the version of the standard that it supports.\n \n This method accepts block names in the following forms:\n \n  Canonical block names as defined by the Unicode Standard.\n For example, the standard defines a \"Basic Latin\" block. Therefore, this\n method accepts \"Basic Latin\" as a valid block name. The documentation of\n each UnicodeBlock provides the canonical name.\n Canonical block names with all spaces removed. For example, \"BasicLatin\"\n is a valid block name for the \"Basic Latin\" block.\n The text representation of each constant UnicodeBlock identifier.\n For example, this method will return the BASIC_LATIN block if\n provided with the \"BASIC_LATIN\" name. This form replaces all spaces and\n hyphens in the canonical name with underscores.\n \n Finally, character case is ignored for all of the valid block name forms.\n For example, \"BASIC_LATIN\" and \"basic_latin\" are both valid block names.\n The en_US locale's case mapping rules are used to provide case-insensitive\n string comparisons for block name validation.\n \n If the Unicode Standard changes block names, both the previous and\n current names will be accepted."
                }
              ]
            }
          ]
        },
        {
          "name": "CharSequence",
          "methods": [
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "int length()",
                  "description": "Returns the length of this character sequence.  The length is the number\n of 16-bit chars in the sequence."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "char charAt(int index)",
                  "description": "Returns the char value at the specified index.  An index ranges from zero\n to length() - 1.  The first char value of the sequence is at\n index zero, the next at index one, and so on, as for array\n indexing.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "default boolean isEmpty()",
                  "description": "Returns true if this character sequence is empty."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "CharSequence subSequence(int start, int end)",
                  "description": "Returns a CharSequence that is a subsequence of this sequence.\n The subsequence starts with the char value at the specified index and\n ends with the char value at index end - 1.  The length\n (in chars) of the\n returned sequence is end - start, so if start == end\n then an empty sequence is returned."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "String toString()",
                  "description": "Returns a string containing the characters in this sequence in the same\n order as this sequence.  The length of the string will be the length of\n this sequence."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "default IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "default IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "static int compare(CharSequence cs1, CharSequence cs2)",
                  "description": "Compares two CharSequence instances lexicographically. Returns a\n negative value, zero, or a positive value if the first sequence is lexicographically\n less than, equal to, or greater than the second, respectively.\n\n \n The lexicographical ordering of CharSequence is defined as follows.\n Consider a CharSequence cs of length len to be a\n sequence of char values, cs[0] to cs[len-1]. Suppose k\n is the lowest index at which the corresponding char values from each sequence\n differ. The lexicographic ordering of the sequences is determined by a numeric\n comparison of the char values cs1[k] with cs2[k]. If there is\n no such index k, the shorter sequence is considered lexicographically\n less than the other. If the sequences have the same length, the sequences are\n considered lexicographically equal."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static StackWalker.Option[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static StackWalker.Option valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Character.UnicodeScript of(int codePoint)",
                  "description": "Returns the enum constant representing the Unicode script of which\n the given character (Unicode code point) is assigned to."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static final Character.UnicodeScript forName(String scriptName)",
                  "description": "Returns the UnicodeScript constant with the given Unicode script\n name or the script name alias. Script names and their aliases are\n determined by The Unicode Standard. The files Scripts<version>.txt\n and PropertyValueAliases<version>.txt define script names\n and the script name aliases for a particular version of the\n standard. The Character class specifies the version of\n the standard that it supports.\n \n Character case is ignored for all of the valid script names.\n The en_US locale's case mapping rules are used to provide\n case-insensitive string comparisons for script name validation."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect.Type[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect.Type valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Thread.State[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Thread.State valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static System.Logger.Level[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static System.Logger.Level valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns the name of this level."
                }
              ]
            },
            {
              "name": "getSeverity",
              "overloads": [
                {
                  "signature": "public final int getSeverity()",
                  "description": "Returns the severity of this level.\n A higher severity means a more severe condition."
                }
              ]
            }
          ]
        },
        {
          "name": "Class<T>",
          "methods": [
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts the object to a string. The string representation is the\n string \"class\" or \"interface\", followed by a space, and then by the\n name of the class in the format returned by getName.\n If this Class object represents a primitive type,\n this method returns the name of the primitive type.  If\n this Class object represents void this method returns\n \"void\". If this Class object represents an array type,\n this method returns \"class \" followed by getName."
                }
              ]
            },
            {
              "name": "toGenericString",
              "overloads": [
                {
                  "signature": "public String toGenericString()",
                  "description": "Returns a string describing this Class, including\n information about modifiers and type parameters.\n\n The string is formatted as a list of type modifiers, if any,\n followed by the kind of type (empty string for primitive types\n and class, enum, interface,\n @interface, or record as appropriate), followed\n by the type's name, followed by an angle-bracketed\n comma-separated list of the type's type parameters, if any,\n including informative bounds on the type parameters, if any.\n\n A space is used to separate modifiers from one another and to\n separate any modifiers from the kind of type. The modifiers\n occur in canonical order. If there are no type parameters, the\n type parameter list is elided.\n\n For an array type, the string starts with the type name,\n followed by an angle-bracketed comma-separated list of the\n type's type parameters, if any, followed by a sequence of\n [] characters, one set of brackets per dimension of\n the array.\n\n Note that since information about the runtime representation\n of a type is being generated, modifiers not present on the\n originating source code or illegal on the originating source\n code may be present."
                }
              ]
            },
            {
              "name": "forName",
              "overloads": [
                {
                  "signature": "public static Class<?> forName(String className) throws ClassNotFoundException",
                  "description": "Returns the Class object associated with the class or\n interface with the given string name.  Invoking this method is\n equivalent to:\n\n \n  Class.forName(className, true, currentLoader)\n \n\n where currentLoader denotes the defining class loader of\n the current class.\n\n  For example, the following code fragment returns the\n runtime Class descriptor for the class named\n java.lang.Thread:\n\n \n   Class t = Class.forName(\"java.lang.Thread\")\n \n \n A call to forName(\"X\") causes the class named\n X to be initialized."
                },
                {
                  "signature": "public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException",
                  "description": "Returns the Class object associated with the class or\n interface with the given string name, using the given class loader.\n Given the fully qualified name for a class or interface (in the same\n format returned by getName) this method attempts to\n locate and load the class or interface.  The specified class\n loader is used to load the class or interface.  If the parameter\n loader is null, the class is loaded through the bootstrap\n class loader.  The class is initialized only if the\n initialize parameter is true and if it has\n not been initialized earlier.\n\n  If name denotes a primitive type or void, an attempt\n will be made to locate a user-defined class in the unnamed package whose\n name is name. Therefore, this method cannot be used to\n obtain any of the Class objects representing primitive\n types or void.\n\n  If name denotes an array class, the component type of\n the array class is loaded but not initialized.\n\n  For example, in an instance method the expression:\n\n \n  Class.forName(\"Foo\")\n \n\n is equivalent to:\n\n \n  Class.forName(\"Foo\", true, this.getClass().getClassLoader())\n \n\n Note that this method throws errors related to loading, linking\n or initializing as specified in Sections 12.2, 12.3, and 12.4 of The Java Language\n Specification.\n Note that this method does not check whether the requested class\n is accessible to its caller."
                },
                {
                  "signature": "public static Class<?> forName(Module module, String name)",
                  "description": "Returns the Class with the given \n binary name in the given module.\n\n  This method attempts to locate and load the class or interface.\n It does not link the class, and does not run the class initializer.\n If the class is not found, this method returns null. \n\n  If the class loader of the given module defines other modules and\n the given name is a class defined in a different module, this method\n returns null after the class is loaded. \n\n  This method does not check whether the requested class is\n accessible to its caller."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public T newInstance() throws InstantiationException, IllegalAccessException",
                  "description": "Creates a new instance of the class represented by this Class\n object.  The class is instantiated as if by a new\n expression with an empty argument list.  The class is initialized if it\n has not already been initialized.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isInstance",
              "overloads": [
                {
                  "signature": "public boolean isInstance(Object obj)",
                  "description": "Determines if the specified Object is assignment-compatible\n with the object represented by this Class.  This method is\n the dynamic equivalent of the Java language instanceof\n operator. The method returns true if the specified\n Object argument is non-null and can be cast to the\n reference type represented by this Class object without\n raising a ClassCastException. It returns false\n otherwise.\n\n  Specifically, if this Class object represents a\n declared class, this method returns true if the specified\n Object argument is an instance of the represented class (or\n of any of its subclasses); it returns false otherwise. If\n this Class object represents an array class, this method\n returns true if the specified Object argument\n can be converted to an object of the array class by an identity\n conversion or by a widening reference conversion; it returns\n false otherwise. If this Class object\n represents an interface, this method returns true if the\n class or any superclass of the specified Object argument\n implements this interface; it returns false otherwise. If\n this Class object represents a primitive type, this method\n returns false."
                }
              ]
            },
            {
              "name": "isAssignableFrom",
              "overloads": [
                {
                  "signature": "public boolean isAssignableFrom(Class<?> cls)",
                  "description": "Determines if the class or interface represented by this\n Class object is either the same as, or is a superclass or\n superinterface of, the class or interface represented by the specified\n Class parameter. It returns true if so;\n otherwise it returns false. If this Class\n object represents a primitive type, this method returns\n true if the specified Class parameter is\n exactly this Class object; otherwise it returns\n false.\n\n  Specifically, this method tests whether the type represented by the\n specified Class parameter can be converted to the type\n represented by this Class object via an identity conversion\n or via a widening reference conversion. See The Java Language\n Specification, sections 5.1.1 and 5.1.4,\n for details."
                }
              ]
            },
            {
              "name": "isInterface",
              "overloads": [
                {
                  "signature": "public boolean isInterface()",
                  "description": "Determines if this Class object represents an\n interface type."
                }
              ]
            },
            {
              "name": "isArray",
              "overloads": [
                {
                  "signature": "public boolean isArray()",
                  "description": "Determines if this Class object represents an array class."
                }
              ]
            },
            {
              "name": "isPrimitive",
              "overloads": [
                {
                  "signature": "public boolean isPrimitive()",
                  "description": "Determines if the specified Class object represents a\n primitive type.\n\n  There are nine predefined Class objects to represent\n the eight primitive types and void.  These are created by the Java\n Virtual Machine, and have the same names as the primitive types that\n they represent, namely boolean, byte,\n char, short, int,\n long, float, and double.\n\n  These objects may only be accessed via the following public static\n final variables, and are the only Class objects for which\n this method returns true."
                }
              ]
            },
            {
              "name": "isAnnotation",
              "overloads": [
                {
                  "signature": "public boolean isAnnotation()",
                  "description": "Returns true if this Class object represents an annotation\n interface.  Note that if this method returns true, isInterface()\n would also return true, as all annotation interfaces are also interfaces."
                }
              ]
            },
            {
              "name": "isSynthetic",
              "overloads": [
                {
                  "signature": "public boolean isSynthetic()",
                  "description": "Returns true if and only if this class has the synthetic modifier\n bit set."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the  name of the entity (class, interface, array class,\n primitive type, or void) represented by this Class object.\n\n  If this Class object represents a class or interface,\n not an array class, then:\n \n  If the class or interface is not hidden,\n      then the binary name\n      of the class or interface is returned.\n  If the class or interface is hidden, then the result is a string\n      of the form: N + '/' + <suffix>\n      where N is the binary name\n      indicated by the class file passed to\n      Lookup::defineHiddenClass, and <suffix> is an unqualified name.\n \n\n  If this Class object represents an array class, then\n the result is a string consisting of one or more '[' characters\n representing the depth of the array nesting, followed by the element\n type as encoded using the following table:\n\n \n Element types and encodings\n \n  Element Type  Encoding\n \n \n  boolean  Z\n  byte     B\n  char     C\n  class or interface with binary name N\n                                       LN;\n  double   D\n  float    F\n  int      I\n  long     J\n  short    S\n \n \n\n  If this Class object represents a primitive type or void,\n then the result is a string with the same spelling as the Java language\n keyword which corresponds to the primitive type or void.\n\n  Examples:\n  String.class.getName()\n     returns \"java.lang.String\"\n byte.class.getName()\n     returns \"byte\"\n (new Object[3]).getClass().getName()\n     returns \"[Ljava.lang.Object;\"\n (new int[3][4][5][6][7][8][9]).getClass().getName()\n     returns \"[[[[[[[I\""
                }
              ]
            },
            {
              "name": "getClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getClassLoader()",
                  "description": "Returns the class loader for the class.  Some implementations may use\n null to represent the bootstrap class loader. This method will return\n null in such implementations if this class was loaded by the bootstrap\n class loader.\n\n If this Class object\n represents a primitive type or void, null is returned."
                }
              ]
            },
            {
              "name": "getModule",
              "overloads": [
                {
                  "signature": "public Module getModule()",
                  "description": "Returns the module that this class or interface is a member of.\n\n If this class represents an array type then this method returns the\n Module for the element type. If this class represents a\n primitive type or void, then the Module object for the\n java.base module is returned.\n\n If this class is in an unnamed module then the unnamed Module of the class\n loader for this class is returned."
                }
              ]
            },
            {
              "name": "getTypeParameters",
              "overloads": [
                {
                  "signature": "public TypeVariable<Class<T>>[] getTypeParameters()",
                  "description": "Returns an array of TypeVariable objects that represent the\n type variables declared by the generic declaration represented by this\n GenericDeclaration object, in declaration order.  Returns an\n array of length 0 if the underlying generic declaration declares no type\n variables."
                }
              ]
            },
            {
              "name": "getSuperclass",
              "overloads": [
                {
                  "signature": "public Class<? super T> getSuperclass()",
                  "description": "Returns the Class representing the direct superclass of the\n entity (class, interface, primitive type or void) represented by\n this Class.  If this Class represents either the\n Object class, an interface, a primitive type, or void, then\n null is returned.  If this Class object represents an array class\n then the Class object representing the Object class is\n returned."
                }
              ]
            },
            {
              "name": "getGenericSuperclass",
              "overloads": [
                {
                  "signature": "public Type getGenericSuperclass()",
                  "description": "Returns the Type representing the direct superclass of\n the entity (class, interface, primitive type or void) represented by\n this Class object.\n\n If the superclass is a parameterized type, the Type\n object returned must accurately reflect the actual type\n arguments used in the source code. The parameterized type\n representing the superclass is created if it had not been\n created before. See the declaration of ParameterizedType for the\n semantics of the creation process for parameterized types.  If\n this Class object represents either the Object\n class, an interface, a primitive type, or void, then null is\n returned.  If this Class object represents an array class\n then the Class object representing the Object class is\n returned."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "public Package getPackage()",
                  "description": "Gets the package of this class.\n\n If this class represents an array type, a primitive type or void,\n this method returns null."
                }
              ]
            },
            {
              "name": "getPackageName",
              "overloads": [
                {
                  "signature": "public String getPackageName()",
                  "description": "Returns the fully qualified package name.\n\n  If this class is a top level class, then this method returns the fully\n qualified name of the package that the class is a member of, or the\n empty string if the class is in an unnamed package.\n\n  If this class is a member class, then this method is equivalent to\n invoking getPackageName() on the enclosing class.\n\n  If this class is a local class or an anonymous class, then this method is equivalent to\n invoking getPackageName() on the declaring class of the enclosing method or\n enclosing constructor.\n\n  If this class represents an array type then this method returns the\n package name of the element type. If this class represents a primitive\n type or void then the package name \"java.lang\" is returned."
                }
              ]
            },
            {
              "name": "getInterfaces",
              "overloads": [
                {
                  "signature": "public Class<?>[] getInterfaces()",
                  "description": "Returns the interfaces directly implemented by the class or interface\n represented by this Class object.\n\n If this Class object represents a class, the return value is an array\n containing objects representing all interfaces directly implemented by\n the class.  The order of the interface objects in the array corresponds\n to the order of the interface names in the implements clause of\n the declaration of the class represented by this Class object.  For example,\n given the declaration:\n \n class Shimmer implements FloorWax, DessertTopping { ... }\n \n suppose the value of s is an instance of\n Shimmer; the value of the expression:\n \n s.getClass().getInterfaces()[0]\n \n is the Class object that represents interface\n FloorWax; and the value of:\n \n s.getClass().getInterfaces()[1]\n \n is the Class object that represents interface\n DessertTopping.\n\n If this Class object represents an interface, the array contains objects\n representing all interfaces directly extended by the interface.  The\n order of the interface objects in the array corresponds to the order of\n the interface names in the extends clause of the declaration of\n the interface represented by this Class object.\n\n If this Class object represents a class or interface that implements no\n interfaces, the method returns an array of length 0.\n\n If this Class object represents a primitive type or void, the method\n returns an array of length 0.\n\n If this Class object represents an array type, the\n interfaces Cloneable and java.io.Serializable are\n returned in that order."
                }
              ]
            },
            {
              "name": "getGenericInterfaces",
              "overloads": [
                {
                  "signature": "public Type[] getGenericInterfaces()",
                  "description": "Returns the Types representing the interfaces\n directly implemented by the class or interface represented by\n this Class object.\n\n If a superinterface is a parameterized type, the\n Type object returned for it must accurately reflect\n the actual type arguments used in the source code. The\n parameterized type representing each superinterface is created\n if it had not been created before. See the declaration of\n ParameterizedType\n for the semantics of the creation process for parameterized\n types.\n\n If this Class object represents a class, the return value is an array\n containing objects representing all interfaces directly implemented by\n the class.  The order of the interface objects in the array corresponds\n to the order of the interface names in the implements clause of\n the declaration of the class represented by this Class object.\n\n If this Class object represents an interface, the array contains objects\n representing all interfaces directly extended by the interface.  The\n order of the interface objects in the array corresponds to the order of\n the interface names in the extends clause of the declaration of\n the interface represented by this Class object.\n\n If this Class object represents a class or interface that implements no\n interfaces, the method returns an array of length 0.\n\n If this Class object represents a primitive type or void, the method\n returns an array of length 0.\n\n If this Class object represents an array type, the\n interfaces Cloneable and java.io.Serializable are\n returned in that order."
                }
              ]
            },
            {
              "name": "getComponentType",
              "overloads": [
                {
                  "signature": "public Class<?> getComponentType()",
                  "description": "Returns the Class representing the component type of an\n array.  If this class does not represent an array class this method\n returns null."
                }
              ]
            },
            {
              "name": "getModifiers",
              "overloads": [
                {
                  "signature": "public int getModifiers()",
                  "description": "Returns the Java language modifiers for this class or interface, encoded\n in an integer. The modifiers consist of the Java Virtual Machine's\n constants for public, protected,\n private, final, static,\n abstract and interface; they should be decoded\n using the methods of class Modifier.\n\n  If the underlying class is an array class, then its\n public, private and protected\n modifiers are the same as those of its component type.  If this\n Class object represents a primitive type or void, its\n public modifier is always true, and its\n protected and private modifiers are always\n false. If this Class object represents an array class, a\n primitive type or void, then its final modifier is always\n true and its interface modifier is always\n false. The values of its other modifiers are not determined\n by this specification.\n\n  The modifier encodings are defined in section 4.1\n of The Java Virtual Machine Specification."
                }
              ]
            },
            {
              "name": "getSigners",
              "overloads": [
                {
                  "signature": "public Object[] getSigners()",
                  "description": "Gets the signers of this class."
                }
              ]
            },
            {
              "name": "getEnclosingMethod",
              "overloads": [
                {
                  "signature": "public Method getEnclosingMethod() throws SecurityException",
                  "description": "If this Class object represents a local or anonymous\n class within a method, returns a Method object representing the\n immediately enclosing method of the underlying class. Returns\n null otherwise.\n\n In particular, this method returns null if the underlying\n class is a local or anonymous class immediately enclosed by a class or\n interface declaration, instance initializer or static initializer."
                }
              ]
            },
            {
              "name": "getEnclosingConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<?> getEnclosingConstructor() throws SecurityException",
                  "description": "If this Class object represents a local or anonymous\n class within a constructor, returns a Constructor object representing\n the immediately enclosing constructor of the underlying\n class. Returns null otherwise.  In particular, this\n method returns null if the underlying class is a local\n or anonymous class immediately enclosed by a class or\n interface declaration, instance initializer or static initializer."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "public Class<?> getDeclaringClass() throws SecurityException",
                  "description": "If the class or interface represented by this Class object\n is a member of another class, returns the Class object\n representing the class in which it was declared.  This method returns\n null if this class or interface is not a member of any other class.  If\n this Class object represents an array class, a primitive\n type, or void,then this method returns null."
                }
              ]
            },
            {
              "name": "getEnclosingClass",
              "overloads": [
                {
                  "signature": "public Class<?> getEnclosingClass() throws SecurityException",
                  "description": "Returns the immediately enclosing class of the underlying\n class.  If the underlying class is a top level class this\n method returns null."
                }
              ]
            },
            {
              "name": "getSimpleName",
              "overloads": [
                {
                  "signature": "public String getSimpleName()",
                  "description": "Returns the simple name of the underlying class as given in the\n source code. An empty string is returned if the underlying class is\n anonymous.\n A synthetic class, one not present\n in source code, can have a non-empty name including special\n characters, such as \"$\".\n\n The simple name of an array class is the simple name of the\n component type with \"[]\" appended.  In particular the simple\n name of an array class whose component type is anonymous is \"[]\"."
                }
              ]
            },
            {
              "name": "getTypeName",
              "overloads": [
                {
                  "signature": "public String getTypeName()",
                  "description": "Return an informative string for the name of this class or interface."
                }
              ]
            },
            {
              "name": "getCanonicalName",
              "overloads": [
                {
                  "signature": "public String getCanonicalName()",
                  "description": "Returns the canonical name of the underlying class as\n defined by The Java Language Specification.\n Returns null if the underlying class does not have a canonical\n name. Classes without canonical names include:\n \n a local class\n a anonymous class\n a hidden class\n an array whose component type does not have a canonical name"
                }
              ]
            },
            {
              "name": "isAnonymousClass",
              "overloads": [
                {
                  "signature": "public boolean isAnonymousClass()",
                  "description": "Returns true if and only if the underlying class\n is an anonymous class."
                }
              ]
            },
            {
              "name": "isLocalClass",
              "overloads": [
                {
                  "signature": "public boolean isLocalClass()",
                  "description": "Returns true if and only if the underlying class\n is a local class."
                }
              ]
            },
            {
              "name": "isMemberClass",
              "overloads": [
                {
                  "signature": "public boolean isMemberClass()",
                  "description": "Returns true if and only if the underlying class\n is a member class."
                }
              ]
            },
            {
              "name": "getClasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getClasses()",
                  "description": "Returns an array containing Class objects representing all\n the public classes and interfaces that are members of the class\n represented by this Class object.  This includes public\n class and interface members inherited from superclasses and public class\n and interface members declared by the class.  This method returns an\n array of length 0 if this Class object has no public member\n classes or interfaces.  This method also returns an array of length 0 if\n this Class object represents a primitive type, an array\n class, or void."
                }
              ]
            },
            {
              "name": "getFields",
              "overloads": [
                {
                  "signature": "public Field[] getFields() throws SecurityException",
                  "description": "Returns an array containing Field objects reflecting all\n the accessible public fields of the class or interface represented by\n this Class object.\n\n  If this Class object represents a class or interface with\n no accessible public fields, then this method returns an array of length\n 0.\n\n  If this Class object represents a class, then this method\n returns the public fields of the class and of all its superclasses and\n superinterfaces.\n\n  If this Class object represents an interface, then this\n method returns the fields of the interface and of all its\n superinterfaces.\n\n  If this Class object represents an array type, a primitive\n type, or void, then this method returns an array of length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getMethods",
              "overloads": [
                {
                  "signature": "public Method[] getMethods() throws SecurityException",
                  "description": "Returns an array containing Method objects reflecting all the\n public methods of the class or interface represented by this \n Class object, including those declared by the class or interface and\n those inherited from superclasses and superinterfaces.\n\n  If this Class object represents an array type, then the\n returned array has a Method object for each of the public\n methods inherited by the array type from Object. It does not\n contain a Method object for clone().\n\n  If this Class object represents an interface then the\n returned array does not contain any implicitly declared methods from\n Object. Therefore, if no methods are explicitly declared in\n this interface or any of its superinterfaces then the returned array\n has length 0. (Note that a Class object which represents a class\n always has public methods, inherited from Object.)\n\n  The returned array never contains methods with names \"<init>\"\n or \"<clinit>\".\n\n  The elements in the returned array are not sorted and are not in any\n particular order.\n\n  Generally, the result is computed as with the following 4 step algorithm.\n Let C be the class or interface represented by this Class object:\n \n  A union of methods is composed of:\n   \n    C's declared public instance and static methods as returned by\n        getDeclaredMethods() and filtered to include only public\n        methods.\n    If C is a class other than Object, then include the result\n        of invoking this algorithm recursively on the superclass of C.\n    Include the results of invoking this algorithm recursively on all\n        direct superinterfaces of C, but include only instance methods.\n   \n  Union from step 1 is partitioned into subsets of methods with same\n      signature (name, parameter types) and return type.\n  Within each such subset only the most specific methods are selected.\n      Let method M be a method from a set of methods with same signature\n      and return type. M is most specific if there is no such method\n      N != M from the same set, such that N is more specific than M.\n      N is more specific than M if:\n   \n    N is declared by a class and M is declared by an interface; or\n    N and M are both declared by classes or both by interfaces and\n        N's declaring type is the same as or a subtype of M's declaring type\n        (clearly, if M's and N's declaring types are the same type, then\n        M and N are the same method).\n   \n  The result of this algorithm is the union of all selected methods from\n      step 3."
                }
              ]
            },
            {
              "name": "getConstructors",
              "overloads": [
                {
                  "signature": "public Constructor<?>[] getConstructors() throws SecurityException",
                  "description": "Returns an array containing Constructor objects reflecting\n all the public constructors of the class represented by this\n Class object.  An array of length 0 is returned if the\n class has no public constructors, or if the class is an array class, or\n if the class reflects a primitive type or void."
                }
              ]
            },
            {
              "name": "getField",
              "overloads": [
                {
                  "signature": "public Field getField(String name) throws NoSuchFieldException, SecurityException",
                  "description": "Returns a Field object that reflects the specified public member\n field of the class or interface represented by this Class\n object. The name parameter is a String specifying the\n simple name of the desired field.\n\n  The field to be reflected is determined by the algorithm that\n follows.  Let C be the class or interface represented by this Class object:\n\n \n  If C declares a public field with the name specified, that is the\n      field to be reflected.\n  If no field was found in step 1 above, this algorithm is applied\n      recursively to each direct superinterface of C. The direct\n      superinterfaces are searched in the order they were declared.\n  If no field was found in steps 1 and 2 above, and C has a\n      superclass S, then this algorithm is invoked recursively upon S.\n      If C has no superclass, then a NoSuchFieldException\n      is thrown.\n \n\n  If this Class object represents an array type, then this\n method does not find the length field of the array type."
                }
              ]
            },
            {
              "name": "getMethod",
              "overloads": [
                {
                  "signature": "public Method getMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Method object that reflects the specified public\n member method of the class or interface represented by this\n Class object. The name parameter is a\n String specifying the simple name of the desired method. The\n parameterTypes parameter is an array of Class\n objects that identify the method's formal parameter types, in declared\n order. If parameterTypes is null, it is\n treated as if it were an empty array.\n\n  If this Class object represents an array type, then this\n method finds any public method inherited by the array type from\n Object except method clone().\n\n  If this Class object represents an interface then this\n method does not find any implicitly declared method from\n Object. Therefore, if no methods are explicitly declared in\n this interface or any of its superinterfaces, then this method does not\n find any method.\n\n  This method does not find any method with name \"<init>\" or\n \"<clinit>\".\n\n  Generally, the method to be reflected is determined by the 4 step\n algorithm that follows.\n Let C be the class or interface represented by this Class object:\n \n  A union of methods is composed of:\n   \n    C's declared public instance and static methods as returned by\n        getDeclaredMethods() and filtered to include only public\n        methods that match given name and parameterTypes\n    If C is a class other than Object, then include the result\n        of invoking this algorithm recursively on the superclass of C.\n    Include the results of invoking this algorithm recursively on all\n        direct superinterfaces of C, but include only instance methods.\n   \n  This union is partitioned into subsets of methods with same\n      return type (the selection of methods from step 1 also guarantees that\n      they have the same method name and parameter types).\n  Within each such subset only the most specific methods are selected.\n      Let method M be a method from a set of methods with same VM\n      signature (return type, name, parameter types).\n      M is most specific if there is no such method N != M from the same\n      set, such that N is more specific than M. N is more specific than M\n      if:\n   \n    N is declared by a class and M is declared by an interface; or\n    N and M are both declared by classes or both by interfaces and\n        N's declaring type is the same as or a subtype of M's declaring type\n        (clearly, if M's and N's declaring types are the same type, then\n        M and N are the same method).\n   \n  The result of this algorithm is chosen arbitrarily from the methods\n      with most specific return type among all selected methods from step 3.\n      Let R be a return type of a method M from the set of all selected methods\n      from step 3. M is a method with most specific return type if there is\n      no such method N != M from the same set, having return type S != R,\n      such that S is a subtype of R as determined by\n      R.class.isAssignableFrom(java.lang.Class<?>)(S.class)."
                }
              ]
            },
            {
              "name": "getConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Constructor object that reflects the specified\n public constructor of the class represented by this Class\n object. The parameterTypes parameter is an array of\n Class objects that identify the constructor's formal\n parameter types, in declared order.\n\n If this Class object represents an inner class\n declared in a non-static context, the formal parameter types\n include the explicit enclosing instance as the first parameter.\n\n  The constructor to reflect is the public constructor of the class\n represented by this Class object whose formal parameter\n types match those specified by parameterTypes."
                }
              ]
            },
            {
              "name": "getDeclaredClasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getDeclaredClasses() throws SecurityException",
                  "description": "Returns an array of Class objects reflecting all the\n classes and interfaces declared as members of the class represented by\n this Class object. This includes public, protected, default\n (package) access, and private classes and interfaces declared by the\n class, but excludes inherited classes and interfaces.  This method\n returns an array of length 0 if the class declares no classes or\n interfaces as members, or if this Class object represents a\n primitive type, an array class, or void."
                }
              ]
            },
            {
              "name": "getDeclaredFields",
              "overloads": [
                {
                  "signature": "public Field[] getDeclaredFields() throws SecurityException",
                  "description": "Returns an array of Field objects reflecting all the fields\n declared by the class or interface represented by this\n Class object. This includes public, protected, default\n (package) access, and private fields, but excludes inherited fields.\n\n  If this Class object represents a class or interface with no\n declared fields, then this method returns an array of length 0.\n\n  If this Class object represents an array type, a primitive\n type, or void, then this method returns an array of length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getRecordComponents",
              "overloads": [
                {
                  "signature": "public RecordComponent[] getRecordComponents()",
                  "description": "Returns an array of RecordComponent objects representing all the\n record components of this record class, or null if this class is\n not a record class.\n\n  The components are returned in the same order that they are declared\n in the record header. The array is empty if this record class has no\n components. If the class is not a record class, that is isRecord() returns false, then this method returns null.\n Conversely, if isRecord() returns true, then this method\n returns a non-null value."
                }
              ]
            },
            {
              "name": "getDeclaredMethods",
              "overloads": [
                {
                  "signature": "public Method[] getDeclaredMethods() throws SecurityException",
                  "description": "Returns an array containing Method objects reflecting all the\n declared methods of the class or interface represented by this \n Class object, including public, protected, default (package)\n access, and private methods, but excluding inherited methods.\n The declared methods may include methods not in the\n source of the class or interface, including bridge methods and other synthetic methods added by compilers.\n\n  If this Class object represents a class or interface that\n has multiple declared methods with the same name and parameter types,\n but different return types, then the returned array has a Method\n object for each such method.\n\n  If this Class object represents a class or interface that\n has a class initialization method <clinit>, then the returned\n array does not have a corresponding Method object.\n\n  If this Class object represents a class or interface with no\n declared methods, then the returned array has length 0.\n\n  If this Class object represents an array type, a primitive\n type, or void, then the returned array has length 0.\n\n  The elements in the returned array are not sorted and are not in any\n particular order."
                }
              ]
            },
            {
              "name": "getDeclaredConstructors",
              "overloads": [
                {
                  "signature": "public Constructor<?>[] getDeclaredConstructors() throws SecurityException",
                  "description": "Returns an array of Constructor objects reflecting all the\n constructors declared by the class represented by this\n Class object. These are public, protected, default\n (package) access, and private constructors.  The elements in the array\n returned are not sorted and are not in any particular order.  If the\n class has a default constructor, it is included in the returned array.\n This method returns an array of length 0 if this Class\n object represents an interface, a primitive type, an array class, or\n void.\n\n  See The Java Language Specification,\n section 8.2."
                }
              ]
            },
            {
              "name": "getDeclaredField",
              "overloads": [
                {
                  "signature": "public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException",
                  "description": "Returns a Field object that reflects the specified declared\n field of the class or interface represented by this Class\n object. The name parameter is a String that specifies\n the simple name of the desired field.\n\n  If this Class object represents an array type, then this\n method does not find the length field of the array type."
                }
              ]
            },
            {
              "name": "getDeclaredMethod",
              "overloads": [
                {
                  "signature": "public Method getDeclaredMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Method object that reflects the specified\n declared method of the class or interface represented by this\n Class object. The name parameter is a\n String that specifies the simple name of the desired\n method, and the parameterTypes parameter is an array of\n Class objects that identify the method's formal parameter\n types, in declared order.  If more than one method with the same\n parameter types is declared in a class, and one of these methods has a\n return type that is more specific than any of the others, that method is\n returned; otherwise one of the methods is chosen arbitrarily.  If the\n name is \"<init>\"or \"<clinit>\" a NoSuchMethodException\n is raised.\n\n  If this Class object represents an array type, then this\n method does not find the clone() method."
                }
              ]
            },
            {
              "name": "getDeclaredConstructor",
              "overloads": [
                {
                  "signature": "public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException",
                  "description": "Returns a Constructor object that reflects the specified\n constructor of the class or interface represented by this\n Class object.  The parameterTypes parameter is\n an array of Class objects that identify the constructor's\n formal parameter types, in declared order.\n\n If this Class object represents an inner class\n declared in a non-static context, the formal parameter types\n include the explicit enclosing instance as the first parameter."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Finds a resource with a given name.\n\n  If this class is in a named Module then this method\n will attempt to find the resource in the module. This is done by\n delegating to the module's class loader findResource(String,String)\n method, invoking it with the module name and the absolute name of the\n resource. Resources in named modules are subject to the rules for\n encapsulation specified in the Module getResourceAsStream method and so this\n method returns null when the resource is a\n non-\".class\" resource in a package that is not open to the\n caller's module.\n\n  Otherwise, if this class is not in a named module then the rules for\n searching resources associated with a given class are implemented by the\n defining class loader of the class.  This method\n delegates to this Class object's class loader.\n If this Class object was loaded by the bootstrap class loader,\n the method delegates to ClassLoader.getSystemResourceAsStream(java.lang.String).\n\n  Before delegation, an absolute resource name is constructed from the\n given resource name using this algorithm:\n\n \n\n  If the name begins with a '/'\n ('\\u002f'), then the absolute name of the resource is the\n portion of the name following the '/'.\n\n  Otherwise, the absolute name is of the following form:\n\n \n   modified_package_name/name\n \n\n  Where the modified_package_name is the package name of this\n object with '/' substituted for '.'\n ('\\u002e')."
                }
              ]
            },
            {
              "name": "getResource",
              "overloads": [
                {
                  "signature": "public URL getResource(String name)",
                  "description": "Finds a resource with a given name.\n\n  If this class is in a named Module then this method\n will attempt to find the resource in the module. This is done by\n delegating to the module's class loader findResource(String,String)\n method, invoking it with the module name and the absolute name of the\n resource. Resources in named modules are subject to the rules for\n encapsulation specified in the Module getResourceAsStream method and so this\n method returns null when the resource is a\n non-\".class\" resource in a package that is not open to the\n caller's module.\n\n  Otherwise, if this class is not in a named module then the rules for\n searching resources associated with a given class are implemented by the\n defining class loader of the class.  This method\n delegates to this Class object's class loader.\n If this Class object was loaded by the bootstrap class loader,\n the method delegates to ClassLoader.getSystemResource(java.lang.String).\n\n  Before delegation, an absolute resource name is constructed from the\n given resource name using this algorithm:\n\n \n\n  If the name begins with a '/'\n ('\\u002f'), then the absolute name of the resource is the\n portion of the name following the '/'.\n\n  Otherwise, the absolute name is of the following form:\n\n \n   modified_package_name/name\n \n\n  Where the modified_package_name is the package name of this\n object with '/' substituted for '.'\n ('\\u002e')."
                }
              ]
            },
            {
              "name": "getProtectionDomain",
              "overloads": [
                {
                  "signature": "public ProtectionDomain getProtectionDomain()",
                  "description": "Returns the ProtectionDomain of this class.  If there is a\n security manager installed, this method first calls the security\n manager's checkPermission method with a\n RuntimePermission(\"getProtectionDomain\") permission to\n ensure it's ok to get the\n ProtectionDomain."
                }
              ]
            },
            {
              "name": "desiredAssertionStatus",
              "overloads": [
                {
                  "signature": "public boolean desiredAssertionStatus()",
                  "description": "Returns the assertion status that would be assigned to this\n class if it were to be initialized at the time this method is invoked.\n If this class has had its assertion status set, the most recent\n setting will be returned; otherwise, if any package default assertion\n status pertains to this class, the most recent setting for the most\n specific pertinent package default assertion status is returned;\n otherwise, if this class is not a system class (i.e., it has a\n class loader) its class loader's default assertion status is returned;\n otherwise, the system class default assertion status is returned."
                }
              ]
            },
            {
              "name": "isEnum",
              "overloads": [
                {
                  "signature": "public boolean isEnum()",
                  "description": "Returns true if and only if this class was declared as an enum in the\n source code.\n\n Note that Enum is not itself an enum class.\n\n Also note that if an enum constant is declared with a class body,\n the class of that enum constant object is an anonymous class\n and not the class of the declaring enum class. The\n Enum.getDeclaringClass() method of an enum constant can\n be used to get the class of the enum class declaring the\n constant."
                }
              ]
            },
            {
              "name": "isRecord",
              "overloads": [
                {
                  "signature": "public boolean isRecord()",
                  "description": "Returns true if and only if this class is a record class.\n\n  The direct superclass of a record\n class is java.lang.Record. A record class is final. A record class has (possibly zero) record\n components; getRecordComponents() returns a non-null but\n possibly empty value for a record.\n\n  Note that class Record is not a record class and thus\n invoking this method on class Record returns false."
                }
              ]
            },
            {
              "name": "getEnumConstants",
              "overloads": [
                {
                  "signature": "public T[] getEnumConstants()",
                  "description": "Returns the elements of this enum class or null if this\n Class object does not represent an enum class."
                }
              ]
            },
            {
              "name": "cast",
              "overloads": [
                {
                  "signature": "public T cast(Object obj)",
                  "description": "Casts an object to the class or interface represented\n by this Class object."
                }
              ]
            },
            {
              "name": "asSubclass",
              "overloads": [
                {
                  "signature": "public <U> Class<? extends U> asSubclass(Class<U> clazz)",
                  "description": "Casts this Class object to represent a subclass of the class\n represented by the specified class object.  Checks that the cast\n is valid, and throws a ClassCastException if it is not.  If\n this method succeeds, it always returns a reference to this Class object.\n\n This method is useful when a client needs to \"narrow\" the type of\n a Class object to pass it to an API that restricts the\n Class objects that it is willing to accept.  A cast would\n generate a compile-time warning, as the correctness of the cast\n could not be checked at runtime (because generic types are implemented\n by erasure)."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "isAnnotationPresent",
              "overloads": [
                {
                  "signature": "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
                  "description": "Returns true if an annotation for the specified type\n is present on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n The truth value returned by this method is equivalent to:\n getAnnotation(annotationClass) != null"
                }
              ]
            },
            {
              "name": "getAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns annotations that are associated with this element.\n\n If there are no annotations associated with this element, the return\n value is an array of length 0.\n\n The difference between this method and AnnotatedElement.getAnnotation(Class)\n is that this method detects if its argument is a repeatable\n annotation type (JLS 9.6), and if so, attempts to find one or\n more annotations of that type by \"looking through\" a container\n annotation.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.\n\n This method ignores inherited annotations. (Returns null if no\n annotations are directly present on this element.)\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns this element's annotation(s) for the specified type if\n such annotations are either directly present or\n indirectly present. This method ignores inherited\n annotations.\n\n If there are no specified annotations directly or indirectly\n present on this element, the return value is an array of length\n 0.\n\n The difference between this method and AnnotatedElement.getDeclaredAnnotation(Class) is that this method detects if its\n argument is a repeatable annotation type (JLS 9.6), and if so,\n attempts to find one or more annotations of that type by \"looking\n through\" a container annotation if one is present.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotatedSuperclass",
              "overloads": [
                {
                  "signature": "public AnnotatedType getAnnotatedSuperclass()",
                  "description": "Returns an AnnotatedType object that represents the use of a\n type to specify the superclass of the entity represented by this \n Class object. (The use of type Foo to specify the superclass\n in '...  extends Foo' is distinct from the declaration of class\n Foo.)\n\n  If this Class object represents a class whose declaration\n does not explicitly indicate an annotated superclass, then the return\n value is an AnnotatedType object representing an element with no\n annotations.\n\n  If this Class represents either the Object class, an\n interface type, an array type, a primitive type, or void, the return\n value is null."
                }
              ]
            },
            {
              "name": "getAnnotatedInterfaces",
              "overloads": [
                {
                  "signature": "public AnnotatedType[] getAnnotatedInterfaces()",
                  "description": "Returns an array of AnnotatedType objects that represent the use\n of types to specify superinterfaces of the entity represented by this\n Class object. (The use of type Foo to specify a\n superinterface in '... implements Foo' is distinct from the\n declaration of interface Foo.)\n\n  If this Class object represents a class, the return value is\n an array containing objects representing the uses of interface types to\n specify interfaces implemented by the class. The order of the objects in\n the array corresponds to the order of the interface types used in the\n 'implements' clause of the declaration of this Class object.\n\n  If this Class object represents an interface, the return\n value is an array containing objects representing the uses of interface\n types to specify interfaces directly extended by the interface. The\n order of the objects in the array corresponds to the order of the\n interface types used in the 'extends' clause of the declaration of this\n Class object.\n\n  If this Class object represents a class or interface whose\n declaration does not explicitly indicate any annotated superinterfaces,\n the return value is an array of length 0.\n\n  If this Class object represents either the Object\n class, an array type, a primitive type, or void, the return value is an\n array of length 0."
                }
              ]
            },
            {
              "name": "getNestHost",
              "overloads": [
                {
                  "signature": "public Class<?> getNestHost()",
                  "description": "Returns the nest host of the nest to which the class\n or interface represented by this Class object belongs.\n Every class and interface belongs to exactly one nest.\n\n If the nest host of this class or interface has previously\n been determined, then this method returns the nest host.\n If the nest host of this class or interface has\n not previously been determined, then this method determines the nest\n host using the algorithm of JVMS 5.4.4, and returns it.\n\n Often, a class or interface belongs to a nest consisting only of itself,\n in which case this method returns this to indicate that the class\n or interface is the nest host.\n\n If this Class object represents a primitive type, an array type,\n or void, then this method returns this,\n indicating that the represented entity belongs to the nest consisting only of\n itself, and is the nest host."
                }
              ]
            },
            {
              "name": "isNestmateOf",
              "overloads": [
                {
                  "signature": "public boolean isNestmateOf(Class<?> c)",
                  "description": "Determines if the given Class is a nestmate of the\n class or interface represented by this Class object.\n Two classes or interfaces are nestmates\n if they have the same nest host."
                }
              ]
            },
            {
              "name": "getNestMembers",
              "overloads": [
                {
                  "signature": "public Class<?>[] getNestMembers()",
                  "description": "Returns an array containing Class objects representing all the\n classes and interfaces that are members of the nest to which the class\n or interface represented by this Class object belongs.\n\n First, this method obtains the nest host,\n H, of the nest to which the class or interface represented by\n this Class object belongs. The zeroth element of the returned\n array is H.\n\n Then, for each class or interface C which is recorded by H\n as being a member of its nest, this method attempts to obtain the Class\n object for C (using the defining class\n loader of the current Class object), and then obtains the\n nest host of the nest to which C belongs.\n The classes and interfaces which are recorded by H as being members\n of its nest, and for which H can be determined as their nest host,\n are indicated by subsequent elements of the returned array. The order of\n such elements is unspecified. Duplicates are permitted.\n\n If this Class object represents a primitive type, an array type,\n or void, then this method returns a single-element array containing\n this."
                }
              ]
            },
            {
              "name": "descriptorString",
              "overloads": [
                {
                  "signature": "public String descriptorString()",
                  "description": "Returns the descriptor string of the entity (class, interface, array class,\n primitive type, or void) represented by this Class object.\n\n  If this Class object represents a class or interface,\n not an array class, then:\n \n  If the class or interface is not hidden,\n      then the result is a field descriptor (JVMS 4.3.2)\n      for the class or interface. Calling\n      ClassDesc::ofDescriptor\n      with the result descriptor string produces a ClassDesc\n      describing this class or interface.\n  If the class or interface is hidden,\n      then the result is a string of the form:\n      \n      \"L\" + N + \".\" + <suffix> + \";\"\n      \n      where N is the binary name\n      encoded in internal form indicated by the class file passed to\n      Lookup::defineHiddenClass, and <suffix> is an unqualified name.\n      A hidden class or interface has no nominal descriptor.\n      The result string is not a type descriptor.\n \n\n  If this Class object represents an array class, then\n the result is a string consisting of one or more '[' characters\n representing the depth of the array nesting, followed by the\n descriptor string of the element type.\n \n  If the element type is not a hidden class\n or interface, then this array class can be described nominally.\n Calling ClassDesc::ofDescriptor\n with the result descriptor string produces a ClassDesc\n describing this array class.\n  If the element type is a hidden class or\n interface, then this array class cannot be described nominally.\n The result string is not a type descriptor.\n \n\n  If this Class object represents a primitive type or\n void, then the result is a field descriptor string which\n is a one-letter code corresponding to a primitive type or void\n (\"B\", \"C\", \"D\", \"F\", \"I\", \"J\", \"S\", \"Z\", \"V\") (JVMS 4.3.2)."
                }
              ]
            },
            {
              "name": "componentType",
              "overloads": [
                {
                  "signature": "public Class<?> componentType()",
                  "description": "Returns the component type of this Class, if it describes\n an array type, or null otherwise."
                }
              ]
            },
            {
              "name": "arrayType",
              "overloads": [
                {
                  "signature": "public Class<?> arrayType()",
                  "description": "Returns a Class for an array type whose component type\n is described by this Class."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<ClassDesc> describeConstable()",
                  "description": "Returns a nominal descriptor for this instance, if one can be\n constructed, or an empty Optional if one cannot be."
                }
              ]
            },
            {
              "name": "isHidden",
              "overloads": [
                {
                  "signature": "public boolean isHidden()",
                  "description": "Returns true if and only if the underlying class is a hidden class."
                }
              ]
            },
            {
              "name": "getPermittedSubclasses",
              "overloads": [
                {
                  "signature": "public Class<?>[] getPermittedSubclasses()",
                  "description": "Returns an array containing Class objects representing the\n direct subinterfaces or subclasses permitted to extend or\n implement this class or interface if it is sealed.  The order of such elements\n is unspecified. The array is empty if this sealed class or interface has no\n permitted subclass. If this Class object represents a primitive type,\n void, an array type, or a class or interface that is not sealed,\n that is isSealed() returns false, then this method returns null.\n Conversely, if isSealed() returns true, then this method\n returns a non-null value.\n\n For each class or interface C which is recorded as a permitted\n direct subinterface or subclass of this class or interface,\n this method attempts to obtain the Class\n object for C (using the defining class\n loader of the current Class object).\n The Class objects which can be obtained and which are direct\n subinterfaces or subclasses of this class or interface,\n are indicated by elements of the returned array. If a Class object\n cannot be obtained, it is silently ignored, and not included in the result\n array."
                }
              ]
            },
            {
              "name": "isSealed",
              "overloads": [
                {
                  "signature": "public boolean isSealed()",
                  "description": "Returns true if and only if this Class object represents\n a sealed class or interface. If this Class object represents a\n primitive type, void, or an array type, this method returns\n false. A sealed class or interface has (possibly zero) permitted\n subclasses; getPermittedSubclasses() returns a non-null but\n possibly empty value for a sealed class or interface."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassCastException",
          "methods": [
            {
              "name": "ClassCastException",
              "overloads": [
                {
                  "signature": "public ClassCastException()",
                  "description": "Constructs a ClassCastException with no detail message."
                },
                {
                  "signature": "public ClassCastException(String s)",
                  "description": "Constructs a ClassCastException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassCircularityError",
          "methods": [
            {
              "name": "ClassCircularityError",
              "overloads": [
                {
                  "signature": "public ClassCircularityError()",
                  "description": "Constructs a ClassCircularityError with no detail message."
                },
                {
                  "signature": "public ClassCircularityError(String s)",
                  "description": "Constructs a ClassCircularityError with the specified detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassFormatError",
          "methods": [
            {
              "name": "ClassFormatError",
              "overloads": [
                {
                  "signature": "public ClassFormatError()",
                  "description": "Constructs a ClassFormatError with no detail message."
                },
                {
                  "signature": "public ClassFormatError(String s)",
                  "description": "Constructs a ClassFormatError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassLoader",
          "methods": [
            {
              "name": "ClassLoader",
              "overloads": [
                {
                  "signature": "protected ClassLoader(String name, ClassLoader parent)",
                  "description": "Creates a new class loader of the specified name and using the\n specified parent class loader for delegation."
                },
                {
                  "signature": "protected ClassLoader(ClassLoader parent)",
                  "description": "Creates a new class loader using the specified parent class loader for\n delegation.\n\n  If there is a security manager, its checkCreateClassLoader method\n is invoked.  This may result in a security exception."
                },
                {
                  "signature": "protected ClassLoader()",
                  "description": "Creates a new class loader using the ClassLoader returned by\n the method getSystemClassLoader() as the parent class loader.\n\n  If there is a security manager, its checkCreateClassLoader method is invoked.  This may result in\n a security exception."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of this class loader or null if\n this class loader is not named."
                }
              ]
            },
            {
              "name": "loadClass",
              "overloads": [
                {
                  "signature": "public Class<?> loadClass(String name) throws ClassNotFoundException",
                  "description": "Loads the class with the specified binary name.\n This method searches for classes in the same manner as the loadClass(String, boolean) method.  It is invoked by the Java virtual\n machine to resolve class references.  Invoking this method is equivalent\n to invoking loadClass(name,\n false)."
                },
                {
                  "signature": "protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException",
                  "description": "Loads the class with the specified binary name.  The\n default implementation of this method searches for classes in the\n following order:\n\n \n\n    Invoke findLoadedClass(String) to check if the class\n   has already been loaded.  \n\n    Invoke the loadClass method\n   on the parent class loader.  If the parent is null the class\n   loader built into the virtual machine is used, instead.  \n\n    Invoke the findClass(String) method to find the\n   class.  \n\n \n\n  If the class was found using the above steps, and the\n resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object.\n\n  Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method.  \n\n  Unless overridden, this method synchronizes on the result of\n getClassLoadingLock method\n during the entire class loading process."
                }
              ]
            },
            {
              "name": "getClassLoadingLock",
              "overloads": [
                {
                  "signature": "protected Object getClassLoadingLock(String className)",
                  "description": "Returns the lock object for class loading operations.\n For backward compatibility, the default implementation of this method\n behaves as follows. If this ClassLoader object is registered as\n parallel capable, the method returns a dedicated object associated\n with the specified class name. Otherwise, the method returns this\n ClassLoader object."
                }
              ]
            },
            {
              "name": "findClass",
              "overloads": [
                {
                  "signature": "protected Class<?> findClass(String name) throws ClassNotFoundException",
                  "description": "Finds the class with the specified binary name.\n This method should be overridden by class loader implementations that\n follow the delegation model for loading classes, and will be invoked by\n the loadClass method after checking the\n parent class loader for the requested class."
                },
                {
                  "signature": "protected Class<?> findClass(String moduleName, String name)",
                  "description": "Finds the class with the given binary name\n in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."
                }
              ]
            },
            {
              "name": "defineClass",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.  This method\n is deprecated in favor of the version that takes a binary name as its first argument, and is more secure.",
                  "deprecated": true
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.\n\n  This method assigns a default ProtectionDomain to the newly defined class.  The\n ProtectionDomain is effectively granted the same set of\n permissions returned when Policy.getPolicy().getPermissions(new CodeSource(null, null))\n is invoked.  The default protection domain is created on the first invocation\n of defineClass,\n and re-used on subsequent invocations.\n\n  To assign a specific ProtectionDomain to the class, use\n the defineClass method that takes a\n ProtectionDomain as one of its arguments.  \n\n \n This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError",
                  "description": "Converts an array of bytes into an instance of class Class,\n with a given ProtectionDomain.\n\n  If the given ProtectionDomain is null,\n then a default protection domain will be assigned to the class as specified\n in the documentation for defineClass(String, byte[], int, int).\n Before the class can be used it must be resolved.\n\n  The first class defined in a package determines the exact set of\n certificates that all subsequent classes defined in that package must\n contain.  The set of certificates for a class is obtained from the\n CodeSource within the\n ProtectionDomain of the class.  Any classes added to that\n package must contain the same set of certificates or a\n SecurityException will be thrown.  Note that if\n name is null, this check is not performed.\n You should always pass in the binary name of the\n class you are defining as well as the bytes.  This ensures that the\n class you are defining is indeed the class you think it is.\n\n  If the specified name begins with \"java.\", it can\n only be defined by the platform class loader or its ancestors; otherwise SecurityException\n will be thrown.  If name is not null, it must be equal to\n the binary name of the class\n specified by the byte array b, otherwise a NoClassDefFoundError will be thrown.\n\n  This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, ByteBuffer b, ProtectionDomain protectionDomain) throws ClassFormatError",
                  "description": "Converts a ByteBuffer into an instance\n of class Class, with the given ProtectionDomain.\n If the given ProtectionDomain is null, then a default\n protection domain will be assigned to the class as\n specified in the documentation for defineClass(String, byte[], int, int).  Before the class can be used it must be resolved.\n\n The rules about the first class defined in a package determining the\n set of certificates for the package, the restrictions on class names,\n and the defined package of the class\n are identical to those specified in the documentation for defineClass(String, byte[], int, int, ProtectionDomain).\n\n  An invocation of this method of the form\n cl.defineClass(name,\n bBuffer, pd) yields exactly the same\n result as the statements\n\n \n ...\n byte[] temp = new byte[bBuffer.remaining()];\n     bBuffer.get(temp);\n     return cl.defineClass(name, temp, 0,\n temp.length, pd);"
                }
              ]
            },
            {
              "name": "resolveClass",
              "overloads": [
                {
                  "signature": "protected final void resolveClass(Class<?> c)",
                  "description": "Links the specified class.  This (misleadingly named) method may be\n used by a class loader to link a class.  If the class c has\n already been linked, then this method simply returns. Otherwise, the\n class is linked as described in the \"Execution\" chapter of\n The Java Language Specification."
                }
              ]
            },
            {
              "name": "findSystemClass",
              "overloads": [
                {
                  "signature": "protected final Class<?> findSystemClass(String name) throws ClassNotFoundException",
                  "description": "Finds a class with the specified binary name,\n loading it if necessary.\n\n  This method loads the class through the system class loader (see\n getSystemClassLoader()).  The Class object returned\n might have more than one ClassLoader associated with it.\n Subclasses of ClassLoader need not usually invoke this method,\n because most class loaders need to override just findClass(String)."
                }
              ]
            },
            {
              "name": "findLoadedClass",
              "overloads": [
                {
                  "signature": "protected final Class<?> findLoadedClass(String name)",
                  "description": "Returns the class with the given binary name if this\n loader has been recorded by the Java virtual machine as an initiating\n loader of a class with that binary name.  Otherwise\n null is returned."
                }
              ]
            },
            {
              "name": "setSigners",
              "overloads": [
                {
                  "signature": "protected final void setSigners(Class<?> c, Object[] signers)",
                  "description": "Sets the signers of a class.  This should be invoked after defining a\n class."
                }
              ]
            },
            {
              "name": "findResource",
              "overloads": [
                {
                  "signature": "protected URL findResource(String moduleName, String name) throws IOException",
                  "description": "Returns a URL to a resource in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."
                },
                {
                  "signature": "protected URL findResource(String name)",
                  "description": "Finds the resource with the given name. Class loader implementations\n should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally."
                }
              ]
            },
            {
              "name": "getResource",
              "overloads": [
                {
                  "signature": "public URL getResource(String name)",
                  "description": "Finds the resource with the given name.  A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a '/'-separated path name that\n identifies the resource. \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "getResources",
              "overloads": [
                {
                  "signature": "public Enumeration<URL> getResources(String name) throws IOException",
                  "description": "Finds all the resources with the given name. A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource. \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "resources",
              "overloads": [
                {
                  "signature": "public Stream<URL> resources(String name)",
                  "description": "Returns a stream whose elements are the URLs of all the resources with\n the given name. A resource is some data (images, audio, text, etc) that\n can be accessed by class code in a way that is independent of the\n location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource.\n\n  The resources will be located when the returned stream is evaluated.\n If the evaluation results in an IOException then the I/O\n exception is wrapped in an UncheckedIOException that is then\n thrown.\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource)."
                }
              ]
            },
            {
              "name": "findResources",
              "overloads": [
                {
                  "signature": "protected Enumeration<URL> findResources(String name) throws IOException",
                  "description": "Returns an enumeration of URL objects\n representing all the resources with the given name. Class loader\n implementations should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally."
                }
              ]
            },
            {
              "name": "registerAsParallelCapable",
              "overloads": [
                {
                  "signature": "protected static boolean registerAsParallelCapable()",
                  "description": "Registers the caller as\n parallel capable.\n The registration succeeds if and only if all of the following\n conditions are met:\n \n  no instance of the caller has been created\n  all of the super classes (except class Object) of the caller are\n registered as parallel capable\n \n Note that once a class loader is registered as parallel capable, there\n is no way to change it back."
                }
              ]
            },
            {
              "name": "isRegisteredAsParallelCapable",
              "overloads": [
                {
                  "signature": "public final boolean isRegisteredAsParallelCapable()",
                  "description": "Returns true if this class loader is registered as\n parallel capable, otherwise\n false."
                }
              ]
            },
            {
              "name": "getSystemResource",
              "overloads": [
                {
                  "signature": "public static URL getSystemResource(String name)",
                  "description": "Find a resource of the specified name from the search path used to load\n classes.  This method locates the resource through the system class\n loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getSystemResources",
              "overloads": [
                {
                  "signature": "public static Enumeration<URL> getSystemResources(String name) throws IOException",
                  "description": "Finds all resources of the specified name from the search path used to\n load classes.  The resources thus found are returned as an\n Enumeration of URL objects.\n\n  The search order is described in the documentation for getSystemResource(String).  \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Returns an input stream for reading the specified resource.\n\n  The search order is described in the documentation for getResource(String).  \n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getSystemResourceAsStream",
              "overloads": [
                {
                  "signature": "public static InputStream getSystemResourceAsStream(String name)",
                  "description": "Open for reading, a resource of the specified name from the search path\n used to load classes.  This method locates the resource through the\n system class loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public final ClassLoader getParent()",
                  "description": "Returns the parent class loader for delegation. Some implementations may\n use null to represent the bootstrap class loader. This method\n will return null in such implementations if this class loader's\n parent is the bootstrap class loader."
                }
              ]
            },
            {
              "name": "getUnnamedModule",
              "overloads": [
                {
                  "signature": "public final Module getUnnamedModule()",
                  "description": "Returns the unnamed Module for this class loader."
                }
              ]
            },
            {
              "name": "getPlatformClassLoader",
              "overloads": [
                {
                  "signature": "public static ClassLoader getPlatformClassLoader()",
                  "description": "Returns the platform class loader.  All\n platform classes are visible to\n the platform class loader."
                }
              ]
            },
            {
              "name": "getSystemClassLoader",
              "overloads": [
                {
                  "signature": "public static ClassLoader getSystemClassLoader()",
                  "description": "Returns the system class loader.  This is the default\n delegation parent for new ClassLoader instances, and is\n typically the class loader used to start the application.\n\n  This method is first invoked early in the runtime's startup\n sequence, at which point it creates the system class loader. This\n class loader will be the context class loader for the main application\n thread (for example, the thread that invokes the main method of\n the main class).\n\n  The default system class loader is an implementation-dependent\n instance of this class.\n\n  If the system property \"java.system.class.loader\"\n is defined when this method is first invoked then the value of that\n property is taken to be the name of a class that will be returned as the\n system class loader. The class is loaded using the default system class\n loader and must define a public constructor that takes a single parameter\n of type ClassLoader which is used as the delegation parent. An\n instance is then created using this constructor with the default system\n class loader as the parameter.  The resulting class loader is defined\n to be the system class loader. During construction, the class loader\n should take great care to avoid calling getSystemClassLoader().\n If circular initialization of the system class loader is detected then\n an IllegalStateException is thrown."
                }
              ]
            },
            {
              "name": "definePackage",
              "overloads": [
                {
                  "signature": "protected Package definePackage(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase)",
                  "description": "Defines a package by name in this ClassLoader.\n \n Package names must be unique within a class loader and\n cannot be redefined or changed once created.\n \n If a class loader wishes to define a package with specific properties,\n such as version information, then the class loader should call this\n definePackage method before calling defineClass.\n Otherwise, the\n defineClass\n method will define a package in this class loader corresponding to the package\n of the newly defined class; the properties of this defined package are\n specified by Package."
                }
              ]
            },
            {
              "name": "getDefinedPackage",
              "overloads": [
                {
                  "signature": "public final Package getDefinedPackage(String name)",
                  "description": "Returns a Package of the given name that\n has been defined by this class loader."
                }
              ]
            },
            {
              "name": "getDefinedPackages",
              "overloads": [
                {
                  "signature": "public final Package[] getDefinedPackages()",
                  "description": "Returns all of the Packages that have been defined by\n this class loader.  The returned array has no duplicated Packages\n of the same name."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected Package getPackage(String name)",
                  "description": "Finds a package by name in this class loader and its ancestors.\n \n If this class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of\n this class loader are searched recursively (parent by parent)\n for a Package of the given name.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "protected Package[] getPackages()",
                  "description": "Returns all of the Packages that have been defined by\n this class loader and its ancestors.  The returned array may contain\n more than one Package object of the same package name, each\n defined by a different class loader in the class loader hierarchy."
                }
              ]
            },
            {
              "name": "findLibrary",
              "overloads": [
                {
                  "signature": "protected String findLibrary(String libname)",
                  "description": "Returns the absolute path name of a native library.  The VM invokes this\n method to locate the native libraries that belong to classes loaded with\n this class loader. If this method returns null, the VM\n searches the library along the path specified as the\n \"java.library.path\" property."
                }
              ]
            },
            {
              "name": "setDefaultAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setDefaultAssertionStatus(boolean enabled)",
                  "description": "Sets the default assertion status for this class loader.  This setting\n determines whether classes loaded by this class loader and initialized\n in the future will have assertions enabled or disabled by default.\n This setting may be overridden on a per-package or per-class basis by\n invoking setPackageAssertionStatus(String, boolean) or setClassAssertionStatus(String, boolean)."
                }
              ]
            },
            {
              "name": "setPackageAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setPackageAssertionStatus(String packageName, boolean enabled)",
                  "description": "Sets the package default assertion status for the named package.  The\n package default assertion status determines the assertion status for\n classes initialized in the future that belong to the named package or\n any of its \"subpackages\".\n\n  A subpackage of a package named p is any package whose name begins\n with \"p.\".  For example, javax.swing.text is a\n subpackage of javax.swing, and both java.util and\n java.lang.reflect are subpackages of java.\n\n  In the event that multiple package defaults apply to a given class,\n the package default pertaining to the most specific package takes\n precedence over the others.  For example, if javax.lang and\n javax.lang.reflect both have package defaults associated with\n them, the latter package default applies to classes in\n javax.lang.reflect.\n\n  Package defaults take precedence over the class loader's default\n assertion status, and may be overridden on a per-class basis by invoking\n setClassAssertionStatus(String, boolean)."
                }
              ]
            },
            {
              "name": "setClassAssertionStatus",
              "overloads": [
                {
                  "signature": "public void setClassAssertionStatus(String className, boolean enabled)",
                  "description": "Sets the desired assertion status for the named top-level class in this\n class loader and any nested classes contained therein.  This setting\n takes precedence over the class loader's default assertion status, and\n over any applicable per-package default.  This method has no effect if\n the named class has already been initialized.  (Once a class is\n initialized, its assertion status cannot change.)\n\n  If the named class is not a top-level class, this invocation will\n have no effect on the actual assertion status of any class."
                }
              ]
            },
            {
              "name": "clearAssertionStatus",
              "overloads": [
                {
                  "signature": "public void clearAssertionStatus()",
                  "description": "Sets the default assertion status for this class loader to\n false and discards any package defaults or class assertion\n status settings associated with the class loader.  This method is\n provided so that class loaders can be made to ignore any command line or\n persistent assertion status settings and \"start with a clean slate.\""
                }
              ]
            }
          ]
        },
        {
          "name": "ClassNotFoundException",
          "methods": [
            {
              "name": "ClassNotFoundException",
              "overloads": [
                {
                  "signature": "public ClassNotFoundException()",
                  "description": "Constructs a ClassNotFoundException with no detail message."
                },
                {
                  "signature": "public ClassNotFoundException(String s)",
                  "description": "Constructs a ClassNotFoundException with the\n specified detail message."
                },
                {
                  "signature": "public ClassNotFoundException(String s, Throwable ex)",
                  "description": "Constructs a ClassNotFoundException with the\n specified detail message and optional exception that was\n raised while loading the class."
                }
              ]
            },
            {
              "name": "getException",
              "overloads": [
                {
                  "signature": "public Throwable getException()",
                  "description": "Returns the exception that was raised if an error occurred while\n attempting to load the class. Otherwise, returns null."
                }
              ]
            }
          ]
        },
        {
          "name": "ClassValue<T>",
          "methods": [
            {
              "name": "ClassValue",
              "overloads": [
                {
                  "signature": "protected ClassValue()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "computeValue",
              "overloads": [
                {
                  "signature": "protected abstract T computeValue(Class<?> type)",
                  "description": "Computes the given class's derived value for this ClassValue.\n \n This method will be invoked within the first thread that accesses\n the value with the get method.\n \n Normally, this method is invoked at most once per class,\n but it may be invoked again if there has been a call to\n remove.\n \n If this method throws an exception, the corresponding call to get\n will terminate abnormally with that exception, and no class value will be recorded."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public T get(Class<?> type)",
                  "description": "Returns the value for the given class.\n If no value has yet been computed, it is obtained by\n an invocation of the computeValue method.\n \n The actual installation of the value on the class\n is performed atomically.\n At that point, if several racing threads have\n computed values, one is chosen, and returned to\n all the racing threads.\n \n The type parameter is typically a class, but it may be any type,\n such as an interface, a primitive type (like int.class), or void.class.\n \n In the absence of remove calls, a class value has a simple\n state diagram:  uninitialized and initialized.\n When remove calls are made,\n the rules for value observation are more complex.\n See the documentation for remove for more information."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public void remove(Class<?> type)",
                  "description": "Removes the associated value for the given class.\n If this value is subsequently read for the same class,\n its value will be reinitialized by invoking its computeValue method.\n This may result in an additional invocation of the\n computeValue method for the given class.\n \n In order to explain the interaction between get and remove calls,\n we must model the state transitions of a class value to take into account\n the alternation between uninitialized and initialized states.\n To do this, number these states sequentially from zero, and note that\n uninitialized (or removed) states are numbered with even numbers,\n while initialized (or re-initialized) states have odd numbers.\n \n When a thread T removes a class value in state 2N,\n nothing happens, since the class value is already uninitialized.\n Otherwise, the state is advanced atomically to 2N+1.\n \n When a thread T queries a class value in state 2N,\n the thread first attempts to initialize the class value to state 2N+1\n by invoking computeValue and installing the resulting value.\n \n When T attempts to install the newly computed value,\n if the state is still at 2N, the class value will be initialized\n with the computed value, advancing it to state 2N+1.\n \n Otherwise, whether the new state is even or odd,\n T will discard the newly computed value\n and retry the get operation.\n \n Discarding and retrying is an important proviso,\n since otherwise T could potentially install\n a disastrously stale value.  For example:\n \n T calls CV.get(C) and sees state 2N\n T quickly computes a time-dependent value V0 and gets ready to install it\n T is hit by an unlucky paging or scheduling event, and goes to sleep for a long time\n ...meanwhile, T2 also calls CV.get(C) and sees state 2N\n T2 quickly computes a similar time-dependent value V1 and installs it on CV.get(C)\n T2 (or a third thread) then calls CV.remove(C), undoing T2's work\n  the previous actions of T2 are repeated several times\n  also, the relevant computed values change over time: V1, V2, ...\n ...meanwhile, T wakes up and attempts to install V0; this must fail\n \n We can assume in the above scenario that CV.computeValue uses locks to properly\n observe the time-dependent states as it computes V1, etc.\n This does not remove the threat of a stale value, since there is a window of time\n between the return of computeValue in T and the installation\n of the new value.  No user synchronization is possible during this time."
                }
              ]
            }
          ]
        },
        {
          "name": "Cloneable",
          "methods": []
        },
        {
          "name": "CloneNotSupportedException",
          "methods": [
            {
              "name": "CloneNotSupportedException",
              "overloads": [
                {
                  "signature": "public CloneNotSupportedException()",
                  "description": "Constructs a CloneNotSupportedException with no\n detail message."
                },
                {
                  "signature": "public CloneNotSupportedException(String s)",
                  "description": "Constructs a CloneNotSupportedException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Comparable<T>",
          "methods": [
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "int compareTo(T o)",
                  "description": "Compares this object with the specified object for order.  Returns a\n negative integer, zero, or a positive integer as this object is less\n than, equal to, or greater than the specified object.\n\n The implementor must ensure signum(x.compareTo(y)) == -signum(y.compareTo(x)) for\n all x and y.  (This implies that \n x.compareTo(y) must throw an exception if and only if \n y.compareTo(x) throws an exception.)\n\n The implementor must also ensure that the relation is transitive:\n (x.compareTo(y) > 0 && y.compareTo(z) > 0) implies\n x.compareTo(z) > 0.\n\n Finally, the implementor must ensure that \n x.compareTo(y)==0 implies that signum(x.compareTo(z))\n == signum(y.compareTo(z)), for all z."
                }
              ]
            }
          ]
        },
        {
          "name": "Compiler",
          "methods": [
            {
              "name": "compileClass",
              "overloads": [
                {
                  "signature": "public static boolean compileClass(Class<?> clazz)",
                  "description": "Compiles the specified class.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "compileClasses",
              "overloads": [
                {
                  "signature": "public static boolean compileClasses(String string)",
                  "description": "Compiles all classes whose name matches the specified string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "public static Object command(Object any)",
                  "description": "Examines the argument type and its fields and perform some documented\n operation.  No specific operations are required.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "enable",
              "overloads": [
                {
                  "signature": "public static void enable()",
                  "description": "Cause the Compiler to resume operation.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "disable",
              "overloads": [
                {
                  "signature": "public static void disable()",
                  "description": "Cause the Compiler to cease operation.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Double",
          "methods": [
            {
              "name": "Double",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Double(double value)",
                  "description": "Constructs a newly allocated Double object that\n represents the primitive double argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Double(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Double object that\n represents the floating-point value of type double\n represented by the string. The string is converted to a\n double value as if by the valueOf method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(double d)",
                  "description": "Returns a string representation of the double\n argument. All characters mentioned below are ASCII characters.\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign character\n appears in the result. As for the magnitude m:\n \n If m is infinity, it is represented by the characters\n \"Infinity\"; thus, positive infinity produces the result\n \"Infinity\" and negative infinity produces the result\n \"-Infinity\".\n\n If m is zero, it is represented by the characters\n \"0.0\"; thus, negative zero produces the result\n \"-0.0\" and positive zero produces the result\n \"0.0\".\n\n If m is greater than or equal to 10-3 but less\n than 107, then it is represented as the integer part of\n m, in decimal form with no leading zeroes, followed by\n '.' ('\\u002E'), followed by one or\n more decimal digits representing the fractional part of m.\n\n If m is less than 10-3 or greater than or\n equal to 107, then it is represented in so-called\n \"computerized scientific notation.\" Let n be the unique\n integer such that 10n  m <\n 10n+1; then let a be the\n mathematically exact quotient of m and\n 10n so that 1  a < 10. The\n magnitude is then represented as the integer part of a,\n as a single decimal digit, followed by '.'\n ('\\u002E'), followed by decimal digits\n representing the fractional part of a, followed by the\n letter 'E' ('\\u0045'), followed\n by a representation of n as a decimal integer, as\n produced by the method Integer.toString(int).\n \n \n How many digits must be printed for the fractional part of\n m or a? There must be at least one digit to represent\n the fractional part, and beyond that as many, but only as many, more\n digits as are needed to uniquely distinguish the argument value from\n adjacent values of type double. That is, suppose that\n x is the exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero argument\n d. Then d must be the double value nearest\n to x; or if two double values are equally close\n to x, then d must be one of them and the least\n significant bit of the significand of d must be 0.\n\n To create localized string representations of a floating-point\n value, use subclasses of NumberFormat."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Double object.\n The primitive double value represented by this\n object is converted to a string exactly as if by the method\n toString of one argument."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(double d)",
                  "description": "Returns a hexadecimal string representation of the\n double argument. All characters mentioned below\n are ASCII characters.\n\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign\n and magnitude of the argument. If the sign is negative, the\n first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign\n character appears in the result. As for the magnitude m:\n\n \n If m is infinity, it is represented by the string\n \"Infinity\"; thus, positive infinity produces the\n result \"Infinity\" and negative infinity produces\n the result \"-Infinity\".\n\n If m is zero, it is represented by the string\n \"0x0.0p0\"; thus, negative zero produces the result\n \"-0x0.0p0\" and positive zero produces the result\n \"0x0.0p0\".\n\n If m is a double value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters \"0x1.\"\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by \"p\" followed\n by a decimal string of the unbiased exponent as if produced by\n a call to Integer.toString on the\n exponent value.\n\n If m is a double value with a subnormal\n representation, the significand is represented by the\n characters \"0x0.\" followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n \"p-1022\".  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \n\n \n\n \n Examples\n \n Floating-point ValueHexadecimal String\n \n \n 1.0 0x1.0p0\n -1.0        -0x1.0p0\n 2.0 0x1.0p1\n 3.0 0x1.8p1\n 0.5 0x1.0p-1\n 0.25        0x1.0p-2\n Double.MAX_VALUE\n     0x1.fffffffffffffp1023\n Minimum Normal Value\n     0x1.0p-1022\n Maximum Subnormal Value\n     0x0.fffffffffffffp-1022\n Double.MIN_VALUE\n     0x0.0000000000001p-1022"
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Double valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Double object holding the\n double value represented by the argument string\n s.\n\n If s is null, then a\n NullPointerException is thrown.\n\n Leading and trailing whitespace characters in s\n are ignored.  Whitespace is removed as if by the String.trim() method; that is, both ASCII space and control\n characters are removed. The rest of s should\n constitute a FloatValue as described by the lexical\n syntax rules:\n\n \n \n FloatValue:\n Signopt NaN\n Signopt Infinity\n Signopt FloatingPointLiteral\n Signopt HexFloatingPointLiteral\n SignedInteger\n \n\n \n HexFloatingPointLiteral:\n  HexSignificand BinaryExponent FloatTypeSuffixopt\n \n\n \n HexSignificand:\n HexNumeral\n HexNumeral .\n 0x HexDigitsopt\n     . HexDigits\n 0X HexDigitsopt\n     . HexDigits\n \n\n \n BinaryExponent:\n BinaryExponentIndicator SignedInteger\n \n\n \n BinaryExponentIndicator:\n p\n P\n \n\n \n\n where Sign, FloatingPointLiteral,\n HexNumeral, HexDigits, SignedInteger and\n FloatTypeSuffix are as defined in the lexical structure\n sections of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n If s does not have the form of\n a FloatValue, then a NumberFormatException\n is thrown. Otherwise, s is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type double\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of s is large\n enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2),\n rounding to double will result in an infinity and if the\n exact value of s is small enough in magnitude (less\n than or equal to MIN_VALUE/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a Double object representing\n this double value is returned.\n\n  To interpret localized string representations of a\n floating-point value, use subclasses of NumberFormat.\n\n Note that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n (1.0f is a float value;\n 1.0d is a double value), do\n not influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  The two-step\n sequence of conversions, string to float followed\n by float to double, is not\n equivalent to converting a string directly to\n double. For example, the float\n literal 0.1f is equal to the double\n value 0.10000000149011612; the float\n literal 0.1f represents a different numerical\n value than the double literal\n 0.1. (The numerical value 0.1 cannot be exactly\n represented in a binary floating-point number.)\n\n To avoid calling this method on an invalid string and having\n a NumberFormatException be thrown, the regular\n expression below can be used to screen the input string:\n\n \n  final String Digits     = \"(\\\\p{Digit}+)\";\n  final String HexDigits  = \"(\\\\p{XDigit}+)\";\n  // an exponent is 'e' or 'E' followed by an optionally\n  // signed decimal integer.\n  final String Exp        = \"[eE][+-]?\"+Digits;\n  final String fpRegex    =\n      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n       \"[+-]?(\" + // Optional sign character\n       \"NaN|\" +           // \"NaN\" string\n       \"Infinity|\" +      // \"Infinity\" string\n\n       // A decimal floating-point string representing a finite positive\n       // number without a leading sign has at most five basic pieces:\n       // Digits . Digits ExponentPart FloatTypeSuffix\n       //\n       // Since this method allows integer-only strings as input\n       // in addition to strings of floating-point literals, the\n       // two sub-patterns below are simplifications of the grammar\n       // productions from section 3.10.2 of\n       // The Java Language Specification.\n\n       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n\n       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n\n       // Hexadecimal strings\n       \"((\" +\n        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n\n        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n\n        \")[pP][+-]?\" + Digits + \"))\" +\n       \"[fFdD]?))\" +\n       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n\n  if (Pattern.matches(fpRegex, myString))\n      Double.valueOf(myString); // Will not throw NumberFormatException\n  else {\n      // Perform suitable alternative action\n  }"
                },
                {
                  "signature": "public static Double valueOf(double d)",
                  "description": "Returns a Double instance representing the specified\n double value.\n If a new Double instance is not required, this method\n should generally be used in preference to the constructor\n Double(double), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values."
                }
              ]
            },
            {
              "name": "parseDouble",
              "overloads": [
                {
                  "signature": "public static double parseDouble(String s) throws NumberFormatException",
                  "description": "Returns a new double initialized to the value\n represented by the specified String, as performed\n by the valueOf method of class\n Double."
                }
              ]
            },
            {
              "name": "isNaN",
              "overloads": [
                {
                  "signature": "public static boolean isNaN(double v)",
                  "description": "Returns true if the specified number is a\n Not-a-Number (NaN) value, false otherwise."
                },
                {
                  "signature": "public boolean isNaN()",
                  "description": "Returns true if this Double value is\n a Not-a-Number (NaN), false otherwise."
                }
              ]
            },
            {
              "name": "isInfinite",
              "overloads": [
                {
                  "signature": "public static boolean isInfinite(double v)",
                  "description": "Returns true if the specified number is infinitely\n large in magnitude, false otherwise."
                },
                {
                  "signature": "public boolean isInfinite()",
                  "description": "Returns true if this Double value is\n infinitely large in magnitude, false otherwise."
                }
              ]
            },
            {
              "name": "isFinite",
              "overloads": [
                {
                  "signature": "public static boolean isFinite(double d)",
                  "description": "Returns true if the argument is a finite floating-point\n value; returns false otherwise (for NaN and infinity\n arguments)."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Double as a byte\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Double as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Double as an int\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Double as a long\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Double as a float\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the double value of this Double object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Double object. The\n result is the exclusive OR of the two halves of the\n long integer bit representation, exactly as\n produced by the method doubleToLongBits(double), of\n the primitive double value represented by this\n Double object. That is, the hash code is the value\n of the expression:\n\n \n  (int)(v^(v>>>32))\n \n\n where v is defined by:\n\n \n  long v = Double.doubleToLongBits(this.doubleValue());"
                },
                {
                  "signature": "public static int hashCode(double value)",
                  "description": "Returns a hash code for a double value; compatible with\n Double.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.  The result\n is true if and only if the argument is not\n null and is a Double object that\n represents a double that has the same value as the\n double represented by this object. For this\n purpose, two double values are considered to be\n the same if and only if the method doubleToLongBits(double) returns the identical\n long value when applied to each."
                }
              ]
            },
            {
              "name": "doubleToLongBits",
              "overloads": [
                {
                  "signature": "public static long doubleToLongBits(double value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout.\n\n Bit 63 (the bit that is selected by the mask\n 0x8000000000000000L) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n 0x7ff0000000000000L) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n 0x000fffffffffffffL) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7ff0000000000000L.\n\n If the argument is negative infinity, the result is\n 0xfff0000000000000L.\n\n If the argument is NaN, the result is\n 0x7ff8000000000000L.\n\n In all cases, the result is a long integer that, when\n given to the longBitsToDouble(long) method, will produce a\n floating-point value the same as the argument to\n doubleToLongBits (except all NaN values are\n collapsed to a single \"canonical\" NaN value)."
                }
              ]
            },
            {
              "name": "doubleToRawLongBits",
              "overloads": [
                {
                  "signature": "public static long doubleToRawLongBits(double value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"double\n format\" bit layout, preserving Not-a-Number (NaN) values.\n\n Bit 63 (the bit that is selected by the mask\n 0x8000000000000000L) represents the sign of the\n floating-point number. Bits\n 62-52 (the bits that are selected by the mask\n 0x7ff0000000000000L) represent the exponent. Bits 51-0\n (the bits that are selected by the mask\n 0x000fffffffffffffL) represent the significand\n (sometimes called the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7ff0000000000000L.\n\n If the argument is negative infinity, the result is\n 0xfff0000000000000L.\n\n If the argument is NaN, the result is the long\n integer representing the actual NaN value.  Unlike the\n doubleToLongBits method,\n doubleToRawLongBits does not collapse all the bit\n patterns encoding a NaN to a single \"canonical\" NaN\n value.\n\n In all cases, the result is a long integer that,\n when given to the longBitsToDouble(long) method, will\n produce a floating-point value the same as the argument to\n doubleToRawLongBits."
                }
              ]
            },
            {
              "name": "longBitsToDouble",
              "overloads": [
                {
                  "signature": "public static double longBitsToDouble(long bits)",
                  "description": "Returns the double value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"double format\" bit layout.\n\n If the argument is 0x7ff0000000000000L, the result\n is positive infinity.\n\n If the argument is 0xfff0000000000000L, the result\n is negative infinity.\n\n If the argument is any value in the range\n 0x7ff0000000000001L through\n 0x7fffffffffffffffL or in the range\n 0xfff0000000000001L through\n 0xffffffffffffffffL, the result is a NaN.  No IEEE\n 754 floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the Double.doubleToRawLongBits method.\n\n In all other cases, let s, e, and m be three\n values that can be computed from the argument:\n\n \n int s = ((bits >> 63) == 0) ? 1 : -1;\n int e = (int)((bits >> 52) & 0x7ffL);\n long m = (e == 0) ?\n                 (bits & 0xfffffffffffffL) << 1 :\n                 (bits & 0xfffffffffffffL) | 0x10000000000000L;\n \n\n Then the floating-point result equals the value of the mathematical\n expression sm2e-1075.\n\n Note that this method may not be able to return a\n double NaN with exactly same bit pattern as the\n long argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and signaling NaNs.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method\n may perform this conversion.  So longBitsToDouble\n may not be able to return a double with a\n signaling NaN bit pattern.  Consequently, for some\n long values,\n doubleToRawLongBits(longBitsToDouble(start)) may\n not equal start.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Double anotherDouble)",
                  "description": "Compares two Double objects numerically.\n\n This method imposes a total order on Double objects\n with two differences compared to the incomplete order defined by\n the Java language numerical comparison operators (<, <=,\n ==, >=, >) on double values.\n\n  A NaN is unordered with respect to other\n          values and unequal to itself under the comparison\n          operators.  This method chooses to define \n          Double.NaN to be equal to itself and greater than all\n          other double values (including \n          Double.POSITIVE_INFINITY).\n\n       Positive zero and negative zero compare equal\n      numerically, but are distinct and distinguishable values.\n      This method chooses to define positive zero (+0.0d),\n      to be greater than negative zero (-0.0d).\n \n\n This ensures that the natural ordering of Double\n objects imposed by this method is consistent with\n equals; see this\n discussion for details of floating-point comparison and\n ordering."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(double d1, double d2)",
                  "description": "Compares the two specified double values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n     new Double(d1).compareTo(new Double(d2))"
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static double sum(double a, double b)",
                  "description": "Adds two double values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Double> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Double resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Enum.EnumDesc<E",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> Enum.EnumDesc<E> of(ClassDesc enumClass, String constantName)",
                  "description": "Returns a nominal descriptor for the specified enum class and name"
                }
              ]
            }
          ]
        },
        {
          "name": "Enum<E",
          "methods": [
            {
              "name": "Enum",
              "overloads": [
                {
                  "signature": "protected Enum(String name, int ordinal)",
                  "description": "Sole constructor.  Programmers cannot invoke this constructor.\n It is for use by code emitted by the compiler in response to\n enum class declarations."
                }
              ]
            },
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "public final String name()",
                  "description": "Returns the name of this enum constant, exactly as declared in its\n enum declaration.\n\n Most programmers should use the toString() method in\n preference to this one, as the toString method may return\n a more user-friendly name.  This method is designed primarily for\n use in specialized situations where correctness depends on getting the\n exact name, which will not vary from release to release."
                }
              ]
            },
            {
              "name": "ordinal",
              "overloads": [
                {
                  "signature": "public final int ordinal()",
                  "description": "Returns the ordinal of this enumeration constant (its position\n in its enum declaration, where the initial constant is assigned\n an ordinal of zero).\n\n Most programmers will have no use for this method.  It is\n designed for use by sophisticated enum-based data structures, such\n as EnumSet and EnumMap."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the name of this enum constant, as contained in the\n declaration.  This method may be overridden, though it typically\n isn't necessary or desirable.  An enum class should override this\n method when a more \"programmer-friendly\" string form exists."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object other)",
                  "description": "Returns true if the specified object is equal to this\n enum constant."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hash code for this enum constant."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected final Object clone() throws CloneNotSupportedException",
                  "description": "Throws CloneNotSupportedException.  This guarantees that enums\n are never cloned, which is necessary to preserve their \"singleton\"\n status."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public final int compareTo(E o)",
                  "description": "Compares this enum with the specified object for order.  Returns a\n negative integer, zero, or a positive integer as this object is less\n than, equal to, or greater than the specified object.\n\n Enum constants are only comparable to other enum constants of the\n same enum type.  The natural order implemented by this\n method is the order in which the constants are declared."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "public final Class<E> getDeclaringClass()",
                  "description": "Returns the Class object corresponding to this enum constant's\n enum type.  Two enum constants e1 and  e2 are of the\n same enum type if and only if\n   e1.getDeclaringClass() == e2.getDeclaringClass().\n (The value returned by this method may differ from the one returned\n by the Object.getClass() method for enum constants with\n constant-specific class bodies.)"
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public final Optional<Enum.EnumDesc<E>> describeConstable()",
                  "description": "Returns an enum descriptor EnumDesc for this instance, if one can be\n constructed, or an empty Optional if one cannot be."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static <T extends Enum<T>> T valueOf(Class<T> enumClass, String name)",
                  "description": "Returns the enum constant of the specified enum class with the\n specified name.  The name must match exactly an identifier used\n to declare an enum constant in this class.  (Extraneous whitespace\n characters are not permitted.)\n\n Note that for a particular enum class T, the\n implicitly declared public static T valueOf(String)\n method on that enum may be used instead of this method to map\n from a name to the corresponding enum constant.  All the\n constants of an enum class can be obtained by calling the\n implicit public static T[] values() method of that\n class."
                }
              ]
            },
            {
              "name": "finalize",
              "overloads": [
                {
                  "signature": "protected final void finalize()",
                  "description": "enum classes cannot have finalize methods."
                }
              ]
            }
          ]
        },
        {
          "name": "EnumConstantNotPresentException",
          "methods": [
            {
              "name": "EnumConstantNotPresentException",
              "overloads": [
                {
                  "signature": "public EnumConstantNotPresentException(Class<? extends Enum> enumType, String constantName)",
                  "description": "Constructs an EnumConstantNotPresentException for the\n specified constant."
                }
              ]
            },
            {
              "name": "enumType",
              "overloads": [
                {
                  "signature": "public Class<? extends Enum> enumType()",
                  "description": "Returns the type of the missing enum constant."
                }
              ]
            },
            {
              "name": "constantName",
              "overloads": [
                {
                  "signature": "public String constantName()",
                  "description": "Returns the name of the missing enum constant."
                }
              ]
            }
          ]
        },
        {
          "name": "Error",
          "methods": [
            {
              "name": "Error",
              "overloads": [
                {
                  "signature": "public Error()",
                  "description": "Constructs a new error with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Error(String message)",
                  "description": "Constructs a new error with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Error(String message, Throwable cause)",
                  "description": "Constructs a new error with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this error's detail message."
                },
                {
                  "signature": "public Error(Throwable cause)",
                  "description": "Constructs a new error with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for errors that are little more than\n wrappers for other throwables."
                },
                {
                  "signature": "protected Error(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new error with the specified detail message,\n cause, suppression enabled or disabled, and writable stack\n trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "Exception",
          "methods": [
            {
              "name": "Exception",
              "overloads": [
                {
                  "signature": "public Exception()",
                  "description": "Constructs a new exception with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Exception(String message)",
                  "description": "Constructs a new exception with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public Exception(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this exception's detail message."
                },
                {
                  "signature": "public Exception(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                },
                {
                  "signature": "protected Exception(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new exception with the specified detail message,\n cause, suppression enabled or disabled, and writable stack\n trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "ExceptionInInitializerError",
          "methods": [
            {
              "name": "ExceptionInInitializerError",
              "overloads": [
                {
                  "signature": "public ExceptionInInitializerError()",
                  "description": "Constructs an ExceptionInInitializerError with\n null as its detail message string and with no saved\n throwable object.\n A detail message is a String that describes this particular exception."
                },
                {
                  "signature": "public ExceptionInInitializerError(Throwable thrown)",
                  "description": "Constructs a new ExceptionInInitializerError class by\n saving a reference to the Throwable object thrown for\n later retrieval by the getException() method. The detail\n message string is set to null."
                },
                {
                  "signature": "public ExceptionInInitializerError(String s)",
                  "description": "Constructs an ExceptionInInitializerError with the specified detail\n message string.  A detail message is a String that describes this\n particular exception. The detail message string is saved for later\n retrieval by the Throwable.getMessage() method. There is no\n saved throwable object."
                }
              ]
            },
            {
              "name": "getException",
              "overloads": [
                {
                  "signature": "public Throwable getException()",
                  "description": "Returns the exception that occurred during a static initialization that\n caused this error to be created."
                }
              ]
            }
          ]
        },
        {
          "name": "Float",
          "methods": [
            {
              "name": "Float",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(float value)",
                  "description": "Constructs a newly allocated Float object that\n represents the primitive float argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(double value)",
                  "description": "Constructs a newly allocated Float object that\n represents the argument converted to type float.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Float(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Float object that\n represents the floating-point value of type float\n represented by the string. The string is converted to a\n float value as if by the valueOf method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(float f)",
                  "description": "Returns a string representation of the float\n argument. All characters mentioned below are ASCII characters.\n \n If the argument is NaN, the result is the string\n \"NaN\".\n Otherwise, the result is a string that represents the sign and\n     magnitude (absolute value) of the argument. If the sign is\n     negative, the first character of the result is\n     '-' ('\\u002D'); if the sign is\n     positive, no sign character appears in the result. As for\n     the magnitude m:\n \n If m is infinity, it is represented by the characters\n     \"Infinity\"; thus, positive infinity produces\n     the result \"Infinity\" and negative infinity\n     produces the result \"-Infinity\".\n If m is zero, it is represented by the characters\n     \"0.0\"; thus, negative zero produces the result\n     \"-0.0\" and positive zero produces the result\n     \"0.0\".\n  If m is greater than or equal to 10-3 but\n      less than 107, then it is represented as the\n      integer part of m, in decimal form with no leading\n      zeroes, followed by '.'\n      ('\\u002E'), followed by one or more\n      decimal digits representing the fractional part of\n      m.\n  If m is less than 10-3 or greater than or\n      equal to 107, then it is represented in\n      so-called \"computerized scientific notation.\" Let n\n      be the unique integer such that 10n \n      m < 10n+1; then let a\n      be the mathematically exact quotient of m and\n      10n so that 1  a < 10.\n      The magnitude is then represented as the integer part of\n      a, as a single decimal digit, followed by\n      '.' ('\\u002E'), followed by\n      decimal digits representing the fractional part of\n      a, followed by the letter 'E'\n      ('\\u0045'), followed by a representation\n      of n as a decimal integer, as produced by the\n      method Integer.toString(int).\n\n \n \n How many digits must be printed for the fractional part of\n m or a? There must be at least one digit\n to represent the fractional part, and beyond that as many, but\n only as many, more digits as are needed to uniquely distinguish\n the argument value from adjacent values of type\n float. That is, suppose that x is the\n exact mathematical value represented by the decimal\n representation produced by this method for a finite nonzero\n argument f. Then f must be the float\n value nearest to x; or, if two float values are\n equally close to x, then f must be one of\n them and the least significant bit of the significand of\n f must be 0.\n\n To create localized string representations of a floating-point\n value, use subclasses of NumberFormat."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Float object.\n The primitive float value represented by this object\n is converted to a String exactly as if by the method\n toString of one argument."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(float f)",
                  "description": "Returns a hexadecimal string representation of the\n float argument. All characters mentioned below are\n ASCII characters.\n\n \n If the argument is NaN, the result is the string\n     \"NaN\".\n Otherwise, the result is a string that represents the sign and\n magnitude (absolute value) of the argument. If the sign is negative,\n the first character of the result is '-'\n ('\\u002D'); if the sign is positive, no sign character\n appears in the result. As for the magnitude m:\n\n \n If m is infinity, it is represented by the string\n \"Infinity\"; thus, positive infinity produces the\n result \"Infinity\" and negative infinity produces\n the result \"-Infinity\".\n\n If m is zero, it is represented by the string\n \"0x0.0p0\"; thus, negative zero produces the result\n \"-0x0.0p0\" and positive zero produces the result\n \"0x0.0p0\".\n\n If m is a float value with a\n normalized representation, substrings are used to represent the\n significand and exponent fields.  The significand is\n represented by the characters \"0x1.\"\n followed by a lowercase hexadecimal representation of the rest\n of the significand as a fraction.  Trailing zeros in the\n hexadecimal representation are removed unless all the digits\n are zero, in which case a single zero is used. Next, the\n exponent is represented by \"p\" followed\n by a decimal string of the unbiased exponent as if produced by\n a call to Integer.toString on the\n exponent value.\n\n If m is a float value with a subnormal\n representation, the significand is represented by the\n characters \"0x0.\" followed by a\n hexadecimal representation of the rest of the significand as a\n fraction.  Trailing zeros in the hexadecimal representation are\n removed. Next, the exponent is represented by\n \"p-126\".  Note that there must be at\n least one nonzero digit in a subnormal significand.\n\n \n\n \n\n \n Examples\n \n Floating-point ValueHexadecimal String\n \n \n 1.0 0x1.0p0\n -1.0        -0x1.0p0\n 2.0 0x1.0p1\n 3.0 0x1.8p1\n 0.5 0x1.0p-1\n 0.25        0x1.0p-2\n Float.MAX_VALUE\n     0x1.fffffep127\n Minimum Normal Value\n     0x1.0p-126\n Maximum Subnormal Value\n     0x0.fffffep-126\n Float.MIN_VALUE\n     0x0.000002p-126"
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Float valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Float object holding the\n float value represented by the argument string\n s.\n\n If s is null, then a\n NullPointerException is thrown.\n\n Leading and trailing whitespace characters in s\n are ignored.  Whitespace is removed as if by the String.trim() method; that is, both ASCII space and control\n characters are removed. The rest of s should\n constitute a FloatValue as described by the lexical\n syntax rules:\n\n \n \n FloatValue:\n Signopt NaN\n Signopt Infinity\n Signopt FloatingPointLiteral\n Signopt HexFloatingPointLiteral\n SignedInteger\n \n\n \n HexFloatingPointLiteral:\n  HexSignificand BinaryExponent FloatTypeSuffixopt\n \n\n \n HexSignificand:\n HexNumeral\n HexNumeral .\n 0x HexDigitsopt\n     . HexDigits\n 0X HexDigitsopt\n     . HexDigits\n \n\n \n BinaryExponent:\n BinaryExponentIndicator SignedInteger\n \n\n \n BinaryExponentIndicator:\n p\n P\n \n\n \n\n where Sign, FloatingPointLiteral,\n HexNumeral, HexDigits, SignedInteger and\n FloatTypeSuffix are as defined in the lexical structure\n sections of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n If s does not have the form of\n a FloatValue, then a NumberFormatException\n is thrown. Otherwise, s is regarded as\n representing an exact decimal value in the usual\n \"computerized scientific notation\" or as an exact\n hexadecimal value; this exact numerical value is then\n conceptually converted to an \"infinitely precise\"\n binary value that is then rounded to type float\n by the usual round-to-nearest rule of IEEE 754 floating-point\n arithmetic, which includes preserving the sign of a zero\n value.\n\n Note that the round-to-nearest rule also implies overflow and\n underflow behaviour; if the exact value of s is large\n enough in magnitude (greater than or equal to (MAX_VALUE + ulp(MAX_VALUE)/2),\n rounding to float will result in an infinity and if the\n exact value of s is small enough in magnitude (less\n than or equal to MIN_VALUE/2), rounding to float will\n result in a zero.\n\n Finally, after rounding a Float object representing\n this float value is returned.\n\n To interpret localized string representations of a\n floating-point value, use subclasses of NumberFormat.\n\n Note that trailing format specifiers, specifiers that\n determine the type of a floating-point literal\n (1.0f is a float value;\n 1.0d is a double value), do\n not influence the results of this method.  In other\n words, the numerical value of the input string is converted\n directly to the target floating-point type.  In general, the\n two-step sequence of conversions, string to double\n followed by double to float, is\n not equivalent to converting a string directly to\n float.  For example, if first converted to an\n intermediate double and then to\n float, the string\n \"1.00000017881393421514957253748434595763683319091796875001d\"\n results in the float value\n 1.0000002f; if the string is converted directly to\n float, 1.0000001f results.\n\n To avoid calling this method on an invalid string and having\n a NumberFormatException be thrown, the documentation\n for Double.valueOf lists a regular\n expression which can be used to screen the input."
                },
                {
                  "signature": "public static Float valueOf(float f)",
                  "description": "Returns a Float instance representing the specified\n float value.\n If a new Float instance is not required, this method\n should generally be used in preference to the constructor\n Float(float), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values."
                }
              ]
            },
            {
              "name": "parseFloat",
              "overloads": [
                {
                  "signature": "public static float parseFloat(String s) throws NumberFormatException",
                  "description": "Returns a new float initialized to the value\n represented by the specified String, as performed\n by the valueOf method of class Float."
                }
              ]
            },
            {
              "name": "isNaN",
              "overloads": [
                {
                  "signature": "public static boolean isNaN(float v)",
                  "description": "Returns true if the specified number is a\n Not-a-Number (NaN) value, false otherwise."
                },
                {
                  "signature": "public boolean isNaN()",
                  "description": "Returns true if this Float value is a\n Not-a-Number (NaN), false otherwise."
                }
              ]
            },
            {
              "name": "isInfinite",
              "overloads": [
                {
                  "signature": "public static boolean isInfinite(float v)",
                  "description": "Returns true if the specified number is infinitely\n large in magnitude, false otherwise."
                },
                {
                  "signature": "public boolean isInfinite()",
                  "description": "Returns true if this Float value is\n infinitely large in magnitude, false otherwise."
                }
              ]
            },
            {
              "name": "isFinite",
              "overloads": [
                {
                  "signature": "public static boolean isFinite(float f)",
                  "description": "Returns true if the argument is a finite floating-point\n value; returns false otherwise (for NaN and infinity\n arguments)."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Float as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Float as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Float as an int after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns value of this Float as a long after a\n narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the float value of this Float object."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Float as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Float object. The\n result is the integer bit representation, exactly as produced\n by the method floatToIntBits(float), of the primitive\n float value represented by this Float\n object."
                },
                {
                  "signature": "public static int hashCode(float value)",
                  "description": "Returns a hash code for a float value; compatible with\n Float.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.  The result\n is true if and only if the argument is not\n null and is a Float object that\n represents a float with the same value as the\n float represented by this object. For this\n purpose, two float values are considered to be the\n same if and only if the method floatToIntBits(float)\n returns the identical int value when applied to\n each."
                }
              ]
            },
            {
              "name": "floatToIntBits",
              "overloads": [
                {
                  "signature": "public static int floatToIntBits(float value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout.\n\n Bit 31 (the bit that is selected by the mask\n 0x80000000) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n 0x7f800000) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n 0x007fffff) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7f800000.\n\n If the argument is negative infinity, the result is\n 0xff800000.\n\n If the argument is NaN, the result is 0x7fc00000.\n\n In all cases, the result is an integer that, when given to the\n intBitsToFloat(int) method, will produce a floating-point\n value the same as the argument to floatToIntBits\n (except all NaN values are collapsed to a single\n \"canonical\" NaN value)."
                }
              ]
            },
            {
              "name": "floatToRawIntBits",
              "overloads": [
                {
                  "signature": "public static int floatToRawIntBits(float value)",
                  "description": "Returns a representation of the specified floating-point value\n according to the IEEE 754 floating-point \"single format\" bit\n layout, preserving Not-a-Number (NaN) values.\n\n Bit 31 (the bit that is selected by the mask\n 0x80000000) represents the sign of the floating-point\n number.\n Bits 30-23 (the bits that are selected by the mask\n 0x7f800000) represent the exponent.\n Bits 22-0 (the bits that are selected by the mask\n 0x007fffff) represent the significand (sometimes called\n the mantissa) of the floating-point number.\n\n If the argument is positive infinity, the result is\n 0x7f800000.\n\n If the argument is negative infinity, the result is\n 0xff800000.\n\n If the argument is NaN, the result is the integer representing\n the actual NaN value.  Unlike the floatToIntBits\n method, floatToRawIntBits does not collapse all the\n bit patterns encoding a NaN to a single \"canonical\"\n NaN value.\n\n In all cases, the result is an integer that, when given to the\n intBitsToFloat(int) method, will produce a\n floating-point value the same as the argument to\n floatToRawIntBits."
                }
              ]
            },
            {
              "name": "intBitsToFloat",
              "overloads": [
                {
                  "signature": "public static float intBitsToFloat(int bits)",
                  "description": "Returns the float value corresponding to a given\n bit representation.\n The argument is considered to be a representation of a\n floating-point value according to the IEEE 754 floating-point\n \"single format\" bit layout.\n\n If the argument is 0x7f800000, the result is positive\n infinity.\n\n If the argument is 0xff800000, the result is negative\n infinity.\n\n If the argument is any value in the range\n 0x7f800001 through 0x7fffffff or in\n the range 0xff800001 through\n 0xffffffff, the result is a NaN.  No IEEE 754\n floating-point operation provided by Java can distinguish\n between two NaN values of the same type with different bit\n patterns.  Distinct values of NaN are only distinguishable by\n use of the Float.floatToRawIntBits method.\n\n In all other cases, let s, e, and m be three\n values that can be computed from the argument:\n\n \n int s = ((bits >> 31) == 0) ? 1 : -1;\n int e = ((bits >> 23) & 0xff);\n int m = (e == 0) ?\n                 (bits & 0x7fffff) << 1 :\n                 (bits & 0x7fffff) | 0x800000;\n \n\n Then the floating-point result equals the value of the mathematical\n expression sm2e-150.\n\n Note that this method may not be able to return a\n float NaN with exactly same bit pattern as the\n int argument.  IEEE 754 distinguishes between two\n kinds of NaNs, quiet NaNs and signaling NaNs.  The\n differences between the two kinds of NaN are generally not\n visible in Java.  Arithmetic operations on signaling NaNs turn\n them into quiet NaNs with a different, but often similar, bit\n pattern.  However, on some processors merely copying a\n signaling NaN also performs that conversion.  In particular,\n copying a signaling NaN to return it to the calling method may\n perform this conversion.  So intBitsToFloat may\n not be able to return a float with a signaling NaN\n bit pattern.  Consequently, for some int values,\n floatToRawIntBits(intBitsToFloat(start)) may\n not equal start.  Moreover, which\n particular bit patterns represent signaling NaNs is platform\n dependent; although all NaN bit patterns, quiet or signaling,\n must be in the NaN range identified above."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Float anotherFloat)",
                  "description": "Compares two Float objects numerically.\n\n This method imposes a total order on Float objects\n with two differences compared to the incomplete order defined by\n the Java language numerical comparison operators (<, <=,\n ==, >=, >) on float values.\n\n  A NaN is unordered with respect to other\n          values and unequal to itself under the comparison\n          operators.  This method chooses to define \n          Float.NaN to be equal to itself and greater than all\n          other double values (including \n          Float.POSITIVE_INFINITY).\n\n       Positive zero and negative zero compare equal\n      numerically, but are distinct and distinguishable values.\n      This method chooses to define positive zero (+0.0f),\n      to be greater than negative zero (-0.0f).\n \n\n This ensures that the natural ordering of Float\n objects imposed by this method is consistent with\n equals; see this\n discussion for details of floating-point comparison and\n ordering."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(float f1, float f2)",
                  "description": "Compares the two specified float values. The sign\n of the integer value returned is the same as that of the\n integer that would be returned by the call:\n     new Float(f1).compareTo(new Float(f2))"
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static float sum(float a, float b)",
                  "description": "Adds two float values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Float> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Float resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalAccessError",
          "methods": [
            {
              "name": "IllegalAccessError",
              "overloads": [
                {
                  "signature": "public IllegalAccessError()",
                  "description": "Constructs an IllegalAccessError with no detail message."
                },
                {
                  "signature": "public IllegalAccessError(String s)",
                  "description": "Constructs an IllegalAccessError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalAccessException",
          "methods": [
            {
              "name": "IllegalAccessException",
              "overloads": [
                {
                  "signature": "public IllegalAccessException()",
                  "description": "Constructs an IllegalAccessException without a\n detail message."
                },
                {
                  "signature": "public IllegalAccessException(String s)",
                  "description": "Constructs an IllegalAccessException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalArgumentException",
          "methods": [
            {
              "name": "IllegalArgumentException",
              "overloads": [
                {
                  "signature": "public IllegalArgumentException()",
                  "description": "Constructs an IllegalArgumentException with no\n detail message."
                },
                {
                  "signature": "public IllegalArgumentException(String s)",
                  "description": "Constructs an IllegalArgumentException with the\n specified detail message."
                },
                {
                  "signature": "public IllegalArgumentException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public IllegalArgumentException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalCallerException",
          "methods": [
            {
              "name": "IllegalCallerException",
              "overloads": [
                {
                  "signature": "public IllegalCallerException()",
                  "description": "Constructs an IllegalCallerException with no detail message."
                },
                {
                  "signature": "public IllegalCallerException(String s)",
                  "description": "Constructs an IllegalCallerException with the specified detail\n message."
                },
                {
                  "signature": "public IllegalCallerException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause."
                },
                {
                  "signature": "public IllegalCallerException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalMonitorStateException",
          "methods": [
            {
              "name": "IllegalMonitorStateException",
              "overloads": [
                {
                  "signature": "public IllegalMonitorStateException()",
                  "description": "Constructs an IllegalMonitorStateException with no\n detail message."
                },
                {
                  "signature": "public IllegalMonitorStateException(String s)",
                  "description": "Constructs an IllegalMonitorStateException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalStateException",
          "methods": [
            {
              "name": "IllegalStateException",
              "overloads": [
                {
                  "signature": "public IllegalStateException()",
                  "description": "Constructs an IllegalStateException with no detail message.\n A detail message is a String that describes this particular exception."
                },
                {
                  "signature": "public IllegalStateException(String s)",
                  "description": "Constructs an IllegalStateException with the specified detail\n message.  A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public IllegalStateException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public IllegalStateException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalThreadStateException",
          "methods": [
            {
              "name": "IllegalThreadStateException",
              "overloads": [
                {
                  "signature": "public IllegalThreadStateException()",
                  "description": "Constructs an IllegalThreadStateException with no\n detail message."
                },
                {
                  "signature": "public IllegalThreadStateException(String s)",
                  "description": "Constructs an IllegalThreadStateException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IncompatibleClassChangeError",
          "methods": [
            {
              "name": "IncompatibleClassChangeError",
              "overloads": [
                {
                  "signature": "public IncompatibleClassChangeError()",
                  "description": "Constructs an IncompatibleClassChangeError with no\n detail message."
                },
                {
                  "signature": "public IncompatibleClassChangeError(String s)",
                  "description": "Constructs an IncompatibleClassChangeError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "IndexOutOfBoundsException",
          "methods": [
            {
              "name": "IndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public IndexOutOfBoundsException()",
                  "description": "Constructs an IndexOutOfBoundsException with no detail message."
                },
                {
                  "signature": "public IndexOutOfBoundsException(String s)",
                  "description": "Constructs an IndexOutOfBoundsException with the specified detail\n message."
                },
                {
                  "signature": "public IndexOutOfBoundsException(int index)",
                  "description": "Constructs a new IndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                },
                {
                  "signature": "public IndexOutOfBoundsException(long index)",
                  "description": "Constructs a new IndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "InheritableThreadLocal<T>",
          "methods": [
            {
              "name": "InheritableThreadLocal",
              "overloads": [
                {
                  "signature": "public InheritableThreadLocal()",
                  "description": "Creates an inheritable thread local variable."
                }
              ]
            },
            {
              "name": "childValue",
              "overloads": [
                {
                  "signature": "protected T childValue(T parentValue)",
                  "description": "Computes the child's initial value for this inheritable thread-local\n variable as a function of the parent's value at the time the child\n thread is created.  This method is called from within the parent\n thread before the child is started.\n \n This method merely returns its input argument, and should be overridden\n if a different behavior is desired."
                }
              ]
            }
          ]
        },
        {
          "name": "InstantiationError",
          "methods": [
            {
              "name": "InstantiationError",
              "overloads": [
                {
                  "signature": "public InstantiationError()",
                  "description": "Constructs an InstantiationError with no detail  message."
                },
                {
                  "signature": "public InstantiationError(String s)",
                  "description": "Constructs an InstantiationError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "InstantiationException",
          "methods": [
            {
              "name": "InstantiationException",
              "overloads": [
                {
                  "signature": "public InstantiationException()",
                  "description": "Constructs an InstantiationException with no detail message."
                },
                {
                  "signature": "public InstantiationException(String s)",
                  "description": "Constructs an InstantiationException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Integer",
          "methods": [
            {
              "name": "Integer",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Integer(int value)",
                  "description": "Constructs a newly allocated Integer object that\n represents the specified int value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Integer(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Integer object that\n represents the int value indicated by the\n String parameter. The string is converted to an\n int value in exactly the manner used by the\n parseInt method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(int i, int radix)",
                  "description": "Returns a string representation of the first argument in the\n radix specified by the second argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n If the first argument is negative, the first element of the\n result is the ASCII minus character '-'\n ('\\u002D'). If the first argument is not\n negative, no sign character appears in the result.\n\n The remaining characters of the result represent the magnitude\n of the first argument. If the magnitude is zero, it is\n represented by a single zero character '0'\n ('\\u0030'); otherwise, the first character of\n the representation of the magnitude will not be the zero\n character.  The following ASCII characters are used as digits:\n\n \n   0123456789abcdefghijklmnopqrstuvwxyz\n \n\n These are '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u007A'. If radix is\n N, then the first N of these characters\n are used as radix-N digits in the order shown. Thus,\n the digits for hexadecimal (radix 16) are\n 0123456789abcdef. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Integer.toString(n, 16).toUpperCase()"
                },
                {
                  "signature": "public static String toString(int i)",
                  "description": "Returns a String object representing the\n specified integer. The argument is converted to signed decimal\n representation and returned as a string, exactly as if the\n argument and radix 10 were given as arguments to the toString(int, int) method."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Integer's value. The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the integer value were given as an argument to the toString(int) method."
                }
              ]
            },
            {
              "name": "toUnsignedString",
              "overloads": [
                {
                  "signature": "public static String toUnsignedString(int i, int radix)",
                  "description": "Returns a string representation of the first argument as an\n unsigned integer value in the radix specified by the second\n argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n Note that since the first argument is treated as an unsigned\n value, no leading sign character is printed.\n\n If the magnitude is zero, it is represented by a single zero\n character '0' ('\\u0030'); otherwise,\n the first character of the representation of the magnitude will\n not be the zero character.\n\n The behavior of radixes and the characters used as digits\n are the same as toString."
                },
                {
                  "signature": "public static String toUnsignedString(int i)",
                  "description": "Returns a string representation of the argument as an unsigned\n decimal value.\n\n The argument is converted to unsigned decimal representation\n and returned as a string exactly as if the argument and radix\n 10 were given as arguments to the toUnsignedString(int, int) method."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base16.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise, it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in hexadecimal (base16) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 16).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as hexadecimal digits:\n\n \n  0123456789abcdef\n \n\n These are the characters '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u0066'. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Integer.toHexString(n).toUpperCase()"
                }
              ]
            },
            {
              "name": "toOctalString",
              "overloads": [
                {
                  "signature": "public static String toOctalString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base8.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise, it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in octal (base8) with no extra leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 8).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as octal digits:\n\n \n 01234567\n \n\n These are the characters '\\u0030' through\n '\\u0037'."
                }
              ]
            },
            {
              "name": "toBinaryString",
              "overloads": [
                {
                  "signature": "public static String toBinaryString(int i)",
                  "description": "Returns a string representation of the integer argument as an\n unsigned integer in base2.\n\n The unsigned integer value is the argument plus 232\n if the argument is negative; otherwise it is equal to the\n argument.  This value is converted to a string of ASCII digits\n in binary (base2) with no extra leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Integer.parseUnsignedInt(s, 2).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n characters '0' ('\\u0030') and \n '1' ('\\u0031') are used as binary digits."
                }
              ]
            },
            {
              "name": "parseInt",
              "overloads": [
                {
                  "signature": "public static int parseInt(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed integer in the radix\n specified by the second argument. The characters in the string\n must all be digits of the specified radix (as determined by\n whether Character.digit(char, int) returns a\n nonnegative value), except that the first character may be an\n ASCII minus sign '-' ('\\u002D') to\n indicate a negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a minus sign\n '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is not a value of type\n int.\n \n\n Examples:\n  parseInt(\"0\", 10) returns 0\n parseInt(\"473\", 10) returns 473\n parseInt(\"+42\", 10) returns 42\n parseInt(\"-0\", 10) returns 0\n parseInt(\"-FF\", 16) returns -255\n parseInt(\"1100110\", 2) returns 102\n parseInt(\"2147483647\", 10) returns 2147483647\n parseInt(\"-2147483648\", 10) returns -2147483648\n parseInt(\"2147483648\", 10) throws a NumberFormatException\n parseInt(\"99\", 8) throws a NumberFormatException\n parseInt(\"Kona\", 10) throws a NumberFormatException\n parseInt(\"Kona\", 27) returns 411787"
                },
                {
                  "signature": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as a signed int in the\n specified radix, beginning at the specified beginIndex\n and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static int parseInt(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal integer. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value. The resulting integer value is\n returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseInt(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "parseUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned integer in the radix\n specified by the second argument.  An unsigned integer maps the\n values usually associated with negative numbers to positive\n numbers larger than MAX_VALUE.\n\n The characters in the string must all be digits of the\n specified radix (as determined by whether Character.digit(char, int) returns a nonnegative\n value), except that the first character may be an ASCII plus\n sign '+' ('\\u002B'). The resulting\n integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is larger than the\n largest unsigned int, 232-1."
                },
                {
                  "signature": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as an unsigned int in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static int parseUnsignedInt(String s) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned decimal integer. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII plus sign \n '+' ('\\u002B'). The resulting integer value\n is returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseUnsignedInt(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Integer valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns an Integer object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed integer in the radix\n specified by the second argument, exactly as if the arguments\n were given to the parseInt(java.lang.String, int)\n method. The result is an Integer object that\n represents the integer value specified by the string.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  new Integer(Integer.parseInt(s, radix))"
                },
                {
                  "signature": "public static Integer valueOf(String s) throws NumberFormatException",
                  "description": "Returns an Integer object holding the\n value of the specified String. The argument is\n interpreted as representing a signed decimal integer, exactly\n as if the argument were given to the parseInt(java.lang.String) method. The result is an\n Integer object that represents the integer value\n specified by the string.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  new Integer(Integer.parseInt(s))"
                },
                {
                  "signature": "public static Integer valueOf(int i)",
                  "description": "Returns an Integer instance representing the specified\n int value.  If a new Integer instance is not\n required, this method should generally be used in preference to\n the constructor Integer(int), as this method is likely\n to yield significantly better space and time performance by\n caching frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Integer as a byte\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Integer as a short\n after a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Integer as an\n int."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Integer as a long\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Integer as a float\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Integer as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Integer."
                },
                {
                  "signature": "public static int hashCode(int value)",
                  "description": "Returns a hash code for an int value; compatible with\n Integer.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is an Integer object that\n contains the same int value as this object."
                }
              ]
            },
            {
              "name": "getInteger",
              "overloads": [
                {
                  "signature": "public static Integer getInteger(String nm)",
                  "description": "Determines the integer value of the system property with the\n specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as an integer\n value using the grammar supported by decode and\n an Integer object representing this value is returned.\n\n If there is no property with the specified name, if the\n specified name is empty or null, or if the property\n does not have the correct numeric format, then null is\n returned.\n\n In other words, this method returns an Integer\n object equal to the value of:\n\n \n  getInteger(nm, null)"
                },
                {
                  "signature": "public static Integer getInteger(String nm, int val)",
                  "description": "Determines the integer value of the system property with the\n specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as an integer\n value using the grammar supported by decode and\n an Integer object representing this value is returned.\n\n The second argument is the default value. An Integer object\n that represents the value of the second argument is returned if there\n is no property of the specified name, if the property does not have\n the correct numeric format, or if the specified name is empty or\n null.\n\n In other words, this method returns an Integer object\n equal to the value of:\n\n \n  getInteger(nm, new Integer(val))\n \n\n but in practice it may be implemented in a manner such as:\n\n  Integer result = getInteger(nm, null);\n return (result == null) ? new Integer(val) : result;\n \n\n to avoid the unnecessary allocation of an Integer\n object when the default value is not needed."
                },
                {
                  "signature": "public static Integer getInteger(String nm, Integer val)",
                  "description": "Returns the integer value of the system property with the\n specified name.  The first argument is treated as the name of a\n system property.  System properties are accessible through the\n System.getProperty(java.lang.String) method.\n The string value of this property is then interpreted as an\n integer value, as per the decode method,\n and an Integer object representing this value is\n returned; in summary:\n\n If the property value begins with the two ASCII characters\n         0x or the ASCII character #, not\n      followed by a minus sign, then the rest of it is parsed as a\n      hexadecimal integer exactly as by the method\n      valueOf(java.lang.String, int) with radix 16.\n If the property value begins with the ASCII character\n     0 followed by another character, it is parsed as an\n     octal integer exactly as by the method\n     valueOf(java.lang.String, int) with radix 8.\n Otherwise, the property value is parsed as a decimal integer\n exactly as by the method valueOf(java.lang.String, int)\n with radix 10.\n \n\n The second argument is the default value. The default value is\n returned if there is no property of the specified name, if the\n property does not have the correct numeric format, or if the\n specified name is empty or null."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Integer decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into an Integer.\n Accepts decimal, hexadecimal, and octal numbers given\n by the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Integer.parseInt method with the indicated radix (10, 16, or\n 8).  This sequence of characters must represent a positive\n value or a NumberFormatException will be thrown.  The\n result is negated if first character of the specified \n String is the minus sign.  No whitespace characters are\n permitted in the String."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Integer anotherInteger)",
                  "description": "Compares two Integer objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(int x, int y)",
                  "description": "Compares two int values numerically.\n The value returned is identical to what would be returned by:\n     Integer.valueOf(x).compareTo(Integer.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(int x, int y)",
                  "description": "Compares two int values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(int x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 32 bits of the long are zero and the\n low-order 32 bits are equal to the bits of the integer\n argument.\n\n Consequently, zero and positive int values are mapped\n to a numerically equal long value and negative \n int values are mapped to a long value equal to the\n input plus 232."
                }
              ]
            },
            {
              "name": "divideUnsigned",
              "overloads": [
                {
                  "signature": "public static int divideUnsigned(int dividend, int divisor)",
                  "description": "Returns the unsigned quotient of dividing the first argument by\n the second where each argument and the result is interpreted as\n an unsigned value.\n\n Note that in two's complement arithmetic, the three other\n basic arithmetic operations of add, subtract, and multiply are\n bit-wise identical if the two operands are regarded as both\n being signed or both being unsigned.  Therefore separate \n addUnsigned, etc. methods are not provided."
                }
              ]
            },
            {
              "name": "remainderUnsigned",
              "overloads": [
                {
                  "signature": "public static int remainderUnsigned(int dividend, int divisor)",
                  "description": "Returns the unsigned remainder from dividing the first argument\n by the second where each argument and the result is interpreted\n as an unsigned value."
                }
              ]
            },
            {
              "name": "highestOneBit",
              "overloads": [
                {
                  "signature": "public static int highestOneBit(int i)",
                  "description": "Returns an int value with at most a single one-bit, in the\n position of the highest-order (\"leftmost\") one-bit in the specified\n int value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "lowestOneBit",
              "overloads": [
                {
                  "signature": "public static int lowestOneBit(int i)",
                  "description": "Returns an int value with at most a single one-bit, in the\n position of the lowest-order (\"rightmost\") one-bit in the specified\n int value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "numberOfLeadingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfLeadingZeros(int i)",
                  "description": "Returns the number of zero bits preceding the highest-order\n (\"leftmost\") one-bit in the two's complement binary representation\n of the specified int value.  Returns 32 if the\n specified value has no one-bits in its two's complement representation,\n in other words if it is equal to zero.\n\n Note that this method is closely related to the logarithm base 2.\n For all positive int values x:\n \n floor(log2(x)) = 31 - numberOfLeadingZeros(x)\n ceil(log2(x)) = 32 - numberOfLeadingZeros(x - 1)"
                }
              ]
            },
            {
              "name": "numberOfTrailingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfTrailingZeros(int i)",
                  "description": "Returns the number of zero bits following the lowest-order (\"rightmost\")\n one-bit in the two's complement binary representation of the specified\n int value.  Returns 32 if the specified value has no\n one-bits in its two's complement representation, in other words if it is\n equal to zero."
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public static int bitCount(int i)",
                  "description": "Returns the number of one-bits in the two's complement binary\n representation of the specified int value.  This function is\n sometimes referred to as the population count."
                }
              ]
            },
            {
              "name": "rotateLeft",
              "overloads": [
                {
                  "signature": "public static int rotateLeft(int i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified int value left by the\n specified number of bits.  (Bits shifted out of the left hand, or\n high-order, side reenter on the right, or low-order.)\n\n Note that left rotation with a negative distance is equivalent to\n right rotation: rotateLeft(val, -distance) == rotateRight(val,\n distance).  Note also that rotation by any multiple of 32 is a\n no-op, so all but the last five bits of the rotation distance can be\n ignored, even if the distance is negative: rotateLeft(val,\n distance) == rotateLeft(val, distance & 0x1F)."
                }
              ]
            },
            {
              "name": "rotateRight",
              "overloads": [
                {
                  "signature": "public static int rotateRight(int i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified int value right by the\n specified number of bits.  (Bits shifted out of the right hand, or\n low-order, side reenter on the left, or high-order.)\n\n Note that right rotation with a negative distance is equivalent to\n left rotation: rotateRight(val, -distance) == rotateLeft(val,\n distance).  Note also that rotation by any multiple of 32 is a\n no-op, so all but the last five bits of the rotation distance can be\n ignored, even if the distance is negative: rotateRight(val,\n distance) == rotateRight(val, distance & 0x1F)."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public static int reverse(int i)",
                  "description": "Returns the value obtained by reversing the order of the bits in the\n two's complement binary representation of the specified int\n value."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static int signum(int i)",
                  "description": "Returns the signum function of the specified int value.  (The\n return value is -1 if the specified value is negative; 0 if the\n specified value is zero; and 1 if the specified value is positive.)"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static int reverseBytes(int i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified int value."
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static int sum(int a, int b)",
                  "description": "Adds two integers together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Integer> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Integer resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "InternalError",
          "methods": [
            {
              "name": "InternalError",
              "overloads": [
                {
                  "signature": "public InternalError()",
                  "description": "Constructs an InternalError with no detail message."
                },
                {
                  "signature": "public InternalError(String message)",
                  "description": "Constructs an InternalError with the specified\n detail message."
                },
                {
                  "signature": "public InternalError(String message, Throwable cause)",
                  "description": "Constructs an InternalError with the specified detail\n message and cause.  Note that the detail message associated\n with cause is not automatically incorporated in\n this error's detail message."
                },
                {
                  "signature": "public InternalError(Throwable cause)",
                  "description": "Constructs an InternalError with the specified cause\n and a detail message of (cause==null ? null :\n cause.toString()) (which typically contains the class and\n detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "InterruptedException",
          "methods": [
            {
              "name": "InterruptedException",
              "overloads": [
                {
                  "signature": "public InterruptedException()",
                  "description": "Constructs an InterruptedException with no detail  message."
                },
                {
                  "signature": "public InterruptedException(String s)",
                  "description": "Constructs an InterruptedException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Iterable<T>",
          "methods": [
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<T> iterator()",
                  "description": "Returns an iterator over elements of type T."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "default void forEach(Consumer<? super T> action)",
                  "description": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.  Actions are performed in the order of iteration, if that\n order is specified.  Exceptions thrown by the action are relayed to the\n caller.\n \n The behavior of this method is unspecified if the action performs\n side-effects that modify the underlying source of elements, unless an\n overriding class has specified a concurrent modification policy."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<T> spliterator()",
                  "description": "Creates a Spliterator over the elements described by this\n Iterable."
                }
              ]
            }
          ]
        },
        {
          "name": "LayerInstantiationException",
          "methods": [
            {
              "name": "LayerInstantiationException",
              "overloads": [
                {
                  "signature": "public LayerInstantiationException()",
                  "description": "Constructs a LayerInstantiationException with no detail message."
                },
                {
                  "signature": "public LayerInstantiationException(String msg)",
                  "description": "Constructs a LayerInstantiationException with the given detail\n message."
                },
                {
                  "signature": "public LayerInstantiationException(Throwable cause)",
                  "description": "Constructs a LayerInstantiationException with the given cause."
                },
                {
                  "signature": "public LayerInstantiationException(String msg, Throwable cause)",
                  "description": "Constructs a LayerInstantiationException with the given detail\n message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "LinkageError",
          "methods": [
            {
              "name": "LinkageError",
              "overloads": [
                {
                  "signature": "public LinkageError()",
                  "description": "Constructs a LinkageError with no detail message."
                },
                {
                  "signature": "public LinkageError(String s)",
                  "description": "Constructs a LinkageError with the specified detail\n message."
                },
                {
                  "signature": "public LinkageError(String s, Throwable cause)",
                  "description": "Constructs a LinkageError with the specified detail\n message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "Long",
          "methods": [
            {
              "name": "Long",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Long(long value)",
                  "description": "Constructs a newly allocated Long object that\n represents the specified long argument.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Long(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Long object that\n represents the long value indicated by the\n String parameter. The string is converted to a\n long value in exactly the manner used by the\n parseLong method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(long i, int radix)",
                  "description": "Returns a string representation of the first argument in the\n radix specified by the second argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n If the first argument is negative, the first element of the\n result is the ASCII minus sign '-'\n ('\\u002d'). If the first argument is not\n negative, no sign character appears in the result.\n\n The remaining characters of the result represent the magnitude\n of the first argument. If the magnitude is zero, it is\n represented by a single zero character '0'\n ('\\u0030'); otherwise, the first character of\n the representation of the magnitude will not be the zero\n character.  The following ASCII characters are used as digits:\n\n \n   0123456789abcdefghijklmnopqrstuvwxyz\n \n\n These are '\\u0030' through\n '\\u0039' and '\\u0061' through\n '\\u007a'. If radix is\n N, then the first N of these characters\n are used as radix-N digits in the order shown. Thus,\n the digits for hexadecimal (radix 16) are\n 0123456789abcdef. If uppercase letters are\n desired, the String.toUpperCase() method may\n be called on the result:\n\n \n  Long.toString(n, 16).toUpperCase()"
                },
                {
                  "signature": "public static String toString(long i)",
                  "description": "Returns a String object representing the specified\n long.  The argument is converted to signed decimal\n representation and returned as a string, exactly as if the\n argument and the radix 10 were given as arguments to the toString(long, int) method."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Long's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the long value were given as an argument to the\n toString(long) method."
                }
              ]
            },
            {
              "name": "toUnsignedString",
              "overloads": [
                {
                  "signature": "public static String toUnsignedString(long i, int radix)",
                  "description": "Returns a string representation of the first argument as an\n unsigned integer value in the radix specified by the second\n argument.\n\n If the radix is smaller than Character.MIN_RADIX\n or larger than Character.MAX_RADIX, then the radix\n 10 is used instead.\n\n Note that since the first argument is treated as an unsigned\n value, no leading sign character is printed.\n\n If the magnitude is zero, it is represented by a single zero\n character '0' ('\\u0030'); otherwise,\n the first character of the representation of the magnitude will\n not be the zero character.\n\n The behavior of radixes and the characters used as digits\n are the same as toString."
                },
                {
                  "signature": "public static String toUnsignedString(long i)",
                  "description": "Returns a string representation of the argument as an unsigned\n decimal value.\n\n The argument is converted to unsigned decimal representation\n and returned as a string exactly as if the argument and radix\n 10 were given as arguments to the toUnsignedString(long, int) method."
                }
              ]
            },
            {
              "name": "toHexString",
              "overloads": [
                {
                  "signature": "public static String toHexString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base16.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in hexadecimal (base16) with no extra\n leading 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 16).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as hexadecimal digits:\n\n \n  0123456789abcdef\n \n\n These are the characters '\\u0030' through\n '\\u0039' and  '\\u0061' through\n '\\u0066'.  If uppercase letters are desired,\n the String.toUpperCase() method may be called\n on the result:\n\n \n  Long.toHexString(n).toUpperCase()"
                }
              ]
            },
            {
              "name": "toOctalString",
              "overloads": [
                {
                  "signature": "public static String toOctalString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base8.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in octal (base8) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 8).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n following characters are used as octal digits:\n\n \n  01234567\n \n\n These are the characters '\\u0030' through\n '\\u0037'."
                }
              ]
            },
            {
              "name": "toBinaryString",
              "overloads": [
                {
                  "signature": "public static String toBinaryString(long i)",
                  "description": "Returns a string representation of the long\n argument as an unsigned integer in base2.\n\n The unsigned long value is the argument plus\n 264 if the argument is negative; otherwise, it is\n equal to the argument.  This value is converted to a string of\n ASCII digits in binary (base2) with no extra leading\n 0s.\n\n The value of the argument can be recovered from the returned\n string s by calling Long.parseUnsignedLong(s,\n 2).\n\n If the unsigned magnitude is zero, it is represented by a\n single zero character '0' ('\\u0030');\n otherwise, the first character of the representation of the\n unsigned magnitude will not be the zero character. The\n characters '0' ('\\u0030') and \n '1' ('\\u0031') are used as binary digits."
                }
              ]
            },
            {
              "name": "parseLong",
              "overloads": [
                {
                  "signature": "public static long parseLong(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed long in the\n radix specified by the second argument. The characters in the\n string must all be digits of the specified radix (as determined\n by whether Character.digit(char, int) returns\n a nonnegative value), except that the first character may be an\n ASCII minus sign '-' ('\\u002D') to\n indicate a negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value. The\n resulting long value is returned.\n\n Note that neither the character L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the string as a type indicator, as would be permitted in\n Java programming language source code - except that either\n L or l may appear as a digit for a\n radix greater than or equal to 22.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n\n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a minus sign\n '-' ('\\u002d') or plus sign \n '+' ('\\u002B') provided that the string is\n longer than length 1.\n\n The value represented by the string is not a value of type\n      long.\n \n\n Examples:\n  parseLong(\"0\", 10) returns 0L\n parseLong(\"473\", 10) returns 473L\n parseLong(\"+42\", 10) returns 42L\n parseLong(\"-0\", 10) returns 0L\n parseLong(\"-FF\", 16) returns -255L\n parseLong(\"1100110\", 2) returns 102L\n parseLong(\"99\", 8) throws a NumberFormatException\n parseLong(\"Hazelnut\", 10) throws a NumberFormatException\n parseLong(\"Hazelnut\", 36) returns 1356099454469L"
                },
                {
                  "signature": "public static long parseLong(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as a signed long in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static long parseLong(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal long.\n The characters in the string must all be decimal digits, except\n that the first character may be an ASCII minus sign '-'\n (\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value. The resulting long value is\n returned, exactly as if the argument and the radix 10\n were given as arguments to the parseLong(java.lang.String, int) method.\n\n Note that neither the character L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the string as a type indicator, as would be permitted in\n Java programming language source code."
                }
              ]
            },
            {
              "name": "parseUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long parseUnsignedLong(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned long in the\n radix specified by the second argument.  An unsigned integer\n maps the values usually associated with negative numbers to\n positive numbers larger than MAX_VALUE.\n\n The characters in the string must all be digits of the\n specified radix (as determined by whether Character.digit(char, int) returns a nonnegative\n value), except that the first character may be an ASCII plus\n sign '+' ('\\u002B'). The resulting\n integer value is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n The first argument is null or is a string of\n length zero.\n\n The radix is either smaller than\n Character.MIN_RADIX or\n larger than Character.MAX_RADIX.\n\n Any character of the string is not a digit of the specified\n radix, except that the first character may be a plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n The value represented by the string is larger than the\n largest unsigned long, 264-1."
                },
                {
                  "signature": "public static long parseUnsignedLong(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException",
                  "description": "Parses the CharSequence argument as an unsigned long in\n the specified radix, beginning at the specified\n beginIndex and extending to endIndex - 1.\n\n The method does not take steps to guard against the\n CharSequence being mutated while parsing."
                },
                {
                  "signature": "public static long parseUnsignedLong(String s) throws NumberFormatException",
                  "description": "Parses the string argument as an unsigned decimal long. The\n characters in the string must all be decimal digits, except\n that the first character may be an ASCII plus sign \n '+' ('\\u002B'). The resulting integer value\n is returned, exactly as if the argument and the radix 10 were\n given as arguments to the parseUnsignedLong(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Long valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Long object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument.  The first\n argument is interpreted as representing a signed\n long in the radix specified by the second\n argument, exactly as if the arguments were given to the parseLong(java.lang.String, int) method. The result is a\n Long object that represents the long\n value specified by the string.\n\n In other words, this method returns a Long object equal\n to the value of:\n\n \n  new Long(Long.parseLong(s, radix))"
                },
                {
                  "signature": "public static Long valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Long object holding the value\n of the specified String. The argument is\n interpreted as representing a signed decimal long,\n exactly as if the argument were given to the parseLong(java.lang.String) method. The result is a\n Long object that represents the integer value\n specified by the string.\n\n In other words, this method returns a Long object\n equal to the value of:\n\n \n  new Long(Long.parseLong(s))"
                },
                {
                  "signature": "public static Long valueOf(long l)",
                  "description": "Returns a Long instance representing the specified\n long value.\n If a new Long instance is not required, this method\n should generally be used in preference to the constructor\n Long(long), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Long decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Long.\n Accepts decimal, hexadecimal, and octal numbers given by the\n following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Long.parseLong method with the indicated radix (10, 16, or 8).\n This sequence of characters must represent a positive value or\n a NumberFormatException will be thrown.  The result is\n negated if first character of the specified String is\n the minus sign.  No whitespace characters are permitted in the\n String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Long as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Long as a short after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Long as an int after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Long as a\n long value."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Long as a float after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Long as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Long. The result is\n the exclusive OR of the two halves of the primitive\n long value held by this Long\n object. That is, the hashcode is the value of the expression:\n\n \n  (int)(this.longValue()^(this.longValue()>>>32))"
                },
                {
                  "signature": "public static int hashCode(long value)",
                  "description": "Returns a hash code for a long value; compatible with\n Long.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Long object that\n contains the same long value as this object."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public static Long getLong(String nm)",
                  "description": "Determines the long value of the system property\n with the specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as a \n long value using the grammar supported by decode\n and a Long object representing this value is returned.\n\n If there is no property with the specified name, if the\n specified name is empty or null, or if the property\n does not have the correct numeric format, then null is\n returned.\n\n In other words, this method returns a Long object\n equal to the value of:\n\n \n  getLong(nm, null)"
                },
                {
                  "signature": "public static Long getLong(String nm, long val)",
                  "description": "Determines the long value of the system property\n with the specified name.\n\n The first argument is treated as the name of a system\n property.  System properties are accessible through the System.getProperty(java.lang.String) method. The\n string value of this property is then interpreted as a \n long value using the grammar supported by decode\n and a Long object representing this value is returned.\n\n The second argument is the default value. A Long object\n that represents the value of the second argument is returned if there\n is no property of the specified name, if the property does not have\n the correct numeric format, or if the specified name is empty or null.\n\n In other words, this method returns a Long object equal\n to the value of:\n\n \n  getLong(nm, new Long(val))\n \n\n but in practice it may be implemented in a manner such as:\n\n  Long result = getLong(nm, null);\n return (result == null) ? new Long(val) : result;\n \n\n to avoid the unnecessary allocation of a Long object when\n the default value is not needed."
                },
                {
                  "signature": "public static Long getLong(String nm, Long val)",
                  "description": "Returns the long value of the system property with\n the specified name.  The first argument is treated as the name\n of a system property.  System properties are accessible through\n the System.getProperty(java.lang.String)\n method. The string value of this property is then interpreted\n as a long value, as per the\n decode method, and a Long object\n representing this value is returned; in summary:\n\n \n If the property value begins with the two ASCII characters\n 0x or the ASCII character #, not followed by\n a minus sign, then the rest of it is parsed as a hexadecimal integer\n exactly as for the method valueOf(java.lang.String, int)\n with radix 16.\n If the property value begins with the ASCII character\n 0 followed by another character, it is parsed as\n an octal integer exactly as by the method valueOf(java.lang.String, int) with radix 8.\n Otherwise the property value is parsed as a decimal\n integer exactly as by the method\n valueOf(java.lang.String, int) with radix 10.\n \n\n Note that, in every case, neither L\n ('\\u004C') nor l\n ('\\u006C') is permitted to appear at the end\n of the property value as a type indicator, as would be\n permitted in Java programming language source code.\n\n The second argument is the default value. The default value is\n returned if there is no property of the specified name, if the\n property does not have the correct numeric format, or if the\n specified name is empty or null."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Long anotherLong)",
                  "description": "Compares two Long objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(long x, long y)",
                  "description": "Compares two long values numerically.\n The value returned is identical to what would be returned by:\n     Long.valueOf(x).compareTo(Long.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(long x, long y)",
                  "description": "Compares two long values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "divideUnsigned",
              "overloads": [
                {
                  "signature": "public static long divideUnsigned(long dividend, long divisor)",
                  "description": "Returns the unsigned quotient of dividing the first argument by\n the second where each argument and the result is interpreted as\n an unsigned value.\n\n Note that in two's complement arithmetic, the three other\n basic arithmetic operations of add, subtract, and multiply are\n bit-wise identical if the two operands are regarded as both\n being signed or both being unsigned.  Therefore separate \n addUnsigned, etc. methods are not provided."
                }
              ]
            },
            {
              "name": "remainderUnsigned",
              "overloads": [
                {
                  "signature": "public static long remainderUnsigned(long dividend, long divisor)",
                  "description": "Returns the unsigned remainder from dividing the first argument\n by the second where each argument and the result is interpreted\n as an unsigned value."
                }
              ]
            },
            {
              "name": "highestOneBit",
              "overloads": [
                {
                  "signature": "public static long highestOneBit(long i)",
                  "description": "Returns a long value with at most a single one-bit, in the\n position of the highest-order (\"leftmost\") one-bit in the specified\n long value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "lowestOneBit",
              "overloads": [
                {
                  "signature": "public static long lowestOneBit(long i)",
                  "description": "Returns a long value with at most a single one-bit, in the\n position of the lowest-order (\"rightmost\") one-bit in the specified\n long value.  Returns zero if the specified value has no\n one-bits in its two's complement binary representation, that is, if it\n is equal to zero."
                }
              ]
            },
            {
              "name": "numberOfLeadingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfLeadingZeros(long i)",
                  "description": "Returns the number of zero bits preceding the highest-order\n (\"leftmost\") one-bit in the two's complement binary representation\n of the specified long value.  Returns 64 if the\n specified value has no one-bits in its two's complement representation,\n in other words if it is equal to zero.\n\n Note that this method is closely related to the logarithm base 2.\n For all positive long values x:\n \n floor(log2(x)) = 63 - numberOfLeadingZeros(x)\n ceil(log2(x)) = 64 - numberOfLeadingZeros(x - 1)"
                }
              ]
            },
            {
              "name": "numberOfTrailingZeros",
              "overloads": [
                {
                  "signature": "public static int numberOfTrailingZeros(long i)",
                  "description": "Returns the number of zero bits following the lowest-order (\"rightmost\")\n one-bit in the two's complement binary representation of the specified\n long value.  Returns 64 if the specified value has no\n one-bits in its two's complement representation, in other words if it is\n equal to zero."
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public static int bitCount(long i)",
                  "description": "Returns the number of one-bits in the two's complement binary\n representation of the specified long value.  This function is\n sometimes referred to as the population count."
                }
              ]
            },
            {
              "name": "rotateLeft",
              "overloads": [
                {
                  "signature": "public static long rotateLeft(long i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified long value left by the\n specified number of bits.  (Bits shifted out of the left hand, or\n high-order, side reenter on the right, or low-order.)\n\n Note that left rotation with a negative distance is equivalent to\n right rotation: rotateLeft(val, -distance) == rotateRight(val,\n distance).  Note also that rotation by any multiple of 64 is a\n no-op, so all but the last six bits of the rotation distance can be\n ignored, even if the distance is negative: rotateLeft(val,\n distance) == rotateLeft(val, distance & 0x3F)."
                }
              ]
            },
            {
              "name": "rotateRight",
              "overloads": [
                {
                  "signature": "public static long rotateRight(long i, int distance)",
                  "description": "Returns the value obtained by rotating the two's complement binary\n representation of the specified long value right by the\n specified number of bits.  (Bits shifted out of the right hand, or\n low-order, side reenter on the left, or high-order.)\n\n Note that right rotation with a negative distance is equivalent to\n left rotation: rotateRight(val, -distance) == rotateLeft(val,\n distance).  Note also that rotation by any multiple of 64 is a\n no-op, so all but the last six bits of the rotation distance can be\n ignored, even if the distance is negative: rotateRight(val,\n distance) == rotateRight(val, distance & 0x3F)."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public static long reverse(long i)",
                  "description": "Returns the value obtained by reversing the order of the bits in the\n two's complement binary representation of the specified long\n value."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static int signum(long i)",
                  "description": "Returns the signum function of the specified long value.  (The\n return value is -1 if the specified value is negative; 0 if the\n specified value is zero; and 1 if the specified value is positive.)"
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static long reverseBytes(long i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified long value."
                }
              ]
            },
            {
              "name": "sum",
              "overloads": [
                {
                  "signature": "public static long sum(long a, long b)",
                  "description": "Adds two long values together as per the + operator."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values\n as if by calling Math.max."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values\n as if by calling Math.min."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<Long> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public Long resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "Math",
          "methods": [
            {
              "name": "sin",
              "overloads": [
                {
                  "signature": "public static double sin(double a)",
                  "description": "Returns the trigonometric sine of an angle.  Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "cos",
              "overloads": [
                {
                  "signature": "public static double cos(double a)",
                  "description": "Returns the trigonometric cosine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is 1.0.\n\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "tan",
              "overloads": [
                {
                  "signature": "public static double tan(double a)",
                  "description": "Returns the trigonometric tangent of an angle.  Special cases:\n If the argument is NaN or an infinity, then the result\n is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "asin",
              "overloads": [
                {
                  "signature": "public static double asin(double a)",
                  "description": "Returns the arc sine of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "acos",
              "overloads": [
                {
                  "signature": "public static double acos(double a)",
                  "description": "Returns the arc cosine of a value; the returned angle is in the\n range 0.0 through pi.  Special case:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is 1.0, the result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "atan",
              "overloads": [
                {
                  "signature": "public static double atan(double a)",
                  "description": "Returns the arc tangent of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n If the argument is infinite,\n then the result is the closest value to pi/2 with the\n same sign as the input.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "toRadians",
              "overloads": [
                {
                  "signature": "public static double toRadians(double angdeg)",
                  "description": "Converts an angle measured in degrees to an approximately\n equivalent angle measured in radians.  The conversion from\n degrees to radians is generally inexact."
                }
              ]
            },
            {
              "name": "toDegrees",
              "overloads": [
                {
                  "signature": "public static double toDegrees(double angrad)",
                  "description": "Converts an angle measured in radians to an approximately\n equivalent angle measured in degrees.  The conversion from\n radians to degrees is generally inexact; users should\n not expect cos(toRadians(90.0)) to exactly\n equal 0.0."
                }
              ]
            },
            {
              "name": "exp",
              "overloads": [
                {
                  "signature": "public static double exp(double a)",
                  "description": "Returns Euler's number e raised to the power of a\n double value.  Special cases:\n If the argument is NaN, the result is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is negative infinity, then the result is\n positive zero.\n If the argument is zero, then the result is 1.0.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "public static double log(double a)",
                  "description": "Returns the natural logarithm (base e) of a double\n value.  Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is 1.0, then the result is positive\n zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "log10",
              "overloads": [
                {
                  "signature": "public static double log10(double a)",
                  "description": "Returns the base 10 logarithm of a double value.\n Special cases:\n\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is equal to 10n for\n integer n, then the result is n. In particular,\n if the argument is 1.0 (100), then the\n result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public static double sqrt(double a)",
                  "description": "Returns the correctly rounded positive square root of a\n double value.\n Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is positive\n infinity.\n If the argument is positive zero or negative zero, then the\n result is the same as the argument.\n Otherwise, the result is the double value closest to\n the true mathematical square root of the argument value."
                }
              ]
            },
            {
              "name": "cbrt",
              "overloads": [
                {
                  "signature": "public static double cbrt(double a)",
                  "description": "Returns the cube root of a double value.  For\n positive finite x, cbrt(-x) ==\n -cbrt(x); that is, the cube root of a negative value is\n the negative of the cube root of that value's magnitude.\n\n Special cases:\n\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result."
                }
              ]
            },
            {
              "name": "IEEEremainder",
              "overloads": [
                {
                  "signature": "public static double IEEEremainder(double f1, double f2)",
                  "description": "Computes the remainder operation on two arguments as prescribed\n by the IEEE 754 standard.\n The remainder value is mathematically equal to\n f1-f2n,\n where n is the mathematical integer closest to the exact\n mathematical value of the quotient f1/f2, and if two\n mathematical integers are equally close to f1/f2,\n then n is the integer that is even. If the remainder is\n zero, its sign is the same as the sign of the first argument.\n Special cases:\n If either argument is NaN, or the first argument is infinite,\n or the second argument is positive zero or negative zero, then the\n result is NaN.\n If the first argument is finite and the second argument is\n infinite, then the result is the same as the first argument."
                }
              ]
            },
            {
              "name": "ceil",
              "overloads": [
                {
                  "signature": "public static double ceil(double a)",
                  "description": "Returns the smallest (closest to negative infinity)\n double value that is greater than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument.  If the argument value is less than zero but\n greater than -1.0, then the result is negative zero. Note\n that the value of Math.ceil(x) is exactly the\n value of -Math.floor(-x)."
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "public static double floor(double a)",
                  "description": "Returns the largest (closest to positive infinity)\n double value that is less than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument."
                }
              ]
            },
            {
              "name": "rint",
              "overloads": [
                {
                  "signature": "public static double rint(double a)",
                  "description": "Returns the double value that is closest in value\n to the argument and is equal to a mathematical integer. If two\n double values that are mathematical integers are\n equally close, the result is the integer value that is\n even. Special cases:\n If the argument value is already equal to a mathematical\n integer, then the result is the same as the argument.\n If the argument is NaN or an infinity or positive zero or negative\n zero, then the result is the same as the argument."
                }
              ]
            },
            {
              "name": "atan2",
              "overloads": [
                {
                  "signature": "public static double atan2(double y, double x)",
                  "description": "Returns the angle theta from the conversion of rectangular\n coordinates (x,y) to polar\n coordinates (r,theta).\n This method computes the phase theta by computing an arc tangent\n of y/x in the range of -pi to pi. Special\n cases:\n If either argument is NaN, then the result is NaN.\n If the first argument is positive zero and the second argument\n is positive, or the first argument is positive and finite and the\n second argument is positive infinity, then the result is positive\n zero.\n If the first argument is negative zero and the second argument\n is positive, or the first argument is negative and finite and the\n second argument is positive infinity, then the result is negative zero.\n If the first argument is positive zero and the second argument\n is negative, or the first argument is positive and finite and the\n second argument is negative infinity, then the result is the\n double value closest to pi.\n If the first argument is negative zero and the second argument\n is negative, or the first argument is negative and finite and the\n second argument is negative infinity, then the result is the\n double value closest to -pi.\n If the first argument is positive and the second argument is\n positive zero or negative zero, or the first argument is positive\n infinity and the second argument is finite, then the result is the\n double value closest to pi/2.\n If the first argument is negative and the second argument is\n positive zero or negative zero, or the first argument is negative\n infinity and the second argument is finite, then the result is the\n double value closest to -pi/2.\n If both arguments are positive infinity, then the result is the\n double value closest to pi/4.\n If the first argument is positive infinity and the second argument\n is negative infinity, then the result is the double\n value closest to 3*pi/4.\n If the first argument is negative infinity and the second argument\n is positive infinity, then the result is the double value\n closest to -pi/4.\n If both arguments are negative infinity, then the result is the\n double value closest to -3*pi/4.\n\n The computed result must be within 2 ulps of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public static double pow(double a, double b)",
                  "description": "Returns the value of the first argument raised to the power of the\n second argument. Special cases:\n\n If the second argument is positive or negative zero, then the\n result is 1.0.\n If the second argument is 1.0, then the result is the same as the\n first argument.\n If the second argument is NaN, then the result is NaN.\n If the first argument is NaN and the second argument is nonzero,\n then the result is NaN.\n\n If\n \n the absolute value of the first argument is greater than 1\n and the second argument is positive infinity, or\n the absolute value of the first argument is less than 1 and\n the second argument is negative infinity,\n \n then the result is positive infinity.\n\n If\n \n the absolute value of the first argument is greater than 1 and\n the second argument is negative infinity, or\n the absolute value of the\n first argument is less than 1 and the second argument is positive\n infinity,\n \n then the result is positive zero.\n\n If the absolute value of the first argument equals 1 and the\n second argument is infinite, then the result is NaN.\n\n If\n \n the first argument is positive zero and the second argument\n is greater than zero, or\n the first argument is positive infinity and the second\n argument is less than zero,\n \n then the result is positive zero.\n\n If\n \n the first argument is positive zero and the second argument\n is less than zero, or\n the first argument is positive infinity and the second\n argument is greater than zero,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is greater than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is less than zero but not a finite odd integer,\n \n then the result is positive zero.\n\n If\n \n the first argument is negative zero and the second argument\n is a positive finite odd integer, or\n the first argument is negative infinity and the second\n argument is a negative finite odd integer,\n \n then the result is negative zero.\n\n If\n \n the first argument is negative zero and the second argument\n is less than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is greater than zero but not a finite odd integer,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is a negative finite odd integer, or\n the first argument is negative infinity and the second\n argument is a positive finite odd integer,\n \n then the result is negative infinity.\n\n If the first argument is finite and less than zero\n \n  if the second argument is a finite even integer, the\n result is equal to the result of raising the absolute value of\n the first argument to the power of the second argument\n\n if the second argument is a finite odd integer, the result\n is equal to the negative of the result of raising the absolute\n value of the first argument to the power of the second\n argument\n\n if the second argument is finite and not an integer, then\n the result is NaN.\n \n\n If both arguments are integers, then the result is exactly equal\n to the mathematical result of raising the first argument to the power\n of the second argument if that result can in fact be represented\n exactly as a double value.\n\n (In the foregoing descriptions, a floating-point value is\n considered to be an integer if and only if it is finite and a\n fixed point of the method ceil or,\n equivalently, a fixed point of the method floor. A value is a fixed point of a one-argument\n method if and only if the result of applying the method to the\n value is equal to the value.)\n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public static int round(float a)",
                  "description": "Returns the closest int to the argument, with ties\n rounding to positive infinity.\n\n \n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Integer.MIN_VALUE, the result is\n equal to the value of Integer.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Integer.MAX_VALUE, the result is\n equal to the value of Integer.MAX_VALUE."
                },
                {
                  "signature": "public static long round(double a)",
                  "description": "Returns the closest long to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Long.MIN_VALUE, the result is\n equal to the value of Long.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Long.MAX_VALUE, the result is\n equal to the value of Long.MAX_VALUE."
                }
              ]
            },
            {
              "name": "random",
              "overloads": [
                {
                  "signature": "public static double random()",
                  "description": "Returns a double value with a positive sign, greater\n than or equal to 0.0 and less than 1.0.\n Returned values are chosen pseudorandomly with (approximately)\n uniform distribution from that range.\n\n When this method is first called, it creates a single new\n pseudorandom-number generator, exactly as if by the expression\n\n new java.util.Random()\n\n This new pseudorandom-number generator is used thereafter for\n all calls to this method and is used nowhere else.\n\n This method is properly synchronized to allow correct use by\n more than one thread. However, if many threads need to generate\n pseudorandom numbers at a great rate, it may reduce contention\n for each thread to have its own pseudorandom-number generator."
                }
              ]
            },
            {
              "name": "addExact",
              "overloads": [
                {
                  "signature": "public static int addExact(int x, int y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long addExact(long x, long y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "subtractExact",
              "overloads": [
                {
                  "signature": "public static int subtractExact(int x, int y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long subtractExact(long x, long y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "multiplyExact",
              "overloads": [
                {
                  "signature": "public static int multiplyExact(int x, int y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long multiplyExact(long x, int y)",
                  "description": "Returns the product of the arguments, throwing an exception if the result\n overflows a long."
                },
                {
                  "signature": "public static long multiplyExact(long x, long y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "incrementExact",
              "overloads": [
                {
                  "signature": "public static int incrementExact(int a)",
                  "description": "Returns the argument incremented by one, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the maximum value."
                },
                {
                  "signature": "public static long incrementExact(long a)",
                  "description": "Returns the argument incremented by one, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the maximum value."
                }
              ]
            },
            {
              "name": "decrementExact",
              "overloads": [
                {
                  "signature": "public static int decrementExact(int a)",
                  "description": "Returns the argument decremented by one, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long decrementExact(long a)",
                  "description": "Returns the argument decremented by one, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "negateExact",
              "overloads": [
                {
                  "signature": "public static int negateExact(int a)",
                  "description": "Returns the negation of the argument, throwing an exception if the\n result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long negateExact(long a)",
                  "description": "Returns the negation of the argument, throwing an exception if the\n result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "toIntExact",
              "overloads": [
                {
                  "signature": "public static int toIntExact(long value)",
                  "description": "Returns the value of the long argument,\n throwing an exception if the value overflows an int."
                }
              ]
            },
            {
              "name": "multiplyFull",
              "overloads": [
                {
                  "signature": "public static long multiplyFull(int x, int y)",
                  "description": "Returns the exact mathematical product of the arguments."
                }
              ]
            },
            {
              "name": "multiplyHigh",
              "overloads": [
                {
                  "signature": "public static long multiplyHigh(long x, long y)",
                  "description": "Returns as a long the most significant 64 bits of the 128-bit\n product of two 64-bit factors."
                }
              ]
            },
            {
              "name": "floorDiv",
              "overloads": [
                {
                  "signature": "public static int floorDiv(int x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n int value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Integer.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Integer.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n   If the signs of the arguments are the same, the results of\n       floorDiv and the / operator are the same.  \n       For example, floorDiv(4, 3) == 1 and (4 / 3) == 1.\n   If the signs of the arguments are different,  the quotient is negative and\n       floorDiv returns the integer less than or equal to the quotient\n       and the / operator returns the integer closest to zero.\n       For example, floorDiv(-4, 3) == -2,\n       whereas (-4 / 3) == -1."
                },
                {
                  "signature": "public static long floorDiv(long x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n For examples, see floorDiv(int, int)."
                },
                {
                  "signature": "public static long floorDiv(long x, long y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n Normal integer division operates under the round to zero rounding mode\n (truncation).  This operation instead acts under the round toward\n negative infinity (floor) rounding mode.\n The floor rounding mode gives different results from truncation\n when the exact result is negative.\n \n For examples, see floorDiv(int, int)."
                }
              ]
            },
            {
              "name": "floorMod",
              "overloads": [
                {
                  "signature": "public static int floorMod(int x, int y)",
                  "description": "Returns the floor modulus of the int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n The difference in values between floorMod and\n the % operator is due to the difference between\n floorDiv that returns the integer less than or equal to the quotient\n and the / operator that returns the integer closest to zero.\n \n Examples:\n \n   If the signs of the arguments are the same, the results\n       of floorMod and the % operator are the same.\n       \n       floorMod(+4, +3) == +1;  and (+4 % +3) == +1\n       floorMod(-4, -3) == -1;  and (-4 % -3) == -1\n       \n   If the signs of the arguments are different, the results\n       differ from the % operator.\n       \n       floorMod(+4, -3) == -2;  and (+4 % -3) == +1\n       floorMod(-4, +3) == +2;  and (-4 % +3) == -1\n       \n   \n \n \n If the signs of arguments are unknown and a positive modulus\n is needed it can be computed as (floorMod(x, y) + abs(y)) % abs(y)."
                },
                {
                  "signature": "public static int floorMod(long x, int y)",
                  "description": "Returns the floor modulus of the long and int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n For examples, see floorMod(int, int)."
                },
                {
                  "signature": "public static long floorMod(long x, long y)",
                  "description": "Returns the floor modulus of the long arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n For examples, see floorMod(int, int)."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public static int abs(int a)",
                  "description": "Returns the absolute value of an int value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int\n value, the result is that same value, which is negative. In\n contrast, the absExact(int) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static long abs(long a)",
                  "description": "Returns the absolute value of a long value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Long.MIN_VALUE, the most negative representable long\n value, the result is that same value, which is negative. In\n contrast, the absExact(long) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static float abs(float a)",
                  "description": "Returns the absolute value of a float value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the\n result is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                },
                {
                  "signature": "public static double abs(double a)",
                  "description": "Returns the absolute value of a double value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the result\n is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                }
              ]
            },
            {
              "name": "absExact",
              "overloads": [
                {
                  "signature": "public static int absExact(int a)",
                  "description": "Returns the mathematical absolute value of an int value\n if it is exactly representable as an int, throwing\n ArithmeticException if the result overflows the\n positive int range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Integer.MIN_VALUE\n overflows the positive int range, so an exception is\n thrown for that argument."
                },
                {
                  "signature": "public static long absExact(long a)",
                  "description": "Returns the mathematical absolute value of an long value\n if it is exactly representable as an long, throwing\n ArithmeticException if the result overflows the\n positive long range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Long.MIN_VALUE overflows\n the positive long range, so an exception is thrown for\n that argument."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values. That is, the\n result is the argument closer to the value of\n Integer.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values. That is, the\n result is the argument closer to the value of\n Long.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values.  That is,\n the result is the argument closer to positive infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                },
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values.  That\n is, the result is the argument closer to positive infinity. If\n the arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values. That is,\n the result the argument closer to the value of\n Integer.MIN_VALUE.  If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values. That is,\n the result is the argument closer to the value of\n Long.MIN_VALUE. If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values.  That is,\n the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero.  If\n one argument is positive zero and the other is negative zero,\n the result is negative zero."
                },
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values.  That\n is, the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other is negative zero, the\n result is negative zero."
                }
              ]
            },
            {
              "name": "fma",
              "overloads": [
                {
                  "signature": "public static double fma(double a, double b, double c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n double.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0) does not always return the\n same result as (a * b) since\n fma(-0.0, +0.0, +0.0) is +0.0 while\n (-0.0 * +0.0) is -0.0; fma(a, b, -0.0) is\n equivalent to (a * b) however."
                },
                {
                  "signature": "public static float fma(float a, float b, float c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n float.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0f, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0f) does not always return the\n same result as (a * b) since\n fma(-0.0f, +0.0f, +0.0f) is +0.0f while\n (-0.0f * +0.0f) is -0.0f; fma(a, b, -0.0f) is\n equivalent to (a * b) however."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public static double ulp(double d)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a double value is the positive\n distance between this floating-point value and the \n double value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Double.MIN_VALUE.\n  If the argument is Double.MAX_VALUE, then\n the result is equal to 2971."
                },
                {
                  "signature": "public static float ulp(float f)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a float value is the positive\n distance between this floating-point value and the \n float value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Float.MIN_VALUE.\n  If the argument is Float.MAX_VALUE, then\n the result is equal to 2104."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static double signum(double d)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0 if the argument is greater than zero, -1.0 if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                },
                {
                  "signature": "public static float signum(float f)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0f if the argument is greater than zero, -1.0f if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                }
              ]
            },
            {
              "name": "sinh",
              "overloads": [
                {
                  "signature": "public static double sinh(double x)",
                  "description": "Returns the hyperbolic sine of a double value.\n The hyperbolic sine of x is defined to be\n (ex-e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 2.5 ulps of the exact result."
                }
              ]
            },
            {
              "name": "cosh",
              "overloads": [
                {
                  "signature": "public static double cosh(double x)",
                  "description": "Returns the hyperbolic cosine of a double value.\n The hyperbolic cosine of x is defined to be\n (ex+e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is positive\n infinity.\n\n If the argument is zero, then the result is 1.0.\n\n \n\n The computed result must be within 2.5 ulps of the exact result."
                }
              ]
            },
            {
              "name": "tanh",
              "overloads": [
                {
                  "signature": "public static double tanh(double x)",
                  "description": "Returns the hyperbolic tangent of a double value.\n The hyperbolic tangent of x is defined to be\n (ex-e-x)/(ex+e-x),\n in other words, sinh(x)/cosh(x).  Note\n that the absolute value of the exact tanh is always less than\n 1.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n If the argument is positive infinity, then the result is\n +1.0.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n \n\n The computed result must be within 2.5 ulps of the exact result.\n The result of tanh for any finite input must have\n an absolute value less than or equal to 1.  Note that once the\n exact result of tanh is within 1/2 of an ulp of the limit value\n of 1, correctly signed 1.0 should\n be returned."
                }
              ]
            },
            {
              "name": "hypot",
              "overloads": [
                {
                  "signature": "public static double hypot(double x, double y)",
                  "description": "Returns sqrt(x2+y2)\n without intermediate overflow or underflow.\n\n Special cases:\n \n\n  If either argument is infinite, then the result\n is positive infinity.\n\n  If either argument is NaN and neither argument is infinite,\n then the result is NaN.\n\n  If both arguments are zero, the result is positive zero.\n \n\n The computed result must be within 1 ulp of the exact\n result.  If one parameter is held constant, the results must be\n semi-monotonic in the other parameter."
                }
              ]
            },
            {
              "name": "expm1",
              "overloads": [
                {
                  "signature": "public static double expm1(double x)",
                  "description": "Returns ex-1.  Note that for values of\n x near 0, the exact sum of\n expm1(x)+1 is much closer to the true\n result of ex than exp(x).\n\n Special cases:\n \n If the argument is NaN, the result is NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic.  The result of\n expm1 for any finite input must be greater than or\n equal to -1.0.  Note that once the exact result of\n ex-1 is within 1/2\n ulp of the limit value -1, -1.0 should be\n returned."
                }
              ]
            },
            {
              "name": "log1p",
              "overloads": [
                {
                  "signature": "public static double log1p(double x)",
                  "description": "Returns the natural logarithm of the sum of the argument and 1.\n Note that for small values x, the result of\n log1p(x) is much closer to the true result of ln(1\n + x) than the floating-point evaluation of\n log(1.0+x).\n\n Special cases:\n\n \n\n If the argument is NaN or less than -1, then the result is\n NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative one, then the result is\n negative infinity.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n \n\n The computed result must be within 1 ulp of the exact result.\n Results must be semi-monotonic."
                }
              ]
            },
            {
              "name": "copySign",
              "overloads": [
                {
                  "signature": "public static double copySign(double magnitude, double sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  Note that unlike the StrictMath.copySign\n method, this method does not require NaN sign\n arguments to be treated as positive values; implementations are\n permitted to treat some NaN arguments as positive and other NaN\n arguments as negative to allow greater performance."
                },
                {
                  "signature": "public static float copySign(float magnitude, float sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  Note that unlike the StrictMath.copySign\n method, this method does not require NaN sign\n arguments to be treated as positive values; implementations are\n permitted to treat some NaN arguments as positive and other NaN\n arguments as negative to allow greater performance."
                }
              ]
            },
            {
              "name": "getExponent",
              "overloads": [
                {
                  "signature": "public static int getExponent(float f)",
                  "description": "Returns the unbiased exponent used in the representation of a\n float.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Float.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Float.MIN_EXPONENT -1."
                },
                {
                  "signature": "public static int getExponent(double d)",
                  "description": "Returns the unbiased exponent used in the representation of a\n double.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Double.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Double.MIN_EXPONENT -1."
                }
              ]
            },
            {
              "name": "nextAfter",
              "overloads": [
                {
                  "signature": "public static double nextAfter(double start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal the second argument is returned.\n\n \n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, direction\n is returned unchanged (as implied by the requirement of\n returning the second argument if the arguments compare as\n equal).\n\n  If start is\n Double.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Double.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Double.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                },
                {
                  "signature": "public static float nextAfter(float start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal a value equivalent to the second argument\n is returned.\n\n \n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, a value equivalent\n to direction is returned.\n\n  If start is\n Float.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Float.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Float.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                }
              ]
            },
            {
              "name": "nextUp",
              "overloads": [
                {
                  "signature": "public static double nextUp(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextUp(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "nextDown",
              "overloads": [
                {
                  "signature": "public static double nextDown(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextDown(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "scalb",
              "overloads": [
                {
                  "signature": "public static double scalb(double d, int scaleFactor)",
                  "description": "Returns d  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Double.MIN_EXPONENT and Double.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Double.MAX_EXPONENT, an infinity is returned.  Note that if\n the result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as d.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                },
                {
                  "signature": "public static float scalb(float f, int scaleFactor)",
                  "description": "Returns f  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Float.MIN_EXPONENT and Float.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Float.MAX_EXPONENT, an infinity is returned.  Note that if the\n result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as f.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Module",
          "methods": [
            {
              "name": "isNamed",
              "overloads": [
                {
                  "signature": "public boolean isNamed()",
                  "description": "Returns true if this module is a named module."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the module name or null if this module is an unnamed\n module."
                }
              ]
            },
            {
              "name": "getClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getClassLoader()",
                  "description": "Returns the ClassLoader for this module.\n\n  If there is a security manager then its checkPermission\n method if first called with a RuntimePermission(\"getClassLoader\")\n permission to check that the caller is allowed to get access to the\n class loader."
                }
              ]
            },
            {
              "name": "getDescriptor",
              "overloads": [
                {
                  "signature": "public ModuleDescriptor getDescriptor()",
                  "description": "Returns the module descriptor for this module or null if this\n module is an unnamed module."
                }
              ]
            },
            {
              "name": "getLayer",
              "overloads": [
                {
                  "signature": "public ModuleLayer getLayer()",
                  "description": "Returns the module layer that contains this module or null if\n this module is not in a module layer.\n\n A module layer contains named modules and therefore this method always\n returns null when invoked on an unnamed module.\n\n  Dynamic modules are\n named modules that are generated at runtime. A dynamic module may or may\n not be in a module layer."
                }
              ]
            },
            {
              "name": "canRead",
              "overloads": [
                {
                  "signature": "public boolean canRead(Module other)",
                  "description": "Indicates if this module reads the given module. This method returns\n true if invoked to test if this module reads itself. It also\n returns true if invoked on an unnamed module (as unnamed\n modules read all modules)."
                }
              ]
            },
            {
              "name": "addReads",
              "overloads": [
                {
                  "signature": "public Module addReads(Module other)",
                  "description": "If the caller's module is this module then update this module to read\n the given module.\n\n This method is a no-op if other is this module (all modules read\n themselves), this module is an unnamed module (as unnamed modules read\n all modules), or this module already reads other."
                }
              ]
            },
            {
              "name": "isExported",
              "overloads": [
                {
                  "signature": "public boolean isExported(String pn, Module other)",
                  "description": "Returns true if this module exports the given package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is exported to itself. It always returns true when\n invoked on an unnamed module. A package that is open to\n the given module is considered exported to that module at run-time and\n so this method returns true if the package is open to the given\n module. \n\n  This method does not check if the given module reads this module."
                },
                {
                  "signature": "public boolean isExported(String pn)",
                  "description": "Returns true if this module exports the given package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. A package that is opened unconditionally\n is considered exported unconditionally at run-time and so this method\n returns true if the package is opened unconditionally. \n\n  This method does not check if the given module reads this module."
                }
              ]
            },
            {
              "name": "isOpen",
              "overloads": [
                {
                  "signature": "public boolean isOpen(String pn, Module other)",
                  "description": "Returns true if this module has opened a package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is open to itself. It returns true when invoked on an\n open module with a package in the module.\n It always returns true when invoked on an unnamed module. \n\n  This method does not check if the given module reads this module."
                },
                {
                  "signature": "public boolean isOpen(String pn)",
                  "description": "Returns true if this module has opened a package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. Additionally, it always returns true when invoked on an\n open module with a package in the\n module. \n\n  This method does not check if the given module reads this module."
                }
              ]
            },
            {
              "name": "addExports",
              "overloads": [
                {
                  "signature": "public Module addExports(String pn, Module other)",
                  "description": "If the caller's module is this module then update this module to export\n the given package to the given module.\n\n  This method has no effect if the package is already exported (or\n open) to the given module."
                }
              ]
            },
            {
              "name": "addOpens",
              "overloads": [
                {
                  "signature": "public Module addOpens(String pn, Module other)",
                  "description": "If this module has opened a package to at least the caller\n module then update this module to open the package to the given module.\n Opening a package with this method allows all types in the package,\n and all their members, not just public types and their public members,\n to be reflected on by the given module when using APIs that support\n private access or a way to bypass or suppress default Java language\n access control checks.\n\n  This method has no effect if the package is already open\n to the given module."
                }
              ]
            },
            {
              "name": "addUses",
              "overloads": [
                {
                  "signature": "public Module addUses(Class<?> service)",
                  "description": "If the caller's module is this module then update this module to add a\n service dependence on the given service type. This method is intended\n for use by frameworks that invoke ServiceLoader on behalf of other modules or where the framework is\n passed a reference to the service type by other code. This method is\n a no-op when invoked on an unnamed module or an automatic module.\n\n  This method does not cause resolveAndBind to be re-run."
                }
              ]
            },
            {
              "name": "canUse",
              "overloads": [
                {
                  "signature": "public boolean canUse(Class<?> service)",
                  "description": "Indicates if this module has a service dependence on the given service\n type. This method always returns true when invoked on an unnamed\n module or an automatic module."
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "public Set<String> getPackages()",
                  "description": "Returns the set of package names for the packages in this module.\n\n  For named modules, the returned set contains an element for each\n package in the module. \n\n  For unnamed modules, the returned set contains an element for\n each package that has been defined\n in the unnamed module."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <T extends Annotation> T getAnnotation(Class<T> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n This method returns null when invoked on an unnamed module.\n\n  Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module.\n\n  Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module.\n\n  Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name) throws IOException",
                  "description": "Returns an input stream for reading a resource in this module.\n The name parameter is a '/'-separated path name that\n identifies the resource. As with Class.getResourceAsStream, this method delegates to the module's class\n loader findResource(String,String) method, invoking it with the module name\n (or null when the module is unnamed) and the name of the\n resource. If the resource name has a leading slash then it is dropped\n before delegation.\n\n  A resource in a named module may be encapsulated so that\n it cannot be located by code in other modules. Whether a resource can be\n located or not is determined as follows: \n\n \n      If the resource name ends with  \".class\" then it is not\n     encapsulated. \n\n      A package name is derived from the resource name. If\n     the package name is a package in the\n     module then the resource can only be located by the caller of this\n     method when the package is open\n     to at least the caller's module. If the resource is not in a\n     package in the module then the resource is not encapsulated. \n \n\n  In the above, the package name for a resource is derived\n from the subsequence of characters that precedes the last '/' in\n the name and then replacing each '/' character in the subsequence\n with '.'. A leading slash is ignored when deriving the package\n name. As an example, the package name derived for a resource named\n \"a/b/c/foo.properties\" is \"a.b.c\". A resource name\n with the name \"META-INF/MANIFEST.MF\" is never encapsulated\n because \"META-INF\" is not a legal package name. \n\n  This method returns null if the resource is not in this\n module, the resource is encapsulated and cannot be located by the caller,\n or access to the resource is denied by the security manager."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this module. For a named module,\n the representation is the string \"module\", followed by a space,\n and then the module name. For an unnamed module, the representation is\n the string \"unnamed module\", followed by a space, and then an\n implementation specific string that identifies the unnamed module."
                }
              ]
            }
          ]
        },
        {
          "name": "ModuleLayer",
          "methods": [
            {
              "name": "defineModulesWithOneLoader",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModulesWithOneLoader(Configuration cf, ClassLoader parentLoader)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n This method creates one class loader and defines all modules to that\n class loader. The parent of each class\n loader is the given parent class loader. This method works exactly as\n specified by the static defineModulesWithOneLoader method when invoked with this layer as the\n parent. In other words, if this layer is thisLayer then this\n method is equivalent to invoking:\n  \n     ModuleLayer.defineModulesWithOneLoader(cf, List.of(thisLayer), parentLoader).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModulesWithOneLoader(Configuration cf, List<ModuleLayer> parentLayers, ClassLoader parentLoader)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. This method creates one\n class loader and defines all modules to that class loader.\n\n  The class loader created by this method implements direct\n delegation when loading classes from modules. If the loadClass method is invoked to\n load a class then it uses the package name of the class to map it to a\n module. This may be a module in this layer and hence defined to the same\n class loader. It may be a package in a module in a parent layer that is\n exported to one or more of the modules in this layer. The class\n loader delegates to the class loader of the module, throwing \n ClassNotFoundException if not found by that class loader.\n When loadClass is invoked to load classes that do not map to a\n module then it delegates to the parent class loader. \n\n  The class loader created by this method locates resources\n (getResource, getResources, and other resource\n methods) in all modules in the layer before searching the parent class\n loader. \n\n  Attempting to create a layer with all modules defined to the same\n class loader can fail for the following reasons:\n\n \n\n      Overlapping packages: Two or more modules in the\n     configuration have the same package. \n\n      Split delegation: The resulting class loader would\n     need to delegate to more than one class loader in order to load\n     classes in a specific package. \n\n \n\n  In addition, a layer cannot be created if the configuration contains\n a module named \"java.base\", or a module contains a package named\n \"java\" or a package with a name starting with \"java.\". \n\n  If there is a security manager then the class loader created by\n this method will load classes and resources with privileges that are\n restricted by the calling context of this method."
                }
              ]
            },
            {
              "name": "defineModulesWithManyLoaders",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModulesWithManyLoaders(Configuration cf, ClassLoader parentLoader)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n Each module is defined to its own ClassLoader created by this\n method. The parent of each class loader\n is the given parent class loader. This method works exactly as specified\n by the static defineModulesWithManyLoaders method when invoked with this layer as the\n parent. In other words, if this layer is thisLayer then this\n method is equivalent to invoking:\n  \n     ModuleLayer.defineModulesWithManyLoaders(cf, List.of(thisLayer), parentLoader).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModulesWithManyLoaders(Configuration cf, List<ModuleLayer> parentLayers, ClassLoader parentLoader)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. Each module is defined to\n its own ClassLoader created by this method. The parent of each class loader is the given parent\n class loader.\n\n  The class loaders created by this method implement direct\n delegation when loading classes from modules. If the loadClass method is invoked to\n load a class then it uses the package name of the class to map it to a\n module. The package may be in the module defined to the class loader.\n The package may be exported by another module in this layer to the\n module defined to the class loader. It may be in a package exported by a\n module in a parent layer. The class loader delegates to the class loader\n of the module, throwing ClassNotFoundException if not found by\n that class loader. When loadClass is invoked to load a class\n that does not map to a module then it delegates to the parent class\n loader. \n\n  The class loaders created by this method locate resources\n (getResource, getResources, and other resource\n methods) in the module defined to the class loader before searching\n the parent class loader. \n\n  If there is a security manager then the class loaders created by\n this method will load classes and resources with privileges that are\n restricted by the calling context of this method."
                }
              ]
            },
            {
              "name": "defineModules",
              "overloads": [
                {
                  "signature": "public ModuleLayer defineModules(Configuration cf, Function<String,ClassLoader> clf)",
                  "description": "Creates a new module layer, with this layer as its parent, by defining the\n modules in the given Configuration to the Java virtual machine.\n Each module is mapped, by name, to its class loader by means of the\n given function. This method works exactly as specified by the static\n defineModules\n method when invoked with this layer as the parent. In other words, if\n this layer is thisLayer then this method is equivalent to\n invoking:\n  \n     ModuleLayer.defineModules(cf, List.of(thisLayer), clf).layer();"
                },
                {
                  "signature": "public static ModuleLayer.Controller defineModules(Configuration cf, List<ModuleLayer> parentLayers, Function<String,ClassLoader> clf)",
                  "description": "Creates a new module layer by defining the modules in the given \n Configuration to the Java virtual machine. The given function maps each\n module in the configuration, by name, to a class loader. Creating the\n layer informs the Java virtual machine about the classes that may be\n loaded so that the Java virtual machine knows which module that each\n class is a member of.\n\n  The class loader delegation implemented by the class loaders must\n respect module readability. The class loaders should be\n parallel-capable so as to\n avoid deadlocks during class loading. In addition, the entity creating\n a new layer with this method should arrange that the class loaders be\n ready to load from these modules before there are any attempts to load\n classes or resources. \n\n  Creating a layer can fail for the following reasons: \n\n \n\n      Two or more modules with the same package are mapped to the\n     same class loader. \n\n      A module is mapped to a class loader that already has a\n     module of the same name defined to it. \n\n      A module is mapped to a class loader that has already\n     defined types in any of the packages in the module. \n\n \n\n  In addition, a layer cannot be created if the configuration contains\n a module named \"java.base\", a configuration contains a module\n with a package named \"java\" or a package name starting with\n \"java.\", or the function to map a module name to a class loader\n returns null or the platform class loader. \n\n  If the function to map a module name to class loader throws an error\n or runtime exception then it is propagated to the caller of this method."
                }
              ]
            },
            {
              "name": "configuration",
              "overloads": [
                {
                  "signature": "public Configuration configuration()",
                  "description": "Returns the configuration for this layer."
                }
              ]
            },
            {
              "name": "parents",
              "overloads": [
                {
                  "signature": "public List<ModuleLayer> parents()",
                  "description": "Returns an unmodifiable list of this layer's parents, in search\n order. If this is the empty layer then an\n empty list is returned."
                }
              ]
            },
            {
              "name": "modules",
              "overloads": [
                {
                  "signature": "public Set<Module> modules()",
                  "description": "Returns an unmodifiable set of the modules in this layer."
                }
              ]
            },
            {
              "name": "findModule",
              "overloads": [
                {
                  "signature": "public Optional<Module> findModule(String name)",
                  "description": "Returns the module with the given name in this layer, or if not in this\n layer, the parent layers. Finding a module in\n parent layers is equivalent to invoking findModule on each\n parent, in search order, until the module is found or all parents have\n been searched. In a tree of layers  then this is equivalent to\n a depth-first search."
                }
              ]
            },
            {
              "name": "findLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader findLoader(String name)",
                  "description": "Returns the ClassLoader for the module with the given name. If\n a module of the given name is not in this layer then the parent layers are searched in the manner specified by findModule.\n\n  If there is a security manager then its checkPermission\n method is called with a RuntimePermission(\"getClassLoader\")\n permission to check that the caller is allowed to get access to the\n class loader."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this module layer."
                }
              ]
            },
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static ModuleLayer empty()",
                  "description": "Returns the empty layer. There are no modules in the empty\n layer. It has no parents."
                }
              ]
            },
            {
              "name": "boot",
              "overloads": [
                {
                  "signature": "public static ModuleLayer boot()",
                  "description": "Returns the boot layer. The boot layer contains at least one module,\n java.base. Its parent is the empty layer."
                }
              ]
            }
          ]
        },
        {
          "name": "ModuleLayer.Controller",
          "methods": [
            {
              "name": "layer",
              "overloads": [
                {
                  "signature": "public ModuleLayer layer()",
                  "description": "Returns the layer that this object controls."
                }
              ]
            },
            {
              "name": "addReads",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addReads(Module source, Module target)",
                  "description": "Updates module source in the layer to read module\n target. This method is a no-op if source already\n reads target."
                }
              ]
            },
            {
              "name": "addExports",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addExports(Module source, String pn, Module target)",
                  "description": "Updates module source in the layer to export a package to\n module target. This method is a no-op if source\n already exports the package to at least target."
                }
              ]
            },
            {
              "name": "addOpens",
              "overloads": [
                {
                  "signature": "public ModuleLayer.Controller addOpens(Module source, String pn, Module target)",
                  "description": "Updates module source in the layer to open a package to\n module target. This method is a no-op if source\n already opens the package to at least target."
                }
              ]
            }
          ]
        },
        {
          "name": "NegativeArraySizeException",
          "methods": [
            {
              "name": "NegativeArraySizeException",
              "overloads": [
                {
                  "signature": "public NegativeArraySizeException()",
                  "description": "Constructs a NegativeArraySizeException with no\n detail message."
                },
                {
                  "signature": "public NegativeArraySizeException(String s)",
                  "description": "Constructs a NegativeArraySizeException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoClassDefFoundError",
          "methods": [
            {
              "name": "NoClassDefFoundError",
              "overloads": [
                {
                  "signature": "public NoClassDefFoundError()",
                  "description": "Constructs a NoClassDefFoundError with no detail message."
                },
                {
                  "signature": "public NoClassDefFoundError(String s)",
                  "description": "Constructs a NoClassDefFoundError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchFieldError",
          "methods": [
            {
              "name": "NoSuchFieldError",
              "overloads": [
                {
                  "signature": "public NoSuchFieldError()",
                  "description": "Constructs a NoSuchFieldError with no detail message."
                },
                {
                  "signature": "public NoSuchFieldError(String s)",
                  "description": "Constructs a NoSuchFieldError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchFieldException",
          "methods": [
            {
              "name": "NoSuchFieldException",
              "overloads": [
                {
                  "signature": "public NoSuchFieldException()",
                  "description": "Constructor."
                },
                {
                  "signature": "public NoSuchFieldException(String s)",
                  "description": "Constructor with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchMethodError",
          "methods": [
            {
              "name": "NoSuchMethodError",
              "overloads": [
                {
                  "signature": "public NoSuchMethodError()",
                  "description": "Constructs a NoSuchMethodError with no detail message."
                },
                {
                  "signature": "public NoSuchMethodError(String s)",
                  "description": "Constructs a NoSuchMethodError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchMethodException",
          "methods": [
            {
              "name": "NoSuchMethodException",
              "overloads": [
                {
                  "signature": "public NoSuchMethodException()",
                  "description": "Constructs a NoSuchMethodException without a detail message."
                },
                {
                  "signature": "public NoSuchMethodException(String s)",
                  "description": "Constructs a NoSuchMethodException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "NullPointerException",
          "methods": [
            {
              "name": "NullPointerException",
              "overloads": [
                {
                  "signature": "public NullPointerException()",
                  "description": "Constructs a NullPointerException with no detail message."
                },
                {
                  "signature": "public NullPointerException(String s)",
                  "description": "Constructs a NullPointerException with the specified\n detail message."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns the detail message string of this throwable.\n\n  If a non-null message was supplied in a constructor it is\n returned. Otherwise, an implementation specific message or\n null is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Number",
          "methods": [
            {
              "name": "Number",
              "overloads": [
                {
                  "signature": "public Number()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public abstract int intValue()",
                  "description": "Returns the value of the specified number as an int."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public abstract long longValue()",
                  "description": "Returns the value of the specified number as a long."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public abstract float floatValue()",
                  "description": "Returns the value of the specified number as a float."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public abstract double doubleValue()",
                  "description": "Returns the value of the specified number as a double."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of the specified number as a byte."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of the specified number as a short."
                }
              ]
            }
          ]
        },
        {
          "name": "NumberFormatException",
          "methods": [
            {
              "name": "NumberFormatException",
              "overloads": [
                {
                  "signature": "public NumberFormatException()",
                  "description": "Constructs a NumberFormatException with no detail message."
                },
                {
                  "signature": "public NumberFormatException(String s)",
                  "description": "Constructs a NumberFormatException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Object",
          "methods": [
            {
              "name": "Object",
              "overloads": [
                {
                  "signature": "public Object()",
                  "description": "Constructs a new object."
                }
              ]
            },
            {
              "name": "getClass",
              "overloads": [
                {
                  "signature": "public final Class<?> getClass()",
                  "description": "Returns the runtime class of this Object. The returned\n Class object is the object that is locked by \n static synchronized methods of the represented class.\n\n The actual result type is Class<? extends |X|>\n where |X| is the erasure of the static type of the\n expression on which getClass is called. For\n example, no cast is required in this code fragment:\n\n \n Number n = 0;                             \n Class<? extends Number> c = n.getClass();"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for the object. This method is\n supported for the benefit of hash tables such as those provided by\n HashMap.\n \n The general contract of hashCode is:\n \n Whenever it is invoked on the same object more than once during\n     an execution of a Java application, the hashCode method\n     must consistently return the same integer, provided no information\n     used in equals comparisons on the object is modified.\n     This integer need not remain consistent from one execution of an\n     application to another execution of the same application.\n If two objects are equal according to the equals method, then calling the \n     hashCode method on each of the two objects must produce the\n     same integer result.\n It is not required that if two objects are unequal\n     according to the equals method, then\n     calling the hashCode method on each of the two objects\n     must produce distinct integer results.  However, the programmer\n     should be aware that producing distinct integer results for\n     unequal objects may improve the performance of hash tables."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this one.\n \n The equals method implements an equivalence relation\n on non-null object references:\n \n It is reflexive: for any non-null reference value\n     x, x.equals(x) should return\n     true.\n It is symmetric: for any non-null reference values\n     x and y, x.equals(y)\n     should return true if and only if\n     y.equals(x) returns true.\n It is transitive: for any non-null reference values\n     x, y, and z, if\n     x.equals(y) returns true and\n     y.equals(z) returns true, then\n     x.equals(z) should return true.\n It is consistent: for any non-null reference values\n     x and y, multiple invocations of\n     x.equals(y) consistently return true\n     or consistently return false, provided no\n     information used in equals comparisons on the\n     objects is modified.\n For any non-null reference value x,\n     x.equals(null) should return false.\n \n\n \n An equivalence relation partitions the elements it operates on\n into equivalence classes; all the members of an\n equivalence class are equal to each other. Members of an\n equivalence class are substitutable for each other, at least\n for some purposes."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected Object clone() throws CloneNotSupportedException",
                  "description": "Creates and returns a copy of this object.  The precise meaning\n of \"copy\" may depend on the class of the object. The general\n intent is that, for any object x, the expression:\n \n  x.clone() != x\n will be true, and that the expression:\n \n  x.clone().getClass() == x.getClass()\n will be true, but these are not absolute requirements.\n While it is typically the case that:\n \n  x.clone().equals(x)\n will be true, this is not an absolute requirement.\n \n By convention, the returned object should be obtained by calling\n super.clone.  If a class and all of its superclasses (except\n Object) obey this convention, it will be the case that\n x.clone().getClass() == x.getClass().\n \n By convention, the object returned by this method should be independent\n of this object (which is being cloned).  To achieve this independence,\n it may be necessary to modify one or more fields of the object returned\n by super.clone before returning it.  Typically, this means\n copying any mutable objects that comprise the internal \"deep structure\"\n of the object being cloned and replacing the references to these\n objects with references to the copies.  If a class contains only\n primitive fields or references to immutable objects, then it is usually\n the case that no fields in the object returned by super.clone\n need to be modified."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of the object."
                }
              ]
            },
            {
              "name": "notify",
              "overloads": [
                {
                  "signature": "public final void notify()",
                  "description": "Wakes up a single thread that is waiting on this object's\n monitor. If any threads are waiting on this object, one of them\n is chosen to be awakened. The choice is arbitrary and occurs at\n the discretion of the implementation. A thread waits on an object's\n monitor by calling one of the wait methods.\n \n The awakened thread will not be able to proceed until the current\n thread relinquishes the lock on this object. The awakened thread will\n compete in the usual manner with any other threads that might be\n actively competing to synchronize on this object; for example, the\n awakened thread enjoys no reliable privilege or disadvantage in being\n the next thread to lock this object.\n \n This method should only be called by a thread that is the owner\n of this object's monitor. A thread becomes the owner of the\n object's monitor in one of three ways:\n \n By executing a synchronized instance method of that object.\n By executing the body of a synchronized statement\n     that synchronizes on the object.\n For objects of type Class, by executing a\n     synchronized static method of that class.\n \n \n Only one thread at a time can own an object's monitor."
                }
              ]
            },
            {
              "name": "notifyAll",
              "overloads": [
                {
                  "signature": "public final void notifyAll()",
                  "description": "Wakes up all threads that are waiting on this object's monitor. A\n thread waits on an object's monitor by calling one of the\n wait methods.\n \n The awakened threads will not be able to proceed until the current\n thread relinquishes the lock on this object. The awakened threads\n will compete in the usual manner with any other threads that might\n be actively competing to synchronize on this object; for example,\n the awakened threads enjoy no reliable privilege or disadvantage in\n being the next thread to lock this object.\n \n This method should only be called by a thread that is the owner\n of this object's monitor. See the notify method for a\n description of the ways in which a thread can become the owner of\n a monitor."
                }
              ]
            },
            {
              "name": "wait",
              "overloads": [
                {
                  "signature": "public final void wait() throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted.\n \n In all respects, this method behaves as if wait(0L, 0)\n had been called. See the specification of the wait(long, int) method\n for details."
                },
                {
                  "signature": "public final void wait(long timeoutMillis) throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted, or until a\n certain amount of real time has elapsed.\n \n In all respects, this method behaves as if wait(timeoutMillis, 0)\n had been called. See the specification of the wait(long, int) method\n for details."
                },
                {
                  "signature": "public final void wait(long timeoutMillis, int nanos) throws InterruptedException",
                  "description": "Causes the current thread to wait until it is awakened, typically\n by being notified or interrupted, or until a\n certain amount of real time has elapsed.\n \n The current thread must own this object's monitor lock. See the\n notify method for a description of the ways in which\n a thread can become the owner of a monitor lock.\n \n This method causes the current thread (referred to here as T) to\n place itself in the wait set for this object and then to relinquish any\n and all synchronization claims on this object. Note that only the locks\n on this object are relinquished; any other objects on which the current\n thread may be synchronized remain locked while the thread waits.\n \n Thread T then becomes disabled for thread scheduling purposes\n and lies dormant until one of the following occurs:\n \n Some other thread invokes the notify method for this\n object and thread T happens to be arbitrarily chosen as\n the thread to be awakened.\n Some other thread invokes the notifyAll method for this\n object.\n Some other thread interrupts\n thread T.\n The specified amount of real time has elapsed, more or less.\n The amount of real time, in nanoseconds, is given by the expression\n 1000000 * timeoutMillis + nanos. If timeoutMillis and nanos\n are both zero, then real time is not taken into consideration and the\n thread waits until awakened by one of the other causes.\n Thread T is awakened spuriously. (See below.)\n \n \n The thread T is then removed from the wait set for this\n object and re-enabled for thread scheduling. It competes in the\n usual manner with other threads for the right to synchronize on the\n object; once it has regained control of the object, all its\n synchronization claims on the object are restored to the status quo\n ante - that is, to the situation as of the time that the wait\n method was invoked. Thread T then returns from the\n invocation of the wait method. Thus, on return from the\n wait method, the synchronization state of the object and of\n thread T is exactly as it was when the wait method\n was invoked.\n \n A thread can wake up without being notified, interrupted, or timing out, a\n so-called spurious wakeup.  While this will rarely occur in practice,\n applications must guard against it by testing for the condition that should\n have caused the thread to be awakened, and continuing to wait if the condition\n is not satisfied. See the example below.\n \n For more information on this topic, see section 14.2,\n \"Condition Queues,\" in Brian Goetz and others' Java Concurrency\n in Practice (Addison-Wesley, 2006) or Item 69 in Joshua\n Bloch's Effective Java, Second Edition (Addison-Wesley,\n 2008).\n \n If the current thread is interrupted\n by any thread before or while it is waiting, then an InterruptedException\n is thrown.  The interrupted status of the current thread is cleared when\n this exception is thrown. This exception is not thrown until the lock status of\n this object has been restored as described above."
                }
              ]
            },
            {
              "name": "finalize",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected void finalize() throws Throwable",
                  "description": "Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.\n A subclass overrides the finalize method to dispose of\n system resources or to perform other cleanup.\n \n The general contract of finalize is that it is invoked\n if and when the Java virtual\n machine has determined that there is no longer any\n means by which this object can be accessed by any thread that has\n not yet died, except as a result of an action taken by the\n finalization of some other object or class which is ready to be\n finalized. The finalize method may take any action, including\n making this object available again to other threads; the usual purpose\n of finalize, however, is to perform cleanup actions before\n the object is irrevocably discarded. For example, the finalize method\n for an object that represents an input/output connection might perform\n explicit I/O transactions to break the connection before the object is\n permanently discarded.\n \n The finalize method of class Object performs no\n special action; it simply returns normally. Subclasses of\n Object may override this definition.\n \n The Java programming language does not guarantee which thread will\n invoke the finalize method for any given object. It is\n guaranteed, however, that the thread that invokes finalize will not\n be holding any user-visible synchronization locks when finalize is\n invoked. If an uncaught exception is thrown by the finalize method,\n the exception is ignored and finalization of that object terminates.\n \n After the finalize method has been invoked for an object, no\n further action is taken until the Java virtual machine has again\n determined that there is no longer any means by which this object can\n be accessed by any thread that has not yet died, including possible\n actions by other objects or classes which are ready to be finalized,\n at which point the object may be discarded.\n \n The finalize method is never invoked more than once by a Java\n virtual machine for any given object.\n \n Any exception thrown by the finalize method causes\n the finalization of this object to be halted, but is otherwise\n ignored.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "OutOfMemoryError",
          "methods": [
            {
              "name": "OutOfMemoryError",
              "overloads": [
                {
                  "signature": "public OutOfMemoryError()",
                  "description": "Constructs an OutOfMemoryError with no detail message."
                },
                {
                  "signature": "public OutOfMemoryError(String s)",
                  "description": "Constructs an OutOfMemoryError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Package",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Return the name of this package."
                }
              ]
            },
            {
              "name": "getSpecificationTitle",
              "overloads": [
                {
                  "signature": "public String getSpecificationTitle()",
                  "description": "Return the title of the specification that this package implements."
                }
              ]
            },
            {
              "name": "getSpecificationVersion",
              "overloads": [
                {
                  "signature": "public String getSpecificationVersion()",
                  "description": "Returns the version number of the specification\n that this package implements.\n This version string must be a sequence of non-negative decimal\n integers separated by \".\"'s and may have leading zeros.\n When version strings are compared the most significant\n numbers are compared.\n\n\n Specification version numbers use a syntax that consists of non-negative\n decimal integers separated by periods \".\", for example \"2.0\" or\n \"1.2.3.4.5.6.7\".  This allows an extensible number to be used to represent\n major, minor, micro, etc. versions.  The version specification is described\n by the following formal grammar:\n \n \n SpecificationVersion:\n Digits RefinedVersionopt\n\n RefinedVersion:\n . Digits\n . Digits RefinedVersion\n\n Digits:\n Digit\n Digits\n\n Digit:\n any character for which Character.isDigit(char) returns true,\n e.g. 0, 1, 2, ..."
                }
              ]
            },
            {
              "name": "getSpecificationVendor",
              "overloads": [
                {
                  "signature": "public String getSpecificationVendor()",
                  "description": "Return the name of the organization, vendor,\n or company that owns and maintains the specification\n of the classes that implement this package."
                }
              ]
            },
            {
              "name": "getImplementationTitle",
              "overloads": [
                {
                  "signature": "public String getImplementationTitle()",
                  "description": "Return the title of this package."
                }
              ]
            },
            {
              "name": "getImplementationVersion",
              "overloads": [
                {
                  "signature": "public String getImplementationVersion()",
                  "description": "Return the version of this implementation. It consists of any string\n assigned by the vendor of this implementation and does\n not have any particular syntax specified or expected by the Java\n runtime. It may be compared for equality with other\n package version strings used for this implementation\n by this vendor for this package."
                }
              ]
            },
            {
              "name": "getImplementationVendor",
              "overloads": [
                {
                  "signature": "public String getImplementationVendor()",
                  "description": "Returns the vendor that implemented this package, null\n is returned if it is not known."
                }
              ]
            },
            {
              "name": "isSealed",
              "overloads": [
                {
                  "signature": "public boolean isSealed()",
                  "description": "Returns true if this package is sealed."
                },
                {
                  "signature": "public boolean isSealed(URL url)",
                  "description": "Returns true if this package is sealed with respect to the specified\n code source url."
                }
              ]
            },
            {
              "name": "isCompatibleWith",
              "overloads": [
                {
                  "signature": "public boolean isCompatibleWith(String desired) throws NumberFormatException",
                  "description": "Compare this package's specification version with a\n desired version. It returns true if\n this packages specification version number is greater than or equal\n to the desired version number. \n\n Version numbers are compared by sequentially comparing corresponding\n components of the desired and specification strings.\n Each component is converted as a decimal integer and the values\n compared.\n If the specification value is greater than the desired\n value true is returned. If the value is less false is returned.\n If the values are equal the period is skipped and the next pair of\n components is compared."
                }
              ]
            },
            {
              "name": "getPackage",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public static Package getPackage(String name)",
                  "description": "Finds a package by name in the caller's class loader and its\n ancestors.\n \n If the caller's class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of the\n caller's class loader are searched recursively (parent by parent)\n for a Package of the given name.\n \n Calling this method is equivalent to calling ClassLoader.getPackage(java.lang.String)\n on a ClassLoader instance which is the caller's class loader.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPackages",
              "overloads": [
                {
                  "signature": "public static Package[] getPackages()",
                  "description": "Returns all of the Packages defined by the caller's class loader\n and its ancestors.  The returned array may contain more than one\n Package object of the same package name, each defined by\n a different class loader in the class loader hierarchy.\n \n Calling this method is equivalent to calling ClassLoader.getPackages()\n on a ClassLoader instance which is the caller's class loader."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Return the hash code computed from the package name."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this Package.\n Its value is the string \"package \" and the package name.\n If the package title is defined it is appended.\n If the package version is defined it is appended."
                }
              ]
            },
            {
              "name": "getAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "isAnnotationPresent",
              "overloads": [
                {
                  "signature": "public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
                  "description": "Returns true if an annotation for the specified type\n is present on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n The truth value returned by this method is equivalent to:\n getAnnotation(annotationClass) != null"
                }
              ]
            },
            {
              "name": "getAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationClass)",
                  "description": "Returns annotations that are associated with this element.\n\n If there are no annotations associated with this element, the return\n value is an array of length 0.\n\n The difference between this method and AnnotatedElement.getAnnotation(Class)\n is that this method detects if its argument is a repeatable\n annotation type (JLS 9.6), and if so, attempts to find one or\n more annotations of that type by \"looking through\" a container\n annotation.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getAnnotations()",
                  "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotation",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)",
                  "description": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.\n\n This method ignores inherited annotations. (Returns null if no\n annotations are directly present on this element.)\n Note that any annotation returned by this method is a\n declaration annotation."
                }
              ]
            },
            {
              "name": "getDeclaredAnnotationsByType",
              "overloads": [
                {
                  "signature": "public <A extends Annotation> A[] getDeclaredAnnotationsByType(Class<A> annotationClass)",
                  "description": "Description copied from interface:AnnotatedElement"
                }
              ]
            },
            {
              "name": "getDeclaredAnnotations",
              "overloads": [
                {
                  "signature": "public Annotation[] getDeclaredAnnotations()",
                  "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n Note that any annotations returned by this method are\n declaration annotations."
                }
              ]
            }
          ]
        },
        {
          "name": "Process",
          "methods": [
            {
              "name": "Process",
              "overloads": [
                {
                  "signature": "public Process()",
                  "description": "Default constructor for Process."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public abstract OutputStream getOutputStream()",
                  "description": "Returns the output stream connected to the normal input of the\n process.  Output to the stream is piped into the standard\n input of the process represented by this Process object.\n\n If the standard input of the process has been redirected using\n ProcessBuilder.redirectInput\n then this method will return a\n null output stream."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public abstract InputStream getInputStream()",
                  "description": "Returns the input stream connected to the normal output of the\n process.  The stream obtains data piped from the standard\n output of the process represented by this Process object.\n\n If the standard output of the process has been redirected using\n ProcessBuilder.redirectOutput\n then this method will return a\n null input stream.\n\n Otherwise, if the standard error of the process has been\n redirected using\n ProcessBuilder.redirectErrorStream\n then the input stream returned by this method will receive the\n merged standard output and the standard error of the process."
                }
              ]
            },
            {
              "name": "getErrorStream",
              "overloads": [
                {
                  "signature": "public abstract InputStream getErrorStream()",
                  "description": "Returns the input stream connected to the error output of the\n process.  The stream obtains data piped from the error output\n of the process represented by this Process object.\n\n If the standard error of the process has been redirected using\n ProcessBuilder.redirectError or\n ProcessBuilder.redirectErrorStream\n then this method will return a\n null input stream."
                }
              ]
            },
            {
              "name": "inputReader",
              "overloads": [
                {
                  "signature": "public final BufferedReader inputReader()",
                  "description": "Returns a BufferedReader connected to the standard\n output of the process. The Charset for the native encoding is used\n to read characters, lines, or stream lines from standard output.\n\n This method delegates to inputReader(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedReader inputReader(Charset charset)",
                  "description": "Returns a BufferedReader connected to the\n standard output of this process using a Charset.\n The BufferedReader can be used to read characters, lines,\n or stream lines of the standard output.\n\n Characters are read by an InputStreamReader that reads and decodes bytes\n from this process getInputStream(). Bytes are decoded to characters\n using the charset; malformed-input and unmappable-character\n sequences are replaced with the charset's default replacement.\n The BufferedReader reads and buffers characters from the InputStreamReader.\n\n The first call to this method creates the BufferedReader,\n if called again with the same charset the same BufferedReader is returned.\n It is an error to call this method again with a different charset.\n\n If the standard output of the process has been redirected using\n ProcessBuilder.redirectOutput\n then the InputStreamReader will be reading from a\n null input stream.\n\n Otherwise, if the standard error of the process has been redirected using\n ProcessBuilder.redirectErrorStream then the input reader returned by\n this method will receive the merged standard output and the standard error\n of the process."
                }
              ]
            },
            {
              "name": "errorReader",
              "overloads": [
                {
                  "signature": "public final BufferedReader errorReader()",
                  "description": "Returns a BufferedReader connected to the standard\n error of the process. The Charset for the native encoding is used\n to read characters, lines, or stream lines from standard error.\n\n This method delegates to errorReader(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedReader errorReader(Charset charset)",
                  "description": "Returns a BufferedReader connected to the\n standard error of this process using a Charset.\n The BufferedReader can be used to read characters, lines,\n or stream lines of the standard error.\n\n Characters are read by an InputStreamReader that reads and decodes bytes\n from this process getErrorStream(). Bytes are decoded to characters\n using the charset; malformed-input and unmappable-character\n sequences are replaced with the charset's default replacement.\n The BufferedReader reads and buffers characters from the InputStreamReader.\n\n The first call to this method creates the BufferedReader,\n if called again with the same charset the same BufferedReader is returned.\n It is an error to call this method again with a different charset.\n\n If the standard error of the process has been redirected using\n ProcessBuilder.redirectError or\n ProcessBuilder.redirectErrorStream\n then the InputStreamReader will be reading from a\n null input stream."
                }
              ]
            },
            {
              "name": "outputWriter",
              "overloads": [
                {
                  "signature": "public final BufferedWriter outputWriter()",
                  "description": "Returns a BufferedWriter connected to the normal input of the process\n using the native encoding.\n Writes text to a character-output stream, buffering characters so as to provide\n for the efficient writing of single characters, arrays, and strings.\n\n This method delegates to outputWriter(Charset) using the\n Charset named by the native.encoding system property.\n If the native.encoding is not a valid charset name or not supported\n the Charset.defaultCharset() is used."
                },
                {
                  "signature": "public final BufferedWriter outputWriter(Charset charset)",
                  "description": "Returns a BufferedWriter connected to the normal input of the process\n using a Charset.\n Writes text to a character-output stream, buffering characters so as to provide\n for the efficient writing of single characters, arrays, and strings.\n\n Characters written by the writer are encoded to bytes using OutputStreamWriter\n and the Charset are written to the standard input of the process represented\n by this Process.\n Malformed-input and unmappable-character sequences are replaced with the charset's\n default replacement.\n\n The first call to this method creates the BufferedWriter,\n if called again with the same charset the same BufferedWriter is returned.\n It is an error to call this method again with a different charset.\n\n If the standard input of the process has been redirected using\n ProcessBuilder.redirectInput then the OutputStreamWriter writes to a\n null output stream."
                }
              ]
            },
            {
              "name": "waitFor",
              "overloads": [
                {
                  "signature": "public abstract int waitFor() throws InterruptedException",
                  "description": "Causes the current thread to wait, if necessary, until the\n process represented by this Process object has\n terminated.  This method returns immediately if the process\n has already terminated.  If the process has not yet\n terminated, the calling thread will be blocked until the\n process exits."
                },
                {
                  "signature": "public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException",
                  "description": "Causes the current thread to wait, if necessary, until the\n process represented by this Process object has\n terminated, or the specified waiting time elapses.\n\n If the process has already terminated then this method returns\n immediately with the value true.  If the process has not\n terminated and the timeout value is less than, or equal to, zero, then\n this method returns immediately with the value false.\n\n The default implementation of this methods polls the exitValue\n to check if the process has terminated. Concrete implementations of this\n class are strongly encouraged to override this method with a more\n efficient implementation."
                }
              ]
            },
            {
              "name": "exitValue",
              "overloads": [
                {
                  "signature": "public abstract int exitValue()",
                  "description": "Returns the exit value for the process."
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "public abstract void destroy()",
                  "description": "Kills the process.\n Whether the process represented by this Process object is\n normally terminated or not is\n implementation dependent.\n Forcible process destruction is defined as the immediate termination of a\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated."
                }
              ]
            },
            {
              "name": "destroyForcibly",
              "overloads": [
                {
                  "signature": "public Process destroyForcibly()",
                  "description": "Kills the process forcibly. The process represented by this\n Process object is forcibly terminated.\n Forcible process destruction is defined as the immediate termination of a\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Invoking this method on Process objects returned by\n ProcessBuilder.start() and Runtime.exec(java.lang.String) forcibly terminate\n the process."
                }
              ]
            },
            {
              "name": "supportsNormalTermination",
              "overloads": [
                {
                  "signature": "public boolean supportsNormalTermination()",
                  "description": "Returns true if the implementation of destroy() is to\n normally terminate the process,\n Returns false if the implementation of destroy\n forcibly and immediately terminates the process.\n \n Invoking this method on Process objects returned by\n ProcessBuilder.start() and Runtime.exec(java.lang.String) return\n true or false depending on the platform implementation."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "public boolean isAlive()",
                  "description": "Tests whether the process represented by this Process is\n alive."
                }
              ]
            },
            {
              "name": "pid",
              "overloads": [
                {
                  "signature": "public long pid()",
                  "description": "Returns the native process ID of the process.\n The native process ID is an identification number that the operating\n system assigns to the process."
                }
              ]
            },
            {
              "name": "onExit",
              "overloads": [
                {
                  "signature": "public CompletableFuture<Process> onExit()",
                  "description": "Returns a CompletableFuture<Process> for the termination of the Process.\n The CompletableFuture provides the ability\n to trigger dependent functions or actions that may be run synchronously\n or asynchronously upon process termination.\n When the process has terminated the CompletableFuture is\n completed regardless\n of the exit status of the process.\n \n Calling onExit().get() waits for the process to terminate and returns\n the Process. The future can be used to check if the process is\n done or to\n wait for it to terminate.\n Cancelling\n the CompletableFuture does not affect the Process.\n \n Processes returned from ProcessBuilder.start() override the\n default implementation to provide an efficient mechanism to wait\n for process exit."
                }
              ]
            },
            {
              "name": "toHandle",
              "overloads": [
                {
                  "signature": "public ProcessHandle toHandle()",
                  "description": "Returns a ProcessHandle for the Process.\n\n Process objects returned by ProcessBuilder.start() and\n Runtime.exec(java.lang.String) implement toHandle as the equivalent of\n ProcessHandle.of(pid) including the\n check for a SecurityManager and RuntimePermission(\"manageProcess\")."
                }
              ]
            },
            {
              "name": "info",
              "overloads": [
                {
                  "signature": "public ProcessHandle.Info info()",
                  "description": "Returns a snapshot of information about the process.\n\n  A ProcessHandle.Info instance has accessor methods\n that return information about the process if it is available."
                }
              ]
            },
            {
              "name": "children",
              "overloads": [
                {
                  "signature": "public Stream<ProcessHandle> children()",
                  "description": "Returns a snapshot of the direct children of the process.\n The parent of a direct child process is the process.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "descendants",
              "overloads": [
                {
                  "signature": "public Stream<ProcessHandle> descendants()",
                  "description": "Returns a snapshot of the descendants of the process.\n The descendants of a process are the children of the process\n plus the descendants of those children, recursively.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessBuilder",
          "methods": [
            {
              "name": "ProcessBuilder",
              "overloads": [
                {
                  "signature": "public ProcessBuilder(List<String> command)",
                  "description": "Constructs a process builder with the specified operating\n system program and arguments.  This constructor does not\n make a copy of the command list.  Subsequent\n updates to the list will be reflected in the state of the\n process builder.  It is not checked whether\n command corresponds to a valid operating system\n command."
                },
                {
                  "signature": "public ProcessBuilder(String... command)",
                  "description": "Constructs a process builder with the specified operating\n system program and arguments.  This is a convenience\n constructor that sets the process builder's command to a string\n list containing the same strings as the command\n array, in the same order.  It is not checked whether\n command corresponds to a valid operating system\n command."
                }
              ]
            },
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "public ProcessBuilder command(List<String> command)",
                  "description": "Sets this process builder's operating system program and\n arguments.  This method does not make a copy of the\n command list.  Subsequent updates to the list will\n be reflected in the state of the process builder.  It is not\n checked whether command corresponds to a valid\n operating system command."
                },
                {
                  "signature": "public ProcessBuilder command(String... command)",
                  "description": "Sets this process builder's operating system program and\n arguments.  This is a convenience method that sets the command\n to a string list containing the same strings as the\n command array, in the same order.  It is not\n checked whether command corresponds to a valid\n operating system command."
                },
                {
                  "signature": "public List<String> command()",
                  "description": "Returns this process builder's operating system program and\n arguments.  The returned list is not a copy.  Subsequent\n updates to the list will be reflected in the state of this\n process builder."
                }
              ]
            },
            {
              "name": "environment",
              "overloads": [
                {
                  "signature": "public Map<String,String> environment()",
                  "description": "Returns a string map view of this process builder's environment.\n\n Whenever a process builder is created, the environment is\n initialized to a copy of the current process environment (see\n System.getenv()).  Subprocesses subsequently started by\n this object's start() method will use this map as\n their environment.\n\n The returned object may be modified using ordinary Map operations.  These modifications will be\n visible to subprocesses started via the start()\n method.  Two ProcessBuilder instances always\n contain independent process environments, so changes to the\n returned map will never be reflected in any other\n ProcessBuilder instance or the values returned by\n System.getenv.\n\n If the system does not support environment variables, an\n empty map is returned.\n\n The returned map does not permit null keys or values.\n Attempting to insert or query the presence of a null key or\n value will throw a NullPointerException.\n Attempting to query the presence of a key or value which is not\n of type String will throw a ClassCastException.\n\n The behavior of the returned map is system-dependent.  A\n system may not allow modifications to environment variables or\n may forbid certain variable names or values.  For this reason,\n attempts to modify the map may fail with\n UnsupportedOperationException or\n IllegalArgumentException\n if the modification is not permitted by the operating system.\n\n Since the external format of environment variable names and\n values is system-dependent, there may not be a one-to-one\n mapping between them and Java's Unicode strings.  Nevertheless,\n the map is implemented in such a way that environment variables\n which are not modified by Java code will have an unmodified\n native representation in the subprocess.\n\n The returned map and its collection views may not obey the\n general contract of the Object.equals(java.lang.Object) and\n Object.hashCode() methods.\n\n The returned map is typically case-sensitive on all platforms.\n\n If a security manager exists, its\n checkPermission method\n is called with a\n RuntimePermission(\"getenv.*\") permission.\n This may result in a SecurityException being thrown.\n\n When passing information to a Java subprocess,\n system properties\n are generally preferred over environment variables."
                }
              ]
            },
            {
              "name": "directory",
              "overloads": [
                {
                  "signature": "public File directory()",
                  "description": "Returns this process builder's working directory.\n\n Subprocesses subsequently started by this object's start() method will use this as their working directory.\n The returned value may be null -- this means to use\n the working directory of the current Java process, usually the\n directory named by the system property user.dir,\n as the working directory of the child process."
                },
                {
                  "signature": "public ProcessBuilder directory(File directory)",
                  "description": "Sets this process builder's working directory.\n\n Subprocesses subsequently started by this object's start() method will use this as their working directory.\n The argument may be null -- this means to use the\n working directory of the current Java process, usually the\n directory named by the system property user.dir,\n as the working directory of the child process."
                }
              ]
            },
            {
              "name": "redirectInput",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectInput(ProcessBuilder.Redirect source)",
                  "description": "Sets this process builder's standard input source.\n\n Subprocesses subsequently started by this object's start()\n method obtain their standard input from this source.\n\n If the source is Redirect.PIPE\n (the initial value), then the standard input of a\n subprocess can be written to using the output stream\n returned by Process.getOutputStream().\n If the source is set to any other value, then\n Process.getOutputStream() will return a\n null output stream."
                },
                {
                  "signature": "public ProcessBuilder redirectInput(File file)",
                  "description": "Sets this process builder's standard input source to a file.\n\n This is a convenience method.  An invocation of the form\n redirectInput(file)\n behaves in exactly the same way as the invocation\n redirectInput\n (Redirect.from(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectInput()",
                  "description": "Returns this process builder's standard input source.\n\n Subprocesses subsequently started by this object's start()\n method obtain their standard input from this source.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "redirectOutput",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectOutput(ProcessBuilder.Redirect destination)",
                  "description": "Sets this process builder's standard output destination.\n\n Subprocesses subsequently started by this object's start()\n method send their standard output to this destination.\n\n If the destination is Redirect.PIPE\n (the initial value), then the standard output of a subprocess\n can be read using the input stream returned by Process.getInputStream().\n If the destination is set to any other value, then\n Process.getInputStream() will return a\n null input stream."
                },
                {
                  "signature": "public ProcessBuilder redirectOutput(File file)",
                  "description": "Sets this process builder's standard output destination to a file.\n\n This is a convenience method.  An invocation of the form\n redirectOutput(file)\n behaves in exactly the same way as the invocation\n redirectOutput\n (Redirect.to(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectOutput()",
                  "description": "Returns this process builder's standard output destination.\n\n Subprocesses subsequently started by this object's start()\n method redirect their standard output to this destination.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "redirectError",
              "overloads": [
                {
                  "signature": "public ProcessBuilder redirectError(ProcessBuilder.Redirect destination)",
                  "description": "Sets this process builder's standard error destination.\n\n Subprocesses subsequently started by this object's start()\n method send their standard error to this destination.\n\n If the destination is Redirect.PIPE\n (the initial value), then the error output of a subprocess\n can be read using the input stream returned by Process.getErrorStream().\n If the destination is set to any other value, then\n Process.getErrorStream() will return a\n null input stream.\n\n If the redirectErrorStream\n attribute has been set true, then the redirection set\n by this method has no effect."
                },
                {
                  "signature": "public ProcessBuilder redirectError(File file)",
                  "description": "Sets this process builder's standard error destination to a file.\n\n This is a convenience method.  An invocation of the form\n redirectError(file)\n behaves in exactly the same way as the invocation\n redirectError\n (Redirect.to(file))."
                },
                {
                  "signature": "public ProcessBuilder.Redirect redirectError()",
                  "description": "Returns this process builder's standard error destination.\n\n Subprocesses subsequently started by this object's start()\n method redirect their standard error to this destination.\n The initial value is Redirect.PIPE."
                }
              ]
            },
            {
              "name": "inheritIO",
              "overloads": [
                {
                  "signature": "public ProcessBuilder inheritIO()",
                  "description": "Sets the source and destination for subprocess standard I/O\n to be the same as those of the current Java process.\n\n This is a convenience method.  An invocation of the form\n   \n pb.inheritIO()\n \n behaves in exactly the same way as the invocation\n   \n pb.redirectInput(Redirect.INHERIT)\n   .redirectOutput(Redirect.INHERIT)\n   .redirectError(Redirect.INHERIT)\n \n\n This gives behavior equivalent to most operating system\n command interpreters, or the standard C library function\n system()."
                }
              ]
            },
            {
              "name": "redirectErrorStream",
              "overloads": [
                {
                  "signature": "public boolean redirectErrorStream()",
                  "description": "Tells whether this process builder merges standard error and\n standard output.\n\n If this property is true, then any error output\n generated by subprocesses subsequently started by this object's\n start() method will be merged with the standard\n output, so that both can be read using the\n Process.getInputStream() method.  This makes it easier\n to correlate error messages with the corresponding output.\n The initial value is false."
                },
                {
                  "signature": "public ProcessBuilder redirectErrorStream(boolean redirectErrorStream)",
                  "description": "Sets this process builder's redirectErrorStream property.\n\n If this property is true, then any error output\n generated by subprocesses subsequently started by this object's\n start() method will be merged with the standard\n output, so that both can be read using the\n Process.getInputStream() method.  This makes it easier\n to correlate error messages with the corresponding output.\n The initial value is false."
                }
              ]
            },
            {
              "name": "start",
              "overloads": [
                {
                  "signature": "public Process start() throws IOException",
                  "description": "Starts a new process using the attributes of this process builder.\n\n The new process will\n invoke the command and arguments given by command(),\n in a working directory as given by directory(),\n with a process environment as given by environment().\n\n This method checks that the command is a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n\n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the process builder's environment().\n\n If there is a security manager, its\n checkExec\n method is called with the first component of this object's\n command array as its argument. This may result in\n a SecurityException being thrown.\n\n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n Invalid character in command argument, such as NUL.\n \n\n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n\n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown.\n\n Subsequent modifications to this process builder will not\n affect the returned Process."
                }
              ]
            },
            {
              "name": "startPipeline",
              "overloads": [
                {
                  "signature": "public static List<Process> startPipeline(List<ProcessBuilder> builders) throws IOException",
                  "description": "Starts a Process for each ProcessBuilder, creating a pipeline of\n processes linked by their standard output and standard input streams.\n The attributes of each ProcessBuilder are used to start the respective\n process except that as each process is started, its standard output\n is directed to the standard input of the next.  The redirects for standard\n input of the first process and standard output of the last process are\n initialized using the redirect settings of the respective ProcessBuilder.\n All other ProcessBuilder redirects should be\n Redirect.PIPE.\n \n All input and output streams between the intermediate processes are\n not accessible.\n The standard input of all processes\n except the first process are null output streams\n The standard output of all processes\n except the last process are null input streams.\n \n The redirectErrorStream() of each ProcessBuilder applies to the\n respective process.  If set to true, the error stream is written\n to the same stream as standard output.\n \n If starting any of the processes throws an Exception, all processes\n are forcibly destroyed.\n \n The startPipeline method performs the same checks on\n each ProcessBuilder as does the start() method. Each new process\n invokes the command and arguments given by the respective process builder's\n command(), in a working directory as given by its directory(),\n with a process environment as given by its environment().\n \n Each process builder's command is checked to be a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n \n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the process builder's environment().\n \n If there is a security manager, its\n checkExec\n method is called with the first component of each process builder's\n command array as its argument. This may result in\n a SecurityException being thrown.\n \n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n Invalid character in command argument, such as NUL.\n \n \n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n \n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown.\n \n Subsequent modifications to any of the specified builders\n will not affect the returned Process."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessBuilder.Redirect",
          "methods": [
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "public abstract ProcessBuilder.Redirect.Type type()",
                  "description": "Returns the type of this Redirect."
                }
              ]
            },
            {
              "name": "file",
              "overloads": [
                {
                  "signature": "public File file()",
                  "description": "Returns the File source or destination associated\n with this redirect, or null if there is no such file."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect from(File file)",
                  "description": "Returns a redirect to read from the specified file.\n\n It will always be true that\n   \n Redirect.from(file).file() == file &&\n Redirect.from(file).type() == Redirect.Type.READ"
                }
              ]
            },
            {
              "name": "to",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect to(File file)",
                  "description": "Returns a redirect to write to the specified file.\n If the specified file exists when the subprocess is started,\n its previous contents will be discarded.\n\n It will always be true that\n   \n Redirect.to(file).file() == file &&\n Redirect.to(file).type() == Redirect.Type.WRITE"
                }
              ]
            },
            {
              "name": "appendTo",
              "overloads": [
                {
                  "signature": "public static ProcessBuilder.Redirect appendTo(File file)",
                  "description": "Returns a redirect to append to the specified file.\n Each write operation first advances the position to the\n end of the file and then writes the requested data.\n Whether the advancement of the position and the writing\n of the data are done in a single atomic operation is\n system-dependent and therefore unspecified.\n\n It will always be true that\n   \n Redirect.appendTo(file).file() == file &&\n Redirect.appendTo(file).type() == Redirect.Type.APPEND"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the specified object with this Redirect for\n equality.  Returns true if and only if the two\n objects are identical or both objects are Redirect\n instances of the same type associated with non-null equal\n File instances."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for this Redirect."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessHandle",
          "methods": [
            {
              "name": "pid",
              "overloads": [
                {
                  "signature": "long pid()",
                  "description": "Returns the native process ID of the process. The native process ID is an\n identification number that the operating system assigns to the process.\n The operating system may reuse the process ID after a process terminates.\n Use equals or\n compareTo to compare ProcessHandles."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static Optional<ProcessHandle> of(long pid)",
                  "description": "Returns an Optional<ProcessHandle> for an existing native process."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "static ProcessHandle current()",
                  "description": "Returns a ProcessHandle for the current process. The ProcessHandle cannot be\n used to destroy the current process, use System.exit instead."
                }
              ]
            },
            {
              "name": "parent",
              "overloads": [
                {
                  "signature": "Optional<ProcessHandle> parent()",
                  "description": "Returns an Optional<ProcessHandle> for the parent process.\n Note that Processes in a zombie state usually don't have a parent."
                }
              ]
            },
            {
              "name": "children",
              "overloads": [
                {
                  "signature": "Stream<ProcessHandle> children()",
                  "description": "Returns a snapshot of the current direct children of the process.\n The parent() of a direct child process is the process.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "descendants",
              "overloads": [
                {
                  "signature": "Stream<ProcessHandle> descendants()",
                  "description": "Returns a snapshot of the descendants of the process.\n The descendants of a process are the children of the process\n plus the descendants of those children, recursively.\n Typically, a process that is not alive has no children.\n \n Note that processes are created and terminate asynchronously.\n There is no guarantee that a process is alive."
                }
              ]
            },
            {
              "name": "allProcesses",
              "overloads": [
                {
                  "signature": "static Stream<ProcessHandle> allProcesses()",
                  "description": "Returns a snapshot of all processes visible to the current process.\n \n Note that processes are created and terminate asynchronously. There\n is no guarantee that a process in the stream is alive or that no other\n processes may have been created since the inception of the snapshot."
                }
              ]
            },
            {
              "name": "info",
              "overloads": [
                {
                  "signature": "ProcessHandle.Info info()",
                  "description": "Returns a snapshot of information about the process.\n\n  A ProcessHandle.Info instance has accessor methods that return\n information about the process if it is available."
                }
              ]
            },
            {
              "name": "onExit",
              "overloads": [
                {
                  "signature": "CompletableFuture<ProcessHandle> onExit()",
                  "description": "Returns a CompletableFuture<ProcessHandle> for the termination\n of the process.\n The CompletableFuture provides the ability\n to trigger dependent functions or actions that may be run synchronously\n or asynchronously upon process termination.\n When the process has terminated the CompletableFuture is\n completed regardless\n of the exit status of the process.\n The onExit method can be called multiple times to invoke\n independent actions when the process exits.\n \n Calling onExit().get() waits for the process to terminate and returns\n the ProcessHandle. The future can be used to check if the process is\n done or to\n wait for it to terminate.\n Cancelling\n the CompleteableFuture does not affect the Process."
                }
              ]
            },
            {
              "name": "supportsNormalTermination",
              "overloads": [
                {
                  "signature": "boolean supportsNormalTermination()",
                  "description": "Returns true if the implementation of destroy()\n normally terminates the process.\n Returns false if the implementation of destroy\n forcibly and immediately terminates the process."
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "boolean destroy()",
                  "description": "Requests the process to be killed.\n Whether the process represented by this ProcessHandle object is\n normally terminated or not is\n implementation dependent.\n Forcible process destruction is defined as the immediate termination of the\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n The operating system access controls may prevent the process\n from being killed.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Note: The process may not terminate immediately.\n For example, isAlive() may return true for a brief period\n after destroy() is called."
                }
              ]
            },
            {
              "name": "destroyForcibly",
              "overloads": [
                {
                  "signature": "boolean destroyForcibly()",
                  "description": "Requests the process to be killed forcibly.\n The process represented by this ProcessHandle object is\n forcibly terminated.\n Forcible process destruction is defined as the immediate termination of the\n process, whereas normal termination allows the process to shut down cleanly.\n If the process is not alive, no action is taken.\n The operating system access controls may prevent the process\n from being killed.\n \n The CompletableFuture from onExit() is\n completed\n when the process has terminated.\n \n Note: The process may not terminate immediately.\n For example, isAlive() may return true for a brief period\n after destroyForcibly() is called."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "boolean isAlive()",
                  "description": "Tests whether the process represented by this ProcessHandle is alive.\n Process termination is implementation and operating system specific.\n The process is considered alive as long as the PID is valid."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns a hash code value for this ProcessHandle.\n The hashcode value follows the general contract for Object.hashCode().\n The value is a function of the pid() value and\n may be a function of additional information to uniquely identify the process.\n If two ProcessHandles are equal according to the equals\n method, then calling the hashCode method on each of the two objects\n must produce the same integer result."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object other)",
                  "description": "Returns true if other object is non-null, is of the\n same implementation, and represents the same system process;\n otherwise it returns false."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "int compareTo(ProcessHandle other)",
                  "description": "Compares this ProcessHandle with the specified ProcessHandle for order.\n The order is not specified, but is consistent with Object.equals(java.lang.Object),\n which returns true if and only if two instances of ProcessHandle\n are of the same implementation and represent the same system process.\n Comparison is only supported among objects of same implementation.\n If attempt is made to mutually compare two different implementations\n of ProcessHandles, ClassCastException is thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "ProcessHandle.Info",
          "methods": [
            {
              "name": "command",
              "overloads": [
                {
                  "signature": "Optional<String> command()",
                  "description": "Returns the executable pathname of the process."
                }
              ]
            },
            {
              "name": "commandLine",
              "overloads": [
                {
                  "signature": "Optional<String> commandLine()",
                  "description": "Returns the command line of the process.\n \n If command() and  arguments() return\n non-empty optionals, this is simply a convenience method which concatenates\n the values of the two functions separated by spaces. Otherwise it will return a\n best-effort, platform dependent representation of the command line."
                }
              ]
            },
            {
              "name": "arguments",
              "overloads": [
                {
                  "signature": "Optional<String[]> arguments()",
                  "description": "Returns an array of Strings of the arguments of the process."
                }
              ]
            },
            {
              "name": "startInstant",
              "overloads": [
                {
                  "signature": "Optional<Instant> startInstant()",
                  "description": "Returns the start time of the process."
                }
              ]
            },
            {
              "name": "totalCpuDuration",
              "overloads": [
                {
                  "signature": "Optional<Duration> totalCpuDuration()",
                  "description": "Returns the total cputime accumulated of the process."
                }
              ]
            },
            {
              "name": "user",
              "overloads": [
                {
                  "signature": "Optional<String> user()",
                  "description": "Return the user of the process."
                }
              ]
            }
          ]
        },
        {
          "name": "Readable",
          "methods": [
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "int read(CharBuffer cb) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                }
              ]
            }
          ]
        },
        {
          "name": "Record",
          "methods": [
            {
              "name": "Record",
              "overloads": [
                {
                  "signature": "protected Record()",
                  "description": "Constructor for record classes to call."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public abstract boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this one.  In addition\n to the general contract of Object.equals,\n record classes must further obey the invariant that when\n a record instance is \"copied\" by passing the result of the record component\n accessor methods to the canonical constructor, as follows:\n      R copy = new R(r.c1(), r.c2(), ..., r.cn());\n \n then it must be the case that r.equals(copy)."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public abstract int hashCode()",
                  "description": "Returns a hash code value for the record.\n Obeys the general contract of Object.hashCode.\n For records, hashing behavior is constrained by the refined contract\n of Record.equals, so that any two records\n created from the same components must have the same hash code."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public abstract String toString()",
                  "description": "Returns a string representation of the record.\n In accordance with the general contract of Object.toString(),\n the toString method returns a string that\n \"textually represents\" this record. The result should\n be a concise but informative representation that is easy for a\n person to read.\n \n In addition to this general contract, record classes must further\n participate in the invariant that any two records which are\n equal must produce equal\n strings.  This invariant is necessarily relaxed in the rare\n case where corresponding equal component values might fail\n to produce equal strings for themselves."
                }
              ]
            }
          ]
        },
        {
          "name": "ReflectiveOperationException",
          "methods": [
            {
              "name": "ReflectiveOperationException",
              "overloads": [
                {
                  "signature": "public ReflectiveOperationException()",
                  "description": "Constructs a new exception with null as its detail\n message.  The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public ReflectiveOperationException(String message)",
                  "description": "Constructs a new exception with the specified detail message.\n The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public ReflectiveOperationException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message\n and cause.\n\n Note that the detail message associated with\n cause is not automatically incorporated in\n this exception's detail message."
                },
                {
                  "signature": "public ReflectiveOperationException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Runnable",
          "methods": [
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "void run()",
                  "description": "When an object implementing interface Runnable is used\n to create a thread, starting the thread causes the object's\n run method to be called in that separately executing\n thread.\n \n The general contract of the method run is that it may\n take any action whatsoever."
                }
              ]
            }
          ]
        },
        {
          "name": "Runtime",
          "methods": [
            {
              "name": "getRuntime",
              "overloads": [
                {
                  "signature": "public static Runtime getRuntime()",
                  "description": "Returns the runtime object associated with the current Java application.\n Most of the methods of class Runtime are instance\n methods and must be invoked with respect to the current runtime object."
                }
              ]
            },
            {
              "name": "exit",
              "overloads": [
                {
                  "signature": "public void exit(int status)",
                  "description": "Terminates the currently running Java virtual machine by initiating its\n shutdown sequence.  This method never returns normally.  The argument\n serves as a status code; by convention, a nonzero status code indicates\n abnormal termination.\n\n  All registered shutdown hooks, if any,\n are started in some unspecified order and allowed to run concurrently\n until they finish.  Once this is done the virtual machine\n halts.\n\n  If this method is invoked after all shutdown hooks have already\n been run and the status is nonzero then this method halts the\n virtual machine with the given status code. Otherwise, this method\n blocks indefinitely.\n\n  The System.exit method is the\n conventional and convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "addShutdownHook",
              "overloads": [
                {
                  "signature": "public void addShutdownHook(Thread hook)",
                  "description": "Registers a new virtual-machine shutdown hook.\n\n  The Java virtual machine shuts down in response to two kinds\n of events:\n\n   \n\n    The program exits normally, when the last non-daemon\n   thread exits or when the exit (equivalently,\n   System.exit) method is invoked, or\n\n    The virtual machine is terminated in response to a\n   user interrupt, such as typing ^C, or a system-wide event,\n   such as user logoff or system shutdown.\n\n   \n\n  A shutdown hook is simply an initialized but unstarted\n thread.  When the virtual machine begins its shutdown sequence it will\n start all registered shutdown hooks in some unspecified order and let\n them run concurrently.  When all the hooks have finished it will then\n halt. Note that daemon threads will continue to run during the shutdown\n sequence, as will non-daemon threads if shutdown was initiated by\n invoking the exit method.\n\n  Once the shutdown sequence has begun it can be stopped only by\n invoking the halt method, which forcibly\n terminates the virtual machine.\n\n  Once the shutdown sequence has begun it is impossible to register a\n new shutdown hook or de-register a previously-registered hook.\n Attempting either of these operations will cause an\n IllegalStateException to be thrown.\n\n  Shutdown hooks run at a delicate time in the life cycle of a virtual\n machine and should therefore be coded defensively.  They should, in\n particular, be written to be thread-safe and to avoid deadlocks insofar\n as possible.  They should also not rely blindly upon services that may\n have registered their own shutdown hooks and therefore may themselves in\n the process of shutting down.  Attempts to use other thread-based\n services such as the AWT event-dispatch thread, for example, may lead to\n deadlocks.\n\n  Shutdown hooks should also finish their work quickly.  When a\n program invokes exit the expectation is\n that the virtual machine will promptly shut down and exit.  When the\n virtual machine is terminated due to user logoff or system shutdown the\n underlying operating system may only allow a fixed amount of time in\n which to shut down and exit.  It is therefore inadvisable to attempt any\n user interaction or to perform a long-running computation in a shutdown\n hook.\n\n  Uncaught exceptions are handled in shutdown hooks just as in any\n other thread, by invoking the\n uncaughtException method of the\n thread's ThreadGroup object. The default implementation of this\n method prints the exception's stack trace to System.err and\n terminates the thread; it does not cause the virtual machine to exit or\n halt.\n\n  In rare circumstances the virtual machine may abort, that is,\n stop running without shutting down cleanly.  This occurs when the\n virtual machine is terminated externally, for example with the\n SIGKILL signal on Unix or the TerminateProcess call on\n Microsoft Windows.  The virtual machine may also abort if a native\n method goes awry by, for example, corrupting internal data structures or\n attempting to access nonexistent memory.  If the virtual machine aborts\n then no guarantee can be made about whether or not any shutdown hooks\n will be run."
                }
              ]
            },
            {
              "name": "removeShutdownHook",
              "overloads": [
                {
                  "signature": "public boolean removeShutdownHook(Thread hook)",
                  "description": "De-registers a previously-registered virtual-machine shutdown hook."
                }
              ]
            },
            {
              "name": "halt",
              "overloads": [
                {
                  "signature": "public void halt(int status)",
                  "description": "Forcibly terminates the currently running Java virtual machine.  This\n method never returns normally.\n\n  This method should be used with extreme caution.  Unlike the\n exit method, this method does not cause shutdown\n hooks to be started.  If the shutdown sequence has already been\n initiated then this method does not wait for any running\n shutdown hooks to finish their work."
                }
              ]
            },
            {
              "name": "exec",
              "overloads": [
                {
                  "signature": "public Process exec(String command) throws IOException",
                  "description": "Executes the specified string command in a separate process.\n\n This is a convenience method.  An invocation of the form\n exec(command)\n behaves in exactly the same way as the invocation\n exec(command, null, null)."
                },
                {
                  "signature": "public Process exec(String command, String[] envp) throws IOException",
                  "description": "Executes the specified string command in a separate process with the\n specified environment.\n\n This is a convenience method.  An invocation of the form\n exec(command, envp)\n behaves in exactly the same way as the invocation\n exec(command, envp, null)."
                },
                {
                  "signature": "public Process exec(String command, String[] envp, File dir) throws IOException",
                  "description": "Executes the specified string command in a separate process with the\n specified environment and working directory.\n\n This is a convenience method.  An invocation of the form\n exec(command, envp, dir)\n behaves in exactly the same way as the invocation\n exec(cmdarray, envp, dir),\n where cmdarray is an array of all the tokens in\n command.\n\n More precisely, the command string is broken\n into tokens using a StringTokenizer created by the call\n new StringTokenizer(command) with no\n further modification of the character categories.  The tokens\n produced by the tokenizer are then placed in the new string\n array cmdarray, in the same order."
                },
                {
                  "signature": "public Process exec(String[] cmdarray) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process.\n\n This is a convenience method.  An invocation of the form\n exec(cmdarray)\n behaves in exactly the same way as the invocation\n exec(cmdarray, null, null)."
                },
                {
                  "signature": "public Process exec(String[] cmdarray, String[] envp) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process\n with the specified environment.\n\n This is a convenience method.  An invocation of the form\n exec(cmdarray, envp)\n behaves in exactly the same way as the invocation\n exec(cmdarray, envp, null)."
                },
                {
                  "signature": "public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException",
                  "description": "Executes the specified command and arguments in a separate process with\n the specified environment and working directory.\n\n Given an array of strings cmdarray, representing the\n tokens of a command line, and an array of strings envp,\n representing \"environment\" variable settings, this method creates\n a new process in which to execute the specified command.\n\n This method checks that cmdarray is a valid operating\n system command.  Which commands are valid is system-dependent,\n but at the very least the command must be a non-empty list of\n non-null strings.\n\n If envp is null, the subprocess inherits the\n environment settings of the current process.\n\n A minimal set of system dependent environment variables may\n be required to start a process on some operating systems.\n As a result, the subprocess may inherit additional environment variable\n settings beyond those in the specified environment.\n\n ProcessBuilder.start() is now the preferred way to\n start a process with a modified environment.\n\n The working directory of the new subprocess is specified by dir.\n If dir is null, the subprocess inherits the\n current working directory of the current process.\n\n If a security manager exists, its\n checkExec\n method is invoked with the first component of the array\n cmdarray as its argument. This may result in a\n SecurityException being thrown.\n\n Starting an operating system process is highly system-dependent.\n Among the many things that can go wrong are:\n \n The operating system program file was not found.\n Access to the program file was denied.\n The working directory does not exist.\n \n\n In such cases an exception will be thrown.  The exact nature\n of the exception is system-dependent, but it will always be a\n subclass of IOException.\n\n If the operating system does not support the creation of\n processes, an UnsupportedOperationException will be thrown."
                }
              ]
            },
            {
              "name": "availableProcessors",
              "overloads": [
                {
                  "signature": "public int availableProcessors()",
                  "description": "Returns the number of processors available to the Java virtual machine.\n\n  This value may change during a particular invocation of the virtual\n machine.  Applications that are sensitive to the number of available\n processors should therefore occasionally poll this property and adjust\n their resource usage appropriately."
                }
              ]
            },
            {
              "name": "freeMemory",
              "overloads": [
                {
                  "signature": "public long freeMemory()",
                  "description": "Returns the amount of free memory in the Java Virtual Machine.\n Calling the\n gc method may result in increasing the value returned\n by freeMemory."
                }
              ]
            },
            {
              "name": "totalMemory",
              "overloads": [
                {
                  "signature": "public long totalMemory()",
                  "description": "Returns the total amount of memory in the Java virtual machine.\n The value returned by this method may vary over time, depending on\n the host environment.\n \n Note that the amount of memory required to hold an object of any\n given type may be implementation-dependent."
                }
              ]
            },
            {
              "name": "maxMemory",
              "overloads": [
                {
                  "signature": "public long maxMemory()",
                  "description": "Returns the maximum amount of memory that the Java virtual machine\n will attempt to use.  If there is no inherent limit then the value\n Long.MAX_VALUE will be returned."
                }
              ]
            },
            {
              "name": "gc",
              "overloads": [
                {
                  "signature": "public void gc()",
                  "description": "Runs the garbage collector in the Java Virtual Machine.\n \n Calling this method suggests that the Java Virtual Machine\n expend effort toward recycling unused objects in order to\n make the memory they currently occupy available for reuse\n by the Java Virtual Machine.\n When control returns from the method call, the Java Virtual Machine\n has made a best effort to reclaim space from all unused objects.\n There is no guarantee that this effort will recycle any particular\n number of unused objects, reclaim any particular amount of space, or\n complete at any particular time, if at all, before the method returns or ever.\n There is also no guarantee that this effort will determine\n the change of reachability in any particular number of objects,\n or that any particular number of Reference\n objects will be cleared and enqueued.\n \n The name gc stands for \"garbage\n collector\". The Java Virtual Machine performs this recycling\n process automatically as needed, in a separate thread, even if the\n gc method is not invoked explicitly.\n \n The method System.gc() is the conventional and convenient\n means of invoking this method."
                }
              ]
            },
            {
              "name": "runFinalization",
              "overloads": [
                {
                  "signature": "public void runFinalization()",
                  "description": "Runs the finalization methods of any objects pending finalization.\n Calling this method suggests that the Java virtual machine expend\n effort toward running the finalize methods of objects\n that have been found to be discarded but whose finalize\n methods have not yet been run. When control returns from the\n method call, the virtual machine has made a best effort to\n complete all outstanding finalizations.\n \n The virtual machine performs the finalization process\n automatically as needed, in a separate thread, if the\n runFinalization method is not invoked explicitly.\n \n The method System.runFinalization() is the conventional\n and convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public void load(String filename)",
                  "description": "Loads the native library specified by the filename argument.  The filename\n argument must be an absolute path name.\n (for example\n Runtime.getRuntime().load(\"/home/avh/lib/libX11.so\");).\n\n If the filename argument, when stripped of any platform-specific library\n prefix, path, and file extension, indicates a library whose name is,\n for example, L, and a native library called L is statically linked\n with the VM, then the JNI_OnLoad_L function exported by the library\n is invoked rather than attempting to load a dynamic library.\n A filename matching the argument does not have to exist in the file\n system.\n See the  JNI Specification\n for more details.\n\n Otherwise, the filename argument is mapped to a native library image in\n an implementation-dependent manner.\n \n First, if there is a security manager, its checkLink\n method is called with the filename as its argument.\n This may result in a security exception.\n \n This is similar to the method loadLibrary(String), but it\n accepts a general file name as an argument rather than just a library\n name, allowing any file of native code to be loaded.\n \n The method System.load(String) is the conventional and\n convenient means of invoking this method."
                }
              ]
            },
            {
              "name": "loadLibrary",
              "overloads": [
                {
                  "signature": "public void loadLibrary(String libname)",
                  "description": "Loads the native library specified by the libname\n argument.  The libname argument must not contain any platform\n specific prefix, file extension or path. If a native library\n called libname is statically linked with the VM, then the\n JNI_OnLoad_libname function exported by the library is invoked.\n See the  JNI Specification\n for more details.\n\n Otherwise, the libname argument is loaded from a system library\n location and mapped to a native library image in an\n implementation-dependent manner.\n \n First, if there is a security manager, its checkLink\n method is called with the libname as its argument.\n This may result in a security exception.\n \n The method System.loadLibrary(String) is the conventional\n and convenient means of invoking this method. If native\n methods are to be used in the implementation of a class, a standard\n strategy is to put the native code in a library file (call it\n LibFile) and then to put a static initializer:\n  static { System.loadLibrary(\"LibFile\"); }\n \n within the class declaration. When the class is loaded and\n initialized, the necessary native code implementation for the native\n methods will then be loaded as well.\n \n If this method is called more than once with the same library\n name, the second and subsequent calls are ignored."
                }
              ]
            },
            {
              "name": "version",
              "overloads": [
                {
                  "signature": "public static Runtime.Version version()",
                  "description": "Returns the version of the Java Runtime Environment as a Runtime.Version."
                }
              ]
            }
          ]
        },
        {
          "name": "Runtime.Version",
          "methods": [
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Runtime.Version parse(String s)",
                  "description": "Parses the given string as a valid\n version string containing a\n version number followed by pre-release and\n build information."
                }
              ]
            },
            {
              "name": "feature",
              "overloads": [
                {
                  "signature": "public int feature()",
                  "description": "Returns the value of the feature element of\n the version number."
                }
              ]
            },
            {
              "name": "interim",
              "overloads": [
                {
                  "signature": "public int interim()",
                  "description": "Returns the value of the interim element of\n the version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "update",
              "overloads": [
                {
                  "signature": "public int update()",
                  "description": "Returns the value of the update element of the\n version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "patch",
              "overloads": [
                {
                  "signature": "public int patch()",
                  "description": "Returns the value of the patch element of the\n version number, or zero if it is absent."
                }
              ]
            },
            {
              "name": "major",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int major()",
                  "description": "Returns the value of the major element of the version number.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "minor",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int minor()",
                  "description": "Returns the value of the minor element of the version number, or\n zero if it is absent.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "security",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"10\") public int security()",
                  "description": "Returns the value of the security element of the version number, or\n zero if it is absent.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "version",
              "overloads": [
                {
                  "signature": "public List<Integer> version()",
                  "description": "Returns an unmodifiable List of the integers\n represented in the version number.\n The List always contains at least one element corresponding to\n the feature version number."
                }
              ]
            },
            {
              "name": "pre",
              "overloads": [
                {
                  "signature": "public Optional<String> pre()",
                  "description": "Returns the optional pre-release information."
                }
              ]
            },
            {
              "name": "build",
              "overloads": [
                {
                  "signature": "public Optional<Integer> build()",
                  "description": "Returns the build number."
                }
              ]
            },
            {
              "name": "optional",
              "overloads": [
                {
                  "signature": "public Optional<String> optional()",
                  "description": "Returns optional additional identifying build\n information."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Runtime.Version obj)",
                  "description": "Compares this version to another.\n\n  Each of the components in the version is\n compared in the following order of precedence: version numbers,\n pre-release identifiers, build numbers, optional build information.\n \n\n  Comparison begins by examining the sequence of version numbers.\n If one sequence is shorter than another, then the missing elements\n of the shorter sequence are considered to be less than the\n corresponding elements of the longer sequence. \n\n  A version with a pre-release identifier is always considered to\n be less than a version without one.  Pre-release identifiers are\n compared numerically when they consist only of digits, and\n lexicographically otherwise.  Numeric identifiers are considered to\n be less than non-numeric identifiers.  \n\n  A version without a build number is always less than one with a\n build number; otherwise build numbers are compared numerically. \n\n  The optional build information is compared lexicographically.\n During this comparison, a version with optional build information is\n considered to be greater than a version without one."
                }
              ]
            },
            {
              "name": "compareToIgnoreOptional",
              "overloads": [
                {
                  "signature": "public int compareToIgnoreOptional(Runtime.Version obj)",
                  "description": "Compares this version to another disregarding optional build\n information.\n\n  Two versions are compared by examining the version string as\n described in compareTo(Version) with the exception that the\n optional build information is always ignored. \n\n  This method provides ordering which is consistent with\n equalsIgnoreOptional()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this version."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Determines whether this Version is equal to another object.\n\n  Two Versions are equal if and only if they represent the\n same version string."
                }
              ]
            },
            {
              "name": "equalsIgnoreOptional",
              "overloads": [
                {
                  "signature": "public boolean equalsIgnoreOptional(Object obj)",
                  "description": "Determines whether this Version is equal to another\n disregarding optional build information.\n\n  Two Versions are equal if and only if they represent the\n same version string disregarding the optional build information."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this version."
                }
              ]
            }
          ]
        },
        {
          "name": "RuntimeException",
          "methods": [
            {
              "name": "RuntimeException",
              "overloads": [
                {
                  "signature": "public RuntimeException()",
                  "description": "Constructs a new runtime exception with null as its\n detail message.  The cause is not initialized, and may subsequently be\n initialized by a call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public RuntimeException(String message)",
                  "description": "Constructs a new runtime exception with the specified detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to Throwable.initCause(java.lang.Throwable)."
                },
                {
                  "signature": "public RuntimeException(String message, Throwable cause)",
                  "description": "Constructs a new runtime exception with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this runtime exception's detail message."
                },
                {
                  "signature": "public RuntimeException(Throwable cause)",
                  "description": "Constructs a new runtime exception with the specified cause and a\n detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause).  This constructor is useful for runtime exceptions\n that are little more than wrappers for other throwables."
                },
                {
                  "signature": "protected RuntimeException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new runtime exception with the specified detail\n message, cause, suppression enabled or disabled, and writable\n stack trace enabled or disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "RuntimePermission",
          "methods": [
            {
              "name": "RuntimePermission",
              "overloads": [
                {
                  "signature": "public RuntimePermission(String name)",
                  "description": "Creates a new RuntimePermission with the specified name.\n The name is the symbolic name of the RuntimePermission, such as\n \"exit\", \"setFactory\", etc. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match."
                },
                {
                  "signature": "public RuntimePermission(String name, String actions)",
                  "description": "Creates a new RuntimePermission object with the specified name.\n The name is the symbolic name of the RuntimePermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "SecurityException",
          "methods": [
            {
              "name": "SecurityException",
              "overloads": [
                {
                  "signature": "public SecurityException()",
                  "description": "Constructs a SecurityException with no detail message."
                },
                {
                  "signature": "public SecurityException(String s)",
                  "description": "Constructs a SecurityException with the specified\n detail message."
                },
                {
                  "signature": "public SecurityException(String message, Throwable cause)",
                  "description": "Creates a SecurityException with the specified\n detail message and cause."
                },
                {
                  "signature": "public SecurityException(Throwable cause)",
                  "description": "Creates a SecurityException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "SecurityManager",
          "methods": [
            {
              "name": "SecurityManager",
              "overloads": [
                {
                  "signature": "public SecurityManager()",
                  "description": "Constructs a new SecurityManager.\n\n  If there is a security manager already installed, this method first\n calls the security manager's checkPermission method\n with the RuntimePermission(\"createSecurityManager\")\n permission to ensure the calling thread has permission to create a new\n security manager.\n This may result in throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getClassContext",
              "overloads": [
                {
                  "signature": "protected Class<?>[] getClassContext()",
                  "description": "Returns the current execution stack as an array of classes.\n \n The length of the array is the number of methods on the execution\n stack. The element at index 0 is the class of the\n currently executing method, the element at index 1 is\n the class of that method's caller, and so on.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSecurityContext",
              "overloads": [
                {
                  "signature": "public Object getSecurityContext()",
                  "description": "Creates an object that encapsulates the current execution\n environment. The result of this method is used, for example, by the\n three-argument checkConnect method and by the\n two-argument checkRead method.\n These methods are needed because a trusted method may be called\n on to read a file or open a socket on behalf of another method.\n The trusted method needs to determine if the other (possibly\n untrusted) method would be allowed to perform the operation on its\n own.\n  The default implementation of this method is to return\n an AccessControlContext object.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public void checkPermission(Permission perm)",
                  "description": "Throws a SecurityException if the requested\n access, specified by the given permission, is not permitted based\n on the security policy currently in effect.\n \n This method calls AccessController.checkPermission\n with the given permission.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkPermission(Permission perm, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is denied access to the resource\n specified by the given permission.\n The context must be a security\n context returned by a previous call to\n getSecurityContext and the access control\n decision is based upon the configured security policy for\n that security context.\n \n If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method is\n invoked with the specified permission.\n \n If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkCreateClassLoader",
              "overloads": [
                {
                  "signature": "public void checkCreateClassLoader()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to create a new class loader.\n \n This method calls checkPermission with the\n RuntimePermission(\"createClassLoader\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkCreateClassLoader\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "public void checkAccess(Thread t)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread argument.\n \n This method is invoked for the current security manager by the\n stop, suspend, resume,\n setPriority, setName, and\n setDaemon methods of class Thread.\n \n If the thread argument is a system thread (belongs to\n the thread group with a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThread\") permission.\n If the thread argument is not a system thread,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThread\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkAccess(ThreadGroup g)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread group argument.\n \n This method is invoked for the current security manager when a\n new child thread or child thread group is created, and by the\n setDaemon, setMaxPriority,\n stop, suspend, resume, and\n destroy methods of class ThreadGroup.\n \n If the thread group argument is the system thread group (\n has a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThreadGroup\") permission.\n If the thread group argument is not the system thread group,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThreadGroup\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkExit",
              "overloads": [
                {
                  "signature": "public void checkExit(int status)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to cause the Java Virtual Machine to\n halt with the specified status code.\n \n This method is invoked for the current security manager by the\n exit method of class Runtime. A status\n of 0 indicates success; other values indicate various\n errors.\n \n This method calls checkPermission with the\n RuntimePermission(\"exitVM.\"+status) permission.\n \n If you override this method, then you should make a call to\n super.checkExit\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkExec",
              "overloads": [
                {
                  "signature": "public void checkExec(String cmd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to create a subprocess.\n \n This method is invoked for the current security manager by the\n exec methods of class Runtime.\n \n This method calls checkPermission with the\n FilePermission(cmd,\"execute\") permission\n if cmd is an absolute path, otherwise it calls\n checkPermission with\n FilePermission(\"<<ALL FILES>>\",\"execute\").\n \n If you override this method, then you should make a call to\n super.checkExec\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkLink",
              "overloads": [
                {
                  "signature": "public void checkLink(String lib)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to dynamic link the library code\n specified by the string argument file. The argument is either a\n simple library name or a complete filename.\n \n This method is invoked for the current security manager by\n methods load and loadLibrary of class\n Runtime.\n \n This method calls checkPermission with the\n RuntimePermission(\"loadLibrary.\"+lib) permission.\n \n If you override this method, then you should make a call to\n super.checkLink\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkRead",
              "overloads": [
                {
                  "signature": "public void checkRead(FileDescriptor fd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to read from the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"readFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkRead(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to read the file specified by the\n string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkRead(String file, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is not allowed to read the file\n specified by the string argument. The context must be a security\n context returned by a previous call to\n getSecurityContext.\n  If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method will\n be invoked with the FilePermission(file,\"read\") permission.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkWrite",
              "overloads": [
                {
                  "signature": "public void checkWrite(FileDescriptor fd)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"writeFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkWrite(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the file specified by\n the string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"write\") permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkDelete",
              "overloads": [
                {
                  "signature": "public void checkDelete(String file)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to delete the specified file.\n \n This method is invoked for the current security manager by the\n delete method of class File.\n \n This method calls checkPermission with the\n FilePermission(file,\"delete\") permission.\n \n If you override this method, then you should make a call to\n super.checkDelete\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkConnect",
              "overloads": [
                {
                  "signature": "public void checkConnect(String host, int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to open a socket connection to the\n specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"connect\") permission if\n the port is not equal to -1. If the port is equal to -1, then\n it calls checkPermission with the\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "public void checkConnect(String host, int port, Object context)",
                  "description": "Throws a SecurityException if the\n specified security context is not allowed to open a socket\n connection to the specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n Otherwise, the port number is checked. If it is not equal\n to -1, the context's checkPermission\n method is called with a\n SocketPermission(host+\":\"+port,\"connect\") permission.\n If the port is equal to -1, then\n the context's checkPermission method\n is called with a\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkListen",
              "overloads": [
                {
                  "signature": "public void checkListen(int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to wait for a connection request on\n the specified local port number.\n \n This method calls checkPermission with the\n SocketPermission(\"localhost:\"+port,\"listen\").\n \n If you override this method, then you should make a call to\n super.checkListen\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkAccept",
              "overloads": [
                {
                  "signature": "public void checkAccept(String host, int port)",
                  "description": "Throws a SecurityException if the\n calling thread is not permitted to accept a socket connection from\n the specified host and port number.\n \n This method is invoked for the current security manager by the\n accept method of class ServerSocket.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"accept\") permission.\n \n If you override this method, then you should make a call to\n super.checkAccept\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkMulticast",
              "overloads": [
                {
                  "signature": "public void checkMulticast(InetAddress maddr)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"1.4\", forRemoval=true) public void checkMulticast(InetAddress maddr, byte ttl)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPropertiesAccess",
              "overloads": [
                {
                  "signature": "public void checkPropertiesAccess()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to access or modify the system\n properties.\n \n This method is used by the getProperties and\n setProperties methods of class System.\n \n This method calls checkPermission with the\n PropertyPermission(\"*\", \"read,write\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertiesAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPropertyAccess",
              "overloads": [
                {
                  "signature": "public void checkPropertyAccess(String key)",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to access the system property with\n the specified key name.\n \n This method is used by the getProperty method of\n class System.\n \n This method calls checkPermission with the\n PropertyPermission(key, \"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertyAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPrintJobAccess",
              "overloads": [
                {
                  "signature": "public void checkPrintJobAccess()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to initiate a print job request.\n \n This method calls\n checkPermission with the\n RuntimePermission(\"queuePrintJob\") permission.\n \n If you override this method, then you should make a call to\n super.checkPrintJobAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPackageAccess",
              "overloads": [
                {
                  "signature": "public void checkPackageAccess(String pkg)",
                  "description": "Throws a SecurityException if the calling thread is not allowed\n to access the specified package.\n \n During class loading, this method may be called by the loadClass\n method of class loaders and by the Java Virtual Machine to ensure that\n the caller is allowed to access the package of the class that is\n being loaded.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.access Security Property.\n An implementation may also check the package against an additional\n list of restricted packages as noted below. If the package is restricted,\n checkPermission(Permission) is called with a\n RuntimePermission(\"accessClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageAccess\n should be called as the first line in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPackageDefinition",
              "overloads": [
                {
                  "signature": "public void checkPackageDefinition(String pkg)",
                  "description": "Throws a SecurityException if the calling thread is not\n allowed to define classes in the specified package.\n \n This method is called by the loadClass method of some\n class loaders.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.definition Security\n Property. An implementation may also check the package against an\n additional list of restricted packages as noted below. If the package\n is restricted, checkPermission(Permission) is called with a\n RuntimePermission(\"defineClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageDefinition\n should be called as the first line in the overridden method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkSetFactory",
              "overloads": [
                {
                  "signature": "public void checkSetFactory()",
                  "description": "Throws a SecurityException if the\n calling thread is not allowed to set the socket factory used by\n ServerSocket or Socket, or the stream\n handler factory used by URL.\n \n This method calls checkPermission with the\n RuntimePermission(\"setFactory\") permission.\n \n If you override this method, then you should make a call to\n super.checkSetFactory\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkSecurityAccess",
              "overloads": [
                {
                  "signature": "public void checkSecurityAccess(String target)",
                  "description": "Determines whether the permission with the specified permission target\n name should be granted or denied.\n\n  If the requested permission is allowed, this method returns\n quietly. If denied, a SecurityException is raised.\n\n  This method creates a SecurityPermission object for\n the given permission target name and calls checkPermission\n with it.\n\n  See the documentation for\n SecurityPermission for\n a list of possible permission target names.\n\n  If you override this method, then you should make a call to\n super.checkSecurityAccess\n at the point the overridden method would normally throw an\n exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getThreadGroup",
              "overloads": [
                {
                  "signature": "public ThreadGroup getThreadGroup()",
                  "description": "Returns the thread group into which to instantiate any new\n thread being created at the time this is being called.\n By default, it returns the thread group of the current\n thread. This should be overridden by a specific security\n manager to return the appropriate thread group.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Short",
          "methods": [
            {
              "name": "Short",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Short(short value)",
                  "description": "Constructs a newly allocated Short object that\n represents the specified short value.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"9\", forRemoval=true) public Short(String s) throws NumberFormatException",
                  "description": "Constructs a newly allocated Short object that\n represents the short value indicated by the\n String parameter. The string is converted to a\n short value in exactly the manner used by the\n parseShort method for radix 10.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(short s)",
                  "description": "Returns a new String object representing the\n specified short. The radix is assumed to be 10."
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this\n Short's value.  The value is converted to signed\n decimal representation and returned as a string, exactly as if\n the short value were given as an argument to the\n toString(short) method."
                }
              ]
            },
            {
              "name": "parseShort",
              "overloads": [
                {
                  "signature": "public static short parseShort(String s, int radix) throws NumberFormatException",
                  "description": "Parses the string argument as a signed short in the\n radix specified by the second argument. The characters in the\n string must all be digits, of the specified radix (as\n determined by whether Character.digit(char, int) returns a nonnegative value) except that the first\n character may be an ASCII minus sign '-'\n ('\\u002D') to indicate a negative value or an\n ASCII plus sign '+' ('\\u002B') to\n indicate a positive value.  The resulting short value\n is returned.\n\n An exception of type NumberFormatException is\n thrown if any of the following situations occurs:\n \n  The first argument is null or is a string of\n length zero.\n\n  The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.\n\n  Any character of the string is not a digit of the\n specified radix, except that the first character may be a minus\n sign '-' ('\\u002D') or plus sign\n '+' ('\\u002B') provided that the\n string is longer than length 1.\n\n  The value represented by the string is not a value of type\n short."
                },
                {
                  "signature": "public static short parseShort(String s) throws NumberFormatException",
                  "description": "Parses the string argument as a signed decimal \n short. The characters in the string must all be decimal\n digits, except that the first character may be an ASCII minus\n sign '-' ('\\u002D') to indicate a\n negative value or an ASCII plus sign '+'\n ('\\u002B') to indicate a positive value.  The\n resulting short value is returned, exactly as if the\n argument and the radix 10 were given as arguments to the parseShort(java.lang.String, int) method."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Short valueOf(String s, int radix) throws NumberFormatException",
                  "description": "Returns a Short object holding the value\n extracted from the specified String when parsed\n with the radix given by the second argument. The first argument\n is interpreted as representing a signed short in\n the radix specified by the second argument, exactly as if the\n argument were given to the parseShort(java.lang.String, int) method. The result is a Short object that\n represents the short value specified by the string.\n\n In other words, this method returns a Short object\n equal to the value of:\n\n \n  new Short(Short.parseShort(s, radix))"
                },
                {
                  "signature": "public static Short valueOf(String s) throws NumberFormatException",
                  "description": "Returns a Short object holding the\n value given by the specified String. The argument\n is interpreted as representing a signed decimal\n short, exactly as if the argument were given to\n the parseShort(java.lang.String) method. The result is\n a Short object that represents the\n short value specified by the string.\n\n In other words, this method returns a Short object\n equal to the value of:\n\n \n  new Short(Short.parseShort(s))"
                },
                {
                  "signature": "public static Short valueOf(short s)",
                  "description": "Returns a Short instance representing the specified\n short value.\n If a new Short instance is not required, this method\n should generally be used in preference to the constructor\n Short(short), as this method is likely to yield\n significantly better space and time performance by caching\n frequently requested values.\n\n This method will always cache values in the range -128 to 127,\n inclusive, and may cache other values outside of this range."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<DynamicConstantDesc<Short>> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance."
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public static Short decode(String nm) throws NumberFormatException",
                  "description": "Decodes a String into a Short.\n Accepts decimal, hexadecimal, and octal numbers given by\n the following grammar:\n\n \n \n DecodableString:\n Signopt DecimalNumeral\n Signopt 0x HexDigits\n Signopt 0X HexDigits\n Signopt # HexDigits\n Signopt 0 OctalDigits\n\n Sign:\n -\n +\n \n \n\n DecimalNumeral, HexDigits, and OctalDigits\n are as defined in section 3.10.1 of\n The Java Language Specification,\n except that underscores are not accepted between digits.\n\n The sequence of characters following an optional\n sign and/or radix specifier (\"0x\", \"0X\",\n \"#\", or leading zero) is parsed as by the \n Short.parseShort method with the indicated radix (10, 16, or\n 8).  This sequence of characters must represent a positive\n value or a NumberFormatException will be thrown.  The\n result is negated if first character of the specified \n String is the minus sign.  No whitespace characters are\n permitted in the String."
                }
              ]
            },
            {
              "name": "byteValue",
              "overloads": [
                {
                  "signature": "public byte byteValue()",
                  "description": "Returns the value of this Short as a byte after\n a narrowing primitive conversion."
                }
              ]
            },
            {
              "name": "shortValue",
              "overloads": [
                {
                  "signature": "public short shortValue()",
                  "description": "Returns the value of this Short as a\n short."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Returns the value of this Short as an int after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Returns the value of this Short as a long after\n a widening primitive conversion."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Returns the value of this Short as a float\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Returns the value of this Short as a double\n after a widening primitive conversion."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this Short; equal to the result\n of invoking intValue()."
                },
                {
                  "signature": "public static int hashCode(short value)",
                  "description": "Returns a hash code for a short value; compatible with\n Short.hashCode()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is\n true if and only if the argument is not\n null and is a Short object that\n contains the same short value as this object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Short anotherShort)",
                  "description": "Compares two Short objects numerically."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(short x, short y)",
                  "description": "Compares two short values numerically.\n The value returned is identical to what would be returned by:\n     Short.valueOf(x).compareTo(Short.valueOf(y))"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(short x, short y)",
                  "description": "Compares two short values numerically treating the values\n as unsigned."
                }
              ]
            },
            {
              "name": "reverseBytes",
              "overloads": [
                {
                  "signature": "public static short reverseBytes(short i)",
                  "description": "Returns the value obtained by reversing the order of the bytes in the\n two's complement representation of the specified short value."
                }
              ]
            },
            {
              "name": "toUnsignedInt",
              "overloads": [
                {
                  "signature": "public static int toUnsignedInt(short x)",
                  "description": "Converts the argument to an int by an unsigned\n conversion.  In an unsigned conversion to an int, the\n high-order 16 bits of the int are zero and the\n low-order 16 bits are equal to the bits of the short argument.\n\n Consequently, zero and positive short values are mapped\n to a numerically equal int value and negative \n short values are mapped to an int value equal to the\n input plus 216."
                }
              ]
            },
            {
              "name": "toUnsignedLong",
              "overloads": [
                {
                  "signature": "public static long toUnsignedLong(short x)",
                  "description": "Converts the argument to a long by an unsigned\n conversion.  In an unsigned conversion to a long, the\n high-order 48 bits of the long are zero and the\n low-order 16 bits are equal to the bits of the short argument.\n\n Consequently, zero and positive short values are mapped\n to a numerically equal long value and negative \n short values are mapped to a long value equal to the\n input plus 216."
                }
              ]
            }
          ]
        },
        {
          "name": "StackOverflowError",
          "methods": [
            {
              "name": "StackOverflowError",
              "overloads": [
                {
                  "signature": "public StackOverflowError()",
                  "description": "Constructs a StackOverflowError with no detail message."
                },
                {
                  "signature": "public StackOverflowError(String s)",
                  "description": "Constructs a StackOverflowError with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "StackTraceElement",
          "methods": [
            {
              "name": "StackTraceElement",
              "overloads": [
                {
                  "signature": "public StackTraceElement(String declaringClass, String methodName, String fileName, int lineNumber)",
                  "description": "Creates a stack trace element representing the specified execution\n point. The module name and module version of the stack trace element will\n be null."
                },
                {
                  "signature": "public StackTraceElement(String classLoaderName, String moduleName, String moduleVersion, String declaringClass, String methodName, String fileName, int lineNumber)",
                  "description": "Creates a stack trace element representing the specified execution\n point."
                }
              ]
            },
            {
              "name": "getFileName",
              "overloads": [
                {
                  "signature": "public String getFileName()",
                  "description": "Returns the name of the source file containing the execution point\n represented by this stack trace element.  Generally, this corresponds\n to the SourceFile attribute of the relevant class\n file (as per The Java Virtual Machine Specification, Section\n 4.7.7).  In some systems, the name may refer to some source code unit\n other than a file, such as an entry in source repository."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Returns the line number of the source line containing the execution\n point represented by this stack trace element.  Generally, this is\n derived from the LineNumberTable attribute of the relevant\n class file (as per The Java Virtual Machine\n Specification, Section 4.7.8)."
                }
              ]
            },
            {
              "name": "getModuleName",
              "overloads": [
                {
                  "signature": "public String getModuleName()",
                  "description": "Returns the module name of the module containing the execution point\n represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getModuleVersion",
              "overloads": [
                {
                  "signature": "public String getModuleVersion()",
                  "description": "Returns the module version of the module containing the execution point\n represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getClassLoaderName",
              "overloads": [
                {
                  "signature": "public String getClassLoaderName()",
                  "description": "Returns the name of the class loader of the class containing the\n execution point represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "public String getClassName()",
                  "description": "Returns the fully qualified name of the class containing the\n execution point represented by this stack trace element."
                }
              ]
            },
            {
              "name": "getMethodName",
              "overloads": [
                {
                  "signature": "public String getMethodName()",
                  "description": "Returns the name of the method containing the execution point\n represented by this stack trace element.  If the execution point is\n contained in an instance or class initializer, this method will return\n the appropriate special method name, <init> or\n <clinit>, as per Section 3.9 of The Java Virtual\n Machine Specification."
                }
              ]
            },
            {
              "name": "isNativeMethod",
              "overloads": [
                {
                  "signature": "public boolean isNativeMethod()",
                  "description": "Returns true if the method containing the execution point\n represented by this stack trace element is a native method."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this stack trace element."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if the specified object is another\n StackTraceElement instance representing the same execution\n point as this instance.  Two stack trace elements a and\n b are equal if and only if:\n \n     equals(a.getClassLoaderName(), b.getClassLoaderName()) &&\n     equals(a.getModuleName(), b.getModuleName()) &&\n     equals(a.getModuleVersion(), b.getModuleVersion()) &&\n     equals(a.getClassName(), b.getClassName()) &&\n     equals(a.getMethodName(), b.getMethodName())\n     equals(a.getFileName(), b.getFileName()) &&\n     a.getLineNumber() == b.getLineNumber()\n\n \n where equals has the semantics of Objects.equals."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for this stack trace element."
                }
              ]
            }
          ]
        },
        {
          "name": "StackWalker",
          "methods": [
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static StackWalker getInstance()",
                  "description": "Returns a StackWalker instance.\n\n  This StackWalker is configured to skip all\n hidden frames and\n no class reference is retained."
                },
                {
                  "signature": "public static StackWalker getInstance(StackWalker.Option option)",
                  "description": "Returns a StackWalker instance with the given option specifying\n the stack frame information it can access.\n\n \n If a security manager is present and the given option is\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\")."
                },
                {
                  "signature": "public static StackWalker getInstance(Set<StackWalker.Option> options)",
                  "description": "Returns a StackWalker instance with the given options specifying\n the stack frame information it can access.  If the given options\n is empty, this StackWalker is configured to skip all\n hidden frames and no\n class reference is retained.\n\n \n If a security manager is present and the given options contains\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\")."
                },
                {
                  "signature": "public static StackWalker getInstance(Set<StackWalker.Option> options, int estimateDepth)",
                  "description": "Returns a StackWalker instance with the given options specifying\n the stack frame information it can access. If the given options\n is empty, this StackWalker is configured to skip all\n hidden frames and no\n class reference is retained.\n\n \n If a security manager is present and the given options contains\n Option.RETAIN_CLASS_REFERENCE,\n it calls its checkPermission\n method for RuntimePermission(\"getStackWalkerWithClassReference\").\n\n \n The estimateDepth specifies the estimate number of stack frames\n this StackWalker will traverse that the StackWalker could\n use as a hint for the buffer size."
                }
              ]
            },
            {
              "name": "walk",
              "overloads": [
                {
                  "signature": "public <T> T walk(Function<? super Stream<StackWalker.StackFrame>,? extends T> function)",
                  "description": "Applies the given function to the stream of StackFrames\n for the current thread, traversing from the top frame of the stack,\n which is the method calling this walk method.\n\n The StackFrame stream will be closed when\n this method returns.  When a closed Stream<StackFrame> object\n is reused, IllegalStateException will be thrown."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super StackWalker.StackFrame> action)",
                  "description": "Performs the given action on each element of StackFrame stream\n of the current thread, traversing from the top frame of the stack,\n which is the method calling this forEach method.\n\n  This method is equivalent to calling\n \n walk(s -> { s.forEach(action); return null; });"
                }
              ]
            },
            {
              "name": "getCallerClass",
              "overloads": [
                {
                  "signature": "public Class<?> getCallerClass()",
                  "description": "Gets the Class object of the caller who invoked the method\n that invoked getCallerClass.\n\n  This method filters reflection\n frames, MethodHandle, and\n hidden frames regardless of the\n SHOW_REFLECT_FRAMES\n and SHOW_HIDDEN_FRAMES options\n this StackWalker has been configured with.\n\n  This method should be called when a caller frame is present.  If\n it is called from the bottom most frame on the stack,\n IllegalCallerException will be thrown.\n\n  This method throws UnsupportedOperationException\n if this StackWalker is not configured with the\n RETAIN_CLASS_REFERENCE option."
                }
              ]
            }
          ]
        },
        {
          "name": "StackWalker.StackFrame",
          "methods": [
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "String getClassName()",
                  "description": "Gets the binary name\n of the declaring class of the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getMethodName",
              "overloads": [
                {
                  "signature": "String getMethodName()",
                  "description": "Gets the name of the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getDeclaringClass",
              "overloads": [
                {
                  "signature": "Class<?> getDeclaringClass()",
                  "description": "Gets the declaring Class for the method represented by\n this stack frame."
                }
              ]
            },
            {
              "name": "getMethodType",
              "overloads": [
                {
                  "signature": "default MethodType getMethodType()",
                  "description": "Returns the MethodType representing the parameter types and\n the return type for the method represented by this stack frame."
                }
              ]
            },
            {
              "name": "getDescriptor",
              "overloads": [
                {
                  "signature": "default String getDescriptor()",
                  "description": "Returns the descriptor of the method represented by\n this stack frame as defined by\n The Java Virtual Machine Specification."
                }
              ]
            },
            {
              "name": "getByteCodeIndex",
              "overloads": [
                {
                  "signature": "int getByteCodeIndex()",
                  "description": "Returns the index to the code array of the Code attribute\n containing the execution point represented by this stack frame.\n The code array gives the actual bytes of Java Virtual Machine code\n that implement the method."
                }
              ]
            },
            {
              "name": "getFileName",
              "overloads": [
                {
                  "signature": "String getFileName()",
                  "description": "Returns the name of the source file containing the execution point\n represented by this stack frame.  Generally, this corresponds\n to the SourceFile attribute of the relevant class\n file as defined by The Java Virtual Machine Specification.\n In some systems, the name may refer to some source code unit\n other than a file, such as an entry in a source repository."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "int getLineNumber()",
                  "description": "Returns the line number of the source line containing the execution\n point represented by this stack frame.  Generally, this is\n derived from the LineNumberTable attribute of the relevant\n class file as defined by The Java Virtual Machine\n Specification."
                }
              ]
            },
            {
              "name": "isNativeMethod",
              "overloads": [
                {
                  "signature": "boolean isNativeMethod()",
                  "description": "Returns true if the method containing the execution point\n represented by this stack frame is a native method."
                }
              ]
            },
            {
              "name": "toStackTraceElement",
              "overloads": [
                {
                  "signature": "StackTraceElement toStackTraceElement()",
                  "description": "Gets a StackTraceElement for this stack frame."
                }
              ]
            }
          ]
        },
        {
          "name": "StrictMath",
          "methods": [
            {
              "name": "sin",
              "overloads": [
                {
                  "signature": "public static double sin(double a)",
                  "description": "Returns the trigonometric sine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "cos",
              "overloads": [
                {
                  "signature": "public static double cos(double a)",
                  "description": "Returns the trigonometric cosine of an angle. Special cases:\n If the argument is NaN or an infinity, then the\n result is NaN.\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "tan",
              "overloads": [
                {
                  "signature": "public static double tan(double a)",
                  "description": "Returns the trigonometric tangent of an angle. Special cases:\n If the argument is NaN or an infinity, then the result\n is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "asin",
              "overloads": [
                {
                  "signature": "public static double asin(double a)",
                  "description": "Returns the arc sine of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "acos",
              "overloads": [
                {
                  "signature": "public static double acos(double a)",
                  "description": "Returns the arc cosine of a value; the returned angle is in the\n range 0.0 through pi.  Special case:\n If the argument is NaN or its absolute value is greater\n than 1, then the result is NaN.\n If the argument is 1.0, the result is positive zero."
                }
              ]
            },
            {
              "name": "atan",
              "overloads": [
                {
                  "signature": "public static double atan(double a)",
                  "description": "Returns the arc tangent of a value; the returned angle is in the\n range -pi/2 through pi/2.  Special cases:\n If the argument is NaN, then the result is NaN.\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n If the argument is infinite,\n then the result is the closest value to pi/2 with the\n same sign as the input."
                }
              ]
            },
            {
              "name": "toRadians",
              "overloads": [
                {
                  "signature": "public static double toRadians(double angdeg)",
                  "description": "Converts an angle measured in degrees to an approximately\n equivalent angle measured in radians.  The conversion from\n degrees to radians is generally inexact."
                }
              ]
            },
            {
              "name": "toDegrees",
              "overloads": [
                {
                  "signature": "public static double toDegrees(double angrad)",
                  "description": "Converts an angle measured in radians to an approximately\n equivalent angle measured in degrees.  The conversion from\n radians to degrees is generally inexact; users should\n not expect cos(toRadians(90.0)) to exactly\n equal 0.0."
                }
              ]
            },
            {
              "name": "exp",
              "overloads": [
                {
                  "signature": "public static double exp(double a)",
                  "description": "Returns Euler's number e raised to the power of a\n double value. Special cases:\n If the argument is NaN, the result is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is negative infinity, then the result is\n positive zero.\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "public static double log(double a)",
                  "description": "Returns the natural logarithm (base e) of a double\n value. Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is 1.0, then the result is positive\n zero."
                }
              ]
            },
            {
              "name": "log10",
              "overloads": [
                {
                  "signature": "public static double log10(double a)",
                  "description": "Returns the base 10 logarithm of a double value.\n Special cases:\n\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is\n positive infinity.\n If the argument is positive zero or negative zero, then the\n result is negative infinity.\n If the argument is equal to 10n for\n integer n, then the result is n. In particular,\n if the argument is 1.0 (100), then the\n result is positive zero."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public static double sqrt(double a)",
                  "description": "Returns the correctly rounded positive square root of a\n double value.\n Special cases:\n If the argument is NaN or less than zero, then the result\n is NaN.\n If the argument is positive infinity, then the result is positive\n infinity.\n If the argument is positive zero or negative zero, then the\n result is the same as the argument.\n Otherwise, the result is the double value closest to\n the true mathematical square root of the argument value."
                }
              ]
            },
            {
              "name": "cbrt",
              "overloads": [
                {
                  "signature": "public static double cbrt(double a)",
                  "description": "Returns the cube root of a double value.  For\n positive finite x, cbrt(-x) ==\n -cbrt(x); that is, the cube root of a negative value is\n the negative of the cube root of that value's magnitude.\n Special cases:\n\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "IEEEremainder",
              "overloads": [
                {
                  "signature": "public static double IEEEremainder(double f1, double f2)",
                  "description": "Computes the remainder operation on two arguments as prescribed\n by the IEEE 754 standard.\n The remainder value is mathematically equal to\n f1-f2n,\n where n is the mathematical integer closest to the exact\n mathematical value of the quotient f1/f2, and if two\n mathematical integers are equally close to f1/f2,\n then n is the integer that is even. If the remainder is\n zero, its sign is the same as the sign of the first argument.\n Special cases:\n If either argument is NaN, or the first argument is infinite,\n or the second argument is positive zero or negative zero, then the\n result is NaN.\n If the first argument is finite and the second argument is\n infinite, then the result is the same as the first argument."
                }
              ]
            },
            {
              "name": "ceil",
              "overloads": [
                {
                  "signature": "public static double ceil(double a)",
                  "description": "Returns the smallest (closest to negative infinity)\n double value that is greater than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument.  If the argument value is less than zero but\n greater than -1.0, then the result is negative zero. Note\n that the value of StrictMath.ceil(x) is exactly the\n value of -StrictMath.floor(-x)."
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "public static double floor(double a)",
                  "description": "Returns the largest (closest to positive infinity)\n double value that is less than or equal to the\n argument and is equal to a mathematical integer. Special cases:\n If the argument value is already equal to a\n mathematical integer, then the result is the same as the\n argument.  If the argument is NaN or an infinity or\n positive zero or negative zero, then the result is the same as\n the argument."
                }
              ]
            },
            {
              "name": "rint",
              "overloads": [
                {
                  "signature": "public static double rint(double a)",
                  "description": "Returns the double value that is closest in value\n to the argument and is equal to a mathematical integer. If two\n double values that are mathematical integers are\n equally close to the value of the argument, the result is the\n integer value that is even. Special cases:\n If the argument value is already equal to a mathematical\n integer, then the result is the same as the argument.\n If the argument is NaN or an infinity or positive zero or negative\n zero, then the result is the same as the argument."
                }
              ]
            },
            {
              "name": "atan2",
              "overloads": [
                {
                  "signature": "public static double atan2(double y, double x)",
                  "description": "Returns the angle theta from the conversion of rectangular\n coordinates (x,y) to polar\n coordinates (r,theta).\n This method computes the phase theta by computing an arc tangent\n of y/x in the range of -pi to pi. Special\n cases:\n If either argument is NaN, then the result is NaN.\n If the first argument is positive zero and the second argument\n is positive, or the first argument is positive and finite and the\n second argument is positive infinity, then the result is positive\n zero.\n If the first argument is negative zero and the second argument\n is positive, or the first argument is negative and finite and the\n second argument is positive infinity, then the result is negative zero.\n If the first argument is positive zero and the second argument\n is negative, or the first argument is positive and finite and the\n second argument is negative infinity, then the result is the\n double value closest to pi.\n If the first argument is negative zero and the second argument\n is negative, or the first argument is negative and finite and the\n second argument is negative infinity, then the result is the\n double value closest to -pi.\n If the first argument is positive and the second argument is\n positive zero or negative zero, or the first argument is positive\n infinity and the second argument is finite, then the result is the\n double value closest to pi/2.\n If the first argument is negative and the second argument is\n positive zero or negative zero, or the first argument is negative\n infinity and the second argument is finite, then the result is the\n double value closest to -pi/2.\n If both arguments are positive infinity, then the result is the\n double value closest to pi/4.\n If the first argument is positive infinity and the second argument\n is negative infinity, then the result is the double\n value closest to 3*pi/4.\n If the first argument is negative infinity and the second argument\n is positive infinity, then the result is the double value\n closest to -pi/4.\n If both arguments are negative infinity, then the result is the\n double value closest to -3*pi/4."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public static double pow(double a, double b)",
                  "description": "Returns the value of the first argument raised to the power of the\n second argument. Special cases:\n\n If the second argument is positive or negative zero, then the\n result is 1.0.\n If the second argument is 1.0, then the result is the same as the\n first argument.\n If the second argument is NaN, then the result is NaN.\n If the first argument is NaN and the second argument is nonzero,\n then the result is NaN.\n\n If\n \n the absolute value of the first argument is greater than 1\n and the second argument is positive infinity, or\n the absolute value of the first argument is less than 1 and\n the second argument is negative infinity,\n \n then the result is positive infinity.\n\n If\n \n the absolute value of the first argument is greater than 1 and\n the second argument is negative infinity, or\n the absolute value of the\n first argument is less than 1 and the second argument is positive\n infinity,\n \n then the result is positive zero.\n\n If the absolute value of the first argument equals 1 and the\n second argument is infinite, then the result is NaN.\n\n If\n \n the first argument is positive zero and the second argument\n is greater than zero, or\n the first argument is positive infinity and the second\n argument is less than zero,\n \n then the result is positive zero.\n\n If\n \n the first argument is positive zero and the second argument\n is less than zero, or\n the first argument is positive infinity and the second\n argument is greater than zero,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is greater than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is less than zero but not a finite odd integer,\n \n then the result is positive zero.\n\n If\n \n the first argument is negative zero and the second argument\n is a positive finite odd integer, or\n the first argument is negative infinity and the second\n argument is a negative finite odd integer,\n \n then the result is negative zero.\n\n If\n \n the first argument is negative zero and the second argument\n is less than zero but not a finite odd integer, or\n the first argument is negative infinity and the second\n argument is greater than zero but not a finite odd integer,\n \n then the result is positive infinity.\n\n If\n \n the first argument is negative zero and the second argument\n is a negative finite odd integer, or\n the first argument is negative infinity and the second\n argument is a positive finite odd integer,\n \n then the result is negative infinity.\n\n If the first argument is finite and less than zero\n \n  if the second argument is a finite even integer, the\n result is equal to the result of raising the absolute value of\n the first argument to the power of the second argument\n\n if the second argument is a finite odd integer, the result\n is equal to the negative of the result of raising the absolute\n value of the first argument to the power of the second\n argument\n\n if the second argument is finite and not an integer, then\n the result is NaN.\n \n\n If both arguments are integers, then the result is exactly equal\n to the mathematical result of raising the first argument to the power\n of the second argument if that result can in fact be represented\n exactly as a double value.\n\n (In the foregoing descriptions, a floating-point value is\n considered to be an integer if and only if it is finite and a\n fixed point of the method ceil or,\n equivalently, a fixed point of the method floor. A value is a fixed point of a one-argument\n method if and only if the result of applying the method to the\n value is equal to the value.)"
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public static int round(float a)",
                  "description": "Returns the closest int to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Integer.MIN_VALUE, the result is\n equal to the value of Integer.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Integer.MAX_VALUE, the result is\n equal to the value of Integer.MAX_VALUE."
                },
                {
                  "signature": "public static long round(double a)",
                  "description": "Returns the closest long to the argument, with ties\n rounding to positive infinity.\n\n Special cases:\n If the argument is NaN, the result is 0.\n If the argument is negative infinity or any value less than or\n equal to the value of Long.MIN_VALUE, the result is\n equal to the value of Long.MIN_VALUE.\n If the argument is positive infinity or any value greater than or\n equal to the value of Long.MAX_VALUE, the result is\n equal to the value of Long.MAX_VALUE."
                }
              ]
            },
            {
              "name": "random",
              "overloads": [
                {
                  "signature": "public static double random()",
                  "description": "Returns a double value with a positive sign, greater\n than or equal to 0.0 and less than 1.0.\n Returned values are chosen pseudorandomly with (approximately)\n uniform distribution from that range.\n\n When this method is first called, it creates a single new\n pseudorandom-number generator, exactly as if by the expression\n\n new java.util.Random()\n\n This new pseudorandom-number generator is used thereafter for\n all calls to this method and is used nowhere else.\n\n This method is properly synchronized to allow correct use by\n more than one thread. However, if many threads need to generate\n pseudorandom numbers at a great rate, it may reduce contention\n for each thread to have its own pseudorandom-number generator."
                }
              ]
            },
            {
              "name": "addExact",
              "overloads": [
                {
                  "signature": "public static int addExact(int x, int y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long addExact(long x, long y)",
                  "description": "Returns the sum of its arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "subtractExact",
              "overloads": [
                {
                  "signature": "public static int subtractExact(int x, int y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long subtractExact(long x, long y)",
                  "description": "Returns the difference of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "multiplyExact",
              "overloads": [
                {
                  "signature": "public static int multiplyExact(int x, int y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows an int."
                },
                {
                  "signature": "public static long multiplyExact(long x, int y)",
                  "description": "Returns the product of the arguments, throwing an exception if the result\n overflows a long."
                },
                {
                  "signature": "public static long multiplyExact(long x, long y)",
                  "description": "Returns the product of the arguments,\n throwing an exception if the result overflows a long."
                }
              ]
            },
            {
              "name": "incrementExact",
              "overloads": [
                {
                  "signature": "public static int incrementExact(int a)",
                  "description": "Returns the argument incremented by one,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the maximum value."
                },
                {
                  "signature": "public static long incrementExact(long a)",
                  "description": "Returns the argument incremented by one,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the maximum value."
                }
              ]
            },
            {
              "name": "decrementExact",
              "overloads": [
                {
                  "signature": "public static int decrementExact(int a)",
                  "description": "Returns the argument decremented by one,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long decrementExact(long a)",
                  "description": "Returns the argument decremented by one,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "negateExact",
              "overloads": [
                {
                  "signature": "public static int negateExact(int a)",
                  "description": "Returns the negation of the argument,\n throwing an exception if the result overflows an int.\n The overflow only occurs for the minimum value."
                },
                {
                  "signature": "public static long negateExact(long a)",
                  "description": "Returns the negation of the argument,\n throwing an exception if the result overflows a long.\n The overflow only occurs for the minimum value."
                }
              ]
            },
            {
              "name": "toIntExact",
              "overloads": [
                {
                  "signature": "public static int toIntExact(long value)",
                  "description": "Returns the value of the long argument, throwing an exception\n if the value overflows an int."
                }
              ]
            },
            {
              "name": "multiplyFull",
              "overloads": [
                {
                  "signature": "public static long multiplyFull(int x, int y)",
                  "description": "Returns the exact mathematical product of the arguments."
                }
              ]
            },
            {
              "name": "multiplyHigh",
              "overloads": [
                {
                  "signature": "public static long multiplyHigh(long x, long y)",
                  "description": "Returns as a long the most significant 64 bits of the 128-bit\n product of two 64-bit factors."
                }
              ]
            },
            {
              "name": "floorDiv",
              "overloads": [
                {
                  "signature": "public static int floorDiv(int x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n int value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Integer.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to the Integer.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                },
                {
                  "signature": "public static long floorDiv(long x, int y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to Long.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                },
                {
                  "signature": "public static long floorDiv(long x, long y)",
                  "description": "Returns the largest (closest to positive infinity)\n long value that is less than or equal to the algebraic quotient.\n There is one special case, if the dividend is the\n Long.MIN_VALUE and the divisor is -1,\n then integer overflow occurs and\n the result is equal to the Long.MIN_VALUE.\n \n See Math.floorDiv for examples and\n a comparison to the integer division / operator."
                }
              ]
            },
            {
              "name": "floorMod",
              "overloads": [
                {
                  "signature": "public static int floorMod(int x, int y)",
                  "description": "Returns the floor modulus of the int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                },
                {
                  "signature": "public static int floorMod(long x, int y)",
                  "description": "Returns the floor modulus of the long and int arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                },
                {
                  "signature": "public static long floorMod(long x, long y)",
                  "description": "Returns the floor modulus of the long arguments.\n \n The floor modulus is x - (floorDiv(x, y) * y),\n has the same sign as the divisor y, and\n is in the range of -abs(y) < r < +abs(y).\n \n The relationship between floorDiv and floorMod is such that:\n \n   floorDiv(x, y) * y + floorMod(x, y) == x\n \n \n See Math.floorMod for examples and\n a comparison to the % operator."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public static int abs(int a)",
                  "description": "Returns the absolute value of an int value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int\n value, the result is that same value, which is negative. In\n contrast, the absExact(int) method throws an\n ArithmeticException for this value."
                },
                {
                  "signature": "public static long abs(long a)",
                  "description": "Returns the absolute value of a long value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n\n Note that if the argument is equal to the value of Long.MIN_VALUE, the most negative representable long\n value, the result is that same value, which is negative. In\n contrast, the absExact(long) method throws\n an ArithmeticException for this value."
                },
                {
                  "signature": "public static float abs(float a)",
                  "description": "Returns the absolute value of a float value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the\n result is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                },
                {
                  "signature": "public static double abs(double a)",
                  "description": "Returns the absolute value of a double value.\n If the argument is not negative, the argument is returned.\n If the argument is negative, the negation of the argument is returned.\n Special cases:\n If the argument is positive zero or negative zero, the result\n is positive zero.\n If the argument is infinite, the result is positive infinity.\n If the argument is NaN, the result is NaN."
                }
              ]
            },
            {
              "name": "absExact",
              "overloads": [
                {
                  "signature": "public static int absExact(int a)",
                  "description": "Returns the mathematical absolute value of an int value\n if it is exactly representable as an int, throwing\n ArithmeticException if the result overflows the\n positive int range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Integer.MIN_VALUE\n overflows the positive int range, so an exception is\n thrown for that argument."
                },
                {
                  "signature": "public static long absExact(long a)",
                  "description": "Returns the mathematical absolute value of an long value\n if it is exactly representable as an long, throwing\n ArithmeticException if the result overflows the\n positive long range.\n\n Since the range of two's complement integers is asymmetric\n with one additional negative value (JLS 4.2.1), the\n mathematical absolute value of Long.MIN_VALUE overflows\n the positive long range, so an exception is thrown for\n that argument."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static int max(int a, int b)",
                  "description": "Returns the greater of two int values. That is, the\n result is the argument closer to the value of\n Integer.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static long max(long a, long b)",
                  "description": "Returns the greater of two long values. That is, the\n result is the argument closer to the value of\n Long.MAX_VALUE. If the arguments have the same value,\n the result is that same value."
                },
                {
                  "signature": "public static float max(float a, float b)",
                  "description": "Returns the greater of two float values.  That is,\n the result is the argument closer to positive infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                },
                {
                  "signature": "public static double max(double a, double b)",
                  "description": "Returns the greater of two double values.  That\n is, the result is the argument closer to positive infinity. If\n the arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other negative zero, the\n result is positive zero."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static int min(int a, int b)",
                  "description": "Returns the smaller of two int values. That is,\n the result the argument closer to the value of\n Integer.MIN_VALUE.  If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static long min(long a, long b)",
                  "description": "Returns the smaller of two long values. That is,\n the result is the argument closer to the value of\n Long.MIN_VALUE. If the arguments have the same\n value, the result is that same value."
                },
                {
                  "signature": "public static float min(float a, float b)",
                  "description": "Returns the smaller of two float values.  That is,\n the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero.  If\n one argument is positive zero and the other is negative zero,\n the result is negative zero."
                },
                {
                  "signature": "public static double min(double a, double b)",
                  "description": "Returns the smaller of two double values.  That\n is, the result is the value closer to negative infinity. If the\n arguments have the same value, the result is that same\n value. If either value is NaN, then the result is NaN.  Unlike\n the numerical comparison operators, this method considers\n negative zero to be strictly smaller than positive zero. If one\n argument is positive zero and the other is negative zero, the\n result is negative zero."
                }
              ]
            },
            {
              "name": "fma",
              "overloads": [
                {
                  "signature": "public static double fma(double a, double b, double c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n double.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fusedMac(a, 1.0, c) returns the same\n result as (a + c).  However,\n fusedMac(a, b, +0.0) does not always return the\n same result as (a * b) since\n fusedMac(-0.0, +0.0, +0.0) is +0.0 while\n (-0.0 * +0.0) is -0.0; fusedMac(a, b, -0.0) is\n equivalent to (a * b) however."
                },
                {
                  "signature": "public static float fma(float a, float b, float c)",
                  "description": "Returns the fused multiply add of the three arguments; that is,\n returns the exact product of the first two arguments summed\n with the third argument and then rounded once to the nearest\n float.\n\n The rounding is done using the round to nearest even\n rounding mode.\n\n In contrast, if a * b + c is evaluated as a regular\n floating-point expression, two rounding errors are involved,\n the first for the multiply operation, the second for the\n addition operation.\n\n Special cases:\n \n  If any argument is NaN, the result is NaN.\n\n  If one of the first two arguments is infinite and the\n other is zero, the result is NaN.\n\n  If the exact product of the first two arguments is infinite\n (in other words, at least one of the arguments is infinite and\n the other is neither zero nor NaN) and the third argument is an\n infinity of the opposite sign, the result is NaN.\n\n \n\n Note that fma(a, 1.0f, c) returns the same\n result as (a + c).  However,\n fma(a, b, +0.0f) does not always return the\n same result as (a * b) since\n fma(-0.0f, +0.0f, +0.0f) is +0.0f while\n (-0.0f * +0.0f) is -0.0f; fma(a, b, -0.0f) is\n equivalent to (a * b) however."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public static double ulp(double d)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a double value is the positive\n distance between this floating-point value and the \n double value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Double.MIN_VALUE.\n  If the argument is Double.MAX_VALUE, then\n the result is equal to 2971."
                },
                {
                  "signature": "public static float ulp(float f)",
                  "description": "Returns the size of an ulp of the argument.  An ulp, unit in\n the last place, of a float value is the positive\n distance between this floating-point value and the \n float value next larger in magnitude.  Note that for non-NaN\n x, ulp(-x) == ulp(x).\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive or negative infinity, then the\n result is positive infinity.\n  If the argument is positive or negative zero, then the result is\n Float.MIN_VALUE.\n  If the argument is Float.MAX_VALUE, then\n the result is equal to 2104."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public static double signum(double d)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0 if the argument is greater than zero, -1.0 if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                },
                {
                  "signature": "public static float signum(float f)",
                  "description": "Returns the signum function of the argument; zero if the argument\n is zero, 1.0f if the argument is greater than zero, -1.0f if the\n argument is less than zero.\n\n Special Cases:\n \n  If the argument is NaN, then the result is NaN.\n  If the argument is positive zero or negative zero, then the\n      result is the same as the argument."
                }
              ]
            },
            {
              "name": "sinh",
              "overloads": [
                {
                  "signature": "public static double sinh(double x)",
                  "description": "Returns the hyperbolic sine of a double value.\n The hyperbolic sine of x is defined to be\n (ex-e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is an infinity\n with the same sign as the argument.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "cosh",
              "overloads": [
                {
                  "signature": "public static double cosh(double x)",
                  "description": "Returns the hyperbolic cosine of a double value.\n The hyperbolic cosine of x is defined to be\n (ex+e-x)/2\n where e is Euler's number.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is infinite, then the result is positive\n infinity.\n\n If the argument is zero, then the result is 1.0."
                }
              ]
            },
            {
              "name": "tanh",
              "overloads": [
                {
                  "signature": "public static double tanh(double x)",
                  "description": "Returns the hyperbolic tangent of a double value.\n The hyperbolic tangent of x is defined to be\n (ex-e-x)/(ex+e-x),\n in other words, sinh(x)/cosh(x).  Note\n that the absolute value of the exact tanh is always less than\n 1.\n\n Special cases:\n \n\n If the argument is NaN, then the result is NaN.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument.\n\n If the argument is positive infinity, then the result is\n +1.0.\n\n If the argument is negative infinity, then the result is\n -1.0."
                }
              ]
            },
            {
              "name": "hypot",
              "overloads": [
                {
                  "signature": "public static double hypot(double x, double y)",
                  "description": "Returns sqrt(x2+y2)\n without intermediate overflow or underflow.\n\n Special cases:\n \n\n  If either argument is infinite, then the result\n is positive infinity.\n\n  If either argument is NaN and neither argument is infinite,\n then the result is NaN.\n\n  If both arguments are zero, the result is positive zero."
                }
              ]
            },
            {
              "name": "expm1",
              "overloads": [
                {
                  "signature": "public static double expm1(double x)",
                  "description": "Returns ex-1.  Note that for values of\n x near 0, the exact sum of\n expm1(x)+1 is much closer to the true\n result of ex than exp(x).\n\n Special cases:\n \n If the argument is NaN, the result is NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative infinity, then the result is\n -1.0.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "log1p",
              "overloads": [
                {
                  "signature": "public static double log1p(double x)",
                  "description": "Returns the natural logarithm of the sum of the argument and 1.\n Note that for small values x, the result of\n log1p(x) is much closer to the true result of ln(1\n + x) than the floating-point evaluation of\n log(1.0+x).\n\n Special cases:\n \n\n If the argument is NaN or less than -1, then the result is\n NaN.\n\n If the argument is positive infinity, then the result is\n positive infinity.\n\n If the argument is negative one, then the result is\n negative infinity.\n\n If the argument is zero, then the result is a zero with the\n same sign as the argument."
                }
              ]
            },
            {
              "name": "copySign",
              "overloads": [
                {
                  "signature": "public static double copySign(double magnitude, double sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  For this method, a NaN\n sign argument is always treated as if it were\n positive."
                },
                {
                  "signature": "public static float copySign(float magnitude, float sign)",
                  "description": "Returns the first floating-point argument with the sign of the\n second floating-point argument.  For this method, a NaN\n sign argument is always treated as if it were\n positive."
                }
              ]
            },
            {
              "name": "getExponent",
              "overloads": [
                {
                  "signature": "public static int getExponent(float f)",
                  "description": "Returns the unbiased exponent used in the representation of a\n float.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Float.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Float.MIN_EXPONENT -1."
                },
                {
                  "signature": "public static int getExponent(double d)",
                  "description": "Returns the unbiased exponent used in the representation of a\n double.  Special cases:\n\n \n If the argument is NaN or infinite, then the result is\n Double.MAX_EXPONENT + 1.\n If the argument is zero or subnormal, then the result is\n Double.MIN_EXPONENT -1."
                }
              ]
            },
            {
              "name": "nextAfter",
              "overloads": [
                {
                  "signature": "public static double nextAfter(double start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal the second argument is returned.\n\n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, direction\n is returned unchanged (as implied by the requirement of\n returning the second argument if the arguments compare as\n equal).\n\n  If start is\n Double.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Double.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Double.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                },
                {
                  "signature": "public static float nextAfter(float start, double direction)",
                  "description": "Returns the floating-point number adjacent to the first\n argument in the direction of the second argument.  If both\n arguments compare as equal a value equivalent to the second argument\n is returned.\n\n Special cases:\n \n  If either argument is a NaN, then NaN is returned.\n\n  If both arguments are signed zeros, a value equivalent\n to direction is returned.\n\n  If start is\n Float.MIN_VALUE and direction\n has a value such that the result should have a smaller\n magnitude, then a zero with the same sign as start\n is returned.\n\n  If start is infinite and\n direction has a value such that the result should\n have a smaller magnitude, Float.MAX_VALUE with the\n same sign as start is returned.\n\n  If start is equal to \n Float.MAX_VALUE and direction has a\n value such that the result should have a larger magnitude, an\n infinity with same sign as start is returned."
                }
              ]
            },
            {
              "name": "nextUp",
              "overloads": [
                {
                  "signature": "public static double nextUp(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextUp(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of positive infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.POSITIVE_INFINITY); however, a nextUp\n implementation may run faster than its equivalent\n nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is positive infinity, the result is\n positive infinity.\n\n  If the argument is zero, the result is\n Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "nextDown",
              "overloads": [
                {
                  "signature": "public static double nextDown(double d)",
                  "description": "Returns the floating-point value adjacent to d in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(d,\n Double.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Double.MIN_VALUE"
                },
                {
                  "signature": "public static float nextDown(float f)",
                  "description": "Returns the floating-point value adjacent to f in\n the direction of negative infinity.  This method is\n semantically equivalent to nextAfter(f,\n Float.NEGATIVE_INFINITY); however, a\n nextDown implementation may run faster than its\n equivalent nextAfter call.\n\n Special Cases:\n \n  If the argument is NaN, the result is NaN.\n\n  If the argument is negative infinity, the result is\n negative infinity.\n\n  If the argument is zero, the result is\n -Float.MIN_VALUE"
                }
              ]
            },
            {
              "name": "scalb",
              "overloads": [
                {
                  "signature": "public static double scalb(double d, int scaleFactor)",
                  "description": "Returns d  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Double.MIN_EXPONENT and Double.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Double.MAX_EXPONENT, an infinity is returned.  Note that if\n the result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as d.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                },
                {
                  "signature": "public static float scalb(float f, int scaleFactor)",
                  "description": "Returns f  2scaleFactor\n rounded as if performed by a single correctly rounded\n floating-point multiply.  If the exponent of the result is\n between Float.MIN_EXPONENT and Float.MAX_EXPONENT, the answer is calculated exactly.  If the\n exponent of the result would be larger than \n Float.MAX_EXPONENT, an infinity is returned.  Note that if the\n result is subnormal, precision may be lost; that is, when\n scalb(x, n) is subnormal, scalb(scalb(x, n),\n -n) may not equal x.  When the result is non-NaN, the\n result has the same sign as f.\n\n Special cases:\n \n  If the first argument is NaN, NaN is returned.\n  If the first argument is infinite, then an infinity of the\n same sign is returned.\n  If the first argument is zero, then a zero of the same\n sign is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "String",
          "methods": [
            {
              "name": "String",
              "overloads": [
                {
                  "signature": "public String()",
                  "description": "Initializes a newly created String object so that it represents\n an empty character sequence.  Note that use of this constructor is\n unnecessary since Strings are immutable."
                },
                {
                  "signature": "public String(String original)",
                  "description": "Initializes a newly created String object so that it represents\n the same sequence of characters as the argument; in other words, the\n newly created string is a copy of the argument string. Unless an\n explicit copy of original is needed, use of this constructor is\n unnecessary since Strings are immutable."
                },
                {
                  "signature": "public String(char[] value)",
                  "description": "Allocates a new String so that it represents the sequence of\n characters currently contained in the character array argument. The\n contents of the character array are copied; subsequent modification of\n the character array does not affect the newly created string."
                },
                {
                  "signature": "public String(char[] value, int offset, int count)",
                  "description": "Allocates a new String that contains characters from a subarray\n of the character array argument. The offset argument is the\n index of the first character of the subarray and the count\n argument specifies the length of the subarray. The contents of the\n subarray are copied; subsequent modification of the character array does\n not affect the newly created string."
                },
                {
                  "signature": "public String(int[] codePoints, int offset, int count)",
                  "description": "Allocates a new String that contains characters from a subarray\n of the Unicode code point array\n argument.  The offset argument is the index of the first code\n point of the subarray and the count argument specifies the\n length of the subarray.  The contents of the subarray are converted to\n chars; subsequent modification of the int array does not\n affect the newly created string."
                },
                {
                  "signature": "@Deprecated(since=\"1.1\") public String(byte[] ascii, int hibyte, int offset, int count)",
                  "description": "Allocates a new String constructed from a subarray of an array\n of 8-bit integer values.\n\n  The offset argument is the index of the first byte of the\n subarray, and the count argument specifies the length of the\n subarray.\n\n  Each byte in the subarray is converted to a char as\n specified in the String(byte[],int) constructor.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated(since=\"1.1\") public String(byte[] ascii, int hibyte)",
                  "description": "Allocates a new String containing characters constructed from\n an array of 8-bit integer values. Each character c in the\n resulting string is constructed from the corresponding component\n b in the byte array such that:\n\n      c == (char)(((hibyte & 0xff) << 8)\n                         | (b & 0xff))",
                  "deprecated": true
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length, String charsetName) throws UnsupportedEncodingException",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the specified charset.  The length of the new String\n is a function of the charset, and hence may not be equal to the length\n of the subarray.\n\n  The behavior of this constructor when the given bytes are not valid\n in the given charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length, Charset charset)",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the specified charset.\n The length of the new String is a function of the charset, and\n hence may not be equal to the length of the subarray.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement string.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, String charsetName) throws UnsupportedEncodingException",
                  "description": "Constructs a new String by decoding the specified array of bytes\n using the specified charset.  The\n length of the new String is a function of the charset, and hence\n may not be equal to the length of the byte array.\n\n  The behavior of this constructor when the given bytes are not valid\n in the given charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, Charset charset)",
                  "description": "Constructs a new String by decoding the specified array of\n bytes using the specified charset.\n The length of the new String is a function of the charset, and\n hence may not be equal to the length of the byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement string.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes, int offset, int length)",
                  "description": "Constructs a new String by decoding the specified subarray of\n bytes using the platform's default charset.  The length of the new\n String is a function of the charset, and hence may not be equal\n to the length of the subarray.\n\n  The behavior of this constructor when the given bytes are not valid\n in the default charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(byte[] bytes)",
                  "description": "Constructs a new String by decoding the specified array of bytes\n using the platform's default charset.  The length of the new \n String is a function of the charset, and hence may not be equal to the\n length of the byte array.\n\n  The behavior of this constructor when the given bytes are not valid\n in the default charset is unspecified.  The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "public String(StringBuffer buffer)",
                  "description": "Allocates a new string that contains the sequence of characters\n currently contained in the string buffer argument. The contents of the\n string buffer are copied; subsequent modification of the string buffer\n does not affect the newly created string."
                },
                {
                  "signature": "public String(StringBuilder builder)",
                  "description": "Allocates a new string that contains the sequence of characters\n currently contained in the string builder argument. The contents of the\n string builder are copied; subsequent modification of the string builder\n does not affect the newly created string.\n\n  This constructor is provided to ease migration to \n StringBuilder. Obtaining a string from a string builder via the \n toString method is likely to run faster and is generally preferred."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length of this string.\n The length is equal to the number of Unicode\n code units in the string."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if, and only if, length() is 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value at the\n specified index. An index ranges from 0 to\n length() - 1. The first char value of the sequence\n is at index 0, the next at index 1,\n and so on, as for array indexing.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this String, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to length.\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this String. The text range begins at the\n specified beginIndex and extends to the\n char at index endIndex - 1. Thus the\n length (in chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n the text range count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this String that is\n offset from the given index by\n codePointOffset code points. Unpaired surrogates\n within the text range given by index and\n codePointOffset count as one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Copies characters from this string into the destination character\n array.\n \n The first character to be copied is at index srcBegin;\n the last character to be copied is at index srcEnd-1\n (thus the total number of characters to be copied is\n srcEnd-srcBegin). The characters are copied into the\n subarray of dst starting at index dstBegin\n and ending at index:\n      dstBegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "getBytes",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.1\") public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)",
                  "description": "Copies characters from this string into the destination byte array. Each\n byte receives the 8 low-order bits of the corresponding character. The\n eight high-order bits of each character are not copied and do not\n participate in the transfer in any way.\n\n  The first character to be copied is at index srcBegin; the\n last character to be copied is at index srcEnd-1.  The total\n number of characters to be copied is srcEnd-srcBegin. The\n characters, converted to bytes, are copied into the subarray of \n dst starting at index dstBegin and ending at index:\n\n      dstBegin + (srcEnd-srcBegin) - 1",
                  "deprecated": true
                },
                {
                  "signature": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException",
                  "description": "Encodes this String into a sequence of bytes using the named\n charset, storing the result into a new byte array.\n\n  The behavior of this method when this string cannot be encoded in\n the given charset is unspecified.  The CharsetEncoder class should be used when more control\n over the encoding process is required."
                },
                {
                  "signature": "public byte[] getBytes(Charset charset)",
                  "description": "Encodes this String into a sequence of bytes using the given\n charset, storing the result into a\n new byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with this charset's default replacement byte array.  The\n CharsetEncoder class should be used when more\n control over the encoding process is required."
                },
                {
                  "signature": "public byte[] getBytes()",
                  "description": "Encodes this String into a sequence of bytes using the\n platform's default charset, storing the result into a new byte array.\n\n  The behavior of this method when this string cannot be encoded in\n the default charset is unspecified.  The CharsetEncoder class should be used when more control\n over the encoding process is required."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object anObject)",
                  "description": "Compares this string to the specified object.  The result is \n true if and only if the argument is not null and is a \n String object that represents the same sequence of characters as this\n object.\n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "contentEquals",
              "overloads": [
                {
                  "signature": "public boolean contentEquals(StringBuffer sb)",
                  "description": "Compares this string to the specified StringBuffer.  The result\n is true if and only if this String represents the same\n sequence of characters as the specified StringBuffer. This method\n synchronizes on the StringBuffer.\n\n For finer-grained String comparison, refer to\n Collator."
                },
                {
                  "signature": "public boolean contentEquals(CharSequence cs)",
                  "description": "Compares this string to the specified CharSequence.  The\n result is true if and only if this String represents the\n same sequence of char values as the specified sequence. Note that if the\n CharSequence is a StringBuffer then the method\n synchronizes on it.\n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "equalsIgnoreCase",
              "overloads": [
                {
                  "signature": "public boolean equalsIgnoreCase(String anotherString)",
                  "description": "Compares this String to another String, ignoring case\n considerations.  Two strings are considered equal ignoring case if they\n are of the same length and corresponding Unicode code points in the two\n strings are equal ignoring case.\n\n  Two Unicode code points are considered the same\n ignoring case if at least one of the following is true:\n \n    The two Unicode code points are the same (as compared by the\n        == operator)\n    Calling Character.toLowerCase(Character.toUpperCase(int))\n        on each Unicode code point produces the same result\n \n\n Note that this method does not take locale into account, and\n will result in unsatisfactory results for certain locales.  The\n Collator class provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(String anotherString)",
                  "description": "Compares two strings lexicographically.\n The comparison is based on the Unicode value of each character in\n the strings. The character sequence represented by this\n String object is compared lexicographically to the\n character sequence represented by the argument string. The result is\n a negative integer if this String object\n lexicographically precedes the argument string. The result is a\n positive integer if this String object lexicographically\n follows the argument string. The result is zero if the strings\n are equal; compareTo returns 0 exactly when\n the equals(Object) method would return true.\n \n This is the definition of lexicographic ordering. If two strings are\n different, then either they have different characters at some index\n that is a valid index for both strings, or their lengths are different,\n or both. If they have different characters at one or more index\n positions, let k be the smallest such index; then the string\n whose character at position k has the smaller value, as\n determined by using the < operator, lexicographically precedes the\n other string. In this case, compareTo returns the\n difference of the two character values at position k in\n the two string -- that is, the value:\n  this.charAt(k)-anotherString.charAt(k)\n \n If there is no index position at which they differ, then the shorter\n string lexicographically precedes the longer string. In this case,\n compareTo returns the difference of the lengths of the\n strings -- that is, the value:\n  this.length()-anotherString.length()\n \n\n For finer-grained String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "compareToIgnoreCase",
              "overloads": [
                {
                  "signature": "public int compareToIgnoreCase(String str)",
                  "description": "Compares two strings lexicographically, ignoring case\n differences. This method returns an integer whose sign is that of\n calling compareTo with case folded versions of the strings\n where case differences have been eliminated by calling\n Character.toLowerCase(Character.toUpperCase(int)) on\n each Unicode code point.\n \n Note that this method does not take locale into account,\n and will result in an unsatisfactory ordering for certain locales.\n The Collator class provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "regionMatches",
              "overloads": [
                {
                  "signature": "public boolean regionMatches(int toffset, String other, int ooffset, int len)",
                  "description": "Tests if two string regions are equal.\n \n A substring of this String object is compared to a substring\n of the argument other. The result is true if these substrings\n represent identical character sequences. The substring of this\n String object to be compared begins at index toffset\n and has length len. The substring of other to be compared\n begins at index ooffset and has length len. The\n result is false if and only if at least one of the following\n is true:\n toffset is negative.\n ooffset is negative.\n toffset+len is greater than the length of this\n String object.\n ooffset+len is greater than the length of the other\n argument.\n There is some nonnegative integer k less than len\n such that:\n this.charAt(toffset + k) != other.charAt(ooffset + \n k)\n \n\n Note that this method does not take locale into account.  The\n Collator class provides locale-sensitive comparison."
                },
                {
                  "signature": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)",
                  "description": "Tests if two string regions are equal.\n \n A substring of this String object is compared to a substring\n of the argument other. The result is true if these\n substrings represent Unicode code point sequences that are the same,\n ignoring case if and only if ignoreCase is true.\n The sequences tsequence and osequence are compared,\n where tsequence is the sequence produced as if by calling\n this.substring(toffset, toffset + len).codePoints() and\n osequence is the sequence produced as if by calling\n other.substring(ooffset, ooffset + len).codePoints().\n The result is true if and only if all of the following\n are true:\n toffset is non-negative.\n ooffset is non-negative.\n toffset+len is less than or equal to the length of this\n String object.\n ooffset+len is less than or equal to the length of the other\n argument.\n if ignoreCase is false, all pairs of corresponding Unicode\n code points are equal integer values; or if ignoreCase is true,\n Character.toLowerCase(\n Character.toUpperCase(int)) on all pairs of Unicode code points\n results in equal integer values.\n \n\n Note that this method does not take locale into account,\n and will result in unsatisfactory results for certain locales when\n ignoreCase is true.  The Collator class\n provides locale-sensitive comparison."
                }
              ]
            },
            {
              "name": "startsWith",
              "overloads": [
                {
                  "signature": "public boolean startsWith(String prefix, int toffset)",
                  "description": "Tests if the substring of this string beginning at the\n specified index starts with the specified prefix."
                },
                {
                  "signature": "public boolean startsWith(String prefix)",
                  "description": "Tests if this string starts with the specified prefix."
                }
              ]
            },
            {
              "name": "endsWith",
              "overloads": [
                {
                  "signature": "public boolean endsWith(String suffix)",
                  "description": "Tests if this string ends with the specified suffix."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this string. The hash code for a\n String object is computed as\n  s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n \n using int arithmetic, where s[i] is the\n ith character of the string, n is the length of\n the string, and ^ indicates exponentiation.\n (The hash value of the empty string is zero.)"
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(int ch)",
                  "description": "Returns the index within this string of the first occurrence of\n the specified character. If a character with value\n ch occurs in the character sequence represented by\n this String object, then the index (in Unicode\n code units) of the first such occurrence is returned. For\n values of ch in the range from 0 to 0xFFFF\n (inclusive), this is the smallest value k such that:\n  this.charAt(k) == ch\n \n is true. For other values of ch, it is the\n smallest value k such that:\n  this.codePointAt(k) == ch\n \n is true. In either case, if no such character occurs in this\n string, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(int ch, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified character, starting the search at the specified index.\n \n If a character with value ch occurs in the\n character sequence represented by this String\n object at an index no smaller than fromIndex, then\n the index of the first such occurrence is returned. For values\n of ch in the range from 0 to 0xFFFF (inclusive),\n this is the smallest value k such that:\n  (this.charAt(k) == ch) && (k >= fromIndex)\n \n is true. For other values of ch, it is the\n smallest value k such that:\n  (this.codePointAt(k) == ch) && (k >= fromIndex)\n \n is true. In either case, if no such character occurs in this\n string at or after position fromIndex, then\n -1 is returned.\n\n \n There is no restriction on the value of fromIndex. If it\n is negative, it has the same effect as if it were zero: this entire\n string may be searched. If it is greater than the length of this\n string, it has the same effect as if it were equal to the length of\n this string: -1 is returned.\n\n All indices are specified in char values\n (Unicode code units)."
                },
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(int ch)",
                  "description": "Returns the index within this string of the last occurrence of\n the specified character. For values of ch in the\n range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n units) returned is the largest value k such that:\n  this.charAt(k) == ch\n \n is true. For other values of ch, it is the\n largest value k such that:\n  this.codePointAt(k) == ch\n \n is true.  In either case, if no such character occurs in this\n string, then -1 is returned.  The\n String is searched backwards starting at the last\n character."
                },
                {
                  "signature": "public int lastIndexOf(int ch, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of\n the specified character, searching backward starting at the\n specified index. For values of ch in the range\n from 0 to 0xFFFF (inclusive), the index returned is the largest\n value k such that:\n  (this.charAt(k) == ch) && (k <= fromIndex)\n \n is true. For other values of ch, it is the\n largest value k such that:\n  (this.codePointAt(k) == ch) && (k <= fromIndex)\n \n is true. In either case, if no such character occurs in this\n string at or before position fromIndex, then\n -1 is returned.\n\n All indices are specified in char values\n (Unicode code units)."
                },
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\"\n is considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int beginIndex)",
                  "description": "Returns a string that is a substring of this string. The\n substring begins with the character at the specified index and\n extends to the end of this string. \n Examples:\n  \"unhappy\".substring(2) returns \"happy\"\n \"Harbison\".substring(3) returns \"bison\"\n \"emptiness\".substring(9) returns \"\" (an empty string)"
                },
                {
                  "signature": "public String substring(int beginIndex, int endIndex)",
                  "description": "Returns a string that is a substring of this string. The\n substring begins at the specified beginIndex and\n extends to the character at index endIndex - 1.\n Thus the length of the substring is endIndex-beginIndex.\n \n Examples:\n  \"hamburger\".substring(4, 8) returns \"urge\"\n \"smiles\".substring(1, 5) returns \"mile\""
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int beginIndex, int endIndex)",
                  "description": "Returns a character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n  str.subSequence(begin,end)\n\n behaves in exactly the same way as the invocation\n\n  str.substring(begin,end)"
                }
              ]
            },
            {
              "name": "concat",
              "overloads": [
                {
                  "signature": "public String concat(String str)",
                  "description": "Concatenates the specified string to the end of this string.\n \n If the length of the argument string is 0, then this\n String object is returned. Otherwise, a\n String object is returned that represents a character\n sequence that is the concatenation of the character sequence\n represented by this String object and the character\n sequence represented by the argument string.\n Examples:\n  \"cares\".concat(\"s\") returns \"caress\"\n \"to\".concat(\"get\").concat(\"her\") returns \"together\""
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public String replace(char oldChar, char newChar)",
                  "description": "Returns a string resulting from replacing all occurrences of\n oldChar in this string with newChar.\n \n If the character oldChar does not occur in the\n character sequence represented by this String object,\n then a reference to this String object is returned.\n Otherwise, a String object is returned that\n represents a character sequence identical to the character sequence\n represented by this String object, except that every\n occurrence of oldChar is replaced by an occurrence\n of newChar.\n \n Examples:\n  \"mesquite in your cellar\".replace('e', 'o')\n         returns \"mosquito in your collar\"\n \"the war of baronets\".replace('r', 'y')\n         returns \"the way of bayonets\"\n \"sparring with a purple porpoise\".replace('p', 't')\n         returns \"starring with a turtle tortoise\"\n \"JonL\".replace('q', 'x') returns \"JonL\" (no change)"
                },
                {
                  "signature": "public String replace(CharSequence target, CharSequence replacement)",
                  "description": "Replaces each substring of this string that matches the literal target\n sequence with the specified literal replacement sequence. The\n replacement proceeds from the beginning of the string to the end, for\n example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n \"ba\" rather than \"ab\"."
                }
              ]
            },
            {
              "name": "matches",
              "overloads": [
                {
                  "signature": "public boolean matches(String regex)",
                  "description": "Tells whether or not this string matches the given regular expression.\n\n  An invocation of this method of the form\n str.matches(regex) yields exactly the\n same result as the expression\n\n \n Pattern.matches(regex, str)"
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(CharSequence s)",
                  "description": "Returns true if and only if this string contains the specified\n sequence of char values."
                }
              ]
            },
            {
              "name": "replaceFirst",
              "overloads": [
                {
                  "signature": "public String replaceFirst(String regex, String replacement)",
                  "description": "Replaces the first substring of this string that matches the given regular expression with the\n given replacement.\n\n  An invocation of this method of the form\n str.replaceFirst(regex, repl)\n yields exactly the same result as the expression\n\n \n \n Pattern.compile(regex).matcher(str).replaceFirst(repl)\n \n \n\n\n Note that backslashes (\\) and dollar signs ($) in the\n replacement string may cause the results to be different than if it were\n being treated as a literal replacement string; see\n Matcher.replaceFirst(java.lang.String).\n Use Matcher.quoteReplacement(java.lang.String) to suppress the special\n meaning of these characters, if desired."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public String replaceAll(String regex, String replacement)",
                  "description": "Replaces each substring of this string that matches the given regular expression with the\n given replacement.\n\n  An invocation of this method of the form\n str.replaceAll(regex, repl)\n yields exactly the same result as the expression\n\n \n \n Pattern.compile(regex).matcher(str).replaceAll(repl)\n \n \n\n\n Note that backslashes (\\) and dollar signs ($) in the\n replacement string may cause the results to be different than if it were\n being treated as a literal replacement string; see\n Matcher.replaceAll.\n Use Matcher.quoteReplacement(java.lang.String) to suppress the special\n meaning of these characters, if desired."
                }
              ]
            },
            {
              "name": "split",
              "overloads": [
                {
                  "signature": "public String[] split(String regex, int limit)",
                  "description": "Splits this string around matches of the given\n regular expression.\n\n  The array returned by this method contains each substring of this\n string that is terminated by another substring that matches the given\n expression or is terminated by the end of the string.  The substrings in\n the array are in the order in which they occur in this string.  If the\n expression does not match any part of the input then the resulting array\n has just one element, namely this string.\n\n  When there is a positive-width match at the beginning of this\n string then an empty leading substring is included at the beginning\n of the resulting array. A zero-width match at the beginning however\n never produces such empty leading substring.\n\n  The limit parameter controls the number of times the\n pattern is applied and therefore affects the length of the resulting\n array.\n \n    \n    If the limit is positive then the pattern will be applied\n    at most limit-1 times, the array's length will be\n    no greater than limit, and the array's last entry will contain\n    all input beyond the last matched delimiter.\n\n    \n    If the limit is zero then the pattern will be applied as\n    many times as possible, the array can have any length, and trailing\n    empty strings will be discarded.\n\n    \n    If the limit is negative then the pattern will be applied\n    as many times as possible and the array can have any length.\n \n\n  The string \"boo:and:foo\", for example, yields the\n following results with these parameters:\n\n \n Split example showing regex, limit, and result\n \n \n     Regex\n     Limit\n     Result\n \n \n \n :\n     2\n     { \"boo\", \"and:foo\" }\n \n     5\n     { \"boo\", \"and\", \"foo\" }\n \n     -2\n     { \"boo\", \"and\", \"foo\" }\n o\n     5\n     { \"b\", \"\", \":and:f\", \"\", \"\" }\n \n     -2\n     { \"b\", \"\", \":and:f\", \"\", \"\" }\n \n     0\n     { \"b\", \"\", \":and:f\" }\n \n \n\n  An invocation of this method of the form\n str.split(regex,n)\n yields the same result as the expression\n\n \n \n Pattern.compile(regex).split(str,n)"
                },
                {
                  "signature": "public String[] split(String regex)",
                  "description": "Splits this string around matches of the given regular expression.\n\n  This method works as if by invoking the two-argument split method with the given expression and a limit\n argument of zero.  Trailing empty strings are therefore not included in\n the resulting array.\n\n  The string \"boo:and:foo\", for example, yields the following\n results with these expressions:\n\n \n Split examples showing regex and result\n \n \n  Regex\n  Result\n \n \n \n :\n     { \"boo\", \"and\", \"foo\" }\n o\n     { \"b\", \"\", \":and:f\" }"
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "public static String join(CharSequence delimiter, CharSequence... elements)",
                  "description": "Returns a new String composed of copies of the\n CharSequence elements joined together with a copy of\n the specified delimiter.\n\n For example,\n \n     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     // message returned is: \"Java-is-cool\"\n \n\n Note that if an element is null, then \"null\" is added."
                },
                {
                  "signature": "public static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)",
                  "description": "Returns a new String composed of copies of the\n CharSequence elements joined together with a copy of the\n specified delimiter.\n\n For example,\n \n     List<String> strings = List.of(\"Java\", \"is\", \"cool\");\n     String message = String.join(\" \", strings);\n     // message returned is: \"Java is cool\"\n\n     Set<String> strings =\n         new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     String message = String.join(\"-\", strings);\n     // message returned is: \"Java-is-very-cool\"\n \n\n Note that if an individual element is null, then \"null\" is added."
                }
              ]
            },
            {
              "name": "toLowerCase",
              "overloads": [
                {
                  "signature": "public String toLowerCase(Locale locale)",
                  "description": "Converts all of the characters in this String to lower\n case using the rules of the given Locale.  Case mapping is based\n on the Unicode Standard version specified by the Character\n class. Since case mappings are not always 1:1 char mappings, the resulting\n String may be a different length than the original String.\n \n Examples of lowercase  mappings are in the following table:\n \n Lowercase mapping examples showing language code of locale, upper case, lower case, and description\n \n \n   Language Code of Locale\n   Upper Case\n   Lower Case\n   Description\n \n \n \n \n   tr (Turkish)\n   \\u0130\n   \\u0069\n   capital letter I with dot above -> small letter i\n \n \n   tr (Turkish)\n   \\u0049\n   \\u0131\n   capital letter I -> small letter dotless i \n \n \n   (all)\n   French Fries\n   french fries\n   lowercased all chars in String\n \n \n   (all)\n   \n       \n   \n   lowercased all chars in String"
                },
                {
                  "signature": "public String toLowerCase()",
                  "description": "Converts all of the characters in this String to lower\n case using the rules of the default locale. This is equivalent to calling\n toLowerCase(Locale.getDefault()).\n \n Note: This method is locale sensitive, and may produce unexpected\n results if used for strings that are intended to be interpreted locale\n independently.\n Examples are programming language identifiers, protocol keys, and HTML\n tags.\n For instance, \"TITLE\".toLowerCase() in a Turkish locale\n returns \"t\\u0131tle\", where '\\u0131' is the\n LATIN SMALL LETTER DOTLESS I character.\n To obtain correct results for locale insensitive strings, use\n toLowerCase(Locale.ROOT)."
                }
              ]
            },
            {
              "name": "toUpperCase",
              "overloads": [
                {
                  "signature": "public String toUpperCase(Locale locale)",
                  "description": "Converts all of the characters in this String to upper\n case using the rules of the given Locale. Case mapping is based\n on the Unicode Standard version specified by the Character\n class. Since case mappings are not always 1:1 char mappings, the resulting\n String may be a different length than the original String.\n \n Examples of locale-sensitive and 1:M case mappings are in the following table.\n\n \n Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\n \n \n   Language Code of Locale\n   Lower Case\n   Upper Case\n   Description\n \n \n \n \n   tr (Turkish)\n   \\u0069\n   \\u0130\n   small letter i -> capital letter I with dot above\n \n \n   tr (Turkish)\n   \\u0131\n   \\u0049\n   small letter dotless i -> capital letter I\n \n \n   (all)\n   \\u00df\n   \\u0053 \\u0053\n   small letter sharp s -> two letters: SS\n \n \n   (all)\n   Fahrvergngen\n   FAHRVERGNGEN"
                },
                {
                  "signature": "public String toUpperCase()",
                  "description": "Converts all of the characters in this String to upper\n case using the rules of the default locale. This method is equivalent to\n toUpperCase(Locale.getDefault()).\n \n Note: This method is locale sensitive, and may produce unexpected\n results if used for strings that are intended to be interpreted locale\n independently.\n Examples are programming language identifiers, protocol keys, and HTML\n tags.\n For instance, \"title\".toUpperCase() in a Turkish locale\n returns \"T\\u0130TLE\", where '\\u0130' is the\n LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n To obtain correct results for locale insensitive strings, use\n toUpperCase(Locale.ROOT)."
                }
              ]
            },
            {
              "name": "trim",
              "overloads": [
                {
                  "signature": "public String trim()",
                  "description": "Returns a string whose value is this string, with all leading\n and trailing space removed, where space is defined\n as any character whose codepoint is less than or equal to\n 'U+0020' (the space character).\n \n If this String object represents an empty character\n sequence, or the first and last characters of character sequence\n represented by this String object both have codes\n that are not space (as defined above), then a\n reference to this String object is returned.\n \n Otherwise, if all characters in this string are space (as\n defined above), then a  String object representing an\n empty string is returned.\n \n Otherwise, let k be the index of the first character in the\n string whose code is not a space (as defined above) and let\n m be the index of the last character in the string whose code\n is not a space (as defined above). A String\n object is returned, representing the substring of this string that\n begins with the character at index k and ends with the\n character at index m-that is, the result of\n this.substring(k, m + 1).\n \n This method may be used to trim space (as defined above) from\n the beginning and end of a string."
                }
              ]
            },
            {
              "name": "strip",
              "overloads": [
                {
                  "signature": "public String strip()",
                  "description": "Returns a string whose value is this string, with all leading\n and trailing white space\n removed.\n \n If this String object represents an empty string,\n or if all code points in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point that is not a white space\n up to and including the last code point that is not a\n white space.\n \n This method may be used to strip\n white space from\n the beginning and end of a string."
                }
              ]
            },
            {
              "name": "stripLeading",
              "overloads": [
                {
                  "signature": "public String stripLeading()",
                  "description": "Returns a string whose value is this string, with all leading\n white space removed.\n \n If this String object represents an empty string,\n or if all code points in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point that is not a white space\n up to and including the last code point of this string.\n \n This method may be used to trim\n white space from\n the beginning of a string."
                }
              ]
            },
            {
              "name": "stripTrailing",
              "overloads": [
                {
                  "signature": "public String stripTrailing()",
                  "description": "Returns a string whose value is this string, with all trailing\n white space removed.\n \n If this String object represents an empty string,\n or if all characters in this string are\n white space, then an empty string\n is returned.\n \n Otherwise, returns a substring of this string beginning with the first\n code point of this string up to and including the last code point\n that is not a white space.\n \n This method may be used to trim\n white space from\n the end of a string."
                }
              ]
            },
            {
              "name": "isBlank",
              "overloads": [
                {
                  "signature": "public boolean isBlank()",
                  "description": "Returns true if the string is empty or contains only\n white space codepoints,\n otherwise false."
                }
              ]
            },
            {
              "name": "lines",
              "overloads": [
                {
                  "signature": "public Stream<String> lines()",
                  "description": "Returns a stream of lines extracted from this string,\n separated by line terminators.\n \n A line terminator is one of the following:\n a line feed character \"\\n\" (U+000A),\n a carriage return character \"\\r\" (U+000D),\n or a carriage return followed immediately by a line feed\n \"\\r\\n\" (U+000D U+000A).\n \n A line is either a sequence of zero or more characters\n followed by a line terminator, or it is a sequence of one or\n more characters followed by the end of the string. A\n line does not include the line terminator.\n \n The stream returned by this method contains the lines from\n this string in the order in which they occur."
                }
              ]
            },
            {
              "name": "indent",
              "overloads": [
                {
                  "signature": "public String indent(int n)",
                  "description": "Adjusts the indentation of each line of this string based on the value of\n n, and normalizes line termination characters.\n \n This string is conceptually separated into lines using\n lines(). Each line is then adjusted as described below\n and then suffixed with a line feed \"\\n\" (U+000A). The resulting\n lines are then concatenated and returned.\n \n If n > 0 then n spaces (U+0020) are inserted at the\n beginning of each line.\n \n If n < 0 then up to n\n white space characters are removed\n from the beginning of each line. If a given line does not contain\n sufficient white space then all leading\n white space characters are removed.\n Each white space character is treated as a single character. In\n particular, the tab character \"\\t\" (U+0009) is considered a\n single character; it is not expanded.\n \n If n == 0 then the line remains unchanged. However, line\n terminators are still normalized."
                }
              ]
            },
            {
              "name": "stripIndent",
              "overloads": [
                {
                  "signature": "public String stripIndent()",
                  "description": "Returns a string whose value is this string, with incidental\n white space removed from\n the beginning and end of every line.\n \n Incidental white space\n is often present in a text block to align the content with the opening\n delimiter. For example, in the following code, dots represent incidental\n white space:\n  String html = \"\"\"\n ..............<html>\n ..............    <body>\n ..............        <p>Hello, world</p>\n ..............    </body>\n ..............</html>\n ..............\"\"\";\n \n This method treats the incidental\n white space as indentation to be\n stripped, producing a string that preserves the relative indentation of\n the content. Using | to visualize the start of each line of the string:\n  |<html>\n |    <body>\n |        <p>Hello, world</p>\n |    </body>\n |</html>\n \n First, the individual lines of this string are extracted. A line\n is a sequence of zero or more characters followed by either a line\n terminator or the end of the string.\n If the string has at least one line terminator, the last line consists\n of the characters between the last terminator and the end of the string.\n Otherwise, if the string has no terminators, the last line is the start\n of the string to the end of the string, in other words, the entire\n string.\n A line does not include the line terminator.\n \n Then, the minimum indentation (min) is determined as follows:\n \n   For each non-blank line (as defined by isBlank()),\n   the leading white space\n   characters are counted.\n   \n   The leading white space\n   characters on the last line are also counted even if\n   blank.\n   \n \n The min value is the smallest of these counts.\n \n For each non-blank line, min leading\n white space characters are\n removed, and any trailing white\n space characters are removed. Blank lines\n are replaced with the empty string.\n\n \n Finally, the lines are joined into a new string, using the LF character\n \"\\n\" (U+000A) to separate lines."
                }
              ]
            },
            {
              "name": "translateEscapes",
              "overloads": [
                {
                  "signature": "public String translateEscapes()",
                  "description": "Returns a string whose value is this string, with escape sequences\n translated as if in a string literal.\n \n Escape sequences are translated as follows;\n \n   Translation\n   \n   \n     Escape\n     Name\n     Translation\n   \n   \n   \n   \n     \\b\n     backspace\n     U+0008\n   \n   \n     \\t\n     horizontal tab\n     U+0009\n   \n   \n     \\n\n     line feed\n     U+000A\n   \n   \n     \\f\n     form feed\n     U+000C\n   \n   \n     \\r\n     carriage return\n     U+000D\n   \n   \n     \\s\n     space\n     U+0020\n   \n   \n     \\\"\n     double quote\n     U+0022\n   \n   \n     \\'\n     single quote\n     U+0027\n   \n   \n     \\\\\n     backslash\n     U+005C\n   \n   \n     \\0 - \\377\n     octal escape\n     code point equivalents\n   \n   \n     \\<line-terminator>\n     continuation\n     discard"
                }
              ]
            },
            {
              "name": "transform",
              "overloads": [
                {
                  "signature": "public <R> R transform(Function<? super String,? extends R> f)",
                  "description": "This method allows the application of a function to this\n string. The function should expect a single String argument\n and produce an R result.\n \n Any exception thrown by f.apply() will be propagated to the\n caller."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "This object (which is already a string!) is itself returned."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream."
                }
              ]
            },
            {
              "name": "toCharArray",
              "overloads": [
                {
                  "signature": "public char[] toCharArray()",
                  "description": "Converts this string to a new character array."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public static String format(String format, Object... args)",
                  "description": "Returns a formatted string using the specified format string and\n arguments.\n\n  The locale always used is the one returned by Locale.getDefault(Locale.Category) with\n FORMAT category specified."
                },
                {
                  "signature": "public static String format(Locale l, String format, Object... args)",
                  "description": "Returns a formatted string using the specified locale, format string,\n and arguments."
                }
              ]
            },
            {
              "name": "formatted",
              "overloads": [
                {
                  "signature": "public String formatted(Object... args)",
                  "description": "Formats using this string as the format string, and the supplied\n arguments."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static String valueOf(Object obj)",
                  "description": "Returns the string representation of the Object argument."
                },
                {
                  "signature": "public static String valueOf(char[] data)",
                  "description": "Returns the string representation of the char array\n argument. The contents of the character array are copied; subsequent\n modification of the character array does not affect the returned\n string."
                },
                {
                  "signature": "public static String valueOf(char[] data, int offset, int count)",
                  "description": "Returns the string representation of a specific subarray of the\n char array argument.\n \n The offset argument is the index of the first\n character of the subarray. The count argument\n specifies the length of the subarray. The contents of the subarray\n are copied; subsequent modification of the character array does not\n affect the returned string."
                },
                {
                  "signature": "public static String valueOf(boolean b)",
                  "description": "Returns the string representation of the boolean argument."
                },
                {
                  "signature": "public static String valueOf(char c)",
                  "description": "Returns the string representation of the char\n argument."
                },
                {
                  "signature": "public static String valueOf(int i)",
                  "description": "Returns the string representation of the int argument.\n \n The representation is exactly the one returned by the\n Integer.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(long l)",
                  "description": "Returns the string representation of the long argument.\n \n The representation is exactly the one returned by the\n Long.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(float f)",
                  "description": "Returns the string representation of the float argument.\n \n The representation is exactly the one returned by the\n Float.toString method of one argument."
                },
                {
                  "signature": "public static String valueOf(double d)",
                  "description": "Returns the string representation of the double argument.\n \n The representation is exactly the one returned by the\n Double.toString method of one argument."
                }
              ]
            },
            {
              "name": "copyValueOf",
              "overloads": [
                {
                  "signature": "public static String copyValueOf(char[] data, int offset, int count)",
                  "description": "Equivalent to valueOf(char[], int, int)."
                },
                {
                  "signature": "public static String copyValueOf(char[] data)",
                  "description": "Equivalent to valueOf(char[])."
                }
              ]
            },
            {
              "name": "intern",
              "overloads": [
                {
                  "signature": "public String intern()",
                  "description": "Returns a canonical representation for the string object.\n \n A pool of strings, initially empty, is maintained privately by the\n class String.\n \n When the intern method is invoked, if the pool already contains a\n string equal to this String object as determined by\n the equals(Object) method, then the string from the pool is\n returned. Otherwise, this String object is added to the\n pool and a reference to this String object is returned.\n \n It follows that for any two strings s and t,\n s.intern() == t.intern() is true\n if and only if s.equals(t) is true.\n \n All literal strings and string-valued constant expressions are\n interned. String literals are defined in section 3.10.5 of the\n The Java Language Specification."
                }
              ]
            },
            {
              "name": "repeat",
              "overloads": [
                {
                  "signature": "public String repeat(int count)",
                  "description": "Returns a string whose value is the concatenation of this\n string repeated count times.\n \n If this string is empty or count is zero then the empty\n string is returned."
                }
              ]
            },
            {
              "name": "describeConstable",
              "overloads": [
                {
                  "signature": "public Optional<String> describeConstable()",
                  "description": "Returns an Optional containing the nominal descriptor for this\n instance, which is the instance itself."
                }
              ]
            },
            {
              "name": "resolveConstantDesc",
              "overloads": [
                {
                  "signature": "public String resolveConstantDesc(MethodHandles.Lookup lookup)",
                  "description": "Resolves this instance as a ConstantDesc, the result of which is\n the instance itself."
                }
              ]
            }
          ]
        },
        {
          "name": "StringBuffer",
          "methods": [
            {
              "name": "StringBuffer",
              "overloads": [
                {
                  "signature": "public StringBuffer()",
                  "description": "Constructs a string buffer with no characters in it and an\n initial capacity of 16 characters."
                },
                {
                  "signature": "public StringBuffer(int capacity)",
                  "description": "Constructs a string buffer with no characters in it and\n the specified initial capacity."
                },
                {
                  "signature": "public StringBuffer(String str)",
                  "description": "Constructs a string buffer initialized to the contents of the\n specified string. The initial capacity of the string buffer is\n 16 plus the length of the string argument."
                },
                {
                  "signature": "public StringBuffer(CharSequence seq)",
                  "description": "Constructs a string buffer that contains the same characters\n as the specified CharSequence. The initial capacity of\n the string buffer is 16 plus the length of the\n CharSequence argument."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(StringBuffer another)",
                  "description": "Compares two StringBuffer instances lexicographically. This method\n follows the same rules for lexicographical comparison as defined in the\n CharSequence.compare(this, another) method.\n\n \n For finer-grained, locale-sensitive String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length (character count)."
                }
              ]
            },
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public int capacity()",
                  "description": "Returns the current capacity. The capacity is the number of characters\n that can be stored (including already written characters), beyond which\n an allocation will occur."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minimumCapacity)",
                  "description": "Ensures that the capacity is at least equal to the specified minimum.\n If the current capacity is less than the argument, then a new internal\n array is allocated with greater capacity. The new capacity is the\n larger of:\n \n The minimumCapacity argument.\n Twice the old capacity, plus 2.\n \n If the minimumCapacity argument is nonpositive, this\n method takes no action and simply returns.\n Note that subsequent operations on this object can reduce the\n actual capacity below that requested here."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Attempts to reduce storage used for the character sequence.\n If the buffer is larger than necessary to hold its current sequence of\n characters, then it may be resized to become more space efficient.\n Calling this method may, but is not required to, affect the value\n returned by a subsequent call to the capacity() method."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int newLength)",
                  "description": "Sets the length of the character sequence.\n The sequence is changed to a new character sequence\n whose length is specified by the argument. For every nonnegative\n index k less than newLength, the character at\n index k in the new character sequence is the same as the\n character at index k in the old sequence if k is less\n than the length of the old character sequence; otherwise, it is the\n null character '\\u0000'.\n\n In other words, if the newLength argument is less than\n the current length, the length is changed to the specified length.\n \n If the newLength argument is greater than or equal\n to the current length, sufficient null characters\n ('\\u0000') are appended so that\n length becomes the newLength argument.\n \n The newLength argument must be greater than or equal\n to 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value in this sequence at the specified index.\n The first char value is at index 0, the next at index\n 1, and so on, as in array indexing.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n CharSequence.length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this sequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to CharSequence.length().\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this sequence. The text range begins at the specified\n beginIndex and extends to the char at\n index endIndex - 1. Thus the length (in\n chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n this sequence count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this sequence that is offset from the\n given index by codePointOffset code\n points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Characters are copied from this sequence into the\n destination character array dst. The first character to\n be copied is at index srcBegin; the last character to\n be copied is at index srcEnd-1. The total number of\n characters to be copied is srcEnd-srcBegin. The\n characters are copied into the subarray of dst starting\n at index dstBegin and ending at index:\n \n dstbegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "setCharAt",
              "overloads": [
                {
                  "signature": "public void setCharAt(int index, char ch)",
                  "description": "The character at the specified index is set to ch. This\n sequence is altered to represent a new character sequence that is\n identical to the old character sequence, except that it contains the\n character ch at position index.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringBuffer append(Object obj)",
                  "description": "Appends the string representation of the Object argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(Object),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(String str)",
                  "description": "Appends the specified string to this character sequence.\n \n The characters of the String argument are appended, in\n order, increasing the length of this sequence by the length of the\n argument. If str is null, then the four\n characters \"null\" are appended.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in the new character sequence is equal to the character\n at index k in the old character sequence, if k is less\n than n; otherwise, it is equal to the character at index\n k-n in the argument str."
                },
                {
                  "signature": "public StringBuffer append(StringBuffer sb)",
                  "description": "Appends the specified StringBuffer to this sequence.\n \n The characters of the StringBuffer argument are appended,\n in order, to the contents of this StringBuffer, increasing the\n length of this StringBuffer by the length of the argument.\n If sb is null, then the four characters\n \"null\" are appended to this StringBuffer.\n \n Let n be the length of the old character sequence, the one\n contained in the StringBuffer just prior to execution of the\n append method. Then the character at index k in\n the new character sequence is equal to the character at index k\n in the old character sequence, if k is less than n;\n otherwise, it is equal to the character at index k-n in the\n argument sb.\n \n This method synchronizes on this, the destination\n object, but does not synchronize on the source (sb)."
                },
                {
                  "signature": "public StringBuffer append(CharSequence s)",
                  "description": "Appends the specified CharSequence to this\n sequence.\n \n The characters of the CharSequence argument are appended,\n in order, increasing the length of this sequence by the length of the\n argument.\n\n The result of this method is exactly the same as if it were an\n invocation of this.append(s, 0, s.length());\n\n This method synchronizes on this, the destination\n object, but does not synchronize on the source (s).\n\n If s is null, then the four characters\n \"null\" are appended."
                },
                {
                  "signature": "public StringBuffer append(CharSequence s, int start, int end)",
                  "description": "Appends a subsequence of the specified CharSequence to this\n sequence.\n \n Characters of the argument s, starting at\n index start, are appended, in order, to the contents of\n this sequence up to the (exclusive) index end. The length\n of this sequence is increased by the value of end - start.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in this character sequence becomes equal to the\n character at index k in this sequence, if k is less than\n n; otherwise, it is equal to the character at index\n k+start-n in the argument s.\n \n If s is null, then this method appends\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuffer append(char[] str)",
                  "description": "Appends the string representation of the char array\n argument to this sequence.\n \n The characters of the array argument are appended, in order, to\n the contents of this sequence. The length of this sequence\n increases by the length of the argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(char[] str, int offset, int len)",
                  "description": "Appends the string representation of a subarray of the\n char array argument to this sequence.\n \n Characters of the char array str, starting at\n index offset, are appended, in order, to the contents\n of this sequence. The length of this sequence increases\n by the value of len.\n \n The overall effect is exactly as if the arguments were converted\n to a string by the method String.valueOf(char[],int,int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(boolean b)",
                  "description": "Appends the string representation of the boolean\n argument to the sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(char c)",
                  "description": "Appends the string representation of the char\n argument to this sequence.\n \n The argument is appended to the contents of this sequence.\n The length of this sequence increases by 1.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char),\n and the character in that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(int i)",
                  "description": "Appends the string representation of the int\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(long lng)",
                  "description": "Appends the string representation of the long\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(long),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(float f)",
                  "description": "Appends the string representation of the float\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(float),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuffer append(double d)",
                  "description": "Appends the string representation of the double\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(double),\n and the characters of that string were then\n appended to this character sequence."
                }
              ]
            },
            {
              "name": "appendCodePoint",
              "overloads": [
                {
                  "signature": "public StringBuffer appendCodePoint(int codePoint)",
                  "description": "Appends the string representation of the codePoint\n argument to this sequence.\n\n  The argument is appended to the contents of this sequence.\n The length of this sequence increases by\n Character.charCount(codePoint).\n\n  The overall effect is exactly as if the argument were\n converted to a char array by the method\n Character.toChars(int) and the character in that array\n were then appended to this character\n sequence."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public StringBuffer delete(int start, int end)",
                  "description": "Removes the characters in a substring of this sequence.\n The substring begins at the specified start and extends to\n the character at index end - 1 or to the end of the\n sequence if no such character exists. If\n start is equal to end, no changes are made."
                }
              ]
            },
            {
              "name": "deleteCharAt",
              "overloads": [
                {
                  "signature": "public StringBuffer deleteCharAt(int index)",
                  "description": "Removes the char at the specified position in this\n sequence. This sequence is shortened by one char.\n\n Note: If the character at the given index is a supplementary\n character, this method does not remove the entire character. If\n correct handling of supplementary characters is required,\n determine the number of chars to remove by calling\n Character.charCount(thisSequence.codePointAt(index)),\n where thisSequence is this sequence."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public StringBuffer replace(int start, int end, String str)",
                  "description": "Replaces the characters in a substring of this sequence\n with characters in the specified String. The substring\n begins at the specified start and extends to the character\n at index end - 1 or to the end of the\n sequence if no such character exists. First the\n characters in the substring are removed and then the specified\n String is inserted at start. (This\n sequence will be lengthened to accommodate the\n specified String if necessary.)"
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int start)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this character sequence. The\n substring begins at the specified index and extends to the end of\n this sequence."
                },
                {
                  "signature": "public String substring(int start, int end)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this sequence. The\n substring begins at the specified start and\n extends to the character at index end - 1."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int start, int end)",
                  "description": "Returns a new character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n \n sb.subSequence(begin, end)\n\n behaves in exactly the same way as the invocation\n\n \n sb.substring(begin, end)\n\n This method is provided so that this class can\n implement the CharSequence interface."
                }
              ]
            },
            {
              "name": "insert",
              "overloads": [
                {
                  "signature": "public StringBuffer insert(int index, char[] str, int offset, int len)",
                  "description": "Inserts the string representation of a subarray of the str\n array argument into this sequence. The subarray begins at the\n specified offset and extends len chars.\n The characters of the subarray are inserted into this sequence at\n the position indicated by index. The length of this\n sequence increases by len chars."
                },
                {
                  "signature": "public StringBuffer insert(int offset, Object obj)",
                  "description": "Inserts the string representation of the Object\n argument into this character sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(Object),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, String str)",
                  "description": "Inserts the string into this character sequence.\n \n The characters of the String argument are inserted, in\n order, into this sequence at the indicated offset, moving up any\n characters originally above that position and increasing the length\n of this sequence by the length of the argument. If\n str is null, then the four characters\n \"null\" are inserted into this sequence.\n \n The character at index k in the new character sequence is\n equal to:\n \n the character at index k in the old character sequence, if\n k is less than offset\n the character at index k-offset in the\n argument str, if k is not less than\n offset but is less than offset+str.length()\n the character at index k-str.length() in the\n old character sequence, if k is not less than\n offset+str.length()\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, char[] str)",
                  "description": "Inserts the string representation of the char array\n argument into this sequence.\n \n The characters of the array argument are inserted into the\n contents of this sequence at the position indicated by\n offset. The length of this sequence increases by\n the length of the argument.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int dstOffset, CharSequence s)",
                  "description": "Inserts the specified CharSequence into this sequence.\n \n The characters of the CharSequence argument are inserted,\n in order, into this sequence at the indicated offset, moving up\n any characters originally above that position and increasing the length\n of this sequence by the length of the argument s.\n \n The result of this method is exactly the same as if it were an\n invocation of this object's\n insert(dstOffset, s, 0, s.length())\n method.\n\n If s is null, then the four characters\n \"null\" are inserted into this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int dstOffset, CharSequence s, int start, int end)",
                  "description": "Inserts a subsequence of the specified CharSequence into\n this sequence.\n \n The subsequence of the argument s specified by\n start and end are inserted,\n in order, into this sequence at the specified destination offset, moving\n up any characters originally above that position. The length of this\n sequence is increased by end - start.\n \n The character at index k in this sequence becomes equal to:\n \n the character at index k in this sequence, if\n k is less than dstOffset\n the character at index k+start-dstOffset in\n the argument s, if k is greater than or equal to\n dstOffset but is less than dstOffset+end-start\n the character at index k-(end-start) in this\n sequence, if k is greater than or equal to\n dstOffset+end-start\n \n The dstOffset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence.\n The start argument must be nonnegative, and not greater than\n end.\n The end argument must be greater than or equal to\n start, and less than or equal to the length of s.\n\n If s is null, then this method inserts\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuffer insert(int offset, boolean b)",
                  "description": "Inserts the string representation of the boolean\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, char c)",
                  "description": "Inserts the string representation of the char\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char),\n and the character in that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, int i)",
                  "description": "Inserts the string representation of the second int\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(int),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, long l)",
                  "description": "Inserts the string representation of the long\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(long),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, float f)",
                  "description": "Inserts the string representation of the float\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(float),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuffer insert(int offset, double d)",
                  "description": "Inserts the string representation of the double\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(double),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\" is\n considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public StringBuffer reverse()",
                  "description": "Causes this character sequence to be replaced by the reverse of\n the sequence. If there are any surrogate pairs included in the\n sequence, these are treated as single characters for the\n reverse operation. Thus, the order of the high-low surrogates\n is never reversed.\n\n Let n be the character length of this character sequence\n (not the length in char values) just prior to\n execution of the reverse method. Then the\n character at index k in the new character sequence is\n equal to the character at index n-k-1 in the old\n character sequence.\n\n Note that the reverse operation may result in producing\n surrogate pairs that were unpaired low-surrogates and\n high-surrogates before the operation. For example, reversing\n \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is\n a valid surrogate pair."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representing the data in this sequence.\n A new String object is allocated and initialized to\n contain the character sequence currently represented by this\n object. This String is then returned. Subsequent\n changes to this sequence do not affect the contents of the\n String."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            }
          ]
        },
        {
          "name": "StringBuilder",
          "methods": [
            {
              "name": "StringBuilder",
              "overloads": [
                {
                  "signature": "public StringBuilder()",
                  "description": "Constructs a string builder with no characters in it and an\n initial capacity of 16 characters."
                },
                {
                  "signature": "public StringBuilder(int capacity)",
                  "description": "Constructs a string builder with no characters in it and an\n initial capacity specified by the capacity argument."
                },
                {
                  "signature": "public StringBuilder(String str)",
                  "description": "Constructs a string builder initialized to the contents of the\n specified string. The initial capacity of the string builder is\n 16 plus the length of the string argument."
                },
                {
                  "signature": "public StringBuilder(CharSequence seq)",
                  "description": "Constructs a string builder that contains the same characters\n as the specified CharSequence. The initial capacity of\n the string builder is 16 plus the length of the\n CharSequence argument."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(StringBuilder another)",
                  "description": "Compares two StringBuilder instances lexicographically. This method\n follows the same rules for lexicographical comparison as defined in the\n CharSequence.compare(this, another) method.\n\n \n For finer-grained, locale-sensitive String comparison, refer to\n Collator."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringBuilder append(Object obj)",
                  "description": "Appends the string representation of the Object argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(Object),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(String str)",
                  "description": "Appends the specified string to this character sequence.\n \n The characters of the String argument are appended, in\n order, increasing the length of this sequence by the length of the\n argument. If str is null, then the four\n characters \"null\" are appended.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in the new character sequence is equal to the character\n at index k in the old character sequence, if k is less\n than n; otherwise, it is equal to the character at index\n k-n in the argument str."
                },
                {
                  "signature": "public StringBuilder append(StringBuffer sb)",
                  "description": "Appends the specified StringBuffer to this sequence.\n \n The characters of the StringBuffer argument are appended,\n in order, to this sequence, increasing the\n length of this sequence by the length of the argument.\n If sb is null, then the four characters\n \"null\" are appended to this sequence.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at index\n k in the new character sequence is equal to the character at\n index k in the old character sequence, if k is less than\n n; otherwise, it is equal to the character at index k-n\n in the argument sb."
                },
                {
                  "signature": "public StringBuilder append(CharSequence s)",
                  "description": "Description copied from interface:Appendable"
                },
                {
                  "signature": "public StringBuilder append(CharSequence s, int start, int end)",
                  "description": "Appends a subsequence of the specified CharSequence to this\n sequence.\n \n Characters of the argument s, starting at\n index start, are appended, in order, to the contents of\n this sequence up to the (exclusive) index end. The length\n of this sequence is increased by the value of end - start.\n \n Let n be the length of this character sequence just prior to\n execution of the append method. Then the character at\n index k in this character sequence becomes equal to the\n character at index k in this sequence, if k is less than\n n; otherwise, it is equal to the character at index\n k+start-n in the argument s.\n \n If s is null, then this method appends\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuilder append(char[] str)",
                  "description": "Appends the string representation of the char array\n argument to this sequence.\n \n The characters of the array argument are appended, in order, to\n the contents of this sequence. The length of this sequence\n increases by the length of the argument.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(char[] str, int offset, int len)",
                  "description": "Appends the string representation of a subarray of the\n char array argument to this sequence.\n \n Characters of the char array str, starting at\n index offset, are appended, in order, to the contents\n of this sequence. The length of this sequence increases\n by the value of len.\n \n The overall effect is exactly as if the arguments were converted\n to a string by the method String.valueOf(char[],int,int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(boolean b)",
                  "description": "Appends the string representation of the boolean\n argument to the sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(char c)",
                  "description": "Appends the string representation of the char\n argument to this sequence.\n \n The argument is appended to the contents of this sequence.\n The length of this sequence increases by 1.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(char),\n and the character in that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(int i)",
                  "description": "Appends the string representation of the int\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(int),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(long lng)",
                  "description": "Appends the string representation of the long\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(long),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(float f)",
                  "description": "Appends the string representation of the float\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(float),\n and the characters of that string were then\n appended to this character sequence."
                },
                {
                  "signature": "public StringBuilder append(double d)",
                  "description": "Appends the string representation of the double\n argument to this sequence.\n \n The overall effect is exactly as if the argument were converted\n to a string by the method String.valueOf(double),\n and the characters of that string were then\n appended to this character sequence."
                }
              ]
            },
            {
              "name": "appendCodePoint",
              "overloads": [
                {
                  "signature": "public StringBuilder appendCodePoint(int codePoint)",
                  "description": "Appends the string representation of the codePoint\n argument to this sequence.\n\n  The argument is appended to the contents of this sequence.\n The length of this sequence increases by\n Character.charCount(codePoint).\n\n  The overall effect is exactly as if the argument were\n converted to a char array by the method\n Character.toChars(int) and the character in that array\n were then appended to this character\n sequence."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public StringBuilder delete(int start, int end)",
                  "description": "Removes the characters in a substring of this sequence.\n The substring begins at the specified start and extends to\n the character at index end - 1 or to the end of the\n sequence if no such character exists. If\n start is equal to end, no changes are made."
                }
              ]
            },
            {
              "name": "deleteCharAt",
              "overloads": [
                {
                  "signature": "public StringBuilder deleteCharAt(int index)",
                  "description": "Removes the char at the specified position in this\n sequence. This sequence is shortened by one char.\n\n Note: If the character at the given index is a supplementary\n character, this method does not remove the entire character. If\n correct handling of supplementary characters is required,\n determine the number of chars to remove by calling\n Character.charCount(thisSequence.codePointAt(index)),\n where thisSequence is this sequence."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public StringBuilder replace(int start, int end, String str)",
                  "description": "Replaces the characters in a substring of this sequence\n with characters in the specified String. The substring\n begins at the specified start and extends to the character\n at index end - 1 or to the end of the\n sequence if no such character exists. First the\n characters in the substring are removed and then the specified\n String is inserted at start. (This\n sequence will be lengthened to accommodate the\n specified String if necessary.)"
                }
              ]
            },
            {
              "name": "insert",
              "overloads": [
                {
                  "signature": "public StringBuilder insert(int index, char[] str, int offset, int len)",
                  "description": "Inserts the string representation of a subarray of the str\n array argument into this sequence. The subarray begins at the\n specified offset and extends len chars.\n The characters of the subarray are inserted into this sequence at\n the position indicated by index. The length of this\n sequence increases by len chars."
                },
                {
                  "signature": "public StringBuilder insert(int offset, Object obj)",
                  "description": "Inserts the string representation of the Object\n argument into this character sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(Object),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, String str)",
                  "description": "Inserts the string into this character sequence.\n \n The characters of the String argument are inserted, in\n order, into this sequence at the indicated offset, moving up any\n characters originally above that position and increasing the length\n of this sequence by the length of the argument. If\n str is null, then the four characters\n \"null\" are inserted into this sequence.\n \n The character at index k in the new character sequence is\n equal to:\n \n the character at index k in the old character sequence, if\n k is less than offset\n the character at index k-offset in the\n argument str, if k is not less than\n offset but is less than offset+str.length()\n the character at index k-str.length() in the\n old character sequence, if k is not less than\n offset+str.length()\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, char[] str)",
                  "description": "Inserts the string representation of the char array\n argument into this sequence.\n \n The characters of the array argument are inserted into the\n contents of this sequence at the position indicated by\n offset. The length of this sequence increases by\n the length of the argument.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char[]),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int dstOffset, CharSequence s)",
                  "description": "Inserts the specified CharSequence into this sequence.\n \n The characters of the CharSequence argument are inserted,\n in order, into this sequence at the indicated offset, moving up\n any characters originally above that position and increasing the length\n of this sequence by the length of the argument s.\n \n The result of this method is exactly the same as if it were an\n invocation of this object's\n insert(dstOffset, s, 0, s.length())\n method.\n\n If s is null, then the four characters\n \"null\" are inserted into this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int dstOffset, CharSequence s, int start, int end)",
                  "description": "Inserts a subsequence of the specified CharSequence into\n this sequence.\n \n The subsequence of the argument s specified by\n start and end are inserted,\n in order, into this sequence at the specified destination offset, moving\n up any characters originally above that position. The length of this\n sequence is increased by end - start.\n \n The character at index k in this sequence becomes equal to:\n \n the character at index k in this sequence, if\n k is less than dstOffset\n the character at index k+start-dstOffset in\n the argument s, if k is greater than or equal to\n dstOffset but is less than dstOffset+end-start\n the character at index k-(end-start) in this\n sequence, if k is greater than or equal to\n dstOffset+end-start\n \n The dstOffset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence.\n The start argument must be nonnegative, and not greater than\n end.\n The end argument must be greater than or equal to\n start, and less than or equal to the length of s.\n\n If s is null, then this method inserts\n characters as if the s parameter was a sequence containing the four\n characters \"null\"."
                },
                {
                  "signature": "public StringBuilder insert(int offset, boolean b)",
                  "description": "Inserts the string representation of the boolean\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(boolean),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, char c)",
                  "description": "Inserts the string representation of the char\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(char),\n and the character in that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, int i)",
                  "description": "Inserts the string representation of the second int\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(int),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, long l)",
                  "description": "Inserts the string representation of the long\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(long),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, float f)",
                  "description": "Inserts the string representation of the float\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(float),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                },
                {
                  "signature": "public StringBuilder insert(int offset, double d)",
                  "description": "Inserts the string representation of the double\n argument into this sequence.\n \n The overall effect is exactly as if the second argument were\n converted to a string by the method String.valueOf(double),\n and the characters of that string were then\n inserted into this character\n sequence at the indicated offset.\n \n The offset argument must be greater than or equal to\n 0, and less than or equal to the length\n of this sequence."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(String str)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring.\n\n The returned index is the smallest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int indexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the first occurrence of the\n specified substring, starting at the specified index.\n\n The returned index is the smallest value k for which:\n \n     k >= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(String str)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring.  The last occurrence of the empty string \"\" is\n considered to occur at the index value this.length().\n\n The returned index is the largest value k for which:\n \n this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                },
                {
                  "signature": "public int lastIndexOf(String str, int fromIndex)",
                  "description": "Returns the index within this string of the last occurrence of the\n specified substring, searching backward starting at the specified index.\n\n The returned index is the largest value k for which:\n \n     k <= Math.min(fromIndex, this.length()) &&\n                   this.toString().startsWith(str, k)\n \n If no such value of k exists, then -1 is returned."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public StringBuilder reverse()",
                  "description": "Causes this character sequence to be replaced by the reverse of\n the sequence. If there are any surrogate pairs included in the\n sequence, these are treated as single characters for the\n reverse operation. Thus, the order of the high-low surrogates\n is never reversed.\n\n Let n be the character length of this character sequence\n (not the length in char values) just prior to\n execution of the reverse method. Then the\n character at index k in the new character sequence is\n equal to the character at index n-k-1 in the old\n character sequence.\n\n Note that the reverse operation may result in producing\n surrogate pairs that were unpaired low-surrogates and\n high-surrogates before the operation. For example, reversing\n \"\\uDC00\\uD800\" produces \"\\uD800\\uDC00\" which is\n a valid surrogate pair."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representing the data in this sequence.\n A new String object is allocated and initialized to\n contain the character sequence currently represented by this\n object. This String is then returned. Subsequent\n changes to this sequence do not affect the contents of the\n String."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length (character count)."
                }
              ]
            },
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public int capacity()",
                  "description": "Returns the current capacity. The capacity is the number of characters\n that can be stored (including already written characters), beyond which\n an allocation will occur."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minimumCapacity)",
                  "description": "Ensures that the capacity is at least equal to the specified minimum.\n If the current capacity is less than the argument, then a new internal\n array is allocated with greater capacity. The new capacity is the\n larger of:\n \n The minimumCapacity argument.\n Twice the old capacity, plus 2.\n \n If the minimumCapacity argument is nonpositive, this\n method takes no action and simply returns.\n Note that subsequent operations on this object can reduce the\n actual capacity below that requested here."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Attempts to reduce storage used for the character sequence.\n If the buffer is larger than necessary to hold its current sequence of\n characters, then it may be resized to become more space efficient.\n Calling this method may, but is not required to, affect the value\n returned by a subsequent call to the capacity() method."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int newLength)",
                  "description": "Sets the length of the character sequence.\n The sequence is changed to a new character sequence\n whose length is specified by the argument. For every nonnegative\n index k less than newLength, the character at\n index k in the new character sequence is the same as the\n character at index k in the old sequence if k is less\n than the length of the old character sequence; otherwise, it is the\n null character '\\u0000'.\n\n In other words, if the newLength argument is less than\n the current length, the length is changed to the specified length.\n \n If the newLength argument is greater than or equal\n to the current length, sufficient null characters\n ('\\u0000') are appended so that\n length becomes the newLength argument.\n \n The newLength argument must be greater than or equal\n to 0."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public char charAt(int index)",
                  "description": "Returns the char value in this sequence at the specified index.\n The first char value is at index 0, the next at index\n 1, and so on, as in array indexing.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence.\n\n If the char value specified by the index is a\n surrogate, the surrogate\n value is returned."
                }
              ]
            },
            {
              "name": "codePointAt",
              "overloads": [
                {
                  "signature": "public int codePointAt(int index)",
                  "description": "Returns the character (Unicode code point) at the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 0 to\n CharSequence.length() - 1.\n\n  If the char value specified at the given index\n is in the high-surrogate range, the following index is less\n than the length of this sequence, and the\n char value at the following index is in the\n low-surrogate range, then the supplementary code point\n corresponding to this surrogate pair is returned. Otherwise,\n the char value at the given index is returned."
                }
              ]
            },
            {
              "name": "codePointBefore",
              "overloads": [
                {
                  "signature": "public int codePointBefore(int index)",
                  "description": "Returns the character (Unicode code point) before the specified\n index. The index refers to char values\n (Unicode code units) and ranges from 1 to CharSequence.length().\n\n  If the char value at (index - 1)\n is in the low-surrogate range, (index - 2) is not\n negative, and the char value at (index -\n 2) is in the high-surrogate range, then the\n supplementary code point value of the surrogate pair is\n returned. If the char value at index -\n 1 is an unpaired low-surrogate or a high-surrogate, the\n surrogate value is returned."
                }
              ]
            },
            {
              "name": "codePointCount",
              "overloads": [
                {
                  "signature": "public int codePointCount(int beginIndex, int endIndex)",
                  "description": "Returns the number of Unicode code points in the specified text\n range of this sequence. The text range begins at the specified\n beginIndex and extends to the char at\n index endIndex - 1. Thus the length (in\n chars) of the text range is\n endIndex-beginIndex. Unpaired surrogates within\n this sequence count as one code point each."
                }
              ]
            },
            {
              "name": "offsetByCodePoints",
              "overloads": [
                {
                  "signature": "public int offsetByCodePoints(int index, int codePointOffset)",
                  "description": "Returns the index within this sequence that is offset from the\n given index by codePointOffset code\n points. Unpaired surrogates within the text range given by\n index and codePointOffset count as\n one code point each."
                }
              ]
            },
            {
              "name": "getChars",
              "overloads": [
                {
                  "signature": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
                  "description": "Characters are copied from this sequence into the\n destination character array dst. The first character to\n be copied is at index srcBegin; the last character to\n be copied is at index srcEnd-1. The total number of\n characters to be copied is srcEnd-srcBegin. The\n characters are copied into the subarray of dst starting\n at index dstBegin and ending at index:\n \n dstbegin + (srcEnd-srcBegin) - 1"
                }
              ]
            },
            {
              "name": "setCharAt",
              "overloads": [
                {
                  "signature": "public void setCharAt(int index, char ch)",
                  "description": "The character at the specified index is set to ch. This\n sequence is altered to represent a new character sequence that is\n identical to the old character sequence, except that it contains the\n character ch at position index.\n \n The index argument must be greater than or equal to\n 0, and less than the length of this sequence."
                }
              ]
            },
            {
              "name": "substring",
              "overloads": [
                {
                  "signature": "public String substring(int start)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this character sequence. The\n substring begins at the specified index and extends to the end of\n this sequence."
                },
                {
                  "signature": "public String substring(int start, int end)",
                  "description": "Returns a new String that contains a subsequence of\n characters currently contained in this sequence. The\n substring begins at the specified start and\n extends to the character at index end - 1."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public CharSequence subSequence(int start, int end)",
                  "description": "Returns a new character sequence that is a subsequence of this sequence.\n\n  An invocation of this method of the form\n\n \n sb.subSequence(begin, end)\n\n behaves in exactly the same way as the invocation\n\n \n sb.substring(begin, end)\n\n This method is provided so that this class can\n implement the CharSequence interface."
                }
              ]
            },
            {
              "name": "chars",
              "overloads": [
                {
                  "signature": "public IntStream chars()",
                  "description": "Returns a stream of int zero-extending the char values\n from this sequence.  Any char which maps to a surrogate code\n point is passed through uninterpreted.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            },
            {
              "name": "codePoints",
              "overloads": [
                {
                  "signature": "public IntStream codePoints()",
                  "description": "Returns a stream of code point values from this sequence.  Any surrogate\n pairs encountered in the sequence are combined as if by Character.toCodePoint and the result is passed\n to the stream. Any other code units, including ordinary BMP characters,\n unpaired surrogates, and undefined code units, are zero-extended to\n int values which are then passed to the stream.\n\n The stream binds to this sequence when the terminal stream operation\n commences (specifically, for mutable sequences the spliterator for the\n stream is late-binding).\n If the sequence is modified during that operation then the result is\n undefined."
                }
              ]
            }
          ]
        },
        {
          "name": "StringIndexOutOfBoundsException",
          "methods": [
            {
              "name": "StringIndexOutOfBoundsException",
              "overloads": [
                {
                  "signature": "public StringIndexOutOfBoundsException()",
                  "description": "Constructs a StringIndexOutOfBoundsException with no detail\n message."
                },
                {
                  "signature": "public StringIndexOutOfBoundsException(String s)",
                  "description": "Constructs a StringIndexOutOfBoundsException with the specified\n detail message."
                },
                {
                  "signature": "public StringIndexOutOfBoundsException(int index)",
                  "description": "Constructs a new StringIndexOutOfBoundsException class with an\n argument indicating the illegal index.\n\n The index is included in this exception's detail message.  The\n exact presentation format of the detail message is unspecified."
                }
              ]
            }
          ]
        },
        {
          "name": "System",
          "methods": [
            {
              "name": "setIn",
              "overloads": [
                {
                  "signature": "public static void setIn(InputStream in)",
                  "description": "Reassigns the \"standard\" input stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" input stream."
                }
              ]
            },
            {
              "name": "setOut",
              "overloads": [
                {
                  "signature": "public static void setOut(PrintStream out)",
                  "description": "Reassigns the \"standard\" output stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" output stream."
                }
              ]
            },
            {
              "name": "setErr",
              "overloads": [
                {
                  "signature": "public static void setErr(PrintStream err)",
                  "description": "Reassigns the \"standard\" error output stream.\n\n First, if there is a security manager, its checkPermission\n method is called with a RuntimePermission(\"setIO\") permission\n  to see if it's ok to reassign the \"standard\" error output stream."
                }
              ]
            },
            {
              "name": "console",
              "overloads": [
                {
                  "signature": "public static Console console()",
                  "description": "Returns the unique Console object associated\n with the current Java virtual machine, if any."
                }
              ]
            },
            {
              "name": "inheritedChannel",
              "overloads": [
                {
                  "signature": "public static Channel inheritedChannel() throws IOException",
                  "description": "Returns the channel inherited from the entity that created this\n Java virtual machine.\n\n This method returns the channel obtained by invoking the\n inheritedChannel method of the system-wide default\n SelectorProvider object.\n\n  In addition to the network-oriented channels described in\n inheritedChannel, this method may return other kinds of\n channels in the future."
                }
              ]
            },
            {
              "name": "setSecurityManager",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public static void setSecurityManager(SecurityManager sm)",
                  "description": "Sets the system-wide security manager.\n\n If there is a security manager already installed, this method first\n calls the security manager's checkPermission method\n with a RuntimePermission(\"setSecurityManager\")\n permission to ensure it's ok to replace the existing\n security manager.\n This may result in throwing a SecurityException.\n\n  Otherwise, the argument is established as the current\n security manager. If the argument is null and no\n security manager has been established, then no action is taken and\n the method simply returns.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSecurityManager",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public static SecurityManager getSecurityManager()",
                  "description": "Gets the system-wide security manager.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "currentTimeMillis",
              "overloads": [
                {
                  "signature": "public static long currentTimeMillis()",
                  "description": "Returns the current time in milliseconds.  Note that\n while the unit of time of the return value is a millisecond,\n the granularity of the value depends on the underlying\n operating system and may be larger.  For example, many\n operating systems measure time in units of tens of\n milliseconds.\n\n  See the description of the class Date for\n a discussion of slight discrepancies that may arise between\n \"computer time\" and coordinated universal time (UTC)."
                }
              ]
            },
            {
              "name": "nanoTime",
              "overloads": [
                {
                  "signature": "public static long nanoTime()",
                  "description": "Returns the current value of the running Java Virtual Machine's\n high-resolution time source, in nanoseconds.\n\n This method can only be used to measure elapsed time and is\n not related to any other notion of system or wall-clock time.\n The value returned represents nanoseconds since some fixed but\n arbitrary origin time (perhaps in the future, so values\n may be negative).  The same origin is used by all invocations of\n this method in an instance of a Java virtual machine; other\n virtual machine instances are likely to use a different origin.\n\n This method provides nanosecond precision, but not necessarily\n nanosecond resolution (that is, how frequently the value changes)\n - no guarantees are made except that the resolution is at least as\n good as that of currentTimeMillis().\n\n Differences in successive calls that span greater than\n approximately 292 years (263 nanoseconds) will not\n correctly compute elapsed time due to numerical overflow.\n\n The values returned by this method become meaningful only when\n the difference between two such values, obtained within the same\n instance of a Java virtual machine, is computed.\n\n For example, to measure how long some code takes to execute:\n  \n long startTime = System.nanoTime();\n // ... the code being measured ...\n long elapsedNanos = System.nanoTime() - startTime;\n\n To compare elapsed time against a timeout, use  \n if (System.nanoTime() - startTime >= timeoutNanos) ...\n instead of  \n if (System.nanoTime() >= startTime + timeoutNanos) ...\n because of the possibility of numerical overflow."
                }
              ]
            },
            {
              "name": "arraycopy",
              "overloads": [
                {
                  "signature": "public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)",
                  "description": "Copies an array from the specified source array, beginning at the\n specified position, to the specified position of the destination array.\n A subsequence of array components are copied from the source\n array referenced by src to the destination array\n referenced by dest. The number of components copied is\n equal to the length argument. The components at\n positions srcPos through\n srcPos+length-1 in the source array are copied into\n positions destPos through\n destPos+length-1, respectively, of the destination\n array.\n \n If the src and dest arguments refer to the\n same array object, then the copying is performed as if the\n components at positions srcPos through\n srcPos+length-1 were first copied to a temporary\n array with length components and then the contents of\n the temporary array were copied into positions\n destPos through destPos+length-1 of the\n destination array.\n \n If dest is null, then a\n NullPointerException is thrown.\n \n If src is null, then a\n NullPointerException is thrown and the destination\n array is not modified.\n \n Otherwise, if any of the following is true, an\n ArrayStoreException is thrown and the destination is\n not modified:\n \n The src argument refers to an object that is not an\n     array.\n The dest argument refers to an object that is not an\n     array.\n The src argument and dest argument refer\n     to arrays whose component types are different primitive types.\n The src argument refers to an array with a primitive\n    component type and the dest argument refers to an array\n     with a reference component type.\n The src argument refers to an array with a reference\n    component type and the dest argument refers to an array\n     with a primitive component type.\n \n \n Otherwise, if any of the following is true, an\n IndexOutOfBoundsException is\n thrown and the destination is not modified:\n \n The srcPos argument is negative.\n The destPos argument is negative.\n The length argument is negative.\n srcPos+length is greater than\n     src.length, the length of the source array.\n destPos+length is greater than\n     dest.length, the length of the destination array.\n \n \n Otherwise, if any actual component of the source array from\n position srcPos through\n srcPos+length-1 cannot be converted to the component\n type of the destination array by assignment conversion, an\n ArrayStoreException is thrown. In this case, let\n k be the smallest nonnegative integer less than\n length such that src[srcPos+k]\n cannot be converted to the component type of the destination\n array; when the exception is thrown, source array components from\n positions srcPos through\n srcPos+k-1\n will already have been copied to destination array positions\n destPos through\n destPos+k-1 and no other\n positions of the destination array will have been modified.\n (Because of the restrictions already itemized, this\n paragraph effectively applies only to the situation where both\n arrays have component types that are reference types.)"
                }
              ]
            },
            {
              "name": "identityHashCode",
              "overloads": [
                {
                  "signature": "public static int identityHashCode(Object x)",
                  "description": "Returns the same hash code for the given object as\n would be returned by the default method hashCode(),\n whether or not the given object's class overrides\n hashCode().\n The hash code for the null reference is zero."
                }
              ]
            },
            {
              "name": "getProperties",
              "overloads": [
                {
                  "signature": "public static Properties getProperties()",
                  "description": "Determines the current system properties.\n\n First, if there is a security manager, its\n checkPropertiesAccess method is called with no\n arguments. This may result in a security exception.\n \n The current set of system properties for use by the\n getProperty(String) method is returned as a\n Properties object. If there is no current set of\n system properties, a set of system properties is first created and\n initialized. This set of system properties includes a value\n for each of the following keys unless the description of the associated\n value indicates that the value is optional.\n \n Shows property keys and associated values\n \n Key\n     Description of Associated Value\n \n \n java.version\n     Java Runtime Environment version, which may be interpreted\n     as a Runtime.Version\n java.version.date\n     Java Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     format, which may be interpreted as a LocalDate\n java.vendor\n     Java Runtime Environment vendor\n java.vendor.url\n     Java vendor URL\n java.vendor.version\n     Java vendor version (optional) \n java.home\n     Java installation directory\n java.vm.specification.version\n     Java Virtual Machine specification version, whose value is the\n     feature element of the\n     runtime version\n java.vm.specification.vendor\n     Java Virtual Machine specification vendor\n java.vm.specification.name\n     Java Virtual Machine specification name\n java.vm.version\n     Java Virtual Machine implementation version which may be\n     interpreted as a Runtime.Version\n java.vm.vendor\n     Java Virtual Machine implementation vendor\n java.vm.name\n     Java Virtual Machine implementation name\n java.specification.version\n     Java Runtime Environment specification version, whose value is\n     the feature element of the\n     runtime version\n java.specification.maintenance.version\n     Java Runtime Environment specification maintenance version,\n     may be interpreted as a positive integer (optional, see below)\n java.specification.vendor\n     Java Runtime Environment specification  vendor\n java.specification.name\n     Java Runtime Environment specification  name\n java.class.version\n     Java class format version number\n java.class.path\n     Java class path  (refer to\n        ClassLoader.getSystemClassLoader() for details)\n java.library.path\n     List of paths to search when loading libraries\n java.io.tmpdir\n     Default temp file path\n java.compiler\n     Name of JIT compiler to use\n os.name\n     Operating system name\n os.arch\n     Operating system architecture\n os.version\n     Operating system version\n file.separator\n     File separator (\"/\" on UNIX)\n path.separator\n     Path separator (\":\" on UNIX)\n line.separator\n     Line separator (\"\\n\" on UNIX)\n user.name\n     User's account name\n user.home\n     User's home directory\n user.dir\n     User's current working directory\n native.encoding\n     Character encoding name derived from the host environment and/or\n     the user's settings. Setting this system property has no effect.\n \n \n \n The java.specification.maintenance.version property is\n defined if the specification implemented by this runtime at the\n time of its construction had undergone a maintenance\n release. When defined, its value identifies that\n maintenance release. To indicate the first maintenance release\n this property will have the value \"1\", to indicate the\n second maintenance release this property will have the value\n \"2\", and so on.\n \n Multiple paths in a system property value are separated by the path\n separator character of the platform.\n \n Note that even if the security manager does not permit the\n getProperties operation, it may choose to permit the\n getProperty(String) operation."
                }
              ]
            },
            {
              "name": "lineSeparator",
              "overloads": [
                {
                  "signature": "public static String lineSeparator()",
                  "description": "Returns the system-dependent line separator string.  It always\n returns the same value - the initial value of the system property line.separator.\n\n On UNIX systems, it returns \"\\n\"; on Microsoft\n Windows systems it returns \"\\r\\n\"."
                }
              ]
            },
            {
              "name": "setProperties",
              "overloads": [
                {
                  "signature": "public static void setProperties(Properties props)",
                  "description": "Sets the system properties to the Properties argument.\n\n First, if there is a security manager, its\n checkPropertiesAccess method is called with no\n arguments. This may result in a security exception.\n \n The argument becomes the current set of system properties for use\n by the getProperty(String) method. If the argument is\n null, then the current set of system properties is\n forgotten."
                }
              ]
            },
            {
              "name": "getProperty",
              "overloads": [
                {
                  "signature": "public static String getProperty(String key)",
                  "description": "Gets the system property indicated by the specified key.\n\n First, if there is a security manager, its\n checkPropertyAccess method is called with the key as\n its argument. This may result in a SecurityException.\n \n If there is no current set of system properties, a set of system\n properties is first created and initialized in the same manner as\n for the getProperties method."
                },
                {
                  "signature": "public static String getProperty(String key, String def)",
                  "description": "Gets the system property indicated by the specified key.\n\n First, if there is a security manager, its\n checkPropertyAccess method is called with the\n key as its argument.\n \n If there is no current set of system properties, a set of system\n properties is first created and initialized in the same manner as\n for the getProperties method."
                }
              ]
            },
            {
              "name": "setProperty",
              "overloads": [
                {
                  "signature": "public static String setProperty(String key, String value)",
                  "description": "Sets the system property indicated by the specified key.\n\n First, if a security manager exists, its\n SecurityManager.checkPermission method\n is called with a PropertyPermission(key, \"write\")\n permission. This may result in a SecurityException being thrown.\n If no exception is thrown, the specified property is set to the given\n value."
                }
              ]
            },
            {
              "name": "clearProperty",
              "overloads": [
                {
                  "signature": "public static String clearProperty(String key)",
                  "description": "Removes the system property indicated by the specified key.\n\n First, if a security manager exists, its\n SecurityManager.checkPermission method\n is called with a PropertyPermission(key, \"write\")\n permission. This may result in a SecurityException being thrown.\n If no exception is thrown, the specified property is removed."
                }
              ]
            },
            {
              "name": "getenv",
              "overloads": [
                {
                  "signature": "public static String getenv(String name)",
                  "description": "Gets the value of the specified environment variable. An\n environment variable is a system-dependent external named\n value.\n\n If a security manager exists, its\n checkPermission\n method is called with a\n RuntimePermission(\"getenv.\"+name)\n permission.  This may result in a SecurityException\n being thrown.  If no exception is thrown the value of the\n variable name is returned.\n\n System\n properties and environment variables are both\n conceptually mappings between names and values.  Both\n mechanisms can be used to pass user-defined information to a\n Java process.  Environment variables have a more global effect,\n because they are visible to all descendants of the process\n which defines them, not just the immediate Java subprocess.\n They can have subtly different semantics, such as case\n insensitivity, on different operating systems.  For these\n reasons, environment variables are more likely to have\n unintended side effects.  It is best to use system properties\n where possible.  Environment variables should be used when a\n global effect is desired, or when an external system interface\n requires an environment variable (such as PATH).\n\n On UNIX systems the alphabetic case of name is\n typically significant, while on Microsoft Windows systems it is\n typically not.  For example, the expression\n System.getenv(\"FOO\").equals(System.getenv(\"foo\"))\n is likely to be true on Microsoft Windows."
                },
                {
                  "signature": "public static Map<String,String> getenv()",
                  "description": "Returns an unmodifiable string map view of the current system environment.\n The environment is a system-dependent mapping from names to\n values which is passed from parent to child processes.\n\n If the system does not support environment variables, an\n empty map is returned.\n\n The returned map will never contain null keys or values.\n Attempting to query the presence of a null key or value will\n throw a NullPointerException.  Attempting to query\n the presence of a key or value which is not of type\n String will throw a ClassCastException.\n\n The returned map and its collection views may not obey the\n general contract of the Object.equals(java.lang.Object) and\n Object.hashCode() methods.\n\n The returned map is typically case-sensitive on all platforms.\n\n If a security manager exists, its\n checkPermission\n method is called with a\n RuntimePermission(\"getenv.*\") permission.\n This may result in a SecurityException being thrown.\n\n When passing information to a Java subprocess,\n system properties\n are generally preferred over environment variables."
                }
              ]
            },
            {
              "name": "getLogger",
              "overloads": [
                {
                  "signature": "public static System.Logger getLogger(String name)",
                  "description": "Returns an instance of Logger for the caller's\n use."
                },
                {
                  "signature": "public static System.Logger getLogger(String name, ResourceBundle bundle)",
                  "description": "Returns a localizable instance of Logger for the caller's use.\n The returned logger will use the provided resource bundle for message\n localization."
                }
              ]
            },
            {
              "name": "exit",
              "overloads": [
                {
                  "signature": "public static void exit(int status)",
                  "description": "Terminates the currently running Java Virtual Machine. The\n argument serves as a status code; by convention, a nonzero status\n code indicates abnormal termination.\n \n This method calls the exit method in class\n Runtime. This method never returns normally.\n \n The call System.exit(n) is effectively equivalent to\n the call:\n  Runtime.getRuntime().exit(n)"
                }
              ]
            },
            {
              "name": "gc",
              "overloads": [
                {
                  "signature": "public static void gc()",
                  "description": "Runs the garbage collector in the Java Virtual Machine.\n \n Calling the gc method suggests that the Java Virtual Machine\n expend effort toward recycling unused objects in order to\n make the memory they currently occupy available for reuse\n by the Java Virtual Machine.\n When control returns from the method call, the Java Virtual Machine\n has made a best effort to reclaim space from all unused objects.\n There is no guarantee that this effort will recycle any particular\n number of unused objects, reclaim any particular amount of space, or\n complete at any particular time, if at all, before the method returns or ever.\n There is also no guarantee that this effort will determine\n the change of reachability in any particular number of objects,\n or that any particular number of Reference\n objects will be cleared and enqueued.\n\n \n The call System.gc() is effectively equivalent to the\n call:\n  Runtime.getRuntime().gc()"
                }
              ]
            },
            {
              "name": "runFinalization",
              "overloads": [
                {
                  "signature": "public static void runFinalization()",
                  "description": "Runs the finalization methods of any objects pending finalization.\n\n Calling this method suggests that the Java Virtual Machine expend\n effort toward running the finalize methods of objects\n that have been found to be discarded but whose finalize\n methods have not yet been run. When control returns from the\n method call, the Java Virtual Machine has made a best effort to\n complete all outstanding finalizations.\n \n The call System.runFinalization() is effectively\n equivalent to the call:\n  Runtime.getRuntime().runFinalization()"
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public static void load(String filename)",
                  "description": "Loads the native library specified by the filename argument.  The filename\n argument must be an absolute path name.\n\n If the filename argument, when stripped of any platform-specific library\n prefix, path, and file extension, indicates a library whose name is,\n for example, L, and a native library called L is statically linked\n with the VM, then the JNI_OnLoad_L function exported by the library\n is invoked rather than attempting to load a dynamic library.\n A filename matching the argument does not have to exist in the\n file system.\n See the  JNI Specification\n for more details.\n\n Otherwise, the filename argument is mapped to a native library image in\n an implementation-dependent manner.\n\n \n The call System.load(name) is effectively equivalent\n to the call:\n  Runtime.getRuntime().load(name)"
                }
              ]
            },
            {
              "name": "loadLibrary",
              "overloads": [
                {
                  "signature": "public static void loadLibrary(String libname)",
                  "description": "Loads the native library specified by the libname\n argument.  The libname argument must not contain any platform\n specific prefix, file extension or path. If a native library\n called libname is statically linked with the VM, then the\n JNI_OnLoad_libname function exported by the library is invoked.\n See the  JNI Specification\n for more details.\n\n Otherwise, the libname argument is loaded from a system library\n location and mapped to a native library image in an\n implementation-dependent manner.\n \n The call System.loadLibrary(name) is effectively\n equivalent to the call\n  Runtime.getRuntime().loadLibrary(name)"
                }
              ]
            },
            {
              "name": "mapLibraryName",
              "overloads": [
                {
                  "signature": "public static String mapLibraryName(String libname)",
                  "description": "Maps a library name into a platform-specific string representing\n a native library."
                }
              ]
            }
          ]
        },
        {
          "name": "System.Logger",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "String getName()",
                  "description": "Returns the name of this logger."
                }
              ]
            },
            {
              "name": "isLoggable",
              "overloads": [
                {
                  "signature": "boolean isLoggable(System.Logger.Level level)",
                  "description": "Checks if a message of the given level would be logged by\n this logger."
                }
              ]
            },
            {
              "name": "log",
              "overloads": [
                {
                  "signature": "default void log(System.Logger.Level level, String msg)",
                  "description": "Logs a message."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Supplier<String> msgSupplier)",
                  "description": "Logs a lazily supplied message.\n\n If the logger is currently enabled for the given log message level\n then a message is logged that is the result produced by the\n given supplier function.  Otherwise, the supplier is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Object obj)",
                  "description": "Logs a message produced from the given object.\n\n If the logger is currently enabled for the given log message level then\n a message is logged that, by default, is the result produced from\n calling  toString on the given object.\n Otherwise, the object is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, String msg, Throwable thrown)",
                  "description": "Logs a message associated with a given throwable."
                },
                {
                  "signature": "default void log(System.Logger.Level level, Supplier<String> msgSupplier, Throwable thrown)",
                  "description": "Logs a lazily supplied message associated with a given throwable.\n\n If the logger is currently enabled for the given log message level\n then a message is logged that is the result produced by the\n given supplier function.  Otherwise, the supplier is not operated on."
                },
                {
                  "signature": "default void log(System.Logger.Level level, String format, Object... params)",
                  "description": "Logs a message with an optional list of parameters."
                },
                {
                  "signature": "void log(System.Logger.Level level, ResourceBundle bundle, String msg, Throwable thrown)",
                  "description": "Logs a localized message associated with a given throwable.\n\n If the given resource bundle is non-null,  the msg\n string is localized using the given resource bundle.\n Otherwise the msg string is not localized."
                },
                {
                  "signature": "void log(System.Logger.Level level, ResourceBundle bundle, String format, Object... params)",
                  "description": "Logs a message with resource bundle and an optional list of\n parameters.\n\n If the given resource bundle is non-null,  the format\n string is localized using the given resource bundle.\n Otherwise the format string is not localized."
                }
              ]
            }
          ]
        },
        {
          "name": "System.LoggerFinder",
          "methods": [
            {
              "name": "LoggerFinder",
              "overloads": [
                {
                  "signature": "protected LoggerFinder()",
                  "description": "Creates a new instance of LoggerFinder."
                }
              ]
            },
            {
              "name": "getLogger",
              "overloads": [
                {
                  "signature": "public abstract System.Logger getLogger(String name, Module module)",
                  "description": "Returns an instance of Logger\n for the given module."
                }
              ]
            },
            {
              "name": "getLocalizedLogger",
              "overloads": [
                {
                  "signature": "public System.Logger getLocalizedLogger(String name, ResourceBundle bundle, Module module)",
                  "description": "Returns a localizable instance of Logger\n for the given module.\n The returned logger will use the provided resource bundle for\n message localization."
                }
              ]
            },
            {
              "name": "getLoggerFinder",
              "overloads": [
                {
                  "signature": "public static System.LoggerFinder getLoggerFinder()",
                  "description": "Returns the LoggerFinder instance. There is one\n single system-wide LoggerFinder instance in\n the Java Runtime.  See the class specification of how the\n LoggerFinder implementation is located and\n loaded."
                }
              ]
            }
          ]
        },
        {
          "name": "Thread",
          "methods": [
            {
              "name": "Thread",
              "overloads": [
                {
                  "signature": "public Thread()",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, null, gname), where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(Runnable target)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, target, gname), where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (group, target, gname) ,where gname is a newly generated\n name. Automatically generated names are of the form\n \"Thread-\"+n, where n is an integer."
                },
                {
                  "signature": "public Thread(String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, null, name)."
                },
                {
                  "signature": "public Thread(ThreadGroup group, String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (group, null, name)."
                },
                {
                  "signature": "public Thread(Runnable target, String name)",
                  "description": "Allocates a new Thread object. This constructor has the same\n effect as Thread\n (null, target, name)."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n and belongs to the thread group referred to by group.\n\n If there is a security manager, its\n checkAccess\n method is invoked with the ThreadGroup as its argument.\n\n In addition, its checkPermission method is invoked with\n the RuntimePermission(\"enableContextClassLoaderOverride\")\n permission when invoked directly or indirectly by the constructor\n of a subclass which overrides the getContextClassLoader\n or setContextClassLoader methods.\n\n The priority of the newly created thread is set equal to the\n priority of the thread creating it, that is, the currently running\n thread. The method setPriority may be\n used to change the priority to a new value.\n\n The newly created thread is initially marked as being a daemon\n thread if and only if the thread creating it is currently marked\n as a daemon thread. The method setDaemon\n may be used to change whether or not a thread is a daemon."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name, long stackSize)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n and belongs to the thread group referred to by group, and has\n the specified stack size.\n\n This constructor is identical to Thread(ThreadGroup,Runnable,String) with the exception of the fact\n that it allows the thread stack size to be specified.  The stack size\n is the approximate number of bytes of address space that the virtual\n machine is to allocate for this thread's stack.  The effect of the\n stackSize parameter, if any, is highly platform dependent.\n\n On some platforms, specifying a higher value for the\n stackSize parameter may allow a thread to achieve greater\n recursion depth before throwing a StackOverflowError.\n Similarly, specifying a lower value may allow a greater number of\n threads to exist concurrently without throwing an OutOfMemoryError (or other internal error).  The details of\n the relationship between the value of the stackSize parameter\n and the maximum recursion depth and concurrency level are\n platform-dependent.  On some platforms, the value of the\n stackSize parameter may have no effect whatsoever.\n\n The virtual machine is free to treat the stackSize\n parameter as a suggestion.  If the specified value is unreasonably low\n for the platform, the virtual machine may instead use some\n platform-specific minimum value; if the specified value is unreasonably\n high, the virtual machine may instead use some platform-specific\n maximum.  Likewise, the virtual machine is free to round the specified\n value up or down as it sees fit (or to ignore it completely).\n\n Specifying a value of zero for the stackSize parameter will\n cause this constructor to behave exactly like the\n Thread(ThreadGroup, Runnable, String) constructor.\n\n Due to the platform-dependent nature of the behavior of this\n constructor, extreme care should be exercised in its use.\n The thread stack size necessary to perform a given computation will\n likely vary from one JRE implementation to another.  In light of this\n variation, careful tuning of the stack size parameter may be required,\n and the tuning may need to be repeated for each JRE implementation on\n which an application is to run.\n\n Implementation note: Java platform implementers are encouraged to\n document their implementation's behavior with respect to the\n stackSize parameter."
                },
                {
                  "signature": "public Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)",
                  "description": "Allocates a new Thread object so that it has target\n as its run object, has the specified name as its name,\n belongs to the thread group referred to by group, has\n the specified stackSize, and inherits initial values for\n inheritable thread-local variables\n if inheritThreadLocals is true.\n\n  This constructor is identical to Thread(ThreadGroup,Runnable,String,long) with the added ability to\n suppress, or not, the inheriting of initial values for inheritable\n thread-local variables from the constructing thread. This allows for\n finer grain control over inheritable thread-locals. Care must be taken\n when passing a value of false for inheritThreadLocals,\n as it may lead to unexpected behavior if the new thread executes code\n that expects a specific thread-local value to be inherited.\n\n  Specifying a value of true for the inheritThreadLocals\n parameter will cause this constructor to behave exactly like the\n Thread(ThreadGroup, Runnable, String, long) constructor."
                }
              ]
            },
            {
              "name": "currentThread",
              "overloads": [
                {
                  "signature": "public static Thread currentThread()",
                  "description": "Returns a reference to the currently executing thread object."
                }
              ]
            },
            {
              "name": "yield",
              "overloads": [
                {
                  "signature": "public static void yield()",
                  "description": "A hint to the scheduler that the current thread is willing to yield\n its current use of a processor. The scheduler is free to ignore this\n hint.\n\n  Yield is a heuristic attempt to improve relative progression\n between threads that would otherwise over-utilise a CPU. Its use\n should be combined with detailed profiling and benchmarking to\n ensure that it actually has the desired effect.\n\n  It is rarely appropriate to use this method. It may be useful\n for debugging or testing purposes, where it may help to reproduce\n bugs due to race conditions. It may also be useful when designing\n concurrency control constructs such as the ones in the\n java.util.concurrent.locks package."
                }
              ]
            },
            {
              "name": "sleep",
              "overloads": [
                {
                  "signature": "public static void sleep(long millis) throws InterruptedException",
                  "description": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds, subject to\n the precision and accuracy of system timers and schedulers. The thread\n does not lose ownership of any monitors."
                },
                {
                  "signature": "public static void sleep(long millis, int nanos) throws InterruptedException",
                  "description": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds plus the specified\n number of nanoseconds, subject to the precision and accuracy of system\n timers and schedulers. The thread does not lose ownership of any\n monitors."
                }
              ]
            },
            {
              "name": "onSpinWait",
              "overloads": [
                {
                  "signature": "public static void onSpinWait()",
                  "description": "Indicates that the caller is momentarily unable to progress, until the\n occurrence of one or more actions on the part of other activities. By\n invoking this method within each iteration of a spin-wait loop construct,\n the calling thread indicates to the runtime that it is busy-waiting.\n The runtime may take action to improve the performance of invoking\n spin-wait loop constructions."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected Object clone() throws CloneNotSupportedException",
                  "description": "Throws CloneNotSupportedException as a Thread can not be meaningfully\n cloned. Construct a new Thread instead."
                }
              ]
            },
            {
              "name": "start",
              "overloads": [
                {
                  "signature": "public void start()",
                  "description": "Causes this thread to begin execution; the Java Virtual Machine\n calls the run method of this thread.\n \n The result is that two threads are running concurrently: the\n current thread (which returns from the call to the\n start method) and the other thread (which executes its\n run method).\n \n It is never legal to start a thread more than once.\n In particular, a thread may not be restarted once it has completed\n execution."
                }
              ]
            },
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "public void run()",
                  "description": "If this thread was constructed using a separate\n Runnable run object, then that\n Runnable object's run method is called;\n otherwise, this method does nothing and returns.\n \n Subclasses of Thread should override this method."
                }
              ]
            },
            {
              "name": "stop",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\") public final void stop()",
                  "description": "Forces the thread to stop executing.\n \n If there is a security manager installed, its checkAccess\n method is called with this\n as its argument. This may result in a\n SecurityException being raised (in the current thread).\n \n If this thread is different from the current thread (that is, the current\n thread is trying to stop a thread other than itself), the\n security manager's checkPermission method (with a\n RuntimePermission(\"stopThread\") argument) is called in\n addition.\n Again, this may result in throwing a\n SecurityException (in the current thread).\n \n The thread represented by this thread is forced to stop whatever\n it is doing abnormally and to throw a newly created\n ThreadDeath object as an exception.\n \n It is permitted to stop a thread that has not yet been started.\n If the thread is eventually started, it immediately terminates.\n \n An application should not normally try to catch\n ThreadDeath unless it must do some extraordinary\n cleanup operation (note that the throwing of\n ThreadDeath causes finally clauses of\n try statements to be executed before the thread\n officially dies).  If a catch clause catches a\n ThreadDeath object, it is important to rethrow the\n object so that the thread actually dies.\n \n The top-level error handler that reacts to otherwise uncaught\n exceptions does not print out a message or otherwise notify the\n application if the uncaught exception is an instance of\n ThreadDeath.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "interrupt",
              "overloads": [
                {
                  "signature": "public void interrupt()",
                  "description": "Interrupts this thread.\n\n  Unless the current thread is interrupting itself, which is\n always permitted, the checkAccess method\n of this thread is invoked, which may cause a SecurityException to be thrown.\n\n  If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object\n class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int)\n methods of this class, then its interrupt status will be cleared and it\n will receive an InterruptedException.\n\n  If this thread is blocked in an I/O operation upon an InterruptibleChannel\n then the channel will be closed, the thread's interrupt\n status will be set, and the thread will receive a ClosedByInterruptException.\n\n  If this thread is blocked in a Selector\n then the thread's interrupt status will be set and it will return\n immediately from the selection operation, possibly with a non-zero\n value, just as if the selector's wakeup method were invoked.\n\n  If none of the previous conditions hold then this thread's interrupt\n status will be set. \n\n  Interrupting a thread that is not alive need not have any effect."
                }
              ]
            },
            {
              "name": "interrupted",
              "overloads": [
                {
                  "signature": "public static boolean interrupted()",
                  "description": "Tests whether the current thread has been interrupted.  The\n interrupted status of the thread is cleared by this method.  In\n other words, if this method were to be called twice in succession, the\n second call would return false (unless the current thread were\n interrupted again, after the first call had cleared its interrupted\n status and before the second call had examined it)."
                }
              ]
            },
            {
              "name": "isInterrupted",
              "overloads": [
                {
                  "signature": "public boolean isInterrupted()",
                  "description": "Tests whether this thread has been interrupted.  The interrupted\n status of the thread is unaffected by this method."
                }
              ]
            },
            {
              "name": "isAlive",
              "overloads": [
                {
                  "signature": "public final boolean isAlive()",
                  "description": "Tests if this thread is alive. A thread is alive if it has\n been started and has not yet died."
                }
              ]
            },
            {
              "name": "suspend",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void suspend()",
                  "description": "Suspends this thread.\n \n First, the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException (in the current thread).\n \n If the thread is alive, it is suspended and makes no further\n progress unless and until it is resumed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "resume",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void resume()",
                  "description": "Resumes a suspended thread.\n \n First, the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException (in the current thread).\n \n If the thread is alive but suspended, it is resumed and is\n permitted to make progress in its execution.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPriority",
              "overloads": [
                {
                  "signature": "public final void setPriority(int newPriority)",
                  "description": "Changes the priority of this thread.\n \n First the checkAccess method of this thread is called\n with no arguments. This may result in throwing a SecurityException.\n \n Otherwise, the priority of this thread is set to the smaller of\n the specified newPriority and the maximum permitted\n priority of the thread's thread group."
                }
              ]
            },
            {
              "name": "getPriority",
              "overloads": [
                {
                  "signature": "public final int getPriority()",
                  "description": "Returns this thread's priority."
                }
              ]
            },
            {
              "name": "setName",
              "overloads": [
                {
                  "signature": "public final void setName(String name)",
                  "description": "Changes the name of this thread to be equal to the argument name.\n \n First the checkAccess method of this thread is called\n with no arguments. This may result in throwing a\n SecurityException."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns this thread's name."
                }
              ]
            },
            {
              "name": "getThreadGroup",
              "overloads": [
                {
                  "signature": "public final ThreadGroup getThreadGroup()",
                  "description": "Returns the thread group to which this thread belongs.\n This method returns null if this thread has died\n (been stopped)."
                }
              ]
            },
            {
              "name": "activeCount",
              "overloads": [
                {
                  "signature": "public static int activeCount()",
                  "description": "Returns an estimate of the number of active threads in the current\n thread's thread group and its\n subgroups. Recursively iterates over all subgroups in the current\n thread's thread group.\n\n  The value returned is only an estimate because the number of\n threads may change dynamically while this method traverses internal\n data structures, and might be affected by the presence of certain\n system threads. This method is intended primarily for debugging\n and monitoring purposes."
                }
              ]
            },
            {
              "name": "enumerate",
              "overloads": [
                {
                  "signature": "public static int enumerate(Thread[] tarray)",
                  "description": "Copies into the specified array every active thread in the current\n thread's thread group and its subgroups. This method simply\n invokes the ThreadGroup.enumerate(Thread[])\n method of the current thread's thread group.\n\n  An application might use the activeCount\n method to get an estimate of how big the array should be, however\n if the array is too short to hold all the threads, the extra threads\n are silently ignored.  If it is critical to obtain every active\n thread in the current thread's thread group and its subgroups, the\n invoker should verify that the returned int value is strictly less\n than the length of tarray.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "countStackFrames",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public int countStackFrames()",
                  "description": "Throws UnsupportedOperationException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "public final void join(long millis) throws InterruptedException",
                  "description": "Waits at most millis milliseconds for this thread to\n die. A timeout of 0 means to wait forever.\n\n  This implementation uses a loop of this.wait calls\n conditioned on this.isAlive. As a thread terminates the\n this.notifyAll method is invoked. It is recommended that\n applications not use wait, notify, or\n notifyAll on Thread instances."
                },
                {
                  "signature": "public final void join(long millis, int nanos) throws InterruptedException",
                  "description": "Waits at most millis milliseconds plus\n nanos nanoseconds for this thread to die.\n If both arguments are 0, it means to wait forever.\n\n  This implementation uses a loop of this.wait calls\n conditioned on this.isAlive. As a thread terminates the\n this.notifyAll method is invoked. It is recommended that\n applications not use wait, notify, or\n notifyAll on Thread instances."
                },
                {
                  "signature": "public final void join() throws InterruptedException",
                  "description": "Waits for this thread to die.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n join(0)"
                }
              ]
            },
            {
              "name": "dumpStack",
              "overloads": [
                {
                  "signature": "public static void dumpStack()",
                  "description": "Prints a stack trace of the current thread to the standard error stream.\n This method is used only for debugging."
                }
              ]
            },
            {
              "name": "setDaemon",
              "overloads": [
                {
                  "signature": "public final void setDaemon(boolean on)",
                  "description": "Marks this thread as either a daemon thread\n or a user thread. The Java Virtual Machine exits when the only\n threads running are all daemon threads.\n\n  This method must be invoked before the thread is started."
                }
              ]
            },
            {
              "name": "isDaemon",
              "overloads": [
                {
                  "signature": "public final boolean isDaemon()",
                  "description": "Tests if this thread is a daemon thread."
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public final void checkAccess()",
                  "description": "Determines if the currently running thread has permission to\n modify this thread.\n \n If there is a security manager, its checkAccess method\n is called with this thread as its argument. This may result in\n throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this thread, including the\n thread's name, priority, and thread group."
                }
              ]
            },
            {
              "name": "getContextClassLoader",
              "overloads": [
                {
                  "signature": "public ClassLoader getContextClassLoader()",
                  "description": "Returns the context ClassLoader for this thread. The context\n ClassLoader is provided by the creator of the thread for use\n by code running in this thread when loading classes and resources.\n If not set, the default is the\n ClassLoader context of the parent thread. The context\n ClassLoader of the\n primordial thread is typically set to the class loader used to load the\n application."
                }
              ]
            },
            {
              "name": "setContextClassLoader",
              "overloads": [
                {
                  "signature": "public void setContextClassLoader(ClassLoader cl)",
                  "description": "Sets the context ClassLoader for this Thread. The context\n ClassLoader can be set when a thread is created, and allows\n the creator of the thread to provide the appropriate class loader,\n through getContextClassLoader, to code running in the thread\n when loading classes and resources.\n\n If a security manager is present, its checkPermission\n method is invoked with a RuntimePermission\n (\"setContextClassLoader\") permission to see if setting the context\n ClassLoader is permitted."
                }
              ]
            },
            {
              "name": "holdsLock",
              "overloads": [
                {
                  "signature": "public static boolean holdsLock(Object obj)",
                  "description": "Returns true if and only if the current thread holds the\n monitor lock on the specified object.\n\n This method is designed to allow a program to assert that\n the current thread already holds a specified lock:\n      assert Thread.holdsLock(obj);"
                }
              ]
            },
            {
              "name": "getStackTrace",
              "overloads": [
                {
                  "signature": "public StackTraceElement[] getStackTrace()",
                  "description": "Returns an array of stack trace elements representing the stack dump\n of this thread.  This method will return a zero-length array if\n this thread has not started, has started but has not yet been\n scheduled to run by the system, or has terminated.\n If the returned array is of non-zero length then the first element of\n the array represents the top of the stack, which is the most recent\n method invocation in the sequence.  The last element of the array\n represents the bottom of the stack, which is the least recent method\n invocation in the sequence.\n\n If there is a security manager, and this thread is not\n the current thread, then the security manager's\n checkPermission method is called with a\n RuntimePermission(\"getStackTrace\") permission\n to see if it's ok to get the stack trace.\n\n Some virtual machines may, under some circumstances, omit one\n or more stack frames from the stack trace.  In the extreme case,\n a virtual machine that has no stack trace information concerning\n this thread is permitted to return a zero-length array from this\n method."
                }
              ]
            },
            {
              "name": "getAllStackTraces",
              "overloads": [
                {
                  "signature": "public static Map<Thread,StackTraceElement[]> getAllStackTraces()",
                  "description": "Returns a map of stack traces for all live threads.\n The map keys are threads and each map value is an array of\n StackTraceElement that represents the stack dump\n of the corresponding Thread.\n The returned stack traces are in the format specified for\n the getStackTrace method.\n\n The threads may be executing while this method is called.\n The stack trace of each thread only represents a snapshot and\n each stack trace may be obtained at different time.  A zero-length\n array will be returned in the map value if the virtual machine has\n no stack trace information about a thread.\n\n If there is a security manager, then the security manager's\n checkPermission method is called with a\n RuntimePermission(\"getStackTrace\") permission as well as\n RuntimePermission(\"modifyThreadGroup\") permission\n to see if it is ok to get the stack trace of all threads."
                }
              ]
            },
            {
              "name": "getId",
              "overloads": [
                {
                  "signature": "public long getId()",
                  "description": "Returns the identifier of this Thread.  The thread ID is a positive\n long number generated when this thread was created.\n The thread ID is unique and remains unchanged during its lifetime.\n When a thread is terminated, this thread ID may be reused."
                }
              ]
            },
            {
              "name": "getState",
              "overloads": [
                {
                  "signature": "public Thread.State getState()",
                  "description": "Returns the state of this thread.\n This method is designed for use in monitoring of the system state,\n not for synchronization control."
                }
              ]
            },
            {
              "name": "setDefaultUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)",
                  "description": "Set the default handler invoked when a thread abruptly terminates\n due to an uncaught exception, and no other handler has been defined\n for that thread.\n\n Uncaught exception handling is controlled first by the thread, then\n by the thread's ThreadGroup object and finally by the default\n uncaught exception handler. If the thread does not have an explicit\n uncaught exception handler set, and the thread's thread group\n (including parent thread groups)  does not specialize its\n uncaughtException method, then the default handler's\n uncaughtException method will be invoked.\n By setting the default uncaught exception handler, an application\n can change the way in which uncaught exceptions are handled (such as\n logging to a specific device, or file) for those threads that would\n already accept whatever \"default\" behavior the system\n provided.\n\n Note that the default uncaught exception handler should not usually\n defer to the thread's ThreadGroup object, as that could cause\n infinite recursion."
                }
              ]
            },
            {
              "name": "getDefaultUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()",
                  "description": "Returns the default handler invoked when a thread abruptly terminates\n due to an uncaught exception. If the returned value is null,\n there is no default."
                }
              ]
            },
            {
              "name": "getUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()",
                  "description": "Returns the handler invoked when this thread abruptly terminates\n due to an uncaught exception. If this thread has not had an\n uncaught exception handler explicitly set then this thread's\n ThreadGroup object is returned, unless this thread\n has terminated, in which case null is returned."
                }
              ]
            },
            {
              "name": "setUncaughtExceptionHandler",
              "overloads": [
                {
                  "signature": "public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)",
                  "description": "Set the handler invoked when this thread abruptly terminates\n due to an uncaught exception.\n A thread can take full control of how it responds to uncaught\n exceptions by having its uncaught exception handler explicitly set.\n If no such handler is set then the thread's ThreadGroup\n object acts as its handler."
                }
              ]
            }
          ]
        },
        {
          "name": "Thread.UncaughtExceptionHandler",
          "methods": [
            {
              "name": "uncaughtException",
              "overloads": [
                {
                  "signature": "void uncaughtException(Thread t, Throwable e)",
                  "description": "Method invoked when the given thread terminates due to the\n given uncaught exception.\n Any exception thrown by this method will be ignored by the\n Java Virtual Machine."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadDeath",
          "methods": [
            {
              "name": "ThreadDeath",
              "overloads": [
                {
                  "signature": "public ThreadDeath()",
                  "description": "Constructs a ThreadDeath."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadGroup",
          "methods": [
            {
              "name": "ThreadGroup",
              "overloads": [
                {
                  "signature": "public ThreadGroup(String name)",
                  "description": "Constructs a new thread group. The parent of this new group is\n the thread group of the currently running thread.\n \n The checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                },
                {
                  "signature": "public ThreadGroup(ThreadGroup parent, String name)",
                  "description": "Creates a new thread group. The parent of this new group is the\n specified thread group.\n \n The checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns the name of this thread group."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public final ThreadGroup getParent()",
                  "description": "Returns the parent of this thread group.\n \n First, if the parent is not null, the\n checkAccess method of the parent thread group is\n called with no arguments; this may result in a security exception."
                }
              ]
            },
            {
              "name": "getMaxPriority",
              "overloads": [
                {
                  "signature": "public final int getMaxPriority()",
                  "description": "Returns the maximum priority of this thread group. Threads that are\n part of this group cannot have a higher priority than the maximum\n priority."
                }
              ]
            },
            {
              "name": "isDaemon",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final boolean isDaemon()",
                  "description": "Tests if this thread group is a daemon thread group. A\n daemon thread group is automatically destroyed when its last\n thread is stopped or its last thread group is destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "isDestroyed",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public boolean isDestroyed()",
                  "description": "Tests if this thread group has been destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setDaemon",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final void setDaemon(boolean daemon)",
                  "description": "Changes the daemon status of this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n A daemon thread group is automatically destroyed when its last\n thread is stopped or its last thread group is destroyed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setMaxPriority",
              "overloads": [
                {
                  "signature": "public final void setMaxPriority(int pri)",
                  "description": "Sets the maximum priority of the group. Threads in the thread\n group that already have a higher priority are not affected.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n If the pri argument is less than\n Thread.MIN_PRIORITY or greater than\n Thread.MAX_PRIORITY, the maximum priority of the group\n remains unchanged.\n \n Otherwise, the priority of this ThreadGroup object is set to the\n smaller of the specified pri and the maximum permitted\n priority of the parent of this thread group. (If this thread group\n is the system thread group, which has no parent, then its maximum\n priority is simply set to pri.) Then this method is\n called recursively, with pri as its argument, for\n every thread group that belongs to this thread group."
                }
              ]
            },
            {
              "name": "parentOf",
              "overloads": [
                {
                  "signature": "public final boolean parentOf(ThreadGroup g)",
                  "description": "Tests if this thread group is either the thread group\n argument or one of its ancestor thread groups."
                }
              ]
            },
            {
              "name": "checkAccess",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\", forRemoval=true) public final void checkAccess()",
                  "description": "Determines if the currently running thread has permission to\n modify this thread group.\n \n If there is a security manager, its checkAccess method\n is called with this thread group as its argument. This may result\n in throwing a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "activeCount",
              "overloads": [
                {
                  "signature": "public int activeCount()",
                  "description": "Returns an estimate of the number of active threads in this thread\n group and its subgroups. Recursively iterates over all subgroups in\n this thread group.\n\n  The value returned is only an estimate because the number of\n threads may change dynamically while this method traverses internal\n data structures, and might be affected by the presence of certain\n system threads. This method is intended primarily for debugging\n and monitoring purposes."
                }
              ]
            },
            {
              "name": "enumerate",
              "overloads": [
                {
                  "signature": "public int enumerate(Thread[] list)",
                  "description": "Copies into the specified array every active thread in this\n thread group and its subgroups.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n enumerate(list, true)"
                },
                {
                  "signature": "public int enumerate(Thread[] list, boolean recurse)",
                  "description": "Copies into the specified array every active thread in this\n thread group. If recurse is true,\n this method recursively enumerates all subgroups of this\n thread group and references to every active thread in these\n subgroups are also included. If the array is too short to\n hold all the threads, the extra threads are silently ignored.\n\n  An application might use the activeCount\n method to get an estimate of how big the array should be, however\n if the array is too short to hold all the threads, the extra threads\n are silently ignored.  If it is critical to obtain every active\n thread in this thread group, the caller should verify that the returned\n int value is strictly less than the length of list.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                },
                {
                  "signature": "public int enumerate(ThreadGroup[] list)",
                  "description": "Copies into the specified array references to every active\n subgroup in this thread group and its subgroups.\n\n  An invocation of this method behaves in exactly the same\n way as the invocation\n\n \n enumerate(list, true)"
                },
                {
                  "signature": "public int enumerate(ThreadGroup[] list, boolean recurse)",
                  "description": "Copies into the specified array references to every active\n subgroup in this thread group. If recurse is\n true, this method recursively enumerates all subgroups of this\n thread group and references to every active thread group in these\n subgroups are also included.\n\n  An application might use the\n activeGroupCount method to\n get an estimate of how big the array should be, however if the\n array is too short to hold all the thread groups, the extra thread\n groups are silently ignored.  If it is critical to obtain every\n active subgroup in this thread group, the caller should verify that\n the returned int value is strictly less than the length of\n list.\n\n  Due to the inherent race condition in this method, it is recommended\n that the method only be used for debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "activeGroupCount",
              "overloads": [
                {
                  "signature": "public int activeGroupCount()",
                  "description": "Returns an estimate of the number of active groups in this\n thread group and its subgroups. Recursively iterates over\n all subgroups in this thread group.\n\n  The value returned is only an estimate because the number of\n thread groups may change dynamically while this method traverses\n internal data structures. This method is intended primarily for\n debugging and monitoring purposes."
                }
              ]
            },
            {
              "name": "stop",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void stop()",
                  "description": "Stops all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the stop method on all the\n threads in this thread group and in all of its subgroups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "interrupt",
              "overloads": [
                {
                  "signature": "public final void interrupt()",
                  "description": "Interrupts all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the interrupt method on all the\n threads in this thread group and in all of its subgroups."
                }
              ]
            },
            {
              "name": "suspend",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void suspend()",
                  "description": "Suspends all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the suspend method on all the\n threads in this thread group and in all of its subgroups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "resume",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public final void resume()",
                  "description": "Resumes all threads in this thread group.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.\n \n This method then calls the resume method on all the\n threads in this thread group and in all of its sub groups.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"16\", forRemoval=true) public final void destroy()",
                  "description": "Destroys this thread group and all of its subgroups. This thread\n group must be empty, indicating that all threads that had been in\n this thread group have since stopped.\n \n First, the checkAccess method of this thread group is\n called with no arguments; this may result in a security exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public void list()",
                  "description": "Prints information about this thread group to the standard\n output. This method is useful only for debugging."
                }
              ]
            },
            {
              "name": "uncaughtException",
              "overloads": [
                {
                  "signature": "public void uncaughtException(Thread t, Throwable e)",
                  "description": "Called by the Java Virtual Machine when a thread in this\n thread group stops because of an uncaught exception, and the thread\n does not have a specific Thread.UncaughtExceptionHandler\n installed.\n \n The uncaughtException method of\n ThreadGroup does the following:\n \n If this thread group has a parent thread group, the\n     uncaughtException method of that parent is called\n     with the same two arguments.\n Otherwise, this method checks to see if there is a\n     default\n     uncaught exception handler installed, and if so, its\n     uncaughtException method is called with the same\n     two arguments.\n Otherwise, this method determines if the Throwable\n     argument is an instance of ThreadDeath. If so, nothing\n     special is done. Otherwise, a message containing the\n     thread's name, as returned from the thread's getName method, and a stack backtrace,\n     using the Throwable's printStackTrace method, is\n     printed to the standard error stream.\n \n \n Applications can override this method in subclasses of\n ThreadGroup to provide alternative handling of\n uncaught exceptions."
                }
              ]
            },
            {
              "name": "allowThreadSuspension",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"1.2\", forRemoval=true) public boolean allowThreadSuspension(boolean b)",
                  "description": "Used by VM to control lowmem implicit suspension.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Thread group."
                }
              ]
            }
          ]
        },
        {
          "name": "ThreadLocal<T>",
          "methods": [
            {
              "name": "ThreadLocal",
              "overloads": [
                {
                  "signature": "public ThreadLocal()",
                  "description": "Creates a thread local variable."
                }
              ]
            },
            {
              "name": "initialValue",
              "overloads": [
                {
                  "signature": "protected T initialValue()",
                  "description": "Returns the current thread's \"initial value\" for this\n thread-local variable.  This method will be invoked the first\n time a thread accesses the variable with the get()\n method, unless the thread previously invoked the set(T)\n method, in which case the initialValue method will not\n be invoked for the thread.  Normally, this method is invoked at\n most once per thread, but it may be invoked again in case of\n subsequent invocations of remove() followed by get().\n\n This implementation simply returns null; if the\n programmer desires thread-local variables to have an initial\n value other than null, ThreadLocal must be\n subclassed, and this method overridden.  Typically, an\n anonymous inner class will be used."
                }
              ]
            },
            {
              "name": "withInitial",
              "overloads": [
                {
                  "signature": "public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier)",
                  "description": "Creates a thread local variable. The initial value of the variable is\n determined by invoking the get method on the Supplier."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public T get()",
                  "description": "Returns the value in the current thread's copy of this\n thread-local variable.  If the variable has no value for the\n current thread, it is first initialized to the value returned\n by an invocation of the initialValue() method."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public void set(T value)",
                  "description": "Sets the current thread's copy of this thread-local variable\n to the specified value.  Most subclasses will have no need to\n override this method, relying solely on the initialValue()\n method to set the values of thread-locals."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public void remove()",
                  "description": "Removes the current thread's value for this thread-local\n variable.  If this thread-local variable is subsequently\n read by the current thread, its value will be\n reinitialized by invoking its initialValue() method,\n unless its value is set by the current thread\n in the interim.  This may result in multiple invocations of the\n initialValue method in the current thread."
                }
              ]
            }
          ]
        },
        {
          "name": "Throwable",
          "methods": [
            {
              "name": "Throwable",
              "overloads": [
                {
                  "signature": "public Throwable()",
                  "description": "Constructs a new throwable with null as its detail message.\n The cause is not initialized, and may subsequently be initialized by a\n call to initCause(java.lang.Throwable).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(String message)",
                  "description": "Constructs a new throwable with the specified detail message.  The\n cause is not initialized, and may subsequently be initialized by\n a call to initCause(java.lang.Throwable).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(String message, Throwable cause)",
                  "description": "Constructs a new throwable with the specified detail message and\n cause.  Note that the detail message associated with\n cause is not automatically incorporated in\n this throwable's detail message.\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "public Throwable(Throwable cause)",
                  "description": "Constructs a new throwable with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for throwables that are little more than\n wrappers for other throwables (for example, PrivilegedActionException).\n\n The fillInStackTrace() method is called to initialize\n the stack trace data in the newly created throwable."
                },
                {
                  "signature": "protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)",
                  "description": "Constructs a new throwable with the specified detail message,\n cause, suppression enabled or\n disabled, and writable stack trace enabled or disabled.  If\n suppression is disabled, getSuppressed() for this object\n will return a zero-length array and calls to addSuppressed(java.lang.Throwable) that would otherwise append an exception to the\n suppressed list will have no effect.  If the writable stack\n trace is false, this constructor will not call fillInStackTrace(), a null will be written to the\n stackTrace field, and subsequent calls to \n fillInStackTrace and setStackTrace(StackTraceElement[]) will not set the stack\n trace.  If the writable stack trace is false, getStackTrace() will return a zero length array.\n\n Note that the other constructors of Throwable treat\n suppression as being enabled and the stack trace as being\n writable.  Subclasses of Throwable should document any\n conditions under which suppression is disabled and document\n conditions under which the stack trace is not writable.\n Disabling of suppression should only occur in exceptional\n circumstances where special requirements exist, such as a\n virtual machine reusing exception objects under low-memory\n situations.  Circumstances where a given exception object is\n repeatedly caught and rethrown, such as to implement control\n flow between two sub-systems, is another situation where\n immutable throwable objects would be appropriate."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns the detail message string of this throwable."
                }
              ]
            },
            {
              "name": "getLocalizedMessage",
              "overloads": [
                {
                  "signature": "public String getLocalizedMessage()",
                  "description": "Creates a localized description of this throwable.\n Subclasses may override this method in order to produce a\n locale-specific message.  For subclasses that do not override this\n method, the default implementation returns the same result as\n getMessage()."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public Throwable getCause()",
                  "description": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.  (The cause is the throwable that\n caused this throwable to get thrown.)\n\n This implementation returns the cause that was supplied via one of\n the constructors requiring a Throwable, or that was set after\n creation with the initCause(Throwable) method.  While it is\n typically unnecessary to override this method, a subclass can override\n it to return a cause set by some other means.  This is appropriate for\n a \"legacy chained throwable\" that predates the addition of chained\n exceptions to Throwable.  Note that it is not\n necessary to override any of the PrintStackTrace methods,\n all of which invoke the getCause method to determine the\n cause of a throwable."
                }
              ]
            },
            {
              "name": "initCause",
              "overloads": [
                {
                  "signature": "public Throwable initCause(Throwable cause)",
                  "description": "Initializes the cause of this throwable to the specified value.\n (The cause is the throwable that caused this throwable to get thrown.)\n\n This method can be called at most once.  It is generally called from\n within the constructor, or immediately after creating the\n throwable.  If this throwable was created\n with Throwable(Throwable) or\n Throwable(String,Throwable), this method cannot be called\n even once.\n\n An example of using this method on a legacy throwable type\n without other support for setting the cause is:\n\n  try {\n     lowLevelOp();\n } catch (LowLevelException le) {\n     throw (HighLevelException)\n           new HighLevelException().initCause(le); // Legacy constructor\n }"
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a short description of this throwable.\n The result is the concatenation of:\n \n  the name of the class of this object\n  \": \" (a colon and a space)\n  the result of invoking this object's getLocalizedMessage()\n      method\n \n If getLocalizedMessage returns null, then just\n the class name is returned."
                }
              ]
            },
            {
              "name": "printStackTrace",
              "overloads": [
                {
                  "signature": "public void printStackTrace()",
                  "description": "Prints this throwable and its backtrace to the\n standard error stream. This method prints a stack trace for this\n Throwable object on the error output stream that is\n the value of the field System.err. The first line of\n output contains the result of the toString() method for\n this object.  Remaining lines represent data previously recorded by\n the method fillInStackTrace(). The format of this\n information depends on the implementation, but the following\n example may be regarded as typical:\n  java.lang.NullPointerException\n         at MyClass.mash(MyClass.java:9)\n         at MyClass.crunch(MyClass.java:6)\n         at MyClass.main(MyClass.java:3)\n \n This example was produced by running the program:\n  class MyClass {\n     public static void main(String[] args) {\n         crunch(null);\n     }\n     static void crunch(int[] a) {\n         mash(a);\n     }\n     static void mash(int[] b) {\n         System.out.println(b[0]);\n     }\n }\n \n The backtrace for a throwable with an initialized, non-null cause\n should generally include the backtrace for the cause.  The format\n of this information depends on the implementation, but the following\n example may be regarded as typical:\n  HighLevelException: MidLevelException: LowLevelException\n         at Junk.a(Junk.java:13)\n         at Junk.main(Junk.java:4)\n Caused by: MidLevelException: LowLevelException\n         at Junk.c(Junk.java:23)\n         at Junk.b(Junk.java:17)\n         at Junk.a(Junk.java:11)\n         ... 1 more\n Caused by: LowLevelException\n         at Junk.e(Junk.java:30)\n         at Junk.d(Junk.java:27)\n         at Junk.c(Junk.java:21)\n         ... 3 more\n \n Note the presence of lines containing the characters \"...\".\n These lines indicate that the remainder of the stack trace for this\n exception matches the indicated number of frames from the bottom of the\n stack trace of the exception that was caused by this exception (the\n \"enclosing\" exception).  This shorthand can greatly reduce the length\n of the output in the common case where a wrapped exception is thrown\n from same method as the \"causative exception\" is caught.  The above\n example was produced by running the program:\n  public class Junk {\n     public static void main(String args[]) {\n         try {\n             a();\n         } catch(HighLevelException e) {\n             e.printStackTrace();\n         }\n     }\n     static void a() throws HighLevelException {\n         try {\n             b();\n         } catch(MidLevelException e) {\n             throw new HighLevelException(e);\n         }\n     }\n     static void b() throws MidLevelException {\n         c();\n     }\n     static void c() throws MidLevelException {\n         try {\n             d();\n         } catch(LowLevelException e) {\n             throw new MidLevelException(e);\n         }\n     }\n     static void d() throws LowLevelException {\n        e();\n     }\n     static void e() throws LowLevelException {\n         throw new LowLevelException();\n     }\n }\n\n class HighLevelException extends Exception {\n     HighLevelException(Throwable cause) { super(cause); }\n }\n\n class MidLevelException extends Exception {\n     MidLevelException(Throwable cause)  { super(cause); }\n }\n\n class LowLevelException extends Exception {\n }\n \n As of release 7, the platform supports the notion of\n suppressed exceptions (in conjunction with the \n try-with-resources statement). Any exceptions that were\n suppressed in order to deliver an exception are printed out\n beneath the stack trace.  The format of this information\n depends on the implementation, but the following example may be\n regarded as typical:\n\n  Exception in thread \"main\" java.lang.Exception: Something happened\n  at Foo.bar(Foo.java:10)\n  at Foo.main(Foo.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID = 0\n          at Resource.close(Resource.java:26)\n          at Foo.bar(Foo.java:9)\n          ... 1 more\n \n Note that the \"... n more\" notation is used on suppressed exceptions\n just as it is used on causes. Unlike causes, suppressed exceptions are\n indented beyond their \"containing exceptions.\"\n\n An exception can have both a cause and one or more suppressed\n exceptions:\n  Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo3.main(Foo3.java:7)\n  Suppressed: Resource$CloseFailException: Resource ID = 2\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n  Suppressed: Resource$CloseFailException: Resource ID = 1\n          at Resource.close(Resource.java:26)\n          at Foo3.main(Foo3.java:5)\n Caused by: java.lang.Exception: I did it\n  at Foo3.main(Foo3.java:8)\n \n Likewise, a suppressed exception can have a cause:\n  Exception in thread \"main\" java.lang.Exception: Main block\n  at Foo4.main(Foo4.java:6)\n  Suppressed: Resource2$CloseFailException: Resource ID = 1\n          at Resource2.close(Resource2.java:20)\n          at Foo4.main(Foo4.java:5)\n  Caused by: java.lang.Exception: Rats, you caught me\n          at Resource2$CloseFailException.<init>(Resource2.java:45)\n          ... 2 more"
                },
                {
                  "signature": "public void printStackTrace(PrintStream s)",
                  "description": "Prints this throwable and its backtrace to the specified print stream."
                },
                {
                  "signature": "public void printStackTrace(PrintWriter s)",
                  "description": "Prints this throwable and its backtrace to the specified\n print writer."
                }
              ]
            },
            {
              "name": "fillInStackTrace",
              "overloads": [
                {
                  "signature": "public Throwable fillInStackTrace()",
                  "description": "Fills in the execution stack trace. This method records within this\n Throwable object information about the current state of\n the stack frames for the current thread.\n\n If the stack trace of this Throwable is not\n writable, calling this method has no effect."
                }
              ]
            },
            {
              "name": "getStackTrace",
              "overloads": [
                {
                  "signature": "public StackTraceElement[] getStackTrace()",
                  "description": "Provides programmatic access to the stack trace information printed by\n printStackTrace().  Returns an array of stack trace elements,\n each representing one stack frame.  The zeroth element of the array\n (assuming the array's length is non-zero) represents the top of the\n stack, which is the last method invocation in the sequence.  Typically,\n this is the point at which this throwable was created and thrown.\n The last element of the array (assuming the array's length is non-zero)\n represents the bottom of the stack, which is the first method invocation\n in the sequence.\n\n Some virtual machines may, under some circumstances, omit one\n or more stack frames from the stack trace.  In the extreme case,\n a virtual machine that has no stack trace information concerning\n this throwable is permitted to return a zero-length array from this\n method.  Generally speaking, the array returned by this method will\n contain one element for every frame that would be printed by\n printStackTrace.  Writes to the returned array do not\n affect future calls to this method."
                }
              ]
            },
            {
              "name": "setStackTrace",
              "overloads": [
                {
                  "signature": "public void setStackTrace(StackTraceElement[] stackTrace)",
                  "description": "Sets the stack trace elements that will be returned by\n getStackTrace() and printed by printStackTrace()\n and related methods.\n\n This method, which is designed for use by RPC frameworks and other\n advanced systems, allows the client to override the default\n stack trace that is either generated by fillInStackTrace()\n when a throwable is constructed or deserialized when a throwable is\n read from a serialization stream.\n\n If the stack trace of this Throwable is not\n writable, calling this method has no effect other than\n validating its argument."
                }
              ]
            },
            {
              "name": "addSuppressed",
              "overloads": [
                {
                  "signature": "public final void addSuppressed(Throwable exception)",
                  "description": "Appends the specified exception to the exceptions that were\n suppressed in order to deliver this exception. This method is\n thread-safe and typically called (automatically and implicitly)\n by the try-with-resources statement.\n\n The suppression behavior is enabled unless disabled\n via\n a constructor.  When suppression is disabled, this method does\n nothing other than to validate its argument.\n\n Note that when one exception causes another exception, the first\n exception is usually caught and then the second exception is\n thrown in response.  In other words, there is a causal\n connection between the two exceptions.\n\n In contrast, there are situations where two independent\n exceptions can be thrown in sibling code blocks, in particular\n in the try block of a try-with-resources\n statement and the compiler-generated finally block\n which closes the resource.\n\n In these situations, only one of the thrown exceptions can be\n propagated.  In the try-with-resources statement, when\n there are two such exceptions, the exception originating from\n the try block is propagated and the exception from the\n finally block is added to the list of exceptions\n suppressed by the exception from the try block.  As an\n exception unwinds the stack, it can accumulate multiple\n suppressed exceptions.\n\n An exception may have suppressed exceptions while also being\n caused by another exception.  Whether or not an exception has a\n cause is semantically known at the time of its creation, unlike\n whether or not an exception will suppress other exceptions\n which is typically only determined after an exception is\n thrown.\n\n Note that programmer written code is also able to take\n advantage of calling this method in situations where there are\n multiple sibling exceptions and only one can be propagated."
                }
              ]
            },
            {
              "name": "getSuppressed",
              "overloads": [
                {
                  "signature": "public final Throwable[] getSuppressed()",
                  "description": "Returns an array containing all of the exceptions that were\n suppressed, typically by the try-with-resources\n statement, in order to deliver this exception.\n\n If no exceptions were suppressed or suppression is\n disabled, an empty array is returned.  This method is\n thread-safe.  Writes to the returned array do not affect future\n calls to this method."
                }
              ]
            }
          ]
        },
        {
          "name": "TypeNotPresentException",
          "methods": [
            {
              "name": "TypeNotPresentException",
              "overloads": [
                {
                  "signature": "public TypeNotPresentException(String typeName, Throwable cause)",
                  "description": "Constructs a TypeNotPresentException for the named type\n with the specified cause."
                }
              ]
            },
            {
              "name": "typeName",
              "overloads": [
                {
                  "signature": "public String typeName()",
                  "description": "Returns the fully qualified name of the unavailable type."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownError",
          "methods": [
            {
              "name": "UnknownError",
              "overloads": [
                {
                  "signature": "public UnknownError()",
                  "description": "Constructs an UnknownError with no detail message."
                },
                {
                  "signature": "public UnknownError(String s)",
                  "description": "Constructs an UnknownError with the specified detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsatisfiedLinkError",
          "methods": [
            {
              "name": "UnsatisfiedLinkError",
              "overloads": [
                {
                  "signature": "public UnsatisfiedLinkError()",
                  "description": "Constructs an UnsatisfiedLinkError with no detail message."
                },
                {
                  "signature": "public UnsatisfiedLinkError(String s)",
                  "description": "Constructs an UnsatisfiedLinkError with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedClassVersionError",
          "methods": [
            {
              "name": "UnsupportedClassVersionError",
              "overloads": [
                {
                  "signature": "public UnsupportedClassVersionError()",
                  "description": "Constructs a UnsupportedClassVersionError\n with no detail message."
                },
                {
                  "signature": "public UnsupportedClassVersionError(String s)",
                  "description": "Constructs a UnsupportedClassVersionError with\n the specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedOperationException",
          "methods": [
            {
              "name": "UnsupportedOperationException",
              "overloads": [
                {
                  "signature": "public UnsupportedOperationException()",
                  "description": "Constructs an UnsupportedOperationException with no detail message."
                },
                {
                  "signature": "public UnsupportedOperationException(String message)",
                  "description": "Constructs an UnsupportedOperationException with the specified\n detail message."
                },
                {
                  "signature": "public UnsupportedOperationException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                },
                {
                  "signature": "public UnsupportedOperationException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause).\n This constructor is useful for exceptions that are little more than\n wrappers for other throwables (for example, PrivilegedActionException)."
                }
              ]
            }
          ]
        },
        {
          "name": "VerifyError",
          "methods": [
            {
              "name": "VerifyError",
              "overloads": [
                {
                  "signature": "public VerifyError()",
                  "description": "Constructs an VerifyError with no detail message."
                },
                {
                  "signature": "public VerifyError(String s)",
                  "description": "Constructs an VerifyError with the specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "VirtualMachineError",
          "methods": [
            {
              "name": "VirtualMachineError",
              "overloads": [
                {
                  "signature": "public VirtualMachineError()",
                  "description": "Constructs a VirtualMachineError with no detail message."
                },
                {
                  "signature": "public VirtualMachineError(String message)",
                  "description": "Constructs a VirtualMachineError with the specified\n detail message."
                },
                {
                  "signature": "public VirtualMachineError(String message, Throwable cause)",
                  "description": "Constructs a VirtualMachineError with the specified\n detail message and cause.  Note that the detail message\n associated with cause is not automatically\n incorporated in this error's detail message."
                },
                {
                  "signature": "public VirtualMachineError(Throwable cause)",
                  "description": "Constructs an a VirtualMachineError with the specified\n cause and a detail message of (cause==null ? null :\n cause.toString()) (which typically contains the class and\n detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Void",
          "methods": []
        }
      ]
    },
    {
      "package": "java.util",
      "description": "Utility classes and collections",
      "classes": [
        {
          "name": "AbstractCollection<E>",
          "methods": [
            {
              "name": "AbstractCollection",
              "overloads": [
                {
                  "signature": "protected AbstractCollection()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public abstract Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements contained in this collection."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this collection contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this collection contains the specified element.\n More formally, returns true if and only if this collection\n contains at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this collection.\n If this collection makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements in\n the same order. The returned array's runtime component type is Object.\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this collection.  (In other words, this method must\n allocate a new array even if this collection is backed by an array).\n The caller is thus free to modify the returned array."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this collection;\n the runtime type of the returned array is that of the specified array.\n If the collection fits in the specified array, it is returned therein.\n Otherwise, a new array is allocated with the runtime type of the\n specified array and the size of this collection.\n\n If this collection fits in the specified array with room to spare\n (i.e., the array has more elements than this collection), the element\n in the array immediately following the end of the collection is set to\n null.  (This is useful in determining the length of this\n collection only if the caller knows that this collection does\n not contain any null elements.)\n\n If this collection makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements in\n the same order."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Ensures that this collection contains the specified element (optional\n operation).  Returns true if this collection changed as a\n result of the call.  (Returns false if this collection does\n not permit duplicates and already contains the specified element.)\n\n Collections that support this operation may place limitations on what\n elements may be added to this collection.  In particular, some\n collections will refuse to add null elements, and others will\n impose restrictions on the type of elements that may be added.\n Collection classes should clearly specify in their documentation any\n restrictions on what elements may be added.\n\n If a collection refuses to add a particular element for any reason\n other than that it already contains the element, it must throw\n an exception (rather than returning false).  This preserves\n the invariant that a collection always contains the specified element\n after this call returns."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes a single instance of the specified element from this\n collection, if it is present (optional operation).  More formally,\n removes an element e such that\n Objects.equals(o, e), if\n this collection contains one or more such elements.  Returns\n true if this collection contained the specified element (or\n equivalently, if this collection changed as a result of the call)."
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "public boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this collection contains all of the elements\n in the specified collection."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this collection\n (optional operation).  The behavior of this operation is undefined if\n the specified collection is modified while the operation is in progress.\n (This implies that the behavior of this call is undefined if the\n specified collection is this collection, and this collection is\n nonempty.)"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Removes all of this collection's elements that are also contained in the\n specified collection (optional operation).  After this call returns,\n this collection will contain no elements in common with the specified\n collection."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "public boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this collection that are contained in the\n specified collection (optional operation).  In other words, removes from\n this collection all of its elements that are not contained in the\n specified collection."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this collection (optional operation).\n The collection will be empty after this method returns."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this collection.  The string\n representation consists of a list of the collection's elements in the\n order they are returned by its iterator, enclosed in square brackets\n (\"[]\").  Adjacent elements are separated by the characters\n \", \" (comma and space).  Elements are converted to strings as\n by String.valueOf(Object)."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractList<E>",
          "methods": [
            {
              "name": "AbstractList",
              "overloads": [
                {
                  "signature": "protected AbstractList()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Appends the specified element to the end of this list (optional\n operation).\n\n Lists that support this operation may place limitations on what\n elements may be added to this list.  In particular, some\n lists will refuse to add null elements, and others will impose\n restrictions on the type of elements that may be added.  List\n classes should clearly specify in their documentation any restrictions\n on what elements may be added."
                },
                {
                  "signature": "public void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this list\n (optional operation).  Shifts the element currently at that position\n (if any) and any subsequent elements to the right (adds one to their\n indices)."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract E get(int index)",
                  "description": "Returns the element at the specified position in this list."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with the\n specified element (optional operation)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public E remove(int index)",
                  "description": "Removes the element at the specified position in this list (optional\n operation).  Shifts any subsequent elements to the left (subtracts one\n from their indices).  Returns the element that was removed from the\n list."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this list (optional operation).\n The list will be empty after this call returns."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list at the specified position (optional operation).  Shifts the\n element currently at that position (if any) and any subsequent\n elements to the right (increases their indices).  The new elements\n will appear in this list in the order that they are returned by the\n specified collection's iterator.  The behavior of this operation is\n undefined if the specified collection is modified while the\n operation is in progress.  (Note that this will occur if the specified\n collection is this list, and it's nonempty.)"
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list in proper sequence."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "public ListIterator<E> listIterator()",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence)."
                },
                {
                  "signature": "public ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.\n The specified index indicates the first element that would be\n returned by an initial call to next.\n An initial call to previous would\n return the element with the specified index minus one."
                }
              ]
            },
            {
              "name": "subList",
              "overloads": [
                {
                  "signature": "public List<E> subList(int fromIndex, int toIndex)",
                  "description": "Returns a view of the portion of this list between the specified\n fromIndex, inclusive, and toIndex, exclusive.  (If\n fromIndex and toIndex are equal, the returned list is\n empty.)  The returned list is backed by this list, so non-structural\n changes in the returned list are reflected in this list, and vice-versa.\n The returned list supports all of the optional list operations supported\n by this list.\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n \n      list.subList(from, to).clear();\n \n Similar idioms may be constructed for indexOf and\n lastIndexOf, and all of the algorithms in the\n Collections class can be applied to a subList.\n\n The semantics of the list returned by this method become undefined if\n the backing list (i.e., this list) is structurally modified in\n any way other than via the returned list.  (Structural modifications are\n those that change the size of this list, or otherwise perturb it in such\n a fashion that iterations in progress may yield incorrect results.)"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this list for equality.  Returns\n true if and only if the specified object is also a list, both\n lists have the same size, and all corresponding pairs of elements in\n the two lists are equal.  (Two elements e1 and\n e2 are equal if (e1==null ? e2==null :\n e1.equals(e2)).)  In other words, two lists are defined to be\n equal if they contain the same elements in the same order."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this list."
                }
              ]
            },
            {
              "name": "removeRange",
              "overloads": [
                {
                  "signature": "protected void removeRange(int fromIndex, int toIndex)",
                  "description": "Removes from this list all of the elements whose index is between\n fromIndex, inclusive, and toIndex, exclusive.\n Shifts any succeeding elements to the left (reduces their index).\n This call shortens the list by (toIndex - fromIndex) elements.\n (If toIndex==fromIndex, this operation has no effect.)\n\n This method is called by the clear operation on this list\n and its subLists.  Overriding this method to take advantage of\n the internals of the list implementation can substantially\n improve the performance of the clear operation on this list\n and its subLists."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractMap.SimpleEntry<K,V>",
          "methods": [
            {
              "name": "SimpleEntry",
              "overloads": [
                {
                  "signature": "public SimpleEntry(K key, V value)",
                  "description": "Creates an entry representing a mapping from the specified\n key to the specified value."
                },
                {
                  "signature": "public SimpleEntry(Map.Entry<? extends K,? extends V> entry)",
                  "description": "Creates an entry representing the same mapping as the\n specified entry."
                }
              ]
            },
            {
              "name": "getKey",
              "overloads": [
                {
                  "signature": "public K getKey()",
                  "description": "Returns the key corresponding to this entry."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public V getValue()",
                  "description": "Returns the value corresponding to this entry."
                }
              ]
            },
            {
              "name": "setValue",
              "overloads": [
                {
                  "signature": "public V setValue(V value)",
                  "description": "Replaces the value corresponding to this entry with the specified\n value."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this entry for equality.\n Returns true if the given object is also a map entry and\n the two entries represent the same mapping.  More formally, two\n entries e1 and e2 represent the same mapping\n if   (e1.getKey()==null ?\n    e2.getKey()==null :\n    e1.getKey().equals(e2.getKey()))\n   &&\n   (e1.getValue()==null ?\n    e2.getValue()==null :\n    e1.getValue().equals(e2.getValue()))\n This ensures that the equals method works properly across\n different implementations of the Map.Entry interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this map entry.  The hash code\n of a map entry e is defined to be:    (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^\n   (e.getValue()==null ? 0 : e.getValue().hashCode())\n This ensures that e1.equals(e2) implies that\n e1.hashCode()==e2.hashCode() for any two Entries\n e1 and e2, as required by the general\n contract of Object.hashCode()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String representation of this map entry.  This\n implementation returns the string representation of this\n entry's key followed by the equals character (\"=\")\n followed by the string representation of this entry's value."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractMap.SimpleImmutableEntry<K,V>",
          "methods": [
            {
              "name": "SimpleImmutableEntry",
              "overloads": [
                {
                  "signature": "public SimpleImmutableEntry(K key, V value)",
                  "description": "Creates an entry representing a mapping from the specified\n key to the specified value."
                },
                {
                  "signature": "public SimpleImmutableEntry(Map.Entry<? extends K,? extends V> entry)",
                  "description": "Creates an entry representing the same mapping as the\n specified entry."
                }
              ]
            },
            {
              "name": "getKey",
              "overloads": [
                {
                  "signature": "public K getKey()",
                  "description": "Returns the key corresponding to this entry."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public V getValue()",
                  "description": "Returns the value corresponding to this entry."
                }
              ]
            },
            {
              "name": "setValue",
              "overloads": [
                {
                  "signature": "public V setValue(V value)",
                  "description": "Replaces the value corresponding to this entry with the specified\n value (optional operation).  This implementation simply throws\n UnsupportedOperationException, as this class implements\n an unmodifiable map entry."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this entry for equality.\n Returns true if the given object is also a map entry and\n the two entries represent the same mapping.  More formally, two\n entries e1 and e2 represent the same mapping\n if   (e1.getKey()==null ?\n    e2.getKey()==null :\n    e1.getKey().equals(e2.getKey()))\n   &&\n   (e1.getValue()==null ?\n    e2.getValue()==null :\n    e1.getValue().equals(e2.getValue()))\n This ensures that the equals method works properly across\n different implementations of the Map.Entry interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this map entry.  The hash code\n of a map entry e is defined to be:    (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^\n   (e.getValue()==null ? 0 : e.getValue().hashCode())\n This ensures that e1.equals(e2) implies that\n e1.hashCode()==e2.hashCode() for any two Entries\n e1 and e2, as required by the general\n contract of Object.hashCode()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String representation of this map entry.  This\n implementation returns the string representation of this\n entry's key followed by the equals character (\"=\")\n followed by the string representation of this entry's value."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractMap<K,V>",
          "methods": [
            {
              "name": "AbstractMap",
              "overloads": [
                {
                  "signature": "protected AbstractMap()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this map.  If the\n map contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this map contains no key-value mappings."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value.  More formally, returns true if and only if\n this map contains at least one mapping to a value v such that\n Objects.equals(value, v).  This operation\n will probably require time linear in the map size for most\n implementations of the Map interface."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the specified\n key.  More formally, returns true if and only if\n this map contains a mapping for a key k such that\n Objects.equals(key, k).  (There can be\n at most one such mapping.)"
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that\n Objects.equals(key, k),\n then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contains no mapping for the key; it's also possible that the map\n explicitly maps the key to null.  The containsKey operation may be used to distinguish these two cases."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map\n (optional operation).  If the map previously contained a mapping for\n the key, the old value is replaced by the specified value.  (A map\n m is said to contain a mapping for a key k if and only\n if m.containsKey(k) would return\n true.)"
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for a key from this map if it is present\n (optional operation).   More formally, if this map contains a mapping\n from key k to value v such that\n Objects.equals(key, k), that mapping\n is removed.  (The map can contain at most one such mapping.)\n\n Returns the value to which this map previously associated the key,\n or null if the map contained no mapping for the key.\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contained no mapping for the key; it's also possible that the map\n explicitly mapped the key to null.\n\n The map will not contain a mapping for the specified key once the\n call returns."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map\n (optional operation).  The effect of this call is equivalent to that\n of calling put(k, v) on this map once\n for each mapping from key k to value v in the\n specified map.  The behavior of this operation is undefined if the\n specified map is modified while the operation is in progress."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map (optional operation).\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent the same mappings.  More formally, two maps m1 and\n m2 represent the same mappings if\n m1.entrySet().equals(m2.entrySet()).  This ensures that the\n equals method works properly across different implementations\n of the Map interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map's\n entrySet() view.  This ensures that m1.equals(m2)\n implies that m1.hashCode()==m2.hashCode() for any two maps\n m1 and m2, as required by the general contract of\n Object.hashCode()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this map.  The string representation\n consists of a list of key-value mappings in the order returned by the\n map's entrySet view's iterator, enclosed in braces\n (\"{}\").  Adjacent mappings are separated by the characters\n \", \" (comma and space).  Each key-value mapping is rendered as\n the key followed by an equals sign (\"=\") followed by the\n associated value.  Keys and values are converted to strings as by\n String.valueOf(Object)."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "protected Object clone() throws CloneNotSupportedException",
                  "description": "Returns a shallow copy of this AbstractMap instance: the keys\n and values themselves are not cloned."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractQueue<E>",
          "methods": [
            {
              "name": "AbstractQueue",
              "overloads": [
                {
                  "signature": "protected AbstractQueue()",
                  "description": "Constructor for use by subclasses."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Inserts the specified element into this queue if it is possible to do so\n immediately without violating capacity restrictions, returning\n true upon success and throwing an IllegalStateException\n if no space is currently available.\n\n This implementation returns true if offer succeeds,\n else throws an IllegalStateException."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public E remove()",
                  "description": "Retrieves and removes the head of this queue.  This method differs\n from poll only in that it throws an exception if this\n queue is empty.\n\n This implementation returns the result of poll\n unless the queue is empty."
                }
              ]
            },
            {
              "name": "element",
              "overloads": [
                {
                  "signature": "public E element()",
                  "description": "Retrieves, but does not remove, the head of this queue.  This method\n differs from peek only in that it throws an exception if\n this queue is empty.\n\n This implementation returns the result of peek\n unless the queue is empty."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this queue.\n The queue will be empty after this call returns.\n\n This implementation repeatedly invokes poll until it\n returns null."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this\n queue.  Attempts to addAll of a queue to itself result in\n IllegalArgumentException. Further, the behavior of\n this operation is undefined if the specified collection is\n modified while the operation is in progress.\n\n This implementation iterates over the specified collection,\n and adds each element returned by the iterator to this\n queue, in turn.  A runtime exception encountered while\n trying to add an element (including, in particular, a\n null element) may result in only some of the elements\n having been successfully added when the associated exception is\n thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractSequentialList<E>",
          "methods": [
            {
              "name": "AbstractSequentialList",
              "overloads": [
                {
                  "signature": "protected AbstractSequentialList()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public E get(int index)",
                  "description": "Returns the element at the specified position in this list.\n\n This implementation first gets a list iterator pointing to the\n indexed element (with listIterator(index)).  Then, it gets\n the element using ListIterator.next and returns it."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with the\n specified element (optional operation).\n\n This implementation first gets a list iterator pointing to the\n indexed element (with listIterator(index)).  Then, it gets\n the current element using ListIterator.next and replaces it\n with ListIterator.set.\n\n Note that this implementation will throw an\n UnsupportedOperationException if the list iterator does not\n implement the set operation."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this list\n (optional operation).  Shifts the element currently at that position\n (if any) and any subsequent elements to the right (adds one to their\n indices).\n\n This implementation first gets a list iterator pointing to the\n indexed element (with listIterator(index)).  Then, it\n inserts the specified element with ListIterator.add.\n\n Note that this implementation will throw an\n UnsupportedOperationException if the list iterator does not\n implement the add operation."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public E remove(int index)",
                  "description": "Removes the element at the specified position in this list (optional\n operation).  Shifts any subsequent elements to the left (subtracts one\n from their indices).  Returns the element that was removed from the\n list.\n\n This implementation first gets a list iterator pointing to the\n indexed element (with listIterator(index)).  Then, it removes\n the element with ListIterator.remove.\n\n Note that this implementation will throw an\n UnsupportedOperationException if the list iterator does not\n implement the remove operation."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list at the specified position (optional operation).  Shifts the\n element currently at that position (if any) and any subsequent\n elements to the right (increases their indices).  The new elements\n will appear in this list in the order that they are returned by the\n specified collection's iterator.  The behavior of this operation is\n undefined if the specified collection is modified while the\n operation is in progress.  (Note that this will occur if the specified\n collection is this list, and it's nonempty.)\n\n This implementation gets an iterator over the specified collection and\n a list iterator over this list pointing to the indexed element (with\n listIterator(index)).  Then, it iterates over the specified\n collection, inserting the elements obtained from the iterator into this\n list, one at a time, using ListIterator.add followed by\n ListIterator.next (to skip over the added element).\n\n Note that this implementation will throw an\n UnsupportedOperationException if the list iterator returned by\n the listIterator method does not implement the add\n operation."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list (in proper\n sequence).\n\n This implementation merely returns a list iterator over the list."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "public abstract ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence)."
                }
              ]
            }
          ]
        },
        {
          "name": "AbstractSet<E>",
          "methods": [
            {
              "name": "AbstractSet",
              "overloads": [
                {
                  "signature": "protected AbstractSet()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this set for equality.  Returns\n true if the given object is also a set, the two sets have\n the same size, and every member of the given set is contained in\n this set.  This ensures that the equals method works\n properly across different implementations of the Set\n interface.\n\n This implementation first checks if the specified object is this\n set; if so it returns true.  Then, it checks if the\n specified object is a set whose size is identical to the size of\n this set; if not, it returns false.  If so, it returns\n containsAll((Collection) o)."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this set.  The hash code of a set is\n defined to be the sum of the hash codes of the elements in the set,\n where the hash code of a null element is defined to be zero.\n This ensures that s1.equals(s2) implies that\n s1.hashCode()==s2.hashCode() for any two sets s1\n and s2, as required by the general contract of\n Object.hashCode().\n\n This implementation iterates over the set, calling the\n hashCode method on each element in the set, and adding up\n the results."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Removes from this set all of its elements that are contained in the\n specified collection (optional operation).  If the specified\n collection is also a set, this operation effectively modifies this\n set so that its value is the asymmetric set difference of\n the two sets.\n\n This implementation determines which is the smaller of this set\n and the specified collection, by invoking the size\n method on each.  If this set has fewer elements, then the\n implementation iterates over this set, checking each element\n returned by the iterator in turn to see if it is contained in\n the specified collection.  If it is so contained, it is removed\n from this set with the iterator's remove method.  If\n the specified collection has fewer elements, then the\n implementation iterates over the specified collection, removing\n from this set each element returned by the iterator, using this\n set's remove method.\n\n Note that this implementation will throw an\n UnsupportedOperationException if the iterator returned by the\n iterator method does not implement the remove method."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayDeque<E>",
          "methods": [
            {
              "name": "ArrayDeque",
              "overloads": [
                {
                  "signature": "public ArrayDeque()",
                  "description": "Constructs an empty array deque with an initial capacity\n sufficient to hold 16 elements."
                },
                {
                  "signature": "public ArrayDeque(int numElements)",
                  "description": "Constructs an empty array deque with an initial capacity\n sufficient to hold the specified number of elements."
                },
                {
                  "signature": "public ArrayDeque(Collection<? extends E> c)",
                  "description": "Constructs a deque containing the elements of the specified\n collection, in the order they are returned by the collection's\n iterator.  (The first element returned by the collection's\n iterator becomes the first element, or front of the\n deque.)"
                }
              ]
            },
            {
              "name": "addFirst",
              "overloads": [
                {
                  "signature": "public void addFirst(E e)",
                  "description": "Inserts the specified element at the front of this deque."
                }
              ]
            },
            {
              "name": "addLast",
              "overloads": [
                {
                  "signature": "public void addLast(E e)",
                  "description": "Inserts the specified element at the end of this deque.\n\n This method is equivalent to add(E)."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection at the end\n of this deque, as if by calling addLast(E) on each one,\n in the order that they are returned by the collection's iterator."
                }
              ]
            },
            {
              "name": "offerFirst",
              "overloads": [
                {
                  "signature": "public boolean offerFirst(E e)",
                  "description": "Inserts the specified element at the front of this deque."
                }
              ]
            },
            {
              "name": "offerLast",
              "overloads": [
                {
                  "signature": "public boolean offerLast(E e)",
                  "description": "Inserts the specified element at the end of this deque."
                }
              ]
            },
            {
              "name": "removeFirst",
              "overloads": [
                {
                  "signature": "public E removeFirst()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "removeLast",
              "overloads": [
                {
                  "signature": "public E removeLast()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "pollFirst",
              "overloads": [
                {
                  "signature": "public E pollFirst()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "pollLast",
              "overloads": [
                {
                  "signature": "public E pollLast()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "getFirst",
              "overloads": [
                {
                  "signature": "public E getFirst()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "getLast",
              "overloads": [
                {
                  "signature": "public E getLast()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "peekFirst",
              "overloads": [
                {
                  "signature": "public E peekFirst()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "peekLast",
              "overloads": [
                {
                  "signature": "public E peekLast()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "removeFirstOccurrence",
              "overloads": [
                {
                  "signature": "public boolean removeFirstOccurrence(Object o)",
                  "description": "Removes the first occurrence of the specified element in this\n deque (when traversing the deque from head to tail).\n If the deque does not contain the element, it is unchanged.\n More formally, removes the first element e such that\n o.equals(e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call)."
                }
              ]
            },
            {
              "name": "removeLastOccurrence",
              "overloads": [
                {
                  "signature": "public boolean removeLastOccurrence(Object o)",
                  "description": "Removes the last occurrence of the specified element in this\n deque (when traversing the deque from head to tail).\n If the deque does not contain the element, it is unchanged.\n More formally, removes the last element e such that\n o.equals(e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call)."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Inserts the specified element at the end of this deque.\n\n This method is equivalent to addLast(E)."
                }
              ]
            },
            {
              "name": "offer",
              "overloads": [
                {
                  "signature": "public boolean offer(E e)",
                  "description": "Inserts the specified element at the end of this deque.\n\n This method is equivalent to offerLast(E)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public E remove()",
                  "description": "Retrieves and removes the head of the queue represented by this deque.\n\n This method differs from poll() only in that it\n throws an exception if this deque is empty.\n\n This method is equivalent to removeFirst()."
                },
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes a single instance of the specified element from this deque.\n If the deque does not contain the element, it is unchanged.\n More formally, removes the first element e such that\n o.equals(e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call).\n\n This method is equivalent to removeFirstOccurrence(Object)."
                }
              ]
            },
            {
              "name": "poll",
              "overloads": [
                {
                  "signature": "public E poll()",
                  "description": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), or returns\n null if this deque is empty.\n\n This method is equivalent to pollFirst()."
                }
              ]
            },
            {
              "name": "element",
              "overloads": [
                {
                  "signature": "public E element()",
                  "description": "Retrieves, but does not remove, the head of the queue represented by\n this deque.  This method differs from peek only in\n that it throws an exception if this deque is empty.\n\n This method is equivalent to getFirst()."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "public E peek()",
                  "description": "Retrieves, but does not remove, the head of the queue represented by\n this deque, or returns null if this deque is empty.\n\n This method is equivalent to peekFirst()."
                }
              ]
            },
            {
              "name": "push",
              "overloads": [
                {
                  "signature": "public void push(E e)",
                  "description": "Pushes an element onto the stack represented by this deque.  In other\n words, inserts the element at the front of this deque.\n\n This method is equivalent to addFirst(E)."
                }
              ]
            },
            {
              "name": "pop",
              "overloads": [
                {
                  "signature": "public E pop()",
                  "description": "Pops an element from the stack represented by this deque.  In other\n words, removes and returns the first element of this deque.\n\n This method is equivalent to removeFirst()."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of elements in this deque."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this deque contains no elements."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this deque.  The elements\n will be ordered from first (head) to last (tail).  This is the same\n order that elements would be dequeued (via successive calls to\n remove() or popped (via successive calls to pop())."
                }
              ]
            },
            {
              "name": "descendingIterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> descendingIterator()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n deque.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.NONNULL.  Overriding implementations should document\n the reporting of additional characteristic values."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super E> action)",
                  "description": "Description copied from interface:Iterable"
                }
              ]
            },
            {
              "name": "removeIf",
              "overloads": [
                {
                  "signature": "public boolean removeIf(Predicate<? super E> filter)",
                  "description": "Description copied from interface:Collection"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Description copied from class:AbstractCollection"
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "public boolean retainAll(Collection<?> c)",
                  "description": "Description copied from class:AbstractCollection"
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this deque contains the specified element.\n More formally, returns true if and only if this deque contains\n at least one element e such that o.equals(e)."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this deque.\n The deque will be empty after this call returns."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this deque\n in proper sequence (from first to last element).\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this deque.  (In other words, this method must allocate\n a new array).  The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this deque in\n proper sequence (from first to last element); the runtime type of the\n returned array is that of the specified array.  If the deque fits in\n the specified array, it is returned therein.  Otherwise, a new array\n is allocated with the runtime type of the specified array and the\n size of this deque.\n\n If this deque fits in the specified array with room to spare\n (i.e., the array has more elements than this deque), the element in\n the array immediately following the end of the deque is set to\n null.\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a deque known to contain only strings.\n The following code can be used to dump the deque into a newly\n allocated array of String:\n\n  String[] y = x.toArray(new String[0]);\n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public ArrayDeque<E> clone()",
                  "description": "Returns a copy of this deque."
                }
              ]
            }
          ]
        },
        {
          "name": "ArrayList<E>",
          "methods": [
            {
              "name": "ArrayList",
              "overloads": [
                {
                  "signature": "public ArrayList(int initialCapacity)",
                  "description": "Constructs an empty list with the specified initial capacity."
                },
                {
                  "signature": "public ArrayList()",
                  "description": "Constructs an empty list with an initial capacity of ten."
                },
                {
                  "signature": "public ArrayList(Collection<? extends E> c)",
                  "description": "Constructs a list containing the elements of the specified\n collection, in the order they are returned by the collection's\n iterator."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Trims the capacity of this ArrayList instance to be the\n list's current size.  An application can use this operation to minimize\n the storage of an ArrayList instance."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minCapacity)",
                  "description": "Increases the capacity of this ArrayList instance, if\n necessary, to ensure that it can hold at least the number of elements\n specified by the minimum capacity argument."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of elements in this list."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this list contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this list contains the specified element.\n More formally, returns true if and only if this list contains\n at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this ArrayList instance.  (The\n elements themselves are not copied.)"
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this list\n in proper sequence (from first to last element).\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this list.  (In other words, this method must allocate\n a new array).  The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this list in proper\n sequence (from first to last element); the runtime type of the returned\n array is that of the specified array.  If the list fits in the\n specified array, it is returned therein.  Otherwise, a new array is\n allocated with the runtime type of the specified array and the size of\n this list.\n\n If the list fits in the specified array with room to spare\n (i.e., the array has more elements than the list), the element in\n the array immediately following the end of the collection is set to\n null.  (This is useful in determining the length of the\n list only if the caller knows that the list does not contain\n any null elements.)"
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public E get(int index)",
                  "description": "Returns the element at the specified position in this list."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with\n the specified element."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Appends the specified element to the end of this list."
                },
                {
                  "signature": "public void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this\n list. Shifts the element currently at that position (if any) and\n any subsequent elements to the right (adds one to their indices)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public E remove(int index)",
                  "description": "Removes the element at the specified position in this list.\n Shifts any subsequent elements to the left (subtracts one from their\n indices)."
                },
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element from this list,\n if it is present.  If the list does not contain the element, it is\n unchanged.  More formally, removes the element with the lowest index\n i such that\n Objects.equals(o, get(i))\n (if such an element exists).  Returns true if this list\n contained the specified element (or equivalently, if this list\n changed as a result of the call)."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this list for equality.  Returns\n true if and only if the specified object is also a list, both\n lists have the same size, and all corresponding pairs of elements in\n the two lists are equal.  (Two elements e1 and\n e2 are equal if (e1==null ? e2==null :\n e1.equals(e2)).)  In other words, two lists are defined to be\n equal if they contain the same elements in the same order."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this list."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this list.  The list will\n be empty after this call returns."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the\n specified collection's Iterator.  The behavior of this operation is\n undefined if the specified collection is modified while the operation\n is in progress.  (This implies that the behavior of this call is\n undefined if the specified collection is this list, and this\n list is nonempty.)"
                },
                {
                  "signature": "public boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.  Shifts the element\n currently at that position (if any) and any subsequent elements to\n the right (increases their indices).  The new elements will appear\n in the list in the order that they are returned by the\n specified collection's iterator."
                }
              ]
            },
            {
              "name": "removeRange",
              "overloads": [
                {
                  "signature": "protected void removeRange(int fromIndex, int toIndex)",
                  "description": "Removes from this list all of the elements whose index is between\n fromIndex, inclusive, and toIndex, exclusive.\n Shifts any succeeding elements to the left (reduces their index).\n This call shortens the list by (toIndex - fromIndex) elements.\n (If toIndex==fromIndex, this operation has no effect.)"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Removes from this list all of its elements that are contained in the\n specified collection."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "public boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this list that are contained in the\n specified collection.  In other words, removes from this list all\n of its elements that are not contained in the specified collection."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "public ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.\n The specified index indicates the first element that would be\n returned by an initial call to next.\n An initial call to previous would\n return the element with the specified index minus one.\n\n The returned list iterator is fail-fast."
                },
                {
                  "signature": "public ListIterator<E> listIterator()",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence).\n\n The returned list iterator is fail-fast."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list in proper sequence.\n\n The returned iterator is fail-fast."
                }
              ]
            },
            {
              "name": "subList",
              "overloads": [
                {
                  "signature": "public List<E> subList(int fromIndex, int toIndex)",
                  "description": "Returns a view of the portion of this list between the specified\n fromIndex, inclusive, and toIndex, exclusive.  (If\n fromIndex and toIndex are equal, the returned list is\n empty.)  The returned list is backed by this list, so non-structural\n changes in the returned list are reflected in this list, and vice-versa.\n The returned list supports all of the optional list operations.\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n       list.subList(from, to).clear();\n \n Similar idioms may be constructed for indexOf(Object) and\n lastIndexOf(Object), and all of the algorithms in the\n Collections class can be applied to a subList.\n\n The semantics of the list returned by this method become undefined if\n the backing list (i.e., this list) is structurally modified in\n any way other than via the returned list.  (Structural modifications are\n those that change the size of this list, or otherwise perturb it in such\n a fashion that iterations in progress may yield incorrect results.)"
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super E> action)",
                  "description": "Description copied from interface:Iterable"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, and Spliterator.ORDERED.\n Overriding implementations should document the reporting of additional\n characteristic values."
                }
              ]
            },
            {
              "name": "removeIf",
              "overloads": [
                {
                  "signature": "public boolean removeIf(Predicate<? super E> filter)",
                  "description": "Description copied from interface:Collection"
                }
              ]
            }
          ]
        },
        {
          "name": "Arrays",
          "methods": [
            {
              "name": "sort",
              "overloads": [
                {
                  "signature": "public static void sort(int[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void sort(int[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty."
                },
                {
                  "signature": "public static void sort(long[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void sort(long[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty."
                },
                {
                  "signature": "public static void sort(short[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void sort(short[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty."
                },
                {
                  "signature": "public static void sort(char[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void sort(char[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty."
                },
                {
                  "signature": "public static void sort(byte[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void sort(byte[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty."
                },
                {
                  "signature": "public static void sort(float[] a)",
                  "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."
                },
                {
                  "signature": "public static void sort(float[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."
                },
                {
                  "signature": "public static void sort(double[] a)",
                  "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."
                },
                {
                  "signature": "public static void sort(double[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."
                },
                {
                  "signature": "public static void sort(Object[] a)",
                  "description": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.\n All elements in the array must implement the Comparable\n interface.  Furthermore, all elements in the array must be\n mutually comparable (that is, e1.compareTo(e2) must\n not throw a ClassCastException for any elements e1\n and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."
                },
                {
                  "signature": "public static void sort(Object[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.  The range to be sorted extends from index\n fromIndex, inclusive, to index toIndex, exclusive.\n (If fromIndex==toIndex, the range to be sorted is empty.)  All\n elements in this range must implement the Comparable\n interface.  Furthermore, all elements in this range must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."
                },
                {
                  "signature": "public static <T> void sort(T[] a, Comparator<? super T> c)",
                  "description": "Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."
                },
                {
                  "signature": "public static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)",
                  "description": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be sorted is empty.)  All elements in the range must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the range).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."
                }
              ]
            },
            {
              "name": "parallelSort",
              "overloads": [
                {
                  "signature": "public static void parallelSort(byte[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void parallelSort(byte[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."
                },
                {
                  "signature": "public static void parallelSort(char[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void parallelSort(char[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."
                },
                {
                  "signature": "public static void parallelSort(short[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void parallelSort(short[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."
                },
                {
                  "signature": "public static void parallelSort(int[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void parallelSort(int[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."
                },
                {
                  "signature": "public static void parallelSort(long[] a)",
                  "description": "Sorts the specified array into ascending numerical order."
                },
                {
                  "signature": "public static void parallelSort(long[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."
                },
                {
                  "signature": "public static void parallelSort(float[] a)",
                  "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."
                },
                {
                  "signature": "public static void parallelSort(float[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."
                },
                {
                  "signature": "public static void parallelSort(double[] a)",
                  "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."
                },
                {
                  "signature": "public static void parallelSort(double[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."
                },
                {
                  "signature": "public static <T extends Comparable<? super T>> void parallelSort(T[] a)",
                  "description": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.\n All elements in the array must implement the Comparable\n interface.  Furthermore, all elements in the array must be\n mutually comparable (that is, e1.compareTo(e2) must\n not throw a ClassCastException for any elements e1\n and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."
                },
                {
                  "signature": "public static <T extends Comparable<? super T>> void parallelSort(T[] a, int fromIndex, int toIndex)",
                  "description": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.  The range to be sorted extends from index\n fromIndex, inclusive, to index toIndex, exclusive.\n (If fromIndex==toIndex, the range to be sorted is empty.)  All\n elements in this range must implement the Comparable\n interface.  Furthermore, all elements in this range must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."
                },
                {
                  "signature": "public static <T> void parallelSort(T[] a, Comparator<? super T> cmp)",
                  "description": "Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."
                },
                {
                  "signature": "public static <T> void parallelSort(T[] a, int fromIndex, int toIndex, Comparator<? super T> cmp)",
                  "description": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be sorted is empty.)  All elements in the range must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the range).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."
                }
              ]
            },
            {
              "name": "parallelPrefix",
              "overloads": [
                {
                  "signature": "public static <T> void parallelPrefix(T[] array, BinaryOperator<T> op)",
                  "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."
                },
                {
                  "signature": "public static <T> void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator<T> op)",
                  "description": "Performs parallelPrefix(Object[], BinaryOperator)\n for the given subrange of the array."
                },
                {
                  "signature": "public static void parallelPrefix(long[] array, LongBinaryOperator op)",
                  "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."
                },
                {
                  "signature": "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)",
                  "description": "Performs parallelPrefix(long[], LongBinaryOperator)\n for the given subrange of the array."
                },
                {
                  "signature": "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)",
                  "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2.0, 1.0, 0.0, 3.0] and the operation performs addition,\n then upon return the array holds [2.0, 3.0, 3.0, 6.0].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.\n\n  Because floating-point operations may not be strictly associative,\n the returned result may not be identical to the value that would be\n obtained if the operation was performed sequentially."
                },
                {
                  "signature": "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)",
                  "description": "Performs parallelPrefix(double[], DoubleBinaryOperator)\n for the given subrange of the array."
                },
                {
                  "signature": "public static void parallelPrefix(int[] array, IntBinaryOperator op)",
                  "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."
                },
                {
                  "signature": "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)",
                  "description": "Performs parallelPrefix(int[], IntBinaryOperator)\n for the given subrange of the array."
                }
              ]
            },
            {
              "name": "binarySearch",
              "overloads": [
                {
                  "signature": "public static int binarySearch(long[] a, long key)",
                  "description": "Searches the specified array of longs for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(long[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)",
                  "description": "Searches a range of\n the specified array of longs for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(long[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(int[] a, int key)",
                  "description": "Searches the specified array of ints for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(int[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)",
                  "description": "Searches a range of\n the specified array of ints for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(int[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(short[] a, short key)",
                  "description": "Searches the specified array of shorts for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the sort(short[]) method) prior to making this call.  If\n it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)",
                  "description": "Searches a range of\n the specified array of shorts for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(short[], int, int) method)\n prior to making this call.  If\n it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(char[] a, char key)",
                  "description": "Searches the specified array of chars for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(char[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)",
                  "description": "Searches a range of\n the specified array of chars for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(char[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(byte[] a, byte key)",
                  "description": "Searches the specified array of bytes for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(byte[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)",
                  "description": "Searches a range of\n the specified array of bytes for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(byte[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(double[] a, double key)",
                  "description": "Searches the specified array of doubles for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the sort(double[]) method) prior to making this call.\n If it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal."
                },
                {
                  "signature": "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)",
                  "description": "Searches a range of\n the specified array of doubles for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(double[], int, int) method)\n prior to making this call.\n If it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal."
                },
                {
                  "signature": "public static int binarySearch(float[] a, float key)",
                  "description": "Searches the specified array of floats for the specified value using\n the binary search algorithm. The array must be sorted\n (as by the sort(float[]) method) prior to making this call. If\n it is not sorted, the results are undefined. If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal."
                },
                {
                  "signature": "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)",
                  "description": "Searches a range of\n the specified array of floats for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(float[], int, int) method)\n prior to making this call. If\n it is not sorted, the results are undefined. If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal."
                },
                {
                  "signature": "public static int binarySearch(Object[] a, Object key)",
                  "description": "Searches the specified array for the specified object using the binary\n search algorithm. The array must be sorted into ascending order\n according to the\n natural ordering\n of its elements (as by the\n sort(Object[]) method) prior to making this call.\n If it is not sorted, the results are undefined.\n (If the array contains elements that are not mutually comparable (for\n example, strings and integers), it cannot be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)",
                  "description": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the\n natural ordering\n of its elements (as by the\n sort(Object[], int, int) method) prior to making this\n call.  If it is not sorted, the results are undefined.\n (If the range contains elements that are not mutually comparable (for\n example, strings and integers), it cannot be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the range contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found."
                },
                {
                  "signature": "public static <T> int binarySearch(T[] a, T key, Comparator<? super T> c)",
                  "description": "Searches the specified array for the specified object using the binary\n search algorithm.  The array must be sorted into ascending order\n according to the specified comparator (as by the\n sort(T[], Comparator)\n method) prior to making this call.  If it is\n not sorted, the results are undefined.\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which one\n will be found."
                },
                {
                  "signature": "public static <T> int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)",
                  "description": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the specified comparator (as by the\n sort(T[], int, int, Comparator)\n method) prior to making this call.\n If it is not sorted, the results are undefined.\n If the range contains multiple elements equal to the specified object,\n there is no guarantee which one will be found."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public static boolean equals(long[] a, long[] a2)",
                  "description": "Returns true if the two specified arrays of longs are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of longs, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(int[] a, int[] a2)",
                  "description": "Returns true if the two specified arrays of ints are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of ints, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(short[] a, short[] a2)",
                  "description": "Returns true if the two specified arrays of shorts are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of shorts, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(char[] a, char[] a2)",
                  "description": "Returns true if the two specified arrays of chars are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of chars, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(byte[] a, byte[] a2)",
                  "description": "Returns true if the two specified arrays of bytes are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of bytes, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(boolean[] a, boolean[] a2)",
                  "description": "Returns true if the two specified arrays of booleans are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of booleans, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."
                },
                {
                  "signature": "public static boolean equals(double[] a, double[] a2)",
                  "description": "Returns true if the two specified arrays of doubles are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null.\n\n Two doubles d1 and d2 are considered equal if:\n     new Double(d1).equals(new Double(d2))\n (Unlike the == operator, this method considers\n NaN equal to itself, and 0.0d unequal to -0.0d.)"
                },
                {
                  "signature": "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of doubles, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two doubles d1 and d2 are considered equal if:\n     new Double(d1).equals(new Double(d2))\n (Unlike the == operator, this method considers\n NaN equal to itself, and 0.0d unequal to -0.0d.)"
                },
                {
                  "signature": "public static boolean equals(float[] a, float[] a2)",
                  "description": "Returns true if the two specified arrays of floats are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null.\n\n Two floats f1 and f2 are considered equal if:\n     new Float(f1).equals(new Float(f2))\n (Unlike the == operator, this method considers\n NaN equal to itself, and 0.0f unequal to -0.0f.)"
                },
                {
                  "signature": "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of floats, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two floats f1 and f2 are considered equal if:\n     new Float(f1).equals(new Float(f2))\n (Unlike the == operator, this method considers\n NaN equal to itself, and 0.0f unequal to -0.0f.)"
                },
                {
                  "signature": "public static boolean equals(Object[] a, Object[] a2)",
                  "description": "Returns true if the two specified arrays of Objects are\n equal to one another.  The two arrays are considered equal if\n both arrays contain the same number of elements, and all corresponding\n pairs of elements in the two arrays are equal.  Two objects e1\n and e2 are considered equal if\n Objects.equals(e1, e2).\n In other words, the two arrays are equal if\n they contain the same elements in the same order.  Also, two array\n references are considered equal if both are null."
                },
                {
                  "signature": "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)",
                  "description": "Returns true if the two specified arrays of Objects, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two objects e1 and e2 are considered equal if\n Objects.equals(e1, e2)."
                },
                {
                  "signature": "public static <T> boolean equals(T[] a, T[] a2, Comparator<? super T> cmp)",
                  "description": "Returns true if the two specified arrays of Objects are\n equal to one another.\n\n Two arrays are considered equal if both arrays contain the same number\n of elements, and all corresponding pairs of elements in the two arrays\n are equal.  In other words, the two arrays are equal if they contain the\n same elements in the same order.  Also, two array references are\n considered equal if both are null.\n\n Two objects e1 and e2 are considered equal if,\n given the specified comparator, cmp.compare(e1, e2) == 0."
                },
                {
                  "signature": "public static <T> boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
                  "description": "Returns true if the two specified arrays of Objects, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two objects e1 and e2 are considered equal if,\n given the specified comparator, cmp.compare(e1, e2) == 0."
                }
              ]
            },
            {
              "name": "fill",
              "overloads": [
                {
                  "signature": "public static void fill(long[] a, long val)",
                  "description": "Assigns the specified long value to each element of the specified array\n of longs."
                },
                {
                  "signature": "public static void fill(long[] a, int fromIndex, int toIndex, long val)",
                  "description": "Assigns the specified long value to each element of the specified\n range of the specified array of longs.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(int[] a, int val)",
                  "description": "Assigns the specified int value to each element of the specified array\n of ints."
                },
                {
                  "signature": "public static void fill(int[] a, int fromIndex, int toIndex, int val)",
                  "description": "Assigns the specified int value to each element of the specified\n range of the specified array of ints.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(short[] a, short val)",
                  "description": "Assigns the specified short value to each element of the specified array\n of shorts."
                },
                {
                  "signature": "public static void fill(short[] a, int fromIndex, int toIndex, short val)",
                  "description": "Assigns the specified short value to each element of the specified\n range of the specified array of shorts.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(char[] a, char val)",
                  "description": "Assigns the specified char value to each element of the specified array\n of chars."
                },
                {
                  "signature": "public static void fill(char[] a, int fromIndex, int toIndex, char val)",
                  "description": "Assigns the specified char value to each element of the specified\n range of the specified array of chars.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(byte[] a, byte val)",
                  "description": "Assigns the specified byte value to each element of the specified array\n of bytes."
                },
                {
                  "signature": "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)",
                  "description": "Assigns the specified byte value to each element of the specified\n range of the specified array of bytes.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(boolean[] a, boolean val)",
                  "description": "Assigns the specified boolean value to each element of the specified\n array of booleans."
                },
                {
                  "signature": "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)",
                  "description": "Assigns the specified boolean value to each element of the specified\n range of the specified array of booleans.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(double[] a, double val)",
                  "description": "Assigns the specified double value to each element of the specified\n array of doubles."
                },
                {
                  "signature": "public static void fill(double[] a, int fromIndex, int toIndex, double val)",
                  "description": "Assigns the specified double value to each element of the specified\n range of the specified array of doubles.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(float[] a, float val)",
                  "description": "Assigns the specified float value to each element of the specified array\n of floats."
                },
                {
                  "signature": "public static void fill(float[] a, int fromIndex, int toIndex, float val)",
                  "description": "Assigns the specified float value to each element of the specified\n range of the specified array of floats.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                },
                {
                  "signature": "public static void fill(Object[] a, Object val)",
                  "description": "Assigns the specified Object reference to each element of the specified\n array of Objects."
                },
                {
                  "signature": "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)",
                  "description": "Assigns the specified Object reference to each element of the specified\n range of the specified array of Objects.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "public static <T> T[] copyOf(T[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain null.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of exactly the same class as the original array."
                },
                {
                  "signature": "public static <T, U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType)",
                  "description": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain null.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of the class newType."
                },
                {
                  "signature": "public static byte[] copyOf(byte[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain (byte)0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static short[] copyOf(short[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain (short)0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static int[] copyOf(int[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static long[] copyOf(long[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0L.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static char[] copyOf(char[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with null characters (if necessary)\n so the copy has the specified length.  For all indices that are valid\n in both the original array and the copy, the two arrays will contain\n identical values.  For any indices that are valid in the copy but not\n the original, the copy will contain '\\u0000'.  Such indices\n will exist if and only if the specified length is greater than that of\n the original array."
                },
                {
                  "signature": "public static float[] copyOf(float[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0f.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static double[] copyOf(double[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0d.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                },
                {
                  "signature": "public static boolean[] copyOf(boolean[] original, int newLength)",
                  "description": "Copies the specified array, truncating or padding with false (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain false.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."
                }
              ]
            },
            {
              "name": "copyOfRange",
              "overloads": [
                {
                  "signature": "public static <T> T[] copyOfRange(T[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n null is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from.\n \n The resulting array is of exactly the same class as the original array."
                },
                {
                  "signature": "public static <T, U> T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n null is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from.\n The resulting array is of the class newType."
                },
                {
                  "signature": "public static byte[] copyOfRange(byte[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n (byte)0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static short[] copyOfRange(short[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n (short)0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static int[] copyOfRange(int[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static long[] copyOfRange(long[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0L is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static char[] copyOfRange(char[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n '\\u0000' is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static float[] copyOfRange(float[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0f is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static double[] copyOfRange(double[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0d is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                },
                {
                  "signature": "public static boolean[] copyOfRange(boolean[] original, int from, int to)",
                  "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n false is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."
                }
              ]
            },
            {
              "name": "asList",
              "overloads": [
                {
                  "signature": "@SafeVarargs public static <T> List<T> asList(T... a)",
                  "description": "Returns a fixed-size list backed by the specified array. Changes made to\n the array will be visible in the returned list, and changes made to the\n list will be visible in the array. The returned list is\n Serializable and implements RandomAccess.\n\n The returned list implements the optional Collection methods, except\n those that would change the size of the returned list. Those methods leave\n the list unchanged and throw UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public static int hashCode(long[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two long arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Long\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(int[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two non-null int arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Integer\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(short[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two short arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Short\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(char[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two char arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Character\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(byte[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two byte arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Byte\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(boolean[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two boolean arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Boolean\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(float[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two float arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Float\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(double[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.\n For any two double arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Double\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."
                },
                {
                  "signature": "public static int hashCode(Object[] a)",
                  "description": "Returns a hash code based on the contents of the specified array.  If\n the array contains other arrays as elements, the hash code is based on\n their identities rather than their contents.  It is therefore\n acceptable to invoke this method on an array that contains itself as an\n element,  either directly or indirectly through one or more levels of\n arrays.\n\n For any two arrays a and b such that\n Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is equal to the value that would\n be returned by Arrays.asList(a).hashCode(), unless a\n is null, in which case 0 is returned."
                }
              ]
            },
            {
              "name": "deepHashCode",
              "overloads": [
                {
                  "signature": "public static int deepHashCode(Object[] a)",
                  "description": "Returns a hash code based on the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the\n hash code is based on their contents and so on, ad infinitum.\n It is therefore unacceptable to invoke this method on an array that\n contains itself as an element, either directly or indirectly through\n one or more levels of arrays.  The behavior of such an invocation is\n undefined.\n\n For any two arrays a and b such that\n Arrays.deepEquals(a, b), it is also the case that\n Arrays.deepHashCode(a) == Arrays.deepHashCode(b).\n\n The computation of the value returned by this method is similar to\n that of the value returned by List.hashCode() on a list\n containing the same elements as a in the same order, with one\n difference: If an element e of a is itself an array,\n its hash code is computed not by calling e.hashCode(), but as\n by calling the appropriate overloading of Arrays.hashCode(e)\n if e is an array of a primitive type, or as by calling\n Arrays.deepHashCode(e) recursively if e is an array\n of a reference type.  If a is null, this method\n returns 0."
                }
              ]
            },
            {
              "name": "deepEquals",
              "overloads": [
                {
                  "signature": "public static boolean deepEquals(Object[] a1, Object[] a2)",
                  "description": "Returns true if the two specified arrays are deeply\n equal to one another.  Unlike the equals(Object[],Object[])\n method, this method is appropriate for use with nested arrays of\n arbitrary depth.\n\n Two array references are considered deeply equal if both\n are null, or if they refer to arrays that contain the same\n number of elements and all corresponding pairs of elements in the two\n arrays are deeply equal.\n\n Two possibly null elements e1 and e2 are\n deeply equal if any of the following conditions hold:\n \n     e1 and e2 are both arrays of object reference\n         types, and Arrays.deepEquals(e1, e2) would return true\n     e1 and e2 are arrays of the same primitive\n         type, and the appropriate overloading of\n         Arrays.equals(e1, e2) would return true.\n     e1 == e2\n     e1.equals(e2) would return true.\n \n Note that this definition permits null elements at any depth.\n\n If either of the specified arrays contain themselves as elements\n either directly or indirectly through one or more levels of arrays,\n the behavior of this method is undefined."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(long[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(long).  Returns \"null\" if a\n is null."
                },
                {
                  "signature": "public static String toString(int[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(int).  Returns \"null\" if a is\n null."
                },
                {
                  "signature": "public static String toString(short[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(short).  Returns \"null\" if a\n is null."
                },
                {
                  "signature": "public static String toString(char[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(char).  Returns \"null\" if a\n is null."
                },
                {
                  "signature": "public static String toString(byte[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements\n are separated by the characters \", \" (a comma followed\n by a space).  Elements are converted to strings as by\n String.valueOf(byte).  Returns \"null\" if\n a is null."
                },
                {
                  "signature": "public static String toString(boolean[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(boolean).  Returns \"null\" if\n a is null."
                },
                {
                  "signature": "public static String toString(float[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(float).  Returns \"null\" if a\n is null."
                },
                {
                  "signature": "public static String toString(double[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(double).  Returns \"null\" if a\n is null."
                },
                {
                  "signature": "public static String toString(Object[] a)",
                  "description": "Returns a string representation of the contents of the specified array.\n If the array contains other arrays as elements, they are converted to\n strings by the Object.toString() method inherited from\n Object, which describes their identities rather than\n their contents.\n\n The value returned by this method is equal to the value that would\n be returned by Arrays.asList(a).toString(), unless a\n is null, in which case \"null\" is returned."
                }
              ]
            },
            {
              "name": "deepToString",
              "overloads": [
                {
                  "signature": "public static String deepToString(Object[] a)",
                  "description": "Returns a string representation of the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the string\n representation contains their contents and so on.  This method is\n designed for converting multidimensional arrays to strings.\n\n The string representation consists of a list of the array's\n elements, enclosed in square brackets (\"[]\").  Adjacent\n elements are separated by the characters \", \" (a comma\n followed by a space).  Elements are converted to strings as by\n String.valueOf(Object), unless they are themselves\n arrays.\n\n If an element e is an array of a primitive type, it is\n converted to a string as by invoking the appropriate overloading of\n Arrays.toString(e).  If an element e is an array of a\n reference type, it is converted to a string as by invoking\n this method recursively.\n\n To avoid infinite recursion, if the specified array contains itself\n as an element, or contains an indirect reference to itself through one\n or more levels of arrays, the self-reference is converted to the string\n \"[...]\".  For example, an array containing only a reference\n to itself would be rendered as \"[[...]]\".\n\n This method returns \"null\" if the specified array\n is null."
                }
              ]
            },
            {
              "name": "setAll",
              "overloads": [
                {
                  "signature": "public static <T> void setAll(T[] array, IntFunction<? extends T> generator)",
                  "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."
                },
                {
                  "signature": "public static void setAll(int[] array, IntUnaryOperator generator)",
                  "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."
                },
                {
                  "signature": "public static void setAll(long[] array, IntToLongFunction generator)",
                  "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."
                },
                {
                  "signature": "public static void setAll(double[] array, IntToDoubleFunction generator)",
                  "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."
                }
              ]
            },
            {
              "name": "parallelSetAll",
              "overloads": [
                {
                  "signature": "public static <T> void parallelSetAll(T[] array, IntFunction<? extends T> generator)",
                  "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."
                },
                {
                  "signature": "public static void parallelSetAll(int[] array, IntUnaryOperator generator)",
                  "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."
                },
                {
                  "signature": "public static void parallelSetAll(long[] array, IntToLongFunction generator)",
                  "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."
                },
                {
                  "signature": "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)",
                  "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public static <T> Spliterator<T> spliterator(T[] array)",
                  "description": "Returns a Spliterator covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static <T> Spliterator<T> spliterator(T[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a Spliterator covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfInt spliterator(int[] array)",
                  "description": "Returns a Spliterator.OfInt covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a Spliterator.OfInt covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfLong spliterator(long[] array)",
                  "description": "Returns a Spliterator.OfLong covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a Spliterator.OfLong covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliterator(double[] array)",
                  "description": "Returns a Spliterator.OfDouble covering all of the specified\n array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a Spliterator.OfDouble covering the specified range of\n the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public static <T> Stream<T> stream(T[] array)",
                  "description": "Returns a sequential Stream with the specified array as its\n source."
                },
                {
                  "signature": "public static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a sequential Stream with the specified range of the\n specified array as its source."
                },
                {
                  "signature": "public static IntStream stream(int[] array)",
                  "description": "Returns a sequential IntStream with the specified array as its\n source."
                },
                {
                  "signature": "public static IntStream stream(int[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a sequential IntStream with the specified range of the\n specified array as its source."
                },
                {
                  "signature": "public static LongStream stream(long[] array)",
                  "description": "Returns a sequential LongStream with the specified array as its\n source."
                },
                {
                  "signature": "public static LongStream stream(long[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a sequential LongStream with the specified range of the\n specified array as its source."
                },
                {
                  "signature": "public static DoubleStream stream(double[] array)",
                  "description": "Returns a sequential DoubleStream with the specified array as its\n source."
                },
                {
                  "signature": "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)",
                  "description": "Returns a sequential DoubleStream with the specified range of the\n specified array as its source."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static int compare(boolean[] a, boolean[] b)",
                  "description": "Compares two boolean arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Boolean.compare(boolean, boolean), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(boolean[], boolean[]) for the definition of a\n common and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two boolean arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Boolean.compare(boolean, boolean), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(boolean[], int, int, boolean[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(byte[] a, byte[] b)",
                  "description": "Compares two byte arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Byte.compare(byte, byte), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(byte[], byte[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two byte arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Byte.compare(byte, byte), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(byte[], int, int, byte[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(short[] a, short[] b)",
                  "description": "Compares two short arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Short.compare(short, short), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(short[], short[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two short arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Short.compare(short, short), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(short[], int, int, short[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(char[] a, char[] b)",
                  "description": "Compares two char arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Character.compare(char, char), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(char[], char[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two char arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Character.compare(char, char), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(char[], int, int, char[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(int[] a, int[] b)",
                  "description": "Compares two int arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Integer.compare(int, int), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(int[], int[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two int arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Integer.compare(int, int), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(int[], int, int, int[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(long[] a, long[] b)",
                  "description": "Compares two long arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Long.compare(long, long), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(long[], long[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two long arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Long.compare(long, long), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(long[], int, int, long[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(float[] a, float[] b)",
                  "description": "Compares two float arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Float.compare(float, float), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(float[], float[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two float arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Float.compare(float, float), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(float[], int, int, float[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static int compare(double[] a, double[] b)",
                  "description": "Compares two double arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Double.compare(double, double), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(double[], double[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two double arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Double.compare(double, double), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(double[], int, int, double[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static <T extends Comparable<? super T>> int compare(T[] a, T[] b)",
                  "description": "Compares two Object arrays, within comparable elements,\n lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements of type T at\n an index i within the respective arrays that is the prefix\n length, as if by:\n \n     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n         compare(a[i], b[i])\n \n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(Object[], Object[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference. Two null array\n references are considered equal.\n A null array element is considered lexicographically less than a\n non-null array element. Two null array elements are\n considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)"
                },
                {
                  "signature": "public static <T extends Comparable<? super T>> int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two Object arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements of type T at a relative index i within the\n respective arrays that is the prefix length, as if by:\n \n     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n         compare(a[aFromIndex + i, b[bFromIndex + i])\n \n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(Object[], int, int, Object[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)"
                },
                {
                  "signature": "public static <T> int compare(T[] a, T[] b, Comparator<? super T> cmp)",
                  "description": "Compares two Object arrays lexicographically using a specified\n comparator.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing with the specified comparator two\n elements at an index within the respective arrays that is the prefix\n length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(Object[], Object[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."
                },
                {
                  "signature": "public static <T> int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
                  "description": "Compares two Object arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing with the\n specified comparator two elements at a relative index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(Object[], int, int, Object[], int, int) for the\n definition of a common and proper prefix.)"
                }
              ]
            },
            {
              "name": "compareUnsigned",
              "overloads": [
                {
                  "signature": "public static int compareUnsigned(byte[] a, byte[] b)",
                  "description": "Compares two byte arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Byte.compareUnsigned(byte, byte), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(byte[], byte[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."
                },
                {
                  "signature": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two byte arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Byte.compareUnsigned(byte, byte), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(byte[], int, int, byte[], int, int) for the\n definition of a common and proper prefix.)"
                },
                {
                  "signature": "public static int compareUnsigned(short[] a, short[] b)",
                  "description": "Compares two short arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Short.compareUnsigned(short, short), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(short[], short[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."
                },
                {
                  "signature": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two short arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Short.compareUnsigned(short, short), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(short[], int, int, short[], int, int) for the\n definition of a common and proper prefix.)"
                },
                {
                  "signature": "public static int compareUnsigned(int[] a, int[] b)",
                  "description": "Compares two int arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Integer.compareUnsigned(int, int), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(int[], int[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."
                },
                {
                  "signature": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two int arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Integer.compareUnsigned(int, int), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(int[], int, int, int[], int, int) for the\n definition of a common and proper prefix.)"
                },
                {
                  "signature": "public static int compareUnsigned(long[] a, long[] b)",
                  "description": "Compares two long arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Long.compareUnsigned(long, long), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(long[], long[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."
                },
                {
                  "signature": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
                  "description": "Compares two long arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Long.compareUnsigned(long, long), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(long[], int, int, long[], int, int) for the\n definition of a common and proper prefix.)"
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public static int mismatch(boolean[] a, boolean[] b)",
                  "description": "Finds and returns the index of the first mismatch between two\n boolean arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n boolean arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(byte[] a, byte[] b)",
                  "description": "Finds and returns the index of the first mismatch between two byte\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n byte arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(char[] a, char[] b)",
                  "description": "Finds and returns the index of the first mismatch between two char\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n char arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(short[] a, short[] b)",
                  "description": "Finds and returns the index of the first mismatch between two short\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n short arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(int[] a, int[] b)",
                  "description": "Finds and returns the index of the first mismatch between two int\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n int arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(long[] a, long[] b)",
                  "description": "Finds and returns the index of the first mismatch between two long\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n long arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(float[] a, float[] b)",
                  "description": "Finds and returns the index of the first mismatch between two float\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     Float.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n float arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(double[] a, double[] b)",
                  "description": "Finds and returns the index of the first mismatch between two\n double arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     Double.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n double arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static int mismatch(Object[] a, Object[] b)",
                  "description": "Finds and returns the index of the first mismatch between two\n Object arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     !Objects.equals(a[pl], b[pl])\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))"
                },
                {
                  "signature": "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n Object arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))"
                },
                {
                  "signature": "public static <T> int mismatch(T[] a, T[] b, Comparator<? super T> cmp)",
                  "description": "Finds and returns the index of the first mismatch between two\n Object arrays, otherwise return -1 if no mismatch is found.\n The index will be in the range of 0 (inclusive) up to the length\n (inclusive) of the smaller array.\n\n The specified comparator is used to determine if two array elements\n from the each array are not equal.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl, cmp)\n     cmp.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length),\n                   cmp)"
                },
                {
                  "signature": "public static <T> int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
                  "description": "Finds and returns the relative index of the first mismatch between two\n Object arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &&\n     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n prefix if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   cmp)"
                }
              ]
            }
          ]
        },
        {
          "name": "Base64",
          "methods": [
            {
              "name": "getEncoder",
              "overloads": [
                {
                  "signature": "public static Base64.Encoder getEncoder()",
                  "description": "Returns a Base64.Encoder that encodes using the\n Basic type base64 encoding scheme."
                }
              ]
            },
            {
              "name": "getUrlEncoder",
              "overloads": [
                {
                  "signature": "public static Base64.Encoder getUrlEncoder()",
                  "description": "Returns a Base64.Encoder that encodes using the\n URL and Filename safe type base64\n encoding scheme."
                }
              ]
            },
            {
              "name": "getMimeEncoder",
              "overloads": [
                {
                  "signature": "public static Base64.Encoder getMimeEncoder()",
                  "description": "Returns a Base64.Encoder that encodes using the\n MIME type base64 encoding scheme."
                },
                {
                  "signature": "public static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)",
                  "description": "Returns a Base64.Encoder that encodes using the\n MIME type base64 encoding scheme\n with specified line length and line separators."
                }
              ]
            },
            {
              "name": "getDecoder",
              "overloads": [
                {
                  "signature": "public static Base64.Decoder getDecoder()",
                  "description": "Returns a Base64.Decoder that decodes using the\n Basic type base64 encoding scheme."
                }
              ]
            },
            {
              "name": "getUrlDecoder",
              "overloads": [
                {
                  "signature": "public static Base64.Decoder getUrlDecoder()",
                  "description": "Returns a Base64.Decoder that decodes using the\n URL and Filename safe type base64\n encoding scheme."
                }
              ]
            },
            {
              "name": "getMimeDecoder",
              "overloads": [
                {
                  "signature": "public static Base64.Decoder getMimeDecoder()",
                  "description": "Returns a Base64.Decoder that decodes using the\n MIME type base64 decoding scheme."
                }
              ]
            }
          ]
        },
        {
          "name": "Base64.Decoder",
          "methods": [
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "public byte[] decode(byte[] src)",
                  "description": "Decodes all bytes from the input byte array using the Base64\n encoding scheme, writing the results into a newly-allocated output\n byte array. The returned byte array is of the length of the resulting\n bytes."
                },
                {
                  "signature": "public byte[] decode(String src)",
                  "description": "Decodes a Base64 encoded String into a newly-allocated byte array\n using the Base64 encoding scheme.\n\n  An invocation of this method has exactly the same effect as invoking\n decode(src.getBytes(StandardCharsets.ISO_8859_1))"
                },
                {
                  "signature": "public int decode(byte[] src, byte[] dst)",
                  "description": "Decodes all bytes from the input byte array using the Base64\n encoding scheme, writing the results into the given output byte array,\n starting at offset 0.\n\n  It is the responsibility of the invoker of this method to make\n sure the output byte array dst has enough space for decoding\n all bytes from the input byte array. No bytes will be written to\n the output byte array if the output byte array is not big enough.\n\n  If the input byte array is not in valid Base64 encoding scheme\n then some bytes may have been written to the output byte array before\n IllegalargumentException is thrown."
                },
                {
                  "signature": "public ByteBuffer decode(ByteBuffer buffer)",
                  "description": "Decodes all bytes from the input byte buffer using the Base64\n encoding scheme, writing the results into a newly-allocated ByteBuffer.\n\n  Upon return, the source buffer's position will be updated to\n its limit; its limit will not have been changed. The returned\n output buffer's position will be zero and its limit will be the\n number of resulting decoded bytes\n\n  IllegalArgumentException is thrown if the input buffer\n is not in valid Base64 encoding scheme. The position of the input\n buffer will not be advanced in this case."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public InputStream wrap(InputStream is)",
                  "description": "Returns an input stream for decoding Base64 encoded byte stream.\n\n  The read  methods of the returned InputStream will\n throw IOException when reading bytes that cannot be decoded.\n\n  Closing the returned input stream will close the underlying\n input stream."
                }
              ]
            }
          ]
        },
        {
          "name": "Base64.Encoder",
          "methods": [
            {
              "name": "encode",
              "overloads": [
                {
                  "signature": "public byte[] encode(byte[] src)",
                  "description": "Encodes all bytes from the specified byte array into a newly-allocated\n byte array using the Base64 encoding scheme. The returned byte\n array is of the length of the resulting bytes."
                },
                {
                  "signature": "public int encode(byte[] src, byte[] dst)",
                  "description": "Encodes all bytes from the specified byte array using the\n Base64 encoding scheme, writing the resulting bytes to the\n given output byte array, starting at offset 0.\n\n  It is the responsibility of the invoker of this method to make\n sure the output byte array dst has enough space for encoding\n all bytes from the input byte array. No bytes will be written to the\n output byte array if the output byte array is not big enough."
                },
                {
                  "signature": "public ByteBuffer encode(ByteBuffer buffer)",
                  "description": "Encodes all remaining bytes from the specified byte buffer into\n a newly-allocated ByteBuffer using the Base64 encoding\n scheme.\n\n Upon return, the source buffer's position will be updated to\n its limit; its limit will not have been changed. The returned\n output buffer's position will be zero and its limit will be the\n number of resulting encoded bytes."
                }
              ]
            },
            {
              "name": "encodeToString",
              "overloads": [
                {
                  "signature": "public String encodeToString(byte[] src)",
                  "description": "Encodes the specified byte array into a String using the Base64\n encoding scheme.\n\n  This method first encodes all input bytes into a base64 encoded\n byte array and then constructs a new String by using the encoded byte\n array and the ISO-8859-1 charset.\n\n  In other words, an invocation of this method has exactly the same\n effect as invoking\n new String(encode(src), StandardCharsets.ISO_8859_1)."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public OutputStream wrap(OutputStream os)",
                  "description": "Wraps an output stream for encoding byte data using the Base64\n encoding scheme.\n\n  It is recommended to promptly close the returned output stream after\n use, during which it will flush all possible leftover bytes to the underlying\n output stream. Closing the returned output stream will close the underlying\n output stream."
                }
              ]
            },
            {
              "name": "withoutPadding",
              "overloads": [
                {
                  "signature": "public Base64.Encoder withoutPadding()",
                  "description": "Returns an encoder instance that encodes equivalently to this one,\n but without adding any padding character at the end of the encoded\n byte data.\n\n  The encoding scheme of this encoder instance is unaffected by\n this invocation. The returned encoder instance should be used for\n non-padding encoding operation."
                }
              ]
            }
          ]
        },
        {
          "name": "BitSet",
          "methods": [
            {
              "name": "BitSet",
              "overloads": [
                {
                  "signature": "public BitSet()",
                  "description": "Creates a new bit set. All bits are initially false."
                },
                {
                  "signature": "public BitSet(int nbits)",
                  "description": "Creates a bit set whose initial size is large enough to explicitly\n represent bits with indices in the range 0 through\n nbits-1. All bits are initially false."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static BitSet valueOf(long[] longs)",
                  "description": "Returns a new bit set containing all the bits in the given long array.\n\n More precisely,\n BitSet.valueOf(longs).get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)\n for all n < 64 * longs.length.\n\n This method is equivalent to\n BitSet.valueOf(LongBuffer.wrap(longs))."
                },
                {
                  "signature": "public static BitSet valueOf(LongBuffer lb)",
                  "description": "Returns a new bit set containing all the bits in the given long\n buffer between its position and limit.\n\n More precisely,\n BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) & (1L<<(n%64))) != 0)\n for all n < 64 * lb.remaining().\n\n The long buffer is not modified by this method, and no\n reference to the buffer is retained by the bit set."
                },
                {
                  "signature": "public static BitSet valueOf(byte[] bytes)",
                  "description": "Returns a new bit set containing all the bits in the given byte array.\n\n More precisely,\n BitSet.valueOf(bytes).get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)\n for all n <  8 * bytes.length.\n\n This method is equivalent to\n BitSet.valueOf(ByteBuffer.wrap(bytes))."
                },
                {
                  "signature": "public static BitSet valueOf(ByteBuffer bb)",
                  "description": "Returns a new bit set containing all the bits in the given byte\n buffer between its position and limit.\n\n More precisely,\n BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) & (1<<(n%8))) != 0)\n for all n < 8 * bb.remaining().\n\n The byte buffer is not modified by this method, and no\n reference to the buffer is retained by the bit set."
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public byte[] toByteArray()",
                  "description": "Returns a new byte array containing all the bits in this bit set.\n\n More precisely, if\n byte[] bytes = s.toByteArray();\n then bytes.length == (s.length()+7)/8 and\n s.get(n) == ((bytes[n/8] & (1<<(n%8))) != 0)\n for all n < 8 * bytes.length."
                }
              ]
            },
            {
              "name": "toLongArray",
              "overloads": [
                {
                  "signature": "public long[] toLongArray()",
                  "description": "Returns a new long array containing all the bits in this bit set.\n\n More precisely, if\n long[] longs = s.toLongArray();\n then longs.length == (s.length()+63)/64 and\n s.get(n) == ((longs[n/64] & (1L<<(n%64))) != 0)\n for all n < 64 * longs.length."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public void flip(int bitIndex)",
                  "description": "Sets the bit at the specified index to the complement of its\n current value."
                },
                {
                  "signature": "public void flip(int fromIndex, int toIndex)",
                  "description": "Sets each bit from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the complement of its current\n value."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public void set(int bitIndex)",
                  "description": "Sets the bit at the specified index to true."
                },
                {
                  "signature": "public void set(int bitIndex, boolean value)",
                  "description": "Sets the bit at the specified index to the specified value."
                },
                {
                  "signature": "public void set(int fromIndex, int toIndex)",
                  "description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to true."
                },
                {
                  "signature": "public void set(int fromIndex, int toIndex, boolean value)",
                  "description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the specified value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear(int bitIndex)",
                  "description": "Sets the bit specified by the index to false."
                },
                {
                  "signature": "public void clear(int fromIndex, int toIndex)",
                  "description": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to false."
                },
                {
                  "signature": "public void clear()",
                  "description": "Sets all of the bits in this BitSet to false."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public boolean get(int bitIndex)",
                  "description": "Returns the value of the bit with the specified index. The value\n is true if the bit with the index bitIndex\n is currently set in this BitSet; otherwise, the result\n is false."
                },
                {
                  "signature": "public BitSet get(int fromIndex, int toIndex)",
                  "description": "Returns a new BitSet composed of bits from this BitSet\n from fromIndex (inclusive) to toIndex (exclusive)."
                }
              ]
            },
            {
              "name": "nextSetBit",
              "overloads": [
                {
                  "signature": "public int nextSetBit(int fromIndex)",
                  "description": "Returns the index of the first bit that is set to true\n that occurs on or after the specified starting index. If no such\n bit exists then -1 is returned.\n\n To iterate over the true bits in a BitSet,\n use the following loop:\n\n   \n for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n     // operate on index i here\n     if (i == Integer.MAX_VALUE) {\n         break; // or (i+1) would overflow\n     }\n }"
                }
              ]
            },
            {
              "name": "nextClearBit",
              "overloads": [
                {
                  "signature": "public int nextClearBit(int fromIndex)",
                  "description": "Returns the index of the first bit that is set to false\n that occurs on or after the specified starting index."
                }
              ]
            },
            {
              "name": "previousSetBit",
              "overloads": [
                {
                  "signature": "public int previousSetBit(int fromIndex)",
                  "description": "Returns the index of the nearest bit that is set to true\n that occurs on or before the specified starting index.\n If no such bit exists, or if -1 is given as the\n starting index, then -1 is returned.\n\n To iterate over the true bits in a BitSet,\n use the following loop:\n\n   \n for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\n     // operate on index i here\n }"
                }
              ]
            },
            {
              "name": "previousClearBit",
              "overloads": [
                {
                  "signature": "public int previousClearBit(int fromIndex)",
                  "description": "Returns the index of the nearest bit that is set to false\n that occurs on or before the specified starting index.\n If no such bit exists, or if -1 is given as the\n starting index, then -1 is returned."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the \"logical size\" of this BitSet: the index of\n the highest set bit in the BitSet plus one. Returns zero\n if the BitSet contains no set bits."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this BitSet contains no bits that are set\n to true."
                }
              ]
            },
            {
              "name": "intersects",
              "overloads": [
                {
                  "signature": "public boolean intersects(BitSet set)",
                  "description": "Returns true if the specified BitSet has any bits set to\n true that are also set to true in this BitSet."
                }
              ]
            },
            {
              "name": "cardinality",
              "overloads": [
                {
                  "signature": "public int cardinality()",
                  "description": "Returns the number of bits set to true in this BitSet."
                }
              ]
            },
            {
              "name": "and",
              "overloads": [
                {
                  "signature": "public void and(BitSet set)",
                  "description": "Performs a logical AND of this target bit set with the\n argument bit set. This bit set is modified so that each bit in it\n has the value true if and only if it both initially\n had the value true and the corresponding bit in the\n bit set argument also had the value true."
                }
              ]
            },
            {
              "name": "or",
              "overloads": [
                {
                  "signature": "public void or(BitSet set)",
                  "description": "Performs a logical OR of this bit set with the bit set\n argument. This bit set is modified so that a bit in it has the\n value true if and only if it either already had the\n value true or the corresponding bit in the bit set\n argument has the value true."
                }
              ]
            },
            {
              "name": "xor",
              "overloads": [
                {
                  "signature": "public void xor(BitSet set)",
                  "description": "Performs a logical XOR of this bit set with the bit set\n argument. This bit set is modified so that a bit in it has the\n value true if and only if one of the following\n statements holds:\n \n The bit initially has the value true, and the\n     corresponding bit in the argument has the value false.\n The bit initially has the value false, and the\n     corresponding bit in the argument has the value true."
                }
              ]
            },
            {
              "name": "andNot",
              "overloads": [
                {
                  "signature": "public void andNot(BitSet set)",
                  "description": "Clears all of the bits in this BitSet whose corresponding\n bit is set in the specified BitSet."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this bit set. The hash code depends\n only on which bits are set within this BitSet.\n\n The hash code is defined to be the result of the following\n calculation:\n   \n public int hashCode() {\n     long h = 1234;\n     long[] words = toLongArray();\n     for (int i = words.length; --i >= 0; )\n         h ^= words[i] * (i + 1);\n     return (int)((h >> 32) ^ h);\n }\n Note that the hash code changes if the set of bits is altered."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of bits of space actually in use by this\n BitSet to represent bit values.\n The maximum element in the set is the size - 1st element."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and is a BitSet object that has\n exactly the same set of bits set to true as this bit\n set. That is, for every nonnegative int index k,\n ((BitSet)obj).get(k) == this.get(k)\n must be true. The current sizes of the two bit sets are not compared."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Cloning this BitSet produces a new BitSet\n that is equal to it.\n The clone of the bit set is another bit set that has exactly the\n same bits set to true as this bit set."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this bit set. For every index\n for which this BitSet contains a bit in the set\n state, the decimal representation of that index is included in\n the result. Such indices are listed in order from lowest to\n highest, separated by \",\" (a comma and a space) and\n surrounded by braces, resulting in the usual mathematical\n notation for a set of integers.\n\n Example:\n  BitSet drPepper = new BitSet();\n Now drPepper.toString() returns \"{}\".\n  drPepper.set(2);\n Now drPepper.toString() returns \"{2}\".\n  drPepper.set(4);\n drPepper.set(10);\n Now drPepper.toString() returns \"{2, 4, 10}\"."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public IntStream stream()",
                  "description": "Returns a stream of indices for which this BitSet\n contains a bit in the set state. The indices are returned\n in order, from lowest to highest. The size of the stream\n is the number of bits in the set state, equal to the value\n returned by the cardinality() method.\n\n The stream binds to this bit set when the terminal stream operation\n commences (specifically, the spliterator for the stream is\n late-binding).  If the\n bit set is modified during that operation then the result is undefined."
                }
              ]
            }
          ]
        },
        {
          "name": "Calendar",
          "methods": [
            {
              "name": "Calendar",
              "overloads": [
                {
                  "signature": "protected Calendar()",
                  "description": "Constructs a Calendar with the default time zone\n and the default FORMAT\n locale."
                },
                {
                  "signature": "protected Calendar(TimeZone zone, Locale aLocale)",
                  "description": "Constructs a calendar with the specified time zone and locale."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Calendar getInstance()",
                  "description": "Gets a calendar using the default time zone and locale. The\n Calendar returned is based on the current time\n in the default time zone with the default\n FORMAT locale.\n \n If the locale contains the time zone with \"tz\"\n Unicode extension,\n that time zone is used instead."
                },
                {
                  "signature": "public static Calendar getInstance(TimeZone zone)",
                  "description": "Gets a calendar using the specified time zone and default locale.\n The Calendar returned is based on the current time\n in the given time zone with the default\n FORMAT locale."
                },
                {
                  "signature": "public static Calendar getInstance(Locale aLocale)",
                  "description": "Gets a calendar using the default time zone and specified locale.\n The Calendar returned is based on the current time\n in the default time zone with the given locale.\n \n If the locale contains the time zone with \"tz\"\n Unicode extension,\n that time zone is used instead."
                },
                {
                  "signature": "public static Calendar getInstance(TimeZone zone, Locale aLocale)",
                  "description": "Gets a calendar with the specified time zone and locale.\n The Calendar returned is based on the current time\n in the given time zone with the given locale."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the getInstance\n methods of this class can return localized instances.\n The array returned must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "computeTime",
              "overloads": [
                {
                  "signature": "protected abstract void computeTime()",
                  "description": "Converts the current calendar field values in fields[]\n to the millisecond time value\n time."
                }
              ]
            },
            {
              "name": "computeFields",
              "overloads": [
                {
                  "signature": "protected abstract void computeFields()",
                  "description": "Converts the current millisecond time value time\n to calendar field values in fields[].\n This allows you to sync up the calendar field values with\n a new time that is set for the calendar.  The time is not\n recomputed first; to recompute the time, then the fields, call the\n complete() method."
                }
              ]
            },
            {
              "name": "getTime",
              "overloads": [
                {
                  "signature": "public final Date getTime()",
                  "description": "Returns a Date object representing this\n Calendar's time value (millisecond offset from the Epoch\")."
                }
              ]
            },
            {
              "name": "setTime",
              "overloads": [
                {
                  "signature": "public final void setTime(Date date)",
                  "description": "Sets this Calendar's time with the given Date.\n \n Note: Calling setTime() with\n Date(Long.MAX_VALUE) or Date(Long.MIN_VALUE)\n may yield incorrect field values from get()."
                }
              ]
            },
            {
              "name": "getTimeInMillis",
              "overloads": [
                {
                  "signature": "public long getTimeInMillis()",
                  "description": "Returns this Calendar's time value in milliseconds."
                }
              ]
            },
            {
              "name": "setTimeInMillis",
              "overloads": [
                {
                  "signature": "public void setTimeInMillis(long millis)",
                  "description": "Sets this Calendar's current time from the given long value."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(int field)",
                  "description": "Returns the value of the given calendar field. In lenient mode,\n all calendar fields are normalized. In non-lenient mode, all\n calendar fields are validated and this method throws an\n exception if any calendar fields have out-of-range values. The\n normalization and validation are handled by the\n complete() method, which process is calendar\n system dependent."
                }
              ]
            },
            {
              "name": "internalGet",
              "overloads": [
                {
                  "signature": "protected final int internalGet(int field)",
                  "description": "Returns the value of the given calendar field. This method does\n not involve normalization or validation of the field value."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public void set(int field, int value)",
                  "description": "Sets the given calendar field to the given value. The value is not\n interpreted by this method regardless of the leniency mode."
                },
                {
                  "signature": "public final void set(int year, int month, int date)",
                  "description": "Sets the values for the calendar fields YEAR,\n MONTH, and DAY_OF_MONTH.\n Previous values of other calendar fields are retained.  If this is not desired,\n call clear() first."
                },
                {
                  "signature": "public final void set(int year, int month, int date, int hourOfDay, int minute)",
                  "description": "Sets the values for the calendar fields YEAR,\n MONTH, DAY_OF_MONTH,\n HOUR_OF_DAY, and MINUTE.\n Previous values of other fields are retained.  If this is not desired,\n call clear() first."
                },
                {
                  "signature": "public final void set(int year, int month, int date, int hourOfDay, int minute, int second)",
                  "description": "Sets the values for the fields YEAR, MONTH,\n DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, and\n SECOND.\n Previous values of other fields are retained.  If this is not desired,\n call clear() first."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final void clear()",
                  "description": "Sets all the calendar field values and the time value\n (millisecond offset from the Epoch) of\n this Calendar undefined. This means that isSet() will return false for all the\n calendar fields, and the date and time calculations will treat\n the fields as if they had never been set. A\n Calendar implementation class may use its specific\n default field values for date/time calculations. For example,\n GregorianCalendar uses 1970 if the\n YEAR field value is undefined."
                },
                {
                  "signature": "public final void clear(int field)",
                  "description": "Sets the given calendar field value and the time value\n (millisecond offset from the Epoch) of\n this Calendar undefined. This means that isSet(field) will return false, and\n the date and time calculations will treat the field as if it\n had never been set. A Calendar implementation\n class may use the field's specific default value for date and\n time calculations.\n\n The HOUR_OF_DAY, HOUR and AM_PM\n fields are handled independently and the the resolution rule for the time of\n day is applied. Clearing one of the fields doesn't reset\n the hour of day value of this Calendar. Use set(Calendar.HOUR_OF_DAY, 0) to reset the hour\n value."
                }
              ]
            },
            {
              "name": "isSet",
              "overloads": [
                {
                  "signature": "public final boolean isSet(int field)",
                  "description": "Determines if the given calendar field has a value set,\n including cases that the value has been set by internal fields\n calculations triggered by a get method call."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName(int field, int style, Locale locale)",
                  "description": "Returns the string representation of the calendar\n field value in the given style and\n locale.  If no string representation is\n applicable, null is returned. This method calls\n get(field) to get the calendar\n field value if the string representation is\n applicable to the given calendar field.\n\n For example, if this Calendar is a\n GregorianCalendar and its date is 2005-01-01, then\n the string representation of the MONTH field would be\n \"January\" in the long style in an English locale or \"Jan\" in\n the short style. However, no string representation would be\n available for the DAY_OF_MONTH field, and this method\n would return null.\n\n The default implementation supports the calendar fields for\n which a DateFormatSymbols has names in the given\n locale."
                }
              ]
            },
            {
              "name": "getDisplayNames",
              "overloads": [
                {
                  "signature": "public Map<String,Integer> getDisplayNames(int field, int style, Locale locale)",
                  "description": "Returns a Map containing all names of the calendar\n field in the given style and\n locale and their corresponding field values. For\n example, if this Calendar is a GregorianCalendar, the returned map would contain \"Jan\" to\n JANUARY, \"Feb\" to FEBRUARY, and so on, in the\n short style in an English locale.\n\n Narrow names may not be unique due to use of single characters,\n such as \"S\" for Sunday and Saturday. In that case narrow names are not\n included in the returned Map.\n\n The values of other calendar fields may be taken into\n account to determine a set of display names. For example, if\n this Calendar is a lunisolar calendar system and\n the year value given by the YEAR field has a leap\n month, this method would return month names containing the leap\n month name, and month names are mapped to their values specific\n for the year.\n\n The default implementation supports display names contained in\n a DateFormatSymbols. For example, if field\n is MONTH and style is ALL_STYLES, this method returns a Map containing\n all strings returned by DateFormatSymbols.getShortMonths()\n and DateFormatSymbols.getMonths()."
                }
              ]
            },
            {
              "name": "complete",
              "overloads": [
                {
                  "signature": "protected void complete()",
                  "description": "Fills in any unset fields in the calendar fields. First, the computeTime() method is called if the time value (millisecond offset\n from the Epoch) has not been calculated from\n calendar field values. Then, the computeFields() method is\n called to calculate all calendar field values."
                }
              ]
            },
            {
              "name": "getAvailableCalendarTypes",
              "overloads": [
                {
                  "signature": "public static Set<String> getAvailableCalendarTypes()",
                  "description": "Returns an unmodifiable Set containing all calendar types\n supported by Calendar in the runtime environment. The available\n calendar types can be used for the Unicode locale extensions.\n The Set returned contains at least \"gregory\". The\n calendar types don't include aliases, such as \"gregorian\" for\n \"gregory\"."
                }
              ]
            },
            {
              "name": "getCalendarType",
              "overloads": [
                {
                  "signature": "public String getCalendarType()",
                  "description": "Returns the calendar type of this Calendar. Calendar types are\n defined by the Unicode Locale Data Markup Language (LDML)\n specification.\n\n The default implementation of this method returns the class name of\n this Calendar instance. Any subclasses that implement\n LDML-defined calendar systems should override this method to return\n appropriate calendar types."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this Calendar to the specified\n Object.  The result is true if and only if\n the argument is a Calendar object of the same calendar\n system that represents the same time value (millisecond offset from the\n Epoch) under the same\n Calendar parameters as this object.\n\n The Calendar parameters are the values represented\n by the isLenient, getFirstDayOfWeek,\n getMinimalDaysInFirstWeek and getTimeZone\n methods. If there is any difference in those parameters\n between the two Calendars, this method returns\n false.\n\n Use the compareTo method to\n compare only the time values."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this calendar."
                }
              ]
            },
            {
              "name": "before",
              "overloads": [
                {
                  "signature": "public boolean before(Object when)",
                  "description": "Returns whether this Calendar represents a time\n before the time represented by the specified\n Object. This method is equivalent to:\n \n         compareTo(when) < 0\n \n if and only if when is a Calendar\n instance. Otherwise, the method returns false."
                }
              ]
            },
            {
              "name": "after",
              "overloads": [
                {
                  "signature": "public boolean after(Object when)",
                  "description": "Returns whether this Calendar represents a time\n after the time represented by the specified\n Object. This method is equivalent to:\n \n         compareTo(when) > 0\n \n if and only if when is a Calendar\n instance. Otherwise, the method returns false."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Calendar anotherCalendar)",
                  "description": "Compares the time values (millisecond offsets from the Epoch) represented by two\n Calendar objects."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public abstract void add(int field, int amount)",
                  "description": "Adds or subtracts the specified amount of time to the given calendar field,\n based on the calendar's rules. For example, to subtract 5 days from\n the current time of the calendar, you can achieve it by calling:\n add(Calendar.DAY_OF_MONTH, -5)."
                }
              ]
            },
            {
              "name": "roll",
              "overloads": [
                {
                  "signature": "public abstract void roll(int field, boolean up)",
                  "description": "Adds or subtracts (up/down) a single unit of time on the given time\n field without changing larger fields. For example, to roll the current\n date up by one day, you can achieve it by calling:\n roll(Calendar.DATE, true).\n When rolling on the year or Calendar.YEAR field, it will roll the year\n value in the range between 1 and the value returned by calling\n getMaximum(Calendar.YEAR).\n When rolling on the month or Calendar.MONTH field, other fields like\n date might conflict and, need to be changed. For instance,\n rolling the month on the date 01/31/96 will result in 02/29/96.\n When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will\n roll the hour value in the range between 0 and 23, which is zero-based."
                },
                {
                  "signature": "public void roll(int field, int amount)",
                  "description": "Adds the specified (signed) amount to the specified calendar field\n without changing larger fields.  A negative amount means to roll\n down.\n\n NOTE:  This default implementation on Calendar just repeatedly calls the\n version of roll() that rolls by one unit.  This may not\n always do the right thing.  For example, if the DAY_OF_MONTH field is 31,\n rolling through February will leave it set to 28.  The GregorianCalendar\n version of this function takes care of this problem.  Other subclasses\n should also provide overrides of this function that do the right thing."
                }
              ]
            },
            {
              "name": "setTimeZone",
              "overloads": [
                {
                  "signature": "public void setTimeZone(TimeZone value)",
                  "description": "Sets the time zone with the given time zone value."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone getTimeZone()",
                  "description": "Gets the time zone."
                }
              ]
            },
            {
              "name": "setLenient",
              "overloads": [
                {
                  "signature": "public void setLenient(boolean lenient)",
                  "description": "Specifies whether or not date/time interpretation is to be lenient.  With\n lenient interpretation, a date such as \"February 942, 1996\" will be\n treated as being equivalent to the 941st day after February 1, 1996.\n With strict (non-lenient) interpretation, such dates will cause an exception to be\n thrown. The default is lenient."
                }
              ]
            },
            {
              "name": "isLenient",
              "overloads": [
                {
                  "signature": "public boolean isLenient()",
                  "description": "Tells whether date/time interpretation is to be lenient."
                }
              ]
            },
            {
              "name": "setFirstDayOfWeek",
              "overloads": [
                {
                  "signature": "public void setFirstDayOfWeek(int value)",
                  "description": "Sets what the first day of the week is; e.g., SUNDAY in the U.S.,\n MONDAY in France."
                }
              ]
            },
            {
              "name": "getFirstDayOfWeek",
              "overloads": [
                {
                  "signature": "public int getFirstDayOfWeek()",
                  "description": "Gets what the first day of the week is; e.g., SUNDAY in the U.S.,\n MONDAY in France."
                }
              ]
            },
            {
              "name": "setMinimalDaysInFirstWeek",
              "overloads": [
                {
                  "signature": "public void setMinimalDaysInFirstWeek(int value)",
                  "description": "Sets what the minimal days required in the first week of the year are;\n For example, if the first week is defined as one that contains the first\n day of the first month of a year, call this method with value 1. If it\n must be a full week, use value 7."
                }
              ]
            },
            {
              "name": "getMinimalDaysInFirstWeek",
              "overloads": [
                {
                  "signature": "public int getMinimalDaysInFirstWeek()",
                  "description": "Gets what the minimal days required in the first week of the year are;\n e.g., if the first week is defined as one that contains the first day\n of the first month of a year, this method returns 1. If\n the minimal days required must be a full week, this method\n returns 7."
                }
              ]
            },
            {
              "name": "isWeekDateSupported",
              "overloads": [
                {
                  "signature": "public boolean isWeekDateSupported()",
                  "description": "Returns whether this Calendar supports week dates.\n\n The default implementation of this method returns false."
                }
              ]
            },
            {
              "name": "getWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeekYear()",
                  "description": "Returns the week year represented by this Calendar. The\n week year is in sync with the week cycle. The first day of the first week is the first\n day of the week year.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "setWeekDate",
              "overloads": [
                {
                  "signature": "public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)",
                  "description": "Sets the date of this Calendar with the given date\n specifiers - week year, week of year, and day of week.\n\n Unlike the set method, all of the calendar fields\n and time values are calculated upon return.\n\n If weekOfYear is out of the valid week-of-year range\n in weekYear, the weekYear and \n weekOfYear values are adjusted in lenient mode, or an \n IllegalArgumentException is thrown in non-lenient mode.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getWeeksInWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeeksInWeekYear()",
                  "description": "Returns the number of weeks in the week year represented by this\n Calendar.\n\n The default implementation of this method throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getMinimum",
              "overloads": [
                {
                  "signature": "public abstract int getMinimum(int field)",
                  "description": "Returns the minimum value for the given calendar field of this\n Calendar instance. The minimum value is defined as\n the smallest value returned by the get method\n for any possible time value.  The minimum value depends on\n calendar system specific parameters of the instance."
                }
              ]
            },
            {
              "name": "getMaximum",
              "overloads": [
                {
                  "signature": "public abstract int getMaximum(int field)",
                  "description": "Returns the maximum value for the given calendar field of this\n Calendar instance. The maximum value is defined as\n the largest value returned by the get method\n for any possible time value. The maximum value depends on\n calendar system specific parameters of the instance."
                }
              ]
            },
            {
              "name": "getGreatestMinimum",
              "overloads": [
                {
                  "signature": "public abstract int getGreatestMinimum(int field)",
                  "description": "Returns the highest minimum value for the given calendar field\n of this Calendar instance. The highest minimum\n value is defined as the largest value returned by getActualMinimum(int) for any possible time value. The\n greatest minimum value depends on calendar system specific\n parameters of the instance."
                }
              ]
            },
            {
              "name": "getLeastMaximum",
              "overloads": [
                {
                  "signature": "public abstract int getLeastMaximum(int field)",
                  "description": "Returns the lowest maximum value for the given calendar field\n of this Calendar instance. The lowest maximum\n value is defined as the smallest value returned by getActualMaximum(int) for any possible time value. The least\n maximum value depends on calendar system specific parameters of\n the instance. For example, a Calendar for the\n Gregorian calendar system returns 28 for the\n DAY_OF_MONTH field, because the 28th is the last\n day of the shortest month of this calendar, February in a\n common year."
                }
              ]
            },
            {
              "name": "getActualMinimum",
              "overloads": [
                {
                  "signature": "public int getActualMinimum(int field)",
                  "description": "Returns the minimum value that the specified calendar field\n could have, given the time value of this Calendar.\n\n The default implementation of this method uses an iterative\n algorithm to determine the actual minimum value for the\n calendar field. Subclasses should, if possible, override this\n with a more efficient implementation - in many cases, they can\n simply return getMinimum()."
                }
              ]
            },
            {
              "name": "getActualMaximum",
              "overloads": [
                {
                  "signature": "public int getActualMaximum(int field)",
                  "description": "Returns the maximum value that the specified calendar field\n could have, given the time value of this\n Calendar. For example, the actual maximum value of\n the MONTH field is 12 in some years, and 13 in\n other years in the Hebrew calendar system.\n\n The default implementation of this method uses an iterative\n algorithm to determine the actual maximum value for the\n calendar field. Subclasses should, if possible, override this\n with a more efficient implementation."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates and returns a copy of this object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string representation of this calendar. This method\n is intended to be used only for debugging purposes, and the\n format of the returned string may vary between implementations.\n The returned string may be empty but may not be null."
                }
              ]
            },
            {
              "name": "toInstant",
              "overloads": [
                {
                  "signature": "public final Instant toInstant()",
                  "description": "Converts this object to an Instant.\n \n The conversion creates an Instant that represents the\n same point on the time-line as this Calendar."
                }
              ]
            }
          ]
        },
        {
          "name": "Calendar.Builder",
          "methods": [
            {
              "name": "Builder",
              "overloads": [
                {
                  "signature": "public Builder()",
                  "description": "Constructs a Calendar.Builder."
                }
              ]
            },
            {
              "name": "setInstant",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setInstant(long instant)",
                  "description": "Sets the instant parameter to the given instant value that is\n a millisecond offset from the\n Epoch."
                },
                {
                  "signature": "public Calendar.Builder setInstant(Date instant)",
                  "description": "Sets the instant parameter to the instant value given by a\n Date. This method is equivalent to a call to\n setInstant(instant.getTime())."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public Calendar.Builder set(int field, int value)",
                  "description": "Sets the field parameter to the given value.\n field is an index to the Calendar.fields, such as\n DAY_OF_MONTH. Field value validation is\n not performed in this method. Any out of range values are either\n normalized in lenient mode or detected as an invalid value in\n non-lenient mode when building a Calendar."
                }
              ]
            },
            {
              "name": "setFields",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setFields(int... fieldValuePairs)",
                  "description": "Sets field parameters to their values given by\n fieldValuePairs that are pairs of a field and its value.\n For example,\n    setFields(Calendar.YEAR, 2013,\n             Calendar.MONTH, Calendar.DECEMBER,\n             Calendar.DAY_OF_MONTH, 23);\n is equivalent to the sequence of the following\n set calls:\n    set(Calendar.YEAR, 2013)\n   .set(Calendar.MONTH, Calendar.DECEMBER)\n   .set(Calendar.DAY_OF_MONTH, 23);"
                }
              ]
            },
            {
              "name": "setDate",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setDate(int year, int month, int dayOfMonth)",
                  "description": "Sets the date field parameters to the values given by year,\n month, and dayOfMonth. This method is equivalent to\n a call to:\n    setFields(Calendar.YEAR, year,\n             Calendar.MONTH, month,\n             Calendar.DAY_OF_MONTH, dayOfMonth);"
                }
              ]
            },
            {
              "name": "setTimeOfDay",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setTimeOfDay(int hourOfDay, int minute, int second)",
                  "description": "Sets the time of day field parameters to the values given by\n hourOfDay, minute, and second. This method is\n equivalent to a call to:\n    setTimeOfDay(hourOfDay, minute, second, 0);"
                },
                {
                  "signature": "public Calendar.Builder setTimeOfDay(int hourOfDay, int minute, int second, int millis)",
                  "description": "Sets the time of day field parameters to the values given by\n hourOfDay, minute, second, and\n millis. This method is equivalent to a call to:\n    setFields(Calendar.HOUR_OF_DAY, hourOfDay,\n             Calendar.MINUTE, minute,\n             Calendar.SECOND, second,\n             Calendar.MILLISECOND, millis);"
                }
              ]
            },
            {
              "name": "setWeekDate",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)",
                  "description": "Sets the week-based date parameters to the values with the given\n date specifiers - week year, week of year, and day of week.\n\n If the specified calendar doesn't support week dates, the\n build method will throw an IllegalArgumentException."
                }
              ]
            },
            {
              "name": "setTimeZone",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setTimeZone(TimeZone zone)",
                  "description": "Sets the time zone parameter to the given zone. If no time\n zone parameter is given to this Calendar.Builder, the\n default\n TimeZone will be used in the build\n method."
                }
              ]
            },
            {
              "name": "setLenient",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setLenient(boolean lenient)",
                  "description": "Sets the lenient mode parameter to the value given by lenient.\n If no lenient parameter is given to this Calendar.Builder,\n lenient mode will be used in the build method."
                }
              ]
            },
            {
              "name": "setCalendarType",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setCalendarType(String type)",
                  "description": "Sets the calendar type parameter to the given type. The\n calendar type given by this method has precedence over any explicit\n or implicit calendar type given by the\n locale.\n\n In addition to the available calendar types returned by the\n Calendar.getAvailableCalendarTypes\n method, \"gregorian\" and \"iso8601\" as aliases of\n \"gregory\" can be used with this method."
                }
              ]
            },
            {
              "name": "setLocale",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setLocale(Locale locale)",
                  "description": "Sets the locale parameter to the given locale. If no locale\n is given to this Calendar.Builder, the default Locale\n for Locale.Category.FORMAT will be used.\n\n If no calendar type is explicitly given by a call to the\n setCalendarType method,\n the Locale value is used to determine what type of\n Calendar to be built.\n\n If no week definition parameters are explicitly given by a call to\n the setWeekDefinition method, the\n Locale's default values are used."
                }
              ]
            },
            {
              "name": "setWeekDefinition",
              "overloads": [
                {
                  "signature": "public Calendar.Builder setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek)",
                  "description": "Sets the week definition parameters to the values given by\n firstDayOfWeek and minimalDaysInFirstWeek that are\n used to determine the first\n week of a year. The parameters given by this method have\n precedence over the default values given by the\n locale."
                }
              ]
            },
            {
              "name": "build",
              "overloads": [
                {
                  "signature": "public Calendar build()",
                  "description": "Returns a Calendar built from the parameters set by the\n setter methods. The calendar type given by the setCalendarType method or the locale is\n used to determine what Calendar to be created. If no explicit\n calendar type is given, the locale's default calendar is created.\n\n If the calendar type is \"iso8601\", the\n Gregorian change date\n of a GregorianCalendar is set to Date(Long.MIN_VALUE)\n to be the proleptic Gregorian calendar. Its week definition\n parameters are also set to be compatible\n with the ISO 8601 standard. Note that the\n getCalendarType method of\n a GregorianCalendar created with \"iso8601\" returns\n \"gregory\".\n\n The default values are used for locale and time zone if these\n parameters haven't been given explicitly.\n \n If the locale contains the time zone with \"tz\"\n Unicode extension,\n and time zone hasn't been given explicitly, time zone in the locale\n is used.\n\n Any out of range field values are either normalized in lenient\n mode or detected as an invalid value in non-lenient mode."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Locale.FilteringMode[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Locale.FilteringMode valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Locale.IsoCountryCode[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Locale.IsoCountryCode valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Formatter.BigDecimalLayoutForm[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Formatter.BigDecimalLayoutForm valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Locale.Category[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Locale.Category valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Collection<E>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this collection.  If this collection\n contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this collection contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this collection contains the specified element.\n More formally, returns true if and only if this collection\n contains at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this collection.  There are no\n guarantees concerning the order in which the elements are returned\n (unless this collection is an instance of some class that provides a\n guarantee)."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this collection.\n If this collection makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements in\n the same order. The returned array's runtime component type is Object.\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this collection.  (In other words, this method must\n allocate a new array even if this collection is backed by an array).\n The caller is thus free to modify the returned array."
                },
                {
                  "signature": "<T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this collection;\n the runtime type of the returned array is that of the specified array.\n If the collection fits in the specified array, it is returned therein.\n Otherwise, a new array is allocated with the runtime type of the\n specified array and the size of this collection.\n\n If this collection fits in the specified array with room to spare\n (i.e., the array has more elements than this collection), the element\n in the array immediately following the end of the collection is set to\n null.  (This is useful in determining the length of this\n collection only if the caller knows that this collection does\n not contain any null elements.)\n\n If this collection makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements in\n the same order."
                },
                {
                  "signature": "default <T> T[] toArray(IntFunction<T[]> generator)",
                  "description": "Returns an array containing all of the elements in this collection,\n using the provided generator function to allocate the returned array.\n\n If this collection makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements in\n the same order."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Ensures that this collection contains the specified element (optional\n operation).  Returns true if this collection changed as a\n result of the call.  (Returns false if this collection does\n not permit duplicates and already contains the specified element.)\n\n Collections that support this operation may place limitations on what\n elements may be added to this collection.  In particular, some\n collections will refuse to add null elements, and others will\n impose restrictions on the type of elements that may be added.\n Collection classes should clearly specify in their documentation any\n restrictions on what elements may be added.\n\n If a collection refuses to add a particular element for any reason\n other than that it already contains the element, it must throw\n an exception (rather than returning false).  This preserves\n the invariant that a collection always contains the specified element\n after this call returns."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes a single instance of the specified element from this\n collection, if it is present (optional operation).  More formally,\n removes an element e such that\n Objects.equals(o, e), if\n this collection contains one or more such elements.  Returns\n true if this collection contained the specified element (or\n equivalently, if this collection changed as a result of the call)."
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this collection contains all of the elements\n in the specified collection."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this collection\n (optional operation).  The behavior of this operation is undefined if\n the specified collection is modified while the operation is in progress.\n (This implies that the behavior of this call is undefined if the\n specified collection is this collection, and this collection is\n nonempty.)"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll(Collection<?> c)",
                  "description": "Removes all of this collection's elements that are also contained in the\n specified collection (optional operation).  After this call returns,\n this collection will contain no elements in common with the specified\n collection."
                }
              ]
            },
            {
              "name": "removeIf",
              "overloads": [
                {
                  "signature": "default boolean removeIf(Predicate<? super E> filter)",
                  "description": "Removes all of the elements of this collection that satisfy the given\n predicate.  Errors or runtime exceptions thrown during iteration or by\n the predicate are relayed to the caller."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this collection that are contained in the\n specified collection (optional operation).  In other words, removes from\n this collection all of its elements that are not contained in the\n specified collection."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the elements from this collection (optional operation).\n The collection will be empty after this method returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this collection for equality. \n\n While the Collection interface adds no stipulations to the\n general contract for the Object.equals, programmers who\n implement the Collection interface \"directly\" (in other words,\n create a class that is a Collection but is not a Set\n or a List) must exercise care if they choose to override the\n Object.equals.  It is not necessary to do so, and the simplest\n course of action is to rely on Object's implementation, but\n the implementor may wish to implement a \"value comparison\" in place of\n the default \"reference comparison.\"  (The List and\n Set interfaces mandate such value comparisons.)\n\n The general contract for the Object.equals method states that\n equals must be symmetric (in other words, a.equals(b) if and\n only if b.equals(a)).  The contracts for List.equals\n and Set.equals state that lists are only equal to other lists,\n and sets to other sets.  Thus, a custom equals method for a\n collection class that implements neither the List nor\n Set interface must return false when this collection\n is compared to any list or set.  (By the same logic, it is not possible\n to write a class that correctly implements both the Set and\n List interfaces.)"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this collection.  While the\n Collection interface adds no stipulations to the general\n contract for the Object.hashCode method, programmers should\n take note that any class that overrides the Object.equals\n method must also override the Object.hashCode method in order\n to satisfy the general contract for the Object.hashCode method.\n In particular, c1.equals(c2) implies that\n c1.hashCode()==c2.hashCode()."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this collection.\n\n Implementations should document characteristic values reported by the\n spliterator.  Such characteristic values are not required to be reported\n if the spliterator reports Spliterator.SIZED and this collection\n contains no elements.\n\n The default implementation should be overridden by subclasses that\n can return a more efficient spliterator.  In order to\n preserve expected laziness behavior for the stream() and\n parallelStream() methods, spliterators should either have the\n characteristic of IMMUTABLE or CONCURRENT, or be\n late-binding.\n If none of these is practical, the overriding class should describe the\n spliterator's documented policy of binding and structural interference,\n and should override the stream() and parallelStream()\n methods to create streams using a Supplier of the spliterator,\n as in:\n \n     Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)\n \n These requirements ensure that streams produced by the\n stream() and parallelStream() methods will reflect the\n contents of the collection as of initiation of the terminal stream\n operation."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "default Stream<E> stream()",
                  "description": "Returns a sequential Stream with this collection as its source.\n\n This method should be overridden when the spliterator()\n method cannot return a spliterator that is IMMUTABLE,\n CONCURRENT, or late-binding. (See spliterator()\n for details.)"
                }
              ]
            },
            {
              "name": "parallelStream",
              "overloads": [
                {
                  "signature": "default Stream<E> parallelStream()",
                  "description": "Returns a possibly parallel Stream with this collection as its\n source.  It is allowable for this method to return a sequential stream.\n\n This method should be overridden when the spliterator()\n method cannot return a spliterator that is IMMUTABLE,\n CONCURRENT, or late-binding. (See spliterator()\n for details.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Collections",
          "methods": [
            {
              "name": "sort",
              "overloads": [
                {
                  "signature": "public static <T extends Comparable<? super T>> void sort(List<T> list)",
                  "description": "Sorts the specified list into ascending order, according to the\n natural ordering of its elements.\n All elements in the list must implement the Comparable\n interface.  Furthermore, all elements in the list must be\n mutually comparable (that is, e1.compareTo(e2)\n must not throw a ClassCastException for any elements\n e1 and e2 in the list).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n The specified list must be modifiable, but need not be resizable."
                },
                {
                  "signature": "public static <T> void sort(List<T> list, Comparator<? super T> c)",
                  "description": "Sorts the specified list according to the order induced by the\n specified comparator.  All elements in the list must be mutually\n comparable using the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the list).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n The specified list must be modifiable, but need not be resizable."
                }
              ]
            },
            {
              "name": "binarySearch",
              "overloads": [
                {
                  "signature": "public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)",
                  "description": "Searches the specified list for the specified object using the binary\n search algorithm.  The list must be sorted into ascending order\n according to the natural ordering of its\n elements (as by the sort(List) method) prior to making this\n call.  If it is not sorted, the results are undefined.  If the list\n contains multiple elements equal to the specified object, there is no\n guarantee which one will be found.\n\n This method runs in log(n) time for a \"random access\" list (which\n provides near-constant-time positional access).  If the specified list\n does not implement the RandomAccess interface and is large,\n this method will do an iterator-based binary search that performs\n O(n) link traversals and O(log n) element comparisons."
                },
                {
                  "signature": "public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)",
                  "description": "Searches the specified list for the specified object using the binary\n search algorithm.  The list must be sorted into ascending order\n according to the specified comparator (as by the\n sort(List, Comparator)\n method), prior to making this call.  If it is\n not sorted, the results are undefined.  If the list contains multiple\n elements equal to the specified object, there is no guarantee which one\n will be found.\n\n This method runs in log(n) time for a \"random access\" list (which\n provides near-constant-time positional access).  If the specified list\n does not implement the RandomAccess interface and is large,\n this method will do an iterator-based binary search that performs\n O(n) link traversals and O(log n) element comparisons."
                }
              ]
            },
            {
              "name": "reverse",
              "overloads": [
                {
                  "signature": "public static void reverse(List<?> list)",
                  "description": "Reverses the order of the elements in the specified list.\n\n This method runs in linear time."
                }
              ]
            },
            {
              "name": "shuffle",
              "overloads": [
                {
                  "signature": "public static void shuffle(List<?> list)",
                  "description": "Randomly permutes the specified list using a default source of\n randomness.  All permutations occur with approximately equal\n likelihood.\n\n The hedge \"approximately\" is used in the foregoing description because\n default source of randomness is only approximately an unbiased source\n of independently chosen bits. If it were a perfect source of randomly\n chosen bits, then the algorithm would choose permutations with perfect\n uniformity.\n\n This implementation traverses the list backwards, from the last\n element up to the second, repeatedly swapping a randomly selected element\n into the \"current position\".  Elements are randomly selected from the\n portion of the list that runs from the first element to the current\n position, inclusive.\n\n This method runs in linear time.  If the specified list does not\n implement the RandomAccess interface and is large, this\n implementation dumps the specified list into an array before shuffling\n it, and dumps the shuffled array back into the list.  This avoids the\n quadratic behavior that would result from shuffling a \"sequential\n access\" list in place."
                },
                {
                  "signature": "public static void shuffle(List<?> list, Random rnd)",
                  "description": "Randomly permute the specified list using the specified source of\n randomness.  All permutations occur with equal likelihood\n assuming that the source of randomness is fair.\n\n This implementation traverses the list backwards, from the last element\n up to the second, repeatedly swapping a randomly selected element into\n the \"current position\".  Elements are randomly selected from the\n portion of the list that runs from the first element to the current\n position, inclusive.\n\n This method runs in linear time.  If the specified list does not\n implement the RandomAccess interface and is large, this\n implementation dumps the specified list into an array before shuffling\n it, and dumps the shuffled array back into the list.  This avoids the\n quadratic behavior that would result from shuffling a \"sequential\n access\" list in place."
                }
              ]
            },
            {
              "name": "swap",
              "overloads": [
                {
                  "signature": "public static void swap(List<?> list, int i, int j)",
                  "description": "Swaps the elements at the specified positions in the specified list.\n (If the specified positions are equal, invoking this method leaves\n the list unchanged.)"
                }
              ]
            },
            {
              "name": "fill",
              "overloads": [
                {
                  "signature": "public static <T> void fill(List<? super T> list, T obj)",
                  "description": "Replaces all of the elements of the specified list with the specified\n element. \n\n This method runs in linear time."
                }
              ]
            },
            {
              "name": "copy",
              "overloads": [
                {
                  "signature": "public static <T> void copy(List<? super T> dest, List<? extends T> src)",
                  "description": "Copies all of the elements from one list into another.  After the\n operation, the index of each copied element in the destination list\n will be identical to its index in the source list.  The destination\n list's size must be greater than or equal to the source list's size.\n If it is greater, the remaining elements in the destination list are\n unaffected. \n\n This method runs in linear time."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)",
                  "description": "Returns the minimum element of the given collection, according to the\n natural ordering of its elements.  All elements in the\n collection must implement the Comparable interface.\n Furthermore, all elements in the collection must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the collection).\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection."
                },
                {
                  "signature": "public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp)",
                  "description": "Returns the minimum element of the given collection, according to the\n order induced by the specified comparator.  All elements in the\n collection must be mutually comparable by the specified\n comparator (that is, comp.compare(e1, e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the collection).\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)",
                  "description": "Returns the maximum element of the given collection, according to the\n natural ordering of its elements.  All elements in the\n collection must implement the Comparable interface.\n Furthermore, all elements in the collection must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the collection).\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection."
                },
                {
                  "signature": "public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp)",
                  "description": "Returns the maximum element of the given collection, according to the\n order induced by the specified comparator.  All elements in the\n collection must be mutually comparable by the specified\n comparator (that is, comp.compare(e1, e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the collection).\n\n This method iterates over the entire collection, hence it requires\n time proportional to the size of the collection."
                }
              ]
            },
            {
              "name": "rotate",
              "overloads": [
                {
                  "signature": "public static void rotate(List<?> list, int distance)",
                  "description": "Rotates the elements in the specified list by the specified distance.\n After calling this method, the element at index i will be\n the element previously at index (i - distance) mod\n list.size(), for all values of i between 0\n and list.size()-1, inclusive.  (This method has no effect on\n the size of the list.)\n\n For example, suppose list comprises [t, a, n, k, s].\n After invoking Collections.rotate(list, 1) (or\n Collections.rotate(list, -4)), list will comprise\n [s, t, a, n, k].\n\n Note that this method can usefully be applied to sublists to\n move one or more elements within a list while preserving the\n order of the remaining elements.  For example, the following idiom\n moves the element at index j forward to position\n k (which must be greater than or equal to j):\n      Collections.rotate(list.subList(j, k+1), -1);\n \n To make this concrete, suppose list comprises\n [a, b, c, d, e].  To move the element at index 1\n (b) forward two positions, perform the following invocation:\n      Collections.rotate(l.subList(1, 4), -1);\n \n The resulting list is [a, c, d, b, e].\n\n To move more than one element forward, increase the absolute value\n of the rotation distance.  To move elements backward, use a positive\n shift distance.\n\n If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first\n element into the location it should go, and then repeatedly exchanges\n the displaced element into the location it should go until a displaced\n element is swapped into the first element.  If necessary, the process\n is repeated on the second and successive elements, until the rotation\n is complete.  If the specified list is large and doesn't implement the\n RandomAccess interface, this implementation breaks the\n list into two sublist views around index -distance mod size.\n Then the reverse(List) method is invoked on each sublist view,\n and finally it is invoked on the entire list.  For a more complete\n description of both algorithms, see Section 2.3 of Jon Bentley's\n Programming Pearls (Addison-Wesley, 1986)."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)",
                  "description": "Replaces all occurrences of one specified value in a list with another.\n More formally, replaces with newVal each element e\n in list such that\n (oldVal==null ? e==null : oldVal.equals(e)).\n (This method has no effect on the size of the list.)"
                }
              ]
            },
            {
              "name": "indexOfSubList",
              "overloads": [
                {
                  "signature": "public static int indexOfSubList(List<?> source, List<?> target)",
                  "description": "Returns the starting position of the first occurrence of the specified\n target list within the specified source list, or -1 if there is no\n such occurrence.  More formally, returns the lowest index i\n such that source.subList(i, i+target.size()).equals(target),\n or -1 if there is no such index.  (Returns -1 if\n target.size() > source.size())\n\n This implementation uses the \"brute force\" technique of scanning\n over the source list, looking for a match with the target at each\n location in turn."
                }
              ]
            },
            {
              "name": "lastIndexOfSubList",
              "overloads": [
                {
                  "signature": "public static int lastIndexOfSubList(List<?> source, List<?> target)",
                  "description": "Returns the starting position of the last occurrence of the specified\n target list within the specified source list, or -1 if there is no such\n occurrence.  More formally, returns the highest index i\n such that source.subList(i, i+target.size()).equals(target),\n or -1 if there is no such index.  (Returns -1 if\n target.size() > source.size())\n\n This implementation uses the \"brute force\" technique of iterating\n over the source list, looking for a match with the target at each\n location in turn."
                }
              ]
            },
            {
              "name": "unmodifiableCollection",
              "overloads": [
                {
                  "signature": "public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c)",
                  "description": "Returns an unmodifiable view of the\n specified collection. Query operations on the returned collection \"read through\"\n to the specified collection, and attempts to modify the returned\n collection, whether direct or via its iterator, result in an\n UnsupportedOperationException.\n\n The returned collection does not pass the hashCode and equals\n operations through to the backing collection, but relies on\n Object's equals and hashCode methods.  This\n is necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\n\n The returned collection will be serializable if the specified collection\n is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableSet",
              "overloads": [
                {
                  "signature": "public static <T> Set<T> unmodifiableSet(Set<? extends T> s)",
                  "description": "Returns an unmodifiable view of the\n specified set. Query operations on the returned set \"read through\" to the specified\n set, and attempts to modify the returned set, whether direct or via its\n iterator, result in an UnsupportedOperationException.\n\n The returned set will be serializable if the specified set\n is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableSortedSet",
              "overloads": [
                {
                  "signature": "public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s)",
                  "description": "Returns an unmodifiable view of the\n specified sorted set. Query operations on the returned sorted set \"read\n through\" to the specified sorted set.  Attempts to modify the returned\n sorted set, whether direct, via its iterator, or via its\n subSet, headSet, or tailSet views, result in\n an UnsupportedOperationException.\n\n The returned sorted set will be serializable if the specified sorted set\n is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableNavigableSet",
              "overloads": [
                {
                  "signature": "public static <T> NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s)",
                  "description": "Returns an unmodifiable view of the\n specified navigable set. Query operations on the returned navigable set \"read\n through\" to the specified navigable set.  Attempts to modify the returned\n navigable set, whether direct, via its iterator, or via its\n subSet, headSet, or tailSet views, result in\n an UnsupportedOperationException.\n\n The returned navigable set will be serializable if the specified\n navigable set is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableList",
              "overloads": [
                {
                  "signature": "public static <T> List<T> unmodifiableList(List<? extends T> list)",
                  "description": "Returns an unmodifiable view of the\n specified list. Query operations on the returned list \"read through\" to the\n specified list, and attempts to modify the returned list, whether\n direct or via its iterator, result in an\n UnsupportedOperationException.\n\n The returned list will be serializable if the specified list\n is serializable. Similarly, the returned list will implement\n RandomAccess if the specified list does."
                }
              ]
            },
            {
              "name": "unmodifiableMap",
              "overloads": [
                {
                  "signature": "public static <K, V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> m)",
                  "description": "Returns an unmodifiable view of the\n specified map. Query operations on the returned map \"read through\"\n to the specified map, and attempts to modify the returned\n map, whether direct or via its collection views, result in an\n UnsupportedOperationException.\n\n The returned map will be serializable if the specified map\n is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableSortedMap",
              "overloads": [
                {
                  "signature": "public static <K, V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K,? extends V> m)",
                  "description": "Returns an unmodifiable view of the\n specified sorted map. Query operations on the returned sorted map \"read through\"\n to the specified sorted map.  Attempts to modify the returned\n sorted map, whether direct, via its collection views, or via its\n subMap, headMap, or tailMap views, result in\n an UnsupportedOperationException.\n\n The returned sorted map will be serializable if the specified sorted map\n is serializable."
                }
              ]
            },
            {
              "name": "unmodifiableNavigableMap",
              "overloads": [
                {
                  "signature": "public static <K, V> NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K,? extends V> m)",
                  "description": "Returns an unmodifiable view of the\n specified navigable map. Query operations on the returned navigable map \"read\n through\" to the specified navigable map.  Attempts to modify the returned\n navigable map, whether direct, via its collection views, or via its\n subMap, headMap, or tailMap views, result in\n an UnsupportedOperationException.\n\n The returned navigable map will be serializable if the specified\n navigable map is serializable."
                }
              ]
            },
            {
              "name": "synchronizedCollection",
              "overloads": [
                {
                  "signature": "public static <T> Collection<T> synchronizedCollection(Collection<T> c)",
                  "description": "Returns a synchronized (thread-safe) collection backed by the specified\n collection.  In order to guarantee serial access, it is critical that\n all access to the backing collection is accomplished\n through the returned collection.\n\n It is imperative that the user manually synchronize on the returned\n collection when traversing it via Iterator, Spliterator\n or Stream:\n   Collection c = Collections.synchronizedCollection(myCollection);\n     ...\n  synchronized (c) {\n      Iterator i = c.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n         foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned collection does not pass the hashCode\n and equals operations through to the backing collection, but\n relies on Object's equals and hashCode methods.  This is\n necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\n\n The returned collection will be serializable if the specified collection\n is serializable."
                }
              ]
            },
            {
              "name": "synchronizedSet",
              "overloads": [
                {
                  "signature": "public static <T> Set<T> synchronizedSet(Set<T> s)",
                  "description": "Returns a synchronized (thread-safe) set backed by the specified\n set.  In order to guarantee serial access, it is critical that\n all access to the backing set is accomplished\n through the returned set.\n\n It is imperative that the user manually synchronize on the returned\n collection when traversing it via Iterator, Spliterator\n or Stream:\n   Set s = Collections.synchronizedSet(new HashSet());\n      ...\n  synchronized (s) {\n      Iterator i = s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned set will be serializable if the specified set is\n serializable."
                }
              ]
            },
            {
              "name": "synchronizedSortedSet",
              "overloads": [
                {
                  "signature": "public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)",
                  "description": "Returns a synchronized (thread-safe) sorted set backed by the specified\n sorted set.  In order to guarantee serial access, it is critical that\n all access to the backing sorted set is accomplished\n through the returned sorted set (or its views).\n\n It is imperative that the user manually synchronize on the returned\n sorted set when traversing it or any of its subSet,\n headSet, or tailSet views via Iterator,\n Spliterator or Stream:\n   SortedSet s = Collections.synchronizedSortedSet(new TreeSet());\n      ...\n  synchronized (s) {\n      Iterator i = s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n or:\n   SortedSet s = Collections.synchronizedSortedSet(new TreeSet());\n  SortedSet s2 = s.headSet(foo);\n      ...\n  synchronized (s) {  // Note: s, not s2!!!\n      Iterator i = s2.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned sorted set will be serializable if the specified\n sorted set is serializable."
                }
              ]
            },
            {
              "name": "synchronizedNavigableSet",
              "overloads": [
                {
                  "signature": "public static <T> NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> s)",
                  "description": "Returns a synchronized (thread-safe) navigable set backed by the\n specified navigable set.  In order to guarantee serial access, it is\n critical that all access to the backing navigable set is\n accomplished through the returned navigable set (or its views).\n\n It is imperative that the user manually synchronize on the returned\n navigable set when traversing it, or any of its subSet,\n headSet, or tailSet views, via Iterator,\n Spliterator or Stream:\n   NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());\n      ...\n  synchronized (s) {\n      Iterator i = s.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n or:\n   NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());\n  NavigableSet s2 = s.headSet(foo, true);\n      ...\n  synchronized (s) {  // Note: s, not s2!!!\n      Iterator i = s2.iterator(); // Must be in the synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned navigable set will be serializable if the specified\n navigable set is serializable."
                }
              ]
            },
            {
              "name": "synchronizedList",
              "overloads": [
                {
                  "signature": "public static <T> List<T> synchronizedList(List<T> list)",
                  "description": "Returns a synchronized (thread-safe) list backed by the specified\n list.  In order to guarantee serial access, it is critical that\n all access to the backing list is accomplished\n through the returned list.\n\n It is imperative that the user manually synchronize on the returned\n list when traversing it via Iterator, Spliterator\n or Stream:\n   List list = Collections.synchronizedList(new ArrayList());\n      ...\n  synchronized (list) {\n      Iterator i = list.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned list will be serializable if the specified list is\n serializable."
                }
              ]
            },
            {
              "name": "synchronizedMap",
              "overloads": [
                {
                  "signature": "public static <K, V> Map<K,V> synchronizedMap(Map<K,V> m)",
                  "description": "Returns a synchronized (thread-safe) map backed by the specified\n map.  In order to guarantee serial access, it is critical that\n all access to the backing map is accomplished\n through the returned map.\n\n It is imperative that the user manually synchronize on the returned\n map when traversing any of its collection views via Iterator,\n Spliterator or Stream:\n   Map m = Collections.synchronizedMap(new HashMap());\n      ...\n  Set s = m.keySet();  // Needn't be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i = s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned map will be serializable if the specified map is\n serializable."
                }
              ]
            },
            {
              "name": "synchronizedSortedMap",
              "overloads": [
                {
                  "signature": "public static <K, V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)",
                  "description": "Returns a synchronized (thread-safe) sorted map backed by the specified\n sorted map.  In order to guarantee serial access, it is critical that\n all access to the backing sorted map is accomplished\n through the returned sorted map (or its views).\n\n It is imperative that the user manually synchronize on the returned\n sorted map when traversing any of its collection views, or the\n collections views of any of its subMap, headMap or\n tailMap views, via Iterator, Spliterator or\n Stream:\n   SortedMap m = Collections.synchronizedSortedMap(new TreeMap());\n      ...\n  Set s = m.keySet();  // Needn't be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i = s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n or:\n   SortedMap m = Collections.synchronizedSortedMap(new TreeMap());\n  SortedMap m2 = m.subMap(foo, bar);\n      ...\n  Set s2 = m2.keySet();  // Needn't be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not m2 or s2!\n      Iterator i = s2.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned sorted map will be serializable if the specified\n sorted map is serializable."
                }
              ]
            },
            {
              "name": "synchronizedNavigableMap",
              "overloads": [
                {
                  "signature": "public static <K, V> NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> m)",
                  "description": "Returns a synchronized (thread-safe) navigable map backed by the\n specified navigable map.  In order to guarantee serial access, it is\n critical that all access to the backing navigable map is\n accomplished through the returned navigable map (or its views).\n\n It is imperative that the user manually synchronize on the returned\n navigable map when traversing any of its collection views, or the\n collections views of any of its subMap, headMap or\n tailMap views, via Iterator, Spliterator or\n Stream:\n   NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());\n      ...\n  Set s = m.keySet();  // Needn't be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not s!\n      Iterator i = s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n or:\n   NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());\n  NavigableMap m2 = m.subMap(foo, true, bar, false);\n      ...\n  Set s2 = m2.keySet();  // Needn't be in synchronized block\n      ...\n  synchronized (m) {  // Synchronizing on m, not m2 or s2!\n      Iterator i = s.iterator(); // Must be in synchronized block\n      while (i.hasNext())\n          foo(i.next());\n  }\n \n Failure to follow this advice may result in non-deterministic behavior.\n\n The returned navigable map will be serializable if the specified\n navigable map is serializable."
                }
              ]
            },
            {
              "name": "checkedCollection",
              "overloads": [
                {
                  "signature": "public static <E> Collection<E> checkedCollection(Collection<E> c, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified collection.\n Any attempt to insert an element of the wrong type will result in an\n immediate ClassCastException.  Assuming a collection\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the collection takes place through the view, it is\n guaranteed that the collection cannot contain an incorrectly\n typed element.\n\n The generics mechanism in the language provides compile-time\n (static) type checking, but it is possible to defeat this mechanism\n with unchecked casts.  Usually this is not a problem, as the compiler\n issues warnings on all such unchecked operations.  There are, however,\n times when static type checking alone is not sufficient.  For example,\n suppose a collection is passed to a third-party library and it is\n imperative that the library code not corrupt the collection by\n inserting an element of the wrong type.\n\n Another use of dynamically typesafe views is debugging.  Suppose a\n program fails with a ClassCastException, indicating that an\n incorrectly typed element was put into a parameterized collection.\n Unfortunately, the exception can occur at any time after the erroneous\n element is inserted, so it typically provides little or no information\n as to the real source of the problem.  If the problem is reproducible,\n one can quickly determine its source by temporarily modifying the\n program to wrap the collection with a dynamically typesafe view.\n For example, this declaration:\n   \n     Collection<String> c = new HashSet<>();\n \n may be replaced temporarily by this one:\n   \n     Collection<String> c = Collections.checkedCollection(\n         new HashSet<>(), String.class);\n \n Running the program again will cause it to fail at the point where\n an incorrectly typed element is inserted into the collection, clearly\n identifying the source of the problem.  Once the problem is fixed, the\n modified declaration may be reverted back to the original.\n\n The returned collection does not pass the hashCode and equals\n operations through to the backing collection, but relies on\n Object's equals and hashCode methods.  This\n is necessary to preserve the contracts of these operations in the case\n that the backing collection is a set or a list.\n\n The returned collection will be serializable if the specified\n collection is serializable.\n\n Since null is considered to be a value of any reference\n type, the returned collection permits insertion of null elements\n whenever the backing collection does."
                }
              ]
            },
            {
              "name": "checkedQueue",
              "overloads": [
                {
                  "signature": "public static <E> Queue<E> checkedQueue(Queue<E> queue, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified queue.\n Any attempt to insert an element of the wrong type will result in\n an immediate ClassCastException.  Assuming a queue contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the queue\n takes place through the view, it is guaranteed that the\n queue cannot contain an incorrectly typed element.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned queue will be serializable if the specified queue\n is serializable.\n\n Since null is considered to be a value of any reference\n type, the returned queue permits insertion of null elements\n whenever the backing queue does."
                }
              ]
            },
            {
              "name": "checkedSet",
              "overloads": [
                {
                  "signature": "public static <E> Set<E> checkedSet(Set<E> s, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified set.\n Any attempt to insert an element of the wrong type will result in\n an immediate ClassCastException.  Assuming a set contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the set\n takes place through the view, it is guaranteed that the\n set cannot contain an incorrectly typed element.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned set will be serializable if the specified set is\n serializable.\n\n Since null is considered to be a value of any reference\n type, the returned set permits insertion of null elements whenever\n the backing set does."
                }
              ]
            },
            {
              "name": "checkedSortedSet",
              "overloads": [
                {
                  "signature": "public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified sorted set.\n Any attempt to insert an element of the wrong type will result in an\n immediate ClassCastException.  Assuming a sorted set\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the sorted set takes place through the view, it is\n guaranteed that the sorted set cannot contain an incorrectly\n typed element.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned sorted set will be serializable if the specified sorted\n set is serializable.\n\n Since null is considered to be a value of any reference\n type, the returned sorted set permits insertion of null elements\n whenever the backing sorted set does."
                }
              ]
            },
            {
              "name": "checkedNavigableSet",
              "overloads": [
                {
                  "signature": "public static <E> NavigableSet<E> checkedNavigableSet(NavigableSet<E> s, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified navigable set.\n Any attempt to insert an element of the wrong type will result in an\n immediate ClassCastException.  Assuming a navigable set\n contains no incorrectly typed elements prior to the time a\n dynamically typesafe view is generated, and that all subsequent\n access to the navigable set takes place through the view, it is\n guaranteed that the navigable set cannot contain an incorrectly\n typed element.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned navigable set will be serializable if the specified\n navigable set is serializable.\n\n Since null is considered to be a value of any reference\n type, the returned navigable set permits insertion of null elements\n whenever the backing sorted set does."
                }
              ]
            },
            {
              "name": "checkedList",
              "overloads": [
                {
                  "signature": "public static <E> List<E> checkedList(List<E> list, Class<E> type)",
                  "description": "Returns a dynamically typesafe view of the specified list.\n Any attempt to insert an element of the wrong type will result in\n an immediate ClassCastException.  Assuming a list contains\n no incorrectly typed elements prior to the time a dynamically typesafe\n view is generated, and that all subsequent access to the list\n takes place through the view, it is guaranteed that the\n list cannot contain an incorrectly typed element.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned list will be serializable if the specified list\n is serializable.\n\n Since null is considered to be a value of any reference\n type, the returned list permits insertion of null elements whenever\n the backing list does."
                }
              ]
            },
            {
              "name": "checkedMap",
              "overloads": [
                {
                  "signature": "public static <K, V> Map<K,V> checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType)",
                  "description": "Returns a dynamically typesafe view of the specified map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate ClassCastException.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate ClassCastException,\n whether the modification is attempted directly through the map\n itself, or through a Map.Entry instance obtained from the\n map's entry set view.\n\n Assuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is guaranteed that the\n map cannot contain an incorrectly typed key or value.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned map will be serializable if the specified map is\n serializable.\n\n Since null is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does."
                }
              ]
            },
            {
              "name": "checkedSortedMap",
              "overloads": [
                {
                  "signature": "public static <K, V> SortedMap<K,V> checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType)",
                  "description": "Returns a dynamically typesafe view of the specified sorted map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate ClassCastException.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate ClassCastException,\n whether the modification is attempted directly through the map\n itself, or through a Map.Entry instance obtained from the\n map's entry set view.\n\n Assuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is guaranteed that the\n map cannot contain an incorrectly typed key or value.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned map will be serializable if the specified map is\n serializable.\n\n Since null is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does."
                }
              ]
            },
            {
              "name": "checkedNavigableMap",
              "overloads": [
                {
                  "signature": "public static <K, V> NavigableMap<K,V> checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType)",
                  "description": "Returns a dynamically typesafe view of the specified navigable map.\n Any attempt to insert a mapping whose key or value have the wrong\n type will result in an immediate ClassCastException.\n Similarly, any attempt to modify the value currently associated with\n a key will result in an immediate ClassCastException,\n whether the modification is attempted directly through the map\n itself, or through a Map.Entry instance obtained from the\n map's entry set view.\n\n Assuming a map contains no incorrectly typed keys or values\n prior to the time a dynamically typesafe view is generated, and\n that all subsequent access to the map takes place through the view\n (or one of its collection views), it is guaranteed that the\n map cannot contain an incorrectly typed key or value.\n\n A discussion of the use of dynamically typesafe views may be\n found in the documentation for the checkedCollection method.\n\n The returned map will be serializable if the specified map is\n serializable.\n\n Since null is considered to be a value of any reference\n type, the returned map permits insertion of null keys or values\n whenever the backing map does."
                }
              ]
            },
            {
              "name": "emptyIterator",
              "overloads": [
                {
                  "signature": "public static <T> Iterator<T> emptyIterator()",
                  "description": "Returns an iterator that has no elements.  More precisely,\n\n \n hasNext always returns \n false.\n next always throws NoSuchElementException.\n remove always throws IllegalStateException.\n \n\n Implementations of this method are permitted, but not\n required, to return the same object from multiple invocations."
                }
              ]
            },
            {
              "name": "emptyListIterator",
              "overloads": [
                {
                  "signature": "public static <T> ListIterator<T> emptyListIterator()",
                  "description": "Returns a list iterator that has no elements.  More precisely,\n\n \n hasNext and hasPrevious always return \n false.\n next and previous always throw NoSuchElementException.\n remove and set always throw IllegalStateException.\n add always throws UnsupportedOperationException.\n nextIndex always returns\n 0.\n previousIndex always\n returns -1.\n \n\n Implementations of this method are permitted, but not\n required, to return the same object from multiple invocations."
                }
              ]
            },
            {
              "name": "emptyEnumeration",
              "overloads": [
                {
                  "signature": "public static <T> Enumeration<T> emptyEnumeration()",
                  "description": "Returns an enumeration that has no elements.  More precisely,\n\n \n hasMoreElements always\n returns false.\n  nextElement always throws\n NoSuchElementException.\n \n\n Implementations of this method are permitted, but not\n required, to return the same object from multiple invocations."
                }
              ]
            },
            {
              "name": "emptySet",
              "overloads": [
                {
                  "signature": "public static final <T> Set<T> emptySet()",
                  "description": "Returns an empty set (immutable).  This set is serializable.\n Unlike the like-named field, this method is parameterized.\n\n This example illustrates the type-safe way to obtain an empty set:\n      Set<String> s = Collections.emptySet();"
                }
              ]
            },
            {
              "name": "emptySortedSet",
              "overloads": [
                {
                  "signature": "public static <E> SortedSet<E> emptySortedSet()",
                  "description": "Returns an empty sorted set (immutable).  This set is serializable.\n\n This example illustrates the type-safe way to obtain an empty\n sorted set:\n  \n     SortedSet<String> s = Collections.emptySortedSet();"
                }
              ]
            },
            {
              "name": "emptyNavigableSet",
              "overloads": [
                {
                  "signature": "public static <E> NavigableSet<E> emptyNavigableSet()",
                  "description": "Returns an empty navigable set (immutable).  This set is serializable.\n\n This example illustrates the type-safe way to obtain an empty\n navigable set:\n  \n     NavigableSet<String> s = Collections.emptyNavigableSet();"
                }
              ]
            },
            {
              "name": "emptyList",
              "overloads": [
                {
                  "signature": "public static final <T> List<T> emptyList()",
                  "description": "Returns an empty list (immutable).  This list is serializable.\n\n This example illustrates the type-safe way to obtain an empty list:\n      List<String> s = Collections.emptyList();"
                }
              ]
            },
            {
              "name": "emptyMap",
              "overloads": [
                {
                  "signature": "public static final <K, V> Map<K,V> emptyMap()",
                  "description": "Returns an empty map (immutable).  This map is serializable.\n\n This example illustrates the type-safe way to obtain an empty map:\n      Map<String, Date> s = Collections.emptyMap();"
                }
              ]
            },
            {
              "name": "emptySortedMap",
              "overloads": [
                {
                  "signature": "public static final <K, V> SortedMap<K,V> emptySortedMap()",
                  "description": "Returns an empty sorted map (immutable).  This map is serializable.\n\n This example illustrates the type-safe way to obtain an empty map:\n  \n     SortedMap<String, Date> s = Collections.emptySortedMap();"
                }
              ]
            },
            {
              "name": "emptyNavigableMap",
              "overloads": [
                {
                  "signature": "public static final <K, V> NavigableMap<K,V> emptyNavigableMap()",
                  "description": "Returns an empty navigable map (immutable).  This map is serializable.\n\n This example illustrates the type-safe way to obtain an empty map:\n  \n     NavigableMap<String, Date> s = Collections.emptyNavigableMap();"
                }
              ]
            },
            {
              "name": "singleton",
              "overloads": [
                {
                  "signature": "public static <T> Set<T> singleton(T o)",
                  "description": "Returns an immutable set containing only the specified object.\n The returned set is serializable."
                }
              ]
            },
            {
              "name": "singletonList",
              "overloads": [
                {
                  "signature": "public static <T> List<T> singletonList(T o)",
                  "description": "Returns an immutable list containing only the specified object.\n The returned list is serializable."
                }
              ]
            },
            {
              "name": "singletonMap",
              "overloads": [
                {
                  "signature": "public static <K, V> Map<K,V> singletonMap(K key, V value)",
                  "description": "Returns an immutable map, mapping only the specified key to the\n specified value.  The returned map is serializable."
                }
              ]
            },
            {
              "name": "nCopies",
              "overloads": [
                {
                  "signature": "public static <T> List<T> nCopies(int n, T o)",
                  "description": "Returns an immutable list consisting of n copies of the\n specified object.  The newly allocated data object is tiny (it contains\n a single reference to the data object).  This method is useful in\n combination with the List.addAll method to grow lists.\n The returned list is serializable."
                }
              ]
            },
            {
              "name": "reverseOrder",
              "overloads": [
                {
                  "signature": "public static <T> Comparator<T> reverseOrder()",
                  "description": "Returns a comparator that imposes the reverse of the natural\n ordering on a collection of objects that implement the\n Comparable interface.  (The natural ordering is the ordering\n imposed by the objects' own compareTo method.)  This enables a\n simple idiom for sorting (or maintaining) collections (or arrays) of\n objects that implement the Comparable interface in\n reverse-natural-order.  For example, suppose a is an array of\n strings. Then:           Arrays.sort(a, Collections.reverseOrder());\n  sorts the array in reverse-lexicographic (alphabetical) order.\n\n The returned comparator is serializable."
                },
                {
                  "signature": "public static <T> Comparator<T> reverseOrder(Comparator<T> cmp)",
                  "description": "Returns a comparator that imposes the reverse ordering of the specified\n comparator.  If the specified comparator is null, this method is\n equivalent to reverseOrder() (in other words, it returns a\n comparator that imposes the reverse of the natural ordering on\n a collection of objects that implement the Comparable interface).\n\n The returned comparator is serializable (assuming the specified\n comparator is also serializable or null)."
                }
              ]
            },
            {
              "name": "enumeration",
              "overloads": [
                {
                  "signature": "public static <T> Enumeration<T> enumeration(Collection<T> c)",
                  "description": "Returns an enumeration over the specified collection.  This provides\n interoperability with legacy APIs that require an enumeration\n as input.\n\n The iterator returned from a call to Enumeration.asIterator()\n does not support removal of elements from the specified collection.  This\n is necessary to avoid unintentionally increasing the capabilities of the\n returned enumeration."
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public static <T> ArrayList<T> list(Enumeration<T> e)",
                  "description": "Returns an array list containing the elements returned by the\n specified enumeration in the order they are returned by the\n enumeration.  This method provides interoperability between\n legacy APIs that return enumerations and new APIs that require\n collections."
                }
              ]
            },
            {
              "name": "frequency",
              "overloads": [
                {
                  "signature": "public static int frequency(Collection<?> c, Object o)",
                  "description": "Returns the number of elements in the specified collection equal to the\n specified object.  More formally, returns the number of elements\n e in the collection such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "disjoint",
              "overloads": [
                {
                  "signature": "public static boolean disjoint(Collection<?> c1, Collection<?> c2)",
                  "description": "Returns true if the two specified collections have no\n elements in common.\n\n Care must be exercised if this method is used on collections that\n do not comply with the general contract for Collection.\n Implementations may elect to iterate over either collection and test\n for containment in the other collection (or to perform any equivalent\n computation).  If either collection uses a nonstandard equality test\n (as does a SortedSet whose ordering is not compatible with\n equals, or the key set of an IdentityHashMap), both\n collections must use the same nonstandard equality test, or the\n result of this method is undefined.\n\n Care must also be exercised when using collections that have\n restrictions on the elements that they may contain. Collection\n implementations are allowed to throw exceptions for any operation\n involving elements they deem ineligible. For absolute safety the\n specified collections should contain only elements which are\n eligible elements for both collections.\n\n Note that it is permissible to pass the same collection in both\n parameters, in which case the method will return true if and\n only if the collection is empty."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "@SafeVarargs public static <T> boolean addAll(Collection<? super T> c, T... elements)",
                  "description": "Adds all of the specified elements to the specified collection.\n Elements to be added may be specified individually or as an array.\n The behaviour of this convenience method is similar to that of\n cc.addAll(Collections.unmodifiableList(Arrays.asList(elements))).\n\n When elements are specified individually, this method provides a\n convenient way to add a few elements to an existing collection:\n      Collections.addAll(flavors, \"Peaches 'n Plutonium\", \"Rocky Racoon\");"
                }
              ]
            },
            {
              "name": "newSetFromMap",
              "overloads": [
                {
                  "signature": "public static <E> Set<E> newSetFromMap(Map<E,Boolean> map)",
                  "description": "Returns a set backed by the specified map.  The resulting set displays\n the same ordering, concurrency, and performance characteristics as the\n backing map.  In essence, this factory method provides a Set\n implementation corresponding to any Map implementation.  There\n is no need to use this method on a Map implementation that\n already has a corresponding Set implementation (such as HashMap or TreeMap).\n\n Each method invocation on the set returned by this method results in\n exactly one method invocation on the backing map or its keySet\n view, with one exception.  The addAll method is implemented\n as a sequence of put invocations on the backing map.\n\n The specified map must be empty at the time this method is invoked,\n and should not be accessed directly after this method returns.  These\n conditions are ensured if the map is created empty, passed directly\n to this method, and no reference to the map is retained, as illustrated\n in the following code fragment:\n     Set<Object> weakHashSet = Collections.newSetFromMap(\n        new WeakHashMap<Object, Boolean>());"
                }
              ]
            },
            {
              "name": "asLifoQueue",
              "overloads": [
                {
                  "signature": "public static <T> Queue<T> asLifoQueue(Deque<T> deque)",
                  "description": "Returns a view of a Deque as a Last-in-first-out (Lifo)\n Queue. Method add is mapped to push,\n remove is mapped to pop and so on. This\n view can be useful when you would like to use a method\n requiring a Queue but you need Lifo ordering.\n\n Each method invocation on the queue returned by this method\n results in exactly one method invocation on the backing deque, with\n one exception.  The addAll method is\n implemented as a sequence of addFirst\n invocations on the backing deque."
                }
              ]
            }
          ]
        },
        {
          "name": "Comparator<T>",
          "methods": [
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "int compare(T o1, T o2)",
                  "description": "Compares its two arguments for order.  Returns a negative integer,\n zero, or a positive integer as the first argument is less than, equal\n to, or greater than the second.\n\n The implementor must ensure that signum(compare(x, y)) == -signum(compare(y, x)) for\n all x and y.  (This implies that \n compare(x, y) must throw an exception if and only if \n compare(y, x) throws an exception.)\n\n The implementor must also ensure that the relation is transitive:\n ((compare(x, y)>0) && (compare(y, z)>0)) implies\n compare(x, z)>0.\n\n Finally, the implementor must ensure that compare(x,\n y)==0 implies that signum(compare(x,\n z))==signum(compare(y, z)) for all z."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\"\n this comparator.  This method must obey the general contract of\n Object.equals(Object).  Additionally, this method can\n return true only if the specified object is also\n a comparator and it imposes the same ordering as this\n comparator.  Thus, comp1.equals(comp2) implies that\n signum(comp1.compare(o1,\n o2))==signum(comp2.compare(o1, o2)) for every object reference\n o1 and o2.\n\n Note that it is always safe not to override\n Object.equals(Object).  However, overriding this method may,\n in some cases, improve performance by allowing programs to determine\n that two distinct comparators impose the same order."
                }
              ]
            },
            {
              "name": "reversed",
              "overloads": [
                {
                  "signature": "default Comparator<T> reversed()",
                  "description": "Returns a comparator that imposes the reverse ordering of this\n comparator."
                }
              ]
            },
            {
              "name": "thenComparing",
              "overloads": [
                {
                  "signature": "default Comparator<T> thenComparing(Comparator<? super T> other)",
                  "description": "Returns a lexicographic-order comparator with another comparator.\n If this Comparator considers two elements equal, i.e.\n compare(a, b) == 0, other is used to determine the order.\n\n The returned comparator is serializable if the specified comparator\n is also serializable."
                },
                {
                  "signature": "default <U> Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)",
                  "description": "Returns a lexicographic-order comparator with a function that\n extracts a key to be compared with the given Comparator."
                },
                {
                  "signature": "default <U extends Comparable<? super U>> Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor)",
                  "description": "Returns a lexicographic-order comparator with a function that\n extracts a Comparable sort key."
                }
              ]
            },
            {
              "name": "thenComparingInt",
              "overloads": [
                {
                  "signature": "default Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor)",
                  "description": "Returns a lexicographic-order comparator with a function that\n extracts an int sort key."
                }
              ]
            },
            {
              "name": "thenComparingLong",
              "overloads": [
                {
                  "signature": "default Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor)",
                  "description": "Returns a lexicographic-order comparator with a function that\n extracts a long sort key."
                }
              ]
            },
            {
              "name": "thenComparingDouble",
              "overloads": [
                {
                  "signature": "default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor)",
                  "description": "Returns a lexicographic-order comparator with a function that\n extracts a double sort key."
                }
              ]
            },
            {
              "name": "reverseOrder",
              "overloads": [
                {
                  "signature": "static <T extends Comparable<? super T>> Comparator<T> reverseOrder()",
                  "description": "Returns a comparator that imposes the reverse of the natural\n ordering.\n\n The returned comparator is serializable and throws NullPointerException when comparing null."
                }
              ]
            },
            {
              "name": "naturalOrder",
              "overloads": [
                {
                  "signature": "static <T extends Comparable<? super T>> Comparator<T> naturalOrder()",
                  "description": "Returns a comparator that compares Comparable objects in natural\n order.\n\n The returned comparator is serializable and throws NullPointerException when comparing null."
                }
              ]
            },
            {
              "name": "nullsFirst",
              "overloads": [
                {
                  "signature": "static <T> Comparator<T> nullsFirst(Comparator<? super T> comparator)",
                  "description": "Returns a null-friendly comparator that considers null to be\n less than non-null. When both are null, they are considered\n equal. If both are non-null, the specified Comparator is used\n to determine the order. If the specified comparator is null,\n then the returned comparator considers all non-null values to be equal.\n\n The returned comparator is serializable if the specified comparator\n is serializable."
                }
              ]
            },
            {
              "name": "nullsLast",
              "overloads": [
                {
                  "signature": "static <T> Comparator<T> nullsLast(Comparator<? super T> comparator)",
                  "description": "Returns a null-friendly comparator that considers null to be\n greater than non-null. When both are null, they are considered\n equal. If both are non-null, the specified Comparator is used\n to determine the order. If the specified comparator is null,\n then the returned comparator considers all non-null values to be equal.\n\n The returned comparator is serializable if the specified comparator\n is serializable."
                }
              ]
            },
            {
              "name": "comparing",
              "overloads": [
                {
                  "signature": "static <T, U> Comparator<T> comparing(Function<? super T,? extends U> keyExtractor, Comparator<? super U> keyComparator)",
                  "description": "Accepts a function that extracts a sort key from a type T, and\n returns a Comparator<T> that compares by that sort key using\n the specified Comparator.\n\n The returned comparator is serializable if the specified function\n and comparator are both serializable."
                },
                {
                  "signature": "static <T, U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T,? extends U> keyExtractor)",
                  "description": "Accepts a function that extracts a Comparable sort key from a type T, and returns a \n Comparator<T> that compares by that sort key.\n\n The returned comparator is serializable if the specified function\n is also serializable."
                }
              ]
            },
            {
              "name": "comparingInt",
              "overloads": [
                {
                  "signature": "static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)",
                  "description": "Accepts a function that extracts an int sort key from a type\n T, and returns a Comparator<T> that compares by that\n sort key.\n\n The returned comparator is serializable if the specified function\n is also serializable."
                }
              ]
            },
            {
              "name": "comparingLong",
              "overloads": [
                {
                  "signature": "static <T> Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor)",
                  "description": "Accepts a function that extracts a long sort key from a type\n T, and returns a Comparator<T> that compares by that\n sort key.\n\n The returned comparator is serializable if the specified function is\n also serializable."
                }
              ]
            },
            {
              "name": "comparingDouble",
              "overloads": [
                {
                  "signature": "static <T> Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor)",
                  "description": "Accepts a function that extracts a double sort key from a type\n T, and returns a Comparator<T> that compares by that\n sort key.\n\n The returned comparator is serializable if the specified function\n is also serializable."
                }
              ]
            }
          ]
        },
        {
          "name": "ConcurrentModificationException",
          "methods": [
            {
              "name": "ConcurrentModificationException",
              "overloads": [
                {
                  "signature": "public ConcurrentModificationException()",
                  "description": "Constructs a ConcurrentModificationException with no\n detail message."
                },
                {
                  "signature": "public ConcurrentModificationException(String message)",
                  "description": "Constructs a ConcurrentModificationException with the\n specified detail message."
                },
                {
                  "signature": "public ConcurrentModificationException(Throwable cause)",
                  "description": "Constructs a new exception with the specified cause and a detail\n message of (cause==null ? null : cause.toString()) (which\n typically contains the class and detail message of cause."
                },
                {
                  "signature": "public ConcurrentModificationException(String message, Throwable cause)",
                  "description": "Constructs a new exception with the specified detail message and\n cause.\n\n Note that the detail message associated with cause is\n not automatically incorporated in this exception's detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "Currency",
          "methods": [
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Currency getInstance(String currencyCode)",
                  "description": "Returns the Currency instance for the given currency code."
                },
                {
                  "signature": "public static Currency getInstance(Locale locale)",
                  "description": "Returns the Currency instance for the country of the\n given locale. The language and variant components of the locale\n are ignored. The result may vary over time, as countries change their\n currencies. For example, for the original member countries of the\n European Monetary Union, the method returns the old national currencies\n until December 31, 2001, and the Euro from January 1, 2002, local time\n of the respective countries.\n \n If the specified locale contains \"cu\" and/or \"rg\"\n Unicode extensions,\n the instance returned from this method reflects\n the values specified with those extensions. If both \"cu\" and \"rg\" are\n specified, the currency from the \"cu\" extension supersedes the implicit one\n from the \"rg\" extension.\n \n The method returns null for territories that don't\n have a currency, such as Antarctica."
                }
              ]
            },
            {
              "name": "getAvailableCurrencies",
              "overloads": [
                {
                  "signature": "public static Set<Currency> getAvailableCurrencies()",
                  "description": "Gets the set of available currencies.  The returned set of currencies\n contains all of the available currencies, which may include currencies\n that represent obsolete ISO 4217 codes.  The set can be modified\n without affecting the available currencies in the runtime."
                }
              ]
            },
            {
              "name": "getCurrencyCode",
              "overloads": [
                {
                  "signature": "public String getCurrencyCode()",
                  "description": "Gets the ISO 4217 currency code of this currency."
                }
              ]
            },
            {
              "name": "getSymbol",
              "overloads": [
                {
                  "signature": "public String getSymbol()",
                  "description": "Gets the symbol of this currency for the default\n DISPLAY locale.\n For example, for the US Dollar, the symbol is \"$\" if the default\n locale is the US, while for other locales it may be \"US$\". If no\n symbol can be determined, the ISO 4217 currency code is returned.\n \n If the default DISPLAY locale\n contains \"rg\" (region override)\n Unicode extension,\n the symbol returned from this method reflects\n the value specified with that extension.\n \n This is equivalent to calling\n getSymbol(Locale.getDefault(Locale.Category.DISPLAY))."
                },
                {
                  "signature": "public String getSymbol(Locale locale)",
                  "description": "Gets the symbol of this currency for the specified locale.\n For example, for the US Dollar, the symbol is \"$\" if the specified\n locale is the US, while for other locales it may be \"US$\". If no\n symbol can be determined, the ISO 4217 currency code is returned.\n \n If the specified locale contains \"rg\" (region override)\n Unicode extension,\n the symbol returned from this method reflects\n the value specified with that extension."
                }
              ]
            },
            {
              "name": "getDefaultFractionDigits",
              "overloads": [
                {
                  "signature": "public int getDefaultFractionDigits()",
                  "description": "Gets the default number of fraction digits used with this currency.\n Note that the number of fraction digits is the same as ISO 4217's\n minor unit for the currency.\n For example, the default number of fraction digits for the Euro is 2,\n while for the Japanese Yen it's 0.\n In the case of pseudo-currencies, such as IMF Special Drawing Rights,\n -1 is returned."
                }
              ]
            },
            {
              "name": "getNumericCode",
              "overloads": [
                {
                  "signature": "public int getNumericCode()",
                  "description": "Returns the ISO 4217 numeric code of this currency."
                }
              ]
            },
            {
              "name": "getNumericCodeAsString",
              "overloads": [
                {
                  "signature": "public String getNumericCodeAsString()",
                  "description": "Returns the 3 digit ISO 4217 numeric code of this currency as a String.\n Unlike getNumericCode(), which returns the numeric code as int,\n this method always returns the numeric code as a 3 digit string.\n e.g. a numeric value of 32 would be returned as \"032\",\n and a numeric value of 6 would be returned as \"006\"."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName()",
                  "description": "Gets the name that is suitable for displaying this currency for\n the default DISPLAY locale.\n If there is no suitable display name found\n for the default locale, the ISO 4217 currency code is returned.\n \n This is equivalent to calling\n getDisplayName(Locale.getDefault(Locale.Category.DISPLAY))."
                },
                {
                  "signature": "public String getDisplayName(Locale locale)",
                  "description": "Gets the name that is suitable for displaying this currency for\n the specified locale.  If there is no suitable display name found\n for the specified locale, the ISO 4217 currency code is returned."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the ISO 4217 currency code of this currency."
                }
              ]
            }
          ]
        },
        {
          "name": "Date",
          "methods": [
            {
              "name": "Date",
              "overloads": [
                {
                  "signature": "public Date()",
                  "description": "Allocates a Date object and initializes it so that\n it represents the time at which it was allocated, measured to the\n nearest millisecond."
                },
                {
                  "signature": "public Date(long date)",
                  "description": "Allocates a Date object and initializes it to\n represent the specified number of milliseconds since the\n standard base time known as \"the epoch\", namely January 1,\n 1970, 00:00:00 GMT."
                },
                {
                  "signature": "@Deprecated public Date(int year, int month, int date)",
                  "description": "Allocates a Date object and initializes it so that\n it represents midnight, local time, at the beginning of the day\n specified by the year, month, and\n date arguments.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated public Date(int year, int month, int date, int hrs, int min)",
                  "description": "Allocates a Date object and initializes it so that\n it represents the instant at the start of the minute specified by\n the year, month, date,\n hrs, and min arguments, in the local\n time zone.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated public Date(int year, int month, int date, int hrs, int min, int sec)",
                  "description": "Allocates a Date object and initializes it so that\n it represents the instant at the start of the second specified\n by the year, month, date,\n hrs, min, and sec arguments,\n in the local time zone.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated public Date(String s)",
                  "description": "Allocates a Date object and initializes it so that\n it represents the date and time indicated by the string\n s, which is interpreted as if by the\n parse(java.lang.String) method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Return a copy of this object."
                }
              ]
            },
            {
              "name": "UTC",
              "overloads": [
                {
                  "signature": "@Deprecated public static long UTC(int year, int month, int date, int hrs, int min, int sec)",
                  "description": "Determines the date and time based on the arguments. The\n arguments are interpreted as a year, month, day of the month,\n hour of the day, minute within the hour, and second within the\n minute, exactly as for the Date constructor with six\n arguments, except that the arguments are interpreted relative\n to UTC rather than to the local time zone. The time indicated is\n returned represented as the distance, measured in milliseconds,\n of that time from the epoch (00:00:00 GMT on January 1, 1970).",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "@Deprecated public static long parse(String s)",
                  "description": "Attempts to interpret the string s as a representation\n of a date and time. If the attempt is successful, the time\n indicated is returned represented as the distance, measured in\n milliseconds, of that time from the epoch (00:00:00 GMT on\n January 1, 1970). If the attempt fails, an\n IllegalArgumentException is thrown.\n \n It accepts many syntaxes; in particular, it recognizes the IETF\n standard date syntax: \"Sat, 12 Aug 1995 13:30:00 GMT\". It also\n understands the continental U.S. time-zone abbreviations, but for\n general use, a time-zone offset should be used: \"Sat, 12 Aug 1995\n 13:30:00 GMT+0430\" (4 hours, 30 minutes west of the Greenwich\n meridian). If no time zone is specified, the local time zone is\n assumed. GMT and UTC are considered equivalent.\n \n The string s is processed from left to right, looking for\n data of interest. Any material in s that is within the\n ASCII parenthesis characters ( and ) is ignored.\n Parentheses may be nested. Otherwise, the only characters permitted\n within s are these ASCII characters:\n  abcdefghijklmnopqrstuvwxyz\n ABCDEFGHIJKLMNOPQRSTUVWXYZ\n 0123456789,+-:/\n and whitespace characters.\n A consecutive sequence of decimal digits is treated as a decimal\n number:\n If a number is preceded by + or - and a year\n     has already been recognized, then the number is a time-zone\n     offset. If the number is less than 24, it is an offset measured\n     in hours. Otherwise, it is regarded as an offset in minutes,\n     expressed in 24-hour time format without punctuation. A\n     preceding - means a westward offset. Time zone offsets\n     are always relative to UTC (Greenwich). Thus, for example,\n     -5 occurring in the string would mean \"five hours west\n     of Greenwich\" and +0430 would mean \"four hours and\n     thirty minutes east of Greenwich.\" It is permitted for the\n     string to specify GMT, UT, or UTC\n     redundantly-for example, GMT-5 or utc+0430.\n The number is regarded as a year number if one of the\n     following conditions is true:\n \n     The number is equal to or greater than 70 and followed by a\n         space, comma, slash, or end of string\n     The number is less than 70, and both a month and a day of\n         the month have already been recognized\n \n     If the recognized year number is less than 100, it is\n     interpreted as an abbreviated year relative to a century of\n     which dates are within 80 years before and 19 years after\n     the time when the Date class is initialized.\n     After adjusting the year number, 1900 is subtracted from\n     it. For example, if the current year is 1999 then years in\n     the range 19 to 99 are assumed to mean 1919 to 1999, while\n     years from 0 to 18 are assumed to mean 2000 to 2018.  Note\n     that this is slightly different from the interpretation of\n     years less than 100 that is used in SimpleDateFormat.\n If the number is followed by a colon, it is regarded as an hour,\n     unless an hour has already been recognized, in which case it is\n     regarded as a minute.\n If the number is followed by a slash, it is regarded as a month\n     (it is decreased by 1 to produce a number in the range 0\n     to 11), unless a month has already been recognized, in\n     which case it is regarded as a day of the month.\n If the number is followed by whitespace, a comma, a hyphen, or\n     end of string, then if an hour has been recognized but not a\n     minute, it is regarded as a minute; otherwise, if a minute has\n     been recognized but not a second, it is regarded as a second;\n     otherwise, it is regarded as a day of the month. \n A consecutive sequence of letters is regarded as a word and treated\n as follows:\n A word that matches AM, ignoring case, is ignored (but\n     the parse fails if an hour has not been recognized or is less\n     than 1 or greater than 12).\n A word that matches PM, ignoring case, adds 12\n     to the hour (but the parse fails if an hour has not been\n     recognized or is less than 1 or greater than 12).\n Any word that matches any prefix of SUNDAY, MONDAY, TUESDAY,\n     WEDNESDAY, THURSDAY, FRIDAY, or SATURDAY, ignoring\n     case, is ignored. For example, sat, Friday, TUE, and\n     Thurs are ignored.\n Otherwise, any word that matches any prefix of JANUARY,\n     FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER,\n     OCTOBER, NOVEMBER, or DECEMBER, ignoring case, and\n     considering them in the order given here, is recognized as\n     specifying a month and is converted to a number (0 to\n     11). For example, aug, Sept, april, and\n     NOV are recognized as months. So is Ma, which\n     is recognized as MARCH, not MAY.\n Any word that matches GMT, UT, or UTC, ignoring\n     case, is treated as referring to UTC.\n Any word that matches EST, CST, MST, or PST,\n     ignoring case, is recognized as referring to the time zone in\n     North America that is five, six, seven, or eight hours west of\n     Greenwich, respectively. Any word that matches EDT, CDT,\n     MDT, or PDT, ignoring case, is recognized as\n     referring to the same time zone, respectively, during daylight\n     saving time.\n Once the entire string s has been scanned, it is converted to a time\n result in one of two ways. If a time zone or time-zone offset has been\n recognized, then the year, month, day of month, hour, minute, and\n second are interpreted in UTC and then the time-zone offset is\n applied. Otherwise, the year, month, day of month, hour, minute, and\n second are interpreted in the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "@Deprecated public int getYear()",
                  "description": "Returns a value that is the result of subtracting 1900 from the\n year that contains or begins with the instant in time represented\n by this Date object, as interpreted in the local\n time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setYear",
              "overloads": [
                {
                  "signature": "@Deprecated public void setYear(int year)",
                  "description": "Sets the year of this Date object to be the specified\n value plus 1900. This Date object is modified so\n that it represents a point in time within the specified year,\n with the month, date, hour, minute, and second the same as\n before, as interpreted in the local time zone. (Of course, if\n the date was February 29, for example, and the year is set to a\n non-leap year, then the new date will be treated as if it were\n on March 1.)",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "@Deprecated public int getMonth()",
                  "description": "Returns a number representing the month that contains or begins\n with the instant in time represented by this Date object.\n The value returned is between 0 and 11,\n with the value 0 representing January.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setMonth",
              "overloads": [
                {
                  "signature": "@Deprecated public void setMonth(int month)",
                  "description": "Sets the month of this date to the specified value. This\n Date object is modified so that it represents a point\n in time within the specified month, with the year, date, hour,\n minute, and second the same as before, as interpreted in the\n local time zone. If the date was October 31, for example, and\n the month is set to June, then the new date will be treated as\n if it were on July 1, because June has only 30 days.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDate",
              "overloads": [
                {
                  "signature": "@Deprecated public int getDate()",
                  "description": "Returns the day of the month represented by this Date object.\n The value returned is between 1 and 31\n representing the day of the month that contains or begins with the\n instant in time represented by this Date object, as\n interpreted in the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setDate",
              "overloads": [
                {
                  "signature": "@Deprecated public void setDate(int date)",
                  "description": "Sets the day of the month of this Date object to the\n specified value. This Date object is modified so that\n it represents a point in time within the specified day of the\n month, with the year, month, hour, minute, and second the same\n as before, as interpreted in the local time zone. If the date\n was April 30, for example, and the date is set to 31, then it\n will be treated as if it were on May 1, because April has only\n 30 days.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDay",
              "overloads": [
                {
                  "signature": "@Deprecated public int getDay()",
                  "description": "Returns the day of the week represented by this date. The\n returned value (0 = Sunday, 1 = Monday,\n 2 = Tuesday, 3 = Wednesday, 4 =\n Thursday, 5 = Friday, 6 = Saturday)\n represents the day of the week that contains or begins with\n the instant in time represented by this Date object,\n as interpreted in the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getHours",
              "overloads": [
                {
                  "signature": "@Deprecated public int getHours()",
                  "description": "Returns the hour represented by this Date object. The\n returned value is a number (0 through 23)\n representing the hour within the day that contains or begins\n with the instant in time represented by this Date\n object, as interpreted in the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setHours",
              "overloads": [
                {
                  "signature": "@Deprecated public void setHours(int hours)",
                  "description": "Sets the hour of this Date object to the specified value.\n This Date object is modified so that it represents a point\n in time within the specified hour of the day, with the year, month,\n date, minute, and second the same as before, as interpreted in the\n local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getMinutes",
              "overloads": [
                {
                  "signature": "@Deprecated public int getMinutes()",
                  "description": "Returns the number of minutes past the hour represented by this date,\n as interpreted in the local time zone.\n The value returned is between 0 and 59.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setMinutes",
              "overloads": [
                {
                  "signature": "@Deprecated public void setMinutes(int minutes)",
                  "description": "Sets the minutes of this Date object to the specified value.\n This Date object is modified so that it represents a point\n in time within the specified minute of the hour, with the year, month,\n date, hour, and second the same as before, as interpreted in the\n local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSeconds",
              "overloads": [
                {
                  "signature": "@Deprecated public int getSeconds()",
                  "description": "Returns the number of seconds past the minute represented by this date.\n The value returned is between 0 and 61. The\n values 60 and 61 can only occur on those\n Java Virtual Machines that take leap seconds into account.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setSeconds",
              "overloads": [
                {
                  "signature": "@Deprecated public void setSeconds(int seconds)",
                  "description": "Sets the seconds of this Date to the specified value.\n This Date object is modified so that it represents a\n point in time within the specified second of the minute, with\n the year, month, date, hour, and minute the same as before, as\n interpreted in the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTime",
              "overloads": [
                {
                  "signature": "public long getTime()",
                  "description": "Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n represented by this Date object."
                }
              ]
            },
            {
              "name": "setTime",
              "overloads": [
                {
                  "signature": "public void setTime(long time)",
                  "description": "Sets this Date object to represent a point in time that is\n time milliseconds after January 1, 1970 00:00:00 GMT."
                }
              ]
            },
            {
              "name": "before",
              "overloads": [
                {
                  "signature": "public boolean before(Date when)",
                  "description": "Tests if this date is before the specified date."
                }
              ]
            },
            {
              "name": "after",
              "overloads": [
                {
                  "signature": "public boolean after(Date when)",
                  "description": "Tests if this date is after the specified date."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares two dates for equality.\n The result is true if and only if the argument is\n not null and is a Date object that\n represents the same point in time, to the millisecond, as this object.\n \n Thus, two Date objects are equal if and only if the\n getTime method returns the same long\n value for both."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Date anotherDate)",
                  "description": "Compares two Dates for ordering."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for this object. The result is the\n exclusive OR of the two halves of the primitive long\n value returned by the getTime()\n method. That is, the hash code is the value of the expression:\n \n (int)(this.getTime()^(this.getTime() >>> 32))"
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this Date object to a String\n of the form:\n  dow mon dd hh:mm:ss zzz yyyy\n where:\n dow is the day of the week (Sun, Mon, Tue, Wed,\n     Thu, Fri, Sat).\n mon is the month (Jan, Feb, Mar, Apr, May, Jun,\n     Jul, Aug, Sep, Oct, Nov, Dec).\n dd is the day of the month (01 through\n     31), as two decimal digits.\n hh is the hour of the day (00 through\n     23), as two decimal digits.\n mm is the minute within the hour (00 through\n     59), as two decimal digits.\n ss is the second within the minute (00 through\n     61, as two decimal digits.\n zzz is the time zone (and may reflect daylight saving\n     time). Standard time zone abbreviations include those\n     recognized by the method parse. If time zone\n     information is not available, then zzz is empty -\n     that is, it consists of no characters at all.\n yyyy is the year, as four decimal digits."
                }
              ]
            },
            {
              "name": "toLocaleString",
              "overloads": [
                {
                  "signature": "@Deprecated public String toLocaleString()",
                  "description": "Creates a string representation of this Date object in an\n implementation-dependent form. The intent is that the form should\n be familiar to the user of the Java application, wherever it may\n happen to be running. The intent is comparable to that of the\n \"%c\" format supported by the strftime()\n function of ISOC.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toGMTString",
              "overloads": [
                {
                  "signature": "@Deprecated public String toGMTString()",
                  "description": "Creates a string representation of this Date object of\n the form:\n  d mon yyyy hh:mm:ss GMT\n where:\n d is the day of the month (1 through 31),\n     as one or two decimal digits.\n mon is the month (Jan, Feb, Mar, Apr, May, Jun, Jul,\n     Aug, Sep, Oct, Nov, Dec).\n yyyy is the year, as four decimal digits.\n hh is the hour of the day (00 through 23),\n     as two decimal digits.\n mm is the minute within the hour (00 through\n     59), as two decimal digits.\n ss is the second within the minute (00 through\n     61), as two decimal digits.\n GMT is exactly the ASCII letters \"GMT\" to indicate\n     Greenwich Mean Time.\n \n The result does not depend on the local time zone.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTimezoneOffset",
              "overloads": [
                {
                  "signature": "@Deprecated public int getTimezoneOffset()",
                  "description": "Returns the offset, measured in minutes, for the local time zone\n relative to UTC that is appropriate for the time represented by\n this Date object.\n \n For example, in Massachusetts, five time zones west of Greenwich:\n  new Date(96, 1, 14).getTimezoneOffset() returns 300\n because on February 14, 1996, standard time (Eastern Standard Time)\n is in use, which is offset five hours from UTC; but:\n  new Date(96, 5, 1).getTimezoneOffset() returns 240\n because on June 1, 1996, daylight saving time (Eastern Daylight Time)\n is in use, which is offset only four hours from UTC.\n This method produces the same result as if it computed:\n  (this.getTime() - UTC(this.getYear(),\n                       this.getMonth(),\n                       this.getDate(),\n                       this.getHours(),\n                       this.getMinutes(),\n                       this.getSeconds())) / (60 * 1000)",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Date from(Instant instant)",
                  "description": "Obtains an instance of Date from an Instant object.\n \n Instant uses a precision of nanoseconds, whereas Date\n uses a precision of milliseconds.  The conversion will truncate any\n excess precision information as though the amount in nanoseconds was\n subject to integer division by one million.\n \n Instant can store points on the time-line further in the future\n and further in the past than Date. In this scenario, this method\n will throw an exception."
                }
              ]
            },
            {
              "name": "toInstant",
              "overloads": [
                {
                  "signature": "public Instant toInstant()",
                  "description": "Converts this Date object to an Instant.\n \n The conversion creates an Instant that represents the same\n point on the time-line as this Date."
                }
              ]
            }
          ]
        },
        {
          "name": "Deque<E>",
          "methods": [
            {
              "name": "addFirst",
              "overloads": [
                {
                  "signature": "void addFirst(E e)",
                  "description": "Inserts the specified element at the front of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n throwing an IllegalStateException if no space is currently\n available.  When using a capacity-restricted deque, it is generally\n preferable to use method offerFirst(E)."
                }
              ]
            },
            {
              "name": "addLast",
              "overloads": [
                {
                  "signature": "void addLast(E e)",
                  "description": "Inserts the specified element at the end of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n throwing an IllegalStateException if no space is currently\n available.  When using a capacity-restricted deque, it is generally\n preferable to use method offerLast(E).\n\n This method is equivalent to add(E)."
                }
              ]
            },
            {
              "name": "offerFirst",
              "overloads": [
                {
                  "signature": "boolean offerFirst(E e)",
                  "description": "Inserts the specified element at the front of this deque unless it would\n violate capacity restrictions.  When using a capacity-restricted deque,\n this method is generally preferable to the addFirst(E) method,\n which can fail to insert an element only by throwing an exception."
                }
              ]
            },
            {
              "name": "offerLast",
              "overloads": [
                {
                  "signature": "boolean offerLast(E e)",
                  "description": "Inserts the specified element at the end of this deque unless it would\n violate capacity restrictions.  When using a capacity-restricted deque,\n this method is generally preferable to the addLast(E) method,\n which can fail to insert an element only by throwing an exception."
                }
              ]
            },
            {
              "name": "removeFirst",
              "overloads": [
                {
                  "signature": "E removeFirst()",
                  "description": "Retrieves and removes the first element of this deque.  This method\n differs from pollFirst only in that it throws an\n exception if this deque is empty."
                }
              ]
            },
            {
              "name": "removeLast",
              "overloads": [
                {
                  "signature": "E removeLast()",
                  "description": "Retrieves and removes the last element of this deque.  This method\n differs from pollLast only in that it throws an\n exception if this deque is empty."
                }
              ]
            },
            {
              "name": "pollFirst",
              "overloads": [
                {
                  "signature": "E pollFirst()",
                  "description": "Retrieves and removes the first element of this deque,\n or returns null if this deque is empty."
                }
              ]
            },
            {
              "name": "pollLast",
              "overloads": [
                {
                  "signature": "E pollLast()",
                  "description": "Retrieves and removes the last element of this deque,\n or returns null if this deque is empty."
                }
              ]
            },
            {
              "name": "getFirst",
              "overloads": [
                {
                  "signature": "E getFirst()",
                  "description": "Retrieves, but does not remove, the first element of this deque.\n\n This method differs from peekFirst only in that it\n throws an exception if this deque is empty."
                }
              ]
            },
            {
              "name": "getLast",
              "overloads": [
                {
                  "signature": "E getLast()",
                  "description": "Retrieves, but does not remove, the last element of this deque.\n This method differs from peekLast only in that it\n throws an exception if this deque is empty."
                }
              ]
            },
            {
              "name": "peekFirst",
              "overloads": [
                {
                  "signature": "E peekFirst()",
                  "description": "Retrieves, but does not remove, the first element of this deque,\n or returns null if this deque is empty."
                }
              ]
            },
            {
              "name": "peekLast",
              "overloads": [
                {
                  "signature": "E peekLast()",
                  "description": "Retrieves, but does not remove, the last element of this deque,\n or returns null if this deque is empty."
                }
              ]
            },
            {
              "name": "removeFirstOccurrence",
              "overloads": [
                {
                  "signature": "boolean removeFirstOccurrence(Object o)",
                  "description": "Removes the first occurrence of the specified element from this deque.\n If the deque does not contain the element, it is unchanged.\n More formally, removes the first element e such that\n Objects.equals(o, e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call)."
                }
              ]
            },
            {
              "name": "removeLastOccurrence",
              "overloads": [
                {
                  "signature": "boolean removeLastOccurrence(Object o)",
                  "description": "Removes the last occurrence of the specified element from this deque.\n If the deque does not contain the element, it is unchanged.\n More formally, removes the last element e such that\n Objects.equals(o, e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call)."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Inserts the specified element into the queue represented by this deque\n (in other words, at the tail of this deque) if it is possible to do so\n immediately without violating capacity restrictions, returning\n true upon success and throwing an\n IllegalStateException if no space is currently available.\n When using a capacity-restricted deque, it is generally preferable to\n use offer.\n\n This method is equivalent to addLast(E)."
                }
              ]
            },
            {
              "name": "offer",
              "overloads": [
                {
                  "signature": "boolean offer(E e)",
                  "description": "Inserts the specified element into the queue represented by this deque\n (in other words, at the tail of this deque) if it is possible to do so\n immediately without violating capacity restrictions, returning\n true upon success and false if no space is currently\n available.  When using a capacity-restricted deque, this method is\n generally preferable to the add(E) method, which can fail to\n insert an element only by throwing an exception.\n\n This method is equivalent to offerLast(E)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "E remove()",
                  "description": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque).\n This method differs from poll() only in that it\n throws an exception if this deque is empty.\n\n This method is equivalent to removeFirst()."
                },
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element from this deque.\n If the deque does not contain the element, it is unchanged.\n More formally, removes the first element e such that\n Objects.equals(o, e) (if such an element exists).\n Returns true if this deque contained the specified element\n (or equivalently, if this deque changed as a result of the call).\n\n This method is equivalent to removeFirstOccurrence(Object)."
                }
              ]
            },
            {
              "name": "poll",
              "overloads": [
                {
                  "signature": "E poll()",
                  "description": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), or returns\n null if this deque is empty.\n\n This method is equivalent to pollFirst()."
                }
              ]
            },
            {
              "name": "element",
              "overloads": [
                {
                  "signature": "E element()",
                  "description": "Retrieves, but does not remove, the head of the queue represented by\n this deque (in other words, the first element of this deque).\n This method differs from peek only in that it throws an\n exception if this deque is empty.\n\n This method is equivalent to getFirst()."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "E peek()",
                  "description": "Retrieves, but does not remove, the head of the queue represented by\n this deque (in other words, the first element of this deque), or\n returns null if this deque is empty.\n\n This method is equivalent to peekFirst()."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection at the end\n of this deque, as if by calling addLast(E) on each one,\n in the order that they are returned by the collection's iterator.\n\n When using a capacity-restricted deque, it is generally preferable\n to call offer separately on each element.\n\n An exception encountered while trying to add an element may result\n in only some of the elements having been successfully added when\n the associated exception is thrown."
                }
              ]
            },
            {
              "name": "push",
              "overloads": [
                {
                  "signature": "void push(E e)",
                  "description": "Pushes an element onto the stack represented by this deque (in other\n words, at the head of this deque) if it is possible to do so\n immediately without violating capacity restrictions, throwing an\n IllegalStateException if no space is currently available.\n\n This method is equivalent to addFirst(E)."
                }
              ]
            },
            {
              "name": "pop",
              "overloads": [
                {
                  "signature": "E pop()",
                  "description": "Pops an element from the stack represented by this deque.  In other\n words, removes and returns the first element of this deque.\n\n This method is equivalent to removeFirst()."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this deque contains the specified element.\n More formally, returns true if and only if this deque contains\n at least one element e such that Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this deque."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this deque in proper sequence.\n The elements will be returned in order from first (head) to last (tail)."
                }
              ]
            },
            {
              "name": "descendingIterator",
              "overloads": [
                {
                  "signature": "Iterator<E> descendingIterator()",
                  "description": "Returns an iterator over the elements in this deque in reverse\n sequential order.  The elements will be returned in order from\n last (tail) to first (head)."
                }
              ]
            }
          ]
        },
        {
          "name": "Dictionary<K,V>",
          "methods": [
            {
              "name": "Dictionary",
              "overloads": [
                {
                  "signature": "public Dictionary()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public abstract int size()",
                  "description": "Returns the number of entries (distinct keys) in this dictionary."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public abstract boolean isEmpty()",
                  "description": "Tests if this dictionary maps no keys to value. The general contract\n for the isEmpty method is that the result is true if and only\n if this dictionary contains no entries."
                }
              ]
            },
            {
              "name": "keys",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<K> keys()",
                  "description": "Returns an enumeration of the keys in this dictionary. The general\n contract for the keys method is that an Enumeration object\n is returned that will generate all the keys for which this dictionary\n contains entries."
                }
              ]
            },
            {
              "name": "elements",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<V> elements()",
                  "description": "Returns an enumeration of the values in this dictionary. The general\n contract for the elements method is that an\n Enumeration is returned that will generate all the elements\n contained in entries in this dictionary."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract V get(Object key)",
                  "description": "Returns the value to which the key is mapped in this dictionary.\n The general contract for the isEmpty method is that if this\n dictionary contains an entry for the specified key, the associated\n value is returned; otherwise, null is returned."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract V put(K key, V value)",
                  "description": "Maps the specified key to the specified\n value in this dictionary. Neither the key nor the\n value can be null.\n \n If this dictionary already contains an entry for the specified\n key, the value already in this dictionary for that\n key is returned, after modifying the entry to contain the\n  new element. If this dictionary does not already have an entry\n  for the specified key, an entry is created for the\n  specified key and value, and null is\n  returned.\n \n The value can be retrieved by calling the\n get method with a key that is equal to\n the original key."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public abstract V remove(Object key)",
                  "description": "Removes the key (and its corresponding\n value) from this dictionary. This method does nothing\n if the key is not in this dictionary."
                }
              ]
            }
          ]
        },
        {
          "name": "DoubleSummaryStatistics",
          "methods": [
            {
              "name": "DoubleSummaryStatistics",
              "overloads": [
                {
                  "signature": "public DoubleSummaryStatistics()",
                  "description": "Constructs an empty instance with zero count, zero sum,\n Double.POSITIVE_INFINITY min, Double.NEGATIVE_INFINITY\n max and zero average."
                },
                {
                  "signature": "public DoubleSummaryStatistics(long count, double min, double max, double sum) throws IllegalArgumentException",
                  "description": "Constructs a non-empty instance with the specified count,\n min, max, and sum.\n\n If count is zero then the remaining arguments are ignored and\n an empty instance is constructed.\n\n If the arguments are inconsistent then an IllegalArgumentException\n is thrown.  The necessary consistent argument conditions are:\n \n   count >= 0\n   (min <= max && !isNaN(sum)) || (isNaN(min) && isNaN(max) && isNaN(sum))"
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "public void accept(double value)",
                  "description": "Records another value into the summary information."
                }
              ]
            },
            {
              "name": "combine",
              "overloads": [
                {
                  "signature": "public void combine(DoubleSummaryStatistics other)",
                  "description": "Combines the state of another DoubleSummaryStatistics into this\n one."
                }
              ]
            },
            {
              "name": "getCount",
              "overloads": [
                {
                  "signature": "public final long getCount()",
                  "description": "Return the count of values recorded."
                }
              ]
            },
            {
              "name": "getSum",
              "overloads": [
                {
                  "signature": "public final double getSum()",
                  "description": "Returns the sum of values recorded, or zero if no values have been\n recorded.\n\n  The value of a floating-point sum is a function both of the\n input values as well as the order of addition operations. The\n order of addition operations of this method is intentionally\n not defined to allow for implementation flexibility to improve\n the speed and accuracy of the computed result.\n\n In particular, this method may be implemented using compensated\n summation or other technique to reduce the error bound in the\n numerical sum compared to a simple summation of double\n values.\n\n Because of the unspecified order of operations and the\n possibility of using differing summation schemes, the output of\n this method may vary on the same input values.\n\n Various conditions can result in a non-finite sum being\n computed. This can occur even if the all the recorded values\n being summed are finite. If any recorded value is non-finite,\n the sum will be non-finite:\n\n \n\n If any recorded value is a NaN, then the final sum will be\n NaN.\n\n If the recorded values contain one or more infinities, the\n sum will be infinite or NaN.\n\n \n\n If the recorded values contain infinities of opposite sign,\n the sum will be NaN.\n\n If the recorded values contain infinities of one sign and\n an intermediate sum overflows to an infinity of the opposite\n sign, the sum may be NaN.\n\n \n\n \n\n It is possible for intermediate sums of finite values to\n overflow into opposite-signed infinities; if that occurs, the\n final sum will be NaN even if the recorded values are all\n finite.\n\n If all the recorded values are zero, the sign of zero is\n not guaranteed to be preserved in the final sum."
                }
              ]
            },
            {
              "name": "getMin",
              "overloads": [
                {
                  "signature": "public final double getMin()",
                  "description": "Returns the minimum recorded value, Double.NaN if any recorded\n value was NaN or Double.POSITIVE_INFINITY if no values were\n recorded. Unlike the numerical comparison operators, this method\n considers negative zero to be strictly smaller than positive zero."
                }
              ]
            },
            {
              "name": "getMax",
              "overloads": [
                {
                  "signature": "public final double getMax()",
                  "description": "Returns the maximum recorded value, Double.NaN if any recorded\n value was NaN or Double.NEGATIVE_INFINITY if no values were\n recorded. Unlike the numerical comparison operators, this method\n considers negative zero to be strictly smaller than positive zero."
                }
              ]
            },
            {
              "name": "getAverage",
              "overloads": [
                {
                  "signature": "public final double getAverage()",
                  "description": "Returns the arithmetic mean of values recorded, or zero if no\n values have been recorded.\n\n  The computed average can vary numerically and have the\n special case behavior as computing the sum; see getSum()\n for details."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this object suitable for\n debugging. The exact presentation format is unspecified and may vary\n between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "DuplicateFormatFlagsException",
          "methods": [
            {
              "name": "DuplicateFormatFlagsException",
              "overloads": [
                {
                  "signature": "public DuplicateFormatFlagsException(String f)",
                  "description": "Constructs an instance of this class with the specified flags."
                }
              ]
            },
            {
              "name": "getFlags",
              "overloads": [
                {
                  "signature": "public String getFlags()",
                  "description": "Returns the set of flags which contains a duplicate flag."
                }
              ]
            }
          ]
        },
        {
          "name": "EmptyStackException",
          "methods": [
            {
              "name": "EmptyStackException",
              "overloads": [
                {
                  "signature": "public EmptyStackException()",
                  "description": "Constructs a new EmptyStackException with null\n as its error message string."
                }
              ]
            }
          ]
        },
        {
          "name": "Enumeration<E>",
          "methods": [
            {
              "name": "hasMoreElements",
              "overloads": [
                {
                  "signature": "boolean hasMoreElements()",
                  "description": "Tests if this enumeration contains more elements."
                }
              ]
            },
            {
              "name": "nextElement",
              "overloads": [
                {
                  "signature": "E nextElement()",
                  "description": "Returns the next element of this enumeration if this enumeration\n object has at least one more element to provide."
                }
              ]
            },
            {
              "name": "asIterator",
              "overloads": [
                {
                  "signature": "default Iterator<E> asIterator()",
                  "description": "Returns an Iterator that traverses the remaining elements\n covered by this enumeration. Traversal is undefined if any methods\n are called on this enumeration after the call to asIterator."
                }
              ]
            }
          ]
        },
        {
          "name": "EnumMap<K",
          "methods": [
            {
              "name": "EnumMap",
              "overloads": [
                {
                  "signature": "public EnumMap(Class<K> keyType)",
                  "description": "Creates an empty enum map with the specified key type."
                },
                {
                  "signature": "public EnumMap(EnumMap<K,? extends V> m)",
                  "description": "Creates an enum map with the same key type as the specified enum\n map, initially containing the same mappings (if any)."
                },
                {
                  "signature": "public EnumMap(Map<K,? extends V> m)",
                  "description": "Creates an enum map initialized from the specified map.  If the\n specified map is an EnumMap instance, this constructor behaves\n identically to EnumMap(EnumMap).  Otherwise, the specified map\n must contain at least one mapping (in order to determine the new\n enum map's key type)."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this map."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the specified\n key."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key == k),\n then this method returns v; otherwise it returns\n null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map.\n If the map previously contained a mapping for this key, the old\n value is replaced."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for this key from this map if present."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for\n any of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all mappings from this map."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The returned set obeys the general contract outlined in\n Map.keySet().  The set's iterator will return the keys\n in their natural order (the order in which the enum constants\n are declared)."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The returned collection obeys the general contract outlined in\n Map.values().  The collection's iterator will return the\n values in the order their corresponding keys appear in map,\n which is their natural order (the order in which the enum constants\n are declared)."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The returned set obeys the general contract outlined in\n Map.keySet().  The set's iterator will return the\n mappings in the order their keys appear in map, which is their\n natural order (the order in which the enum constants are declared)."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent the same mappings, as specified in the Map.equals(Object) contract."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public EnumMap<K,V> clone()",
                  "description": "Returns a shallow copy of this enum map. The values themselves\n are not cloned."
                }
              ]
            }
          ]
        },
        {
          "name": "EnumSet<E",
          "methods": [
            {
              "name": "noneOf",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType)",
                  "description": "Creates an empty enum set with the specified element type."
                }
              ]
            },
            {
              "name": "allOf",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType)",
                  "description": "Creates an enum set containing all of the elements in the specified\n element type."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s)",
                  "description": "Creates an enum set with the same element type as the specified enum\n set, initially containing the same elements (if any)."
                },
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c)",
                  "description": "Creates an enum set initialized from the specified collection.  If\n the specified collection is an EnumSet instance, this static\n factory method behaves identically to copyOf(EnumSet).\n Otherwise, the specified collection must contain at least one element\n (in order to determine the new enum set's element type)."
                }
              ]
            },
            {
              "name": "complementOf",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s)",
                  "description": "Creates an enum set with the same element type as the specified enum\n set, initially containing all the elements of this type that are\n not contained in the specified set."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> of(E e)",
                  "description": "Creates an enum set initially containing the specified element.\n\n Overloadings of this method exist to initialize an enum set with\n one through five elements.  A sixth overloading is provided that\n uses the varargs feature.  This overloading may be used to create\n an enum set initially containing an arbitrary number of elements, but\n is likely to run slower than the overloadings that do not use varargs."
                },
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2)",
                  "description": "Creates an enum set initially containing the specified elements.\n\n Overloadings of this method exist to initialize an enum set with\n one through five elements.  A sixth overloading is provided that\n uses the varargs feature.  This overloading may be used to create\n an enum set initially containing an arbitrary number of elements, but\n is likely to run slower than the overloadings that do not use varargs."
                },
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3)",
                  "description": "Creates an enum set initially containing the specified elements.\n\n Overloadings of this method exist to initialize an enum set with\n one through five elements.  A sixth overloading is provided that\n uses the varargs feature.  This overloading may be used to create\n an enum set initially containing an arbitrary number of elements, but\n is likely to run slower than the overloadings that do not use varargs."
                },
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4)",
                  "description": "Creates an enum set initially containing the specified elements.\n\n Overloadings of this method exist to initialize an enum set with\n one through five elements.  A sixth overloading is provided that\n uses the varargs feature.  This overloading may be used to create\n an enum set initially containing an arbitrary number of elements, but\n is likely to run slower than the overloadings that do not use varargs."
                },
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4, E e5)",
                  "description": "Creates an enum set initially containing the specified elements.\n\n Overloadings of this method exist to initialize an enum set with\n one through five elements.  A sixth overloading is provided that\n uses the varargs feature.  This overloading may be used to create\n an enum set initially containing an arbitrary number of elements, but\n is likely to run slower than the overloadings that do not use varargs."
                },
                {
                  "signature": "@SafeVarargs public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)",
                  "description": "Creates an enum set initially containing the specified elements.\n This factory, whose parameter list uses the varargs feature, may\n be used to create an enum set initially containing an arbitrary\n number of elements, but it is likely to run slower than the overloadings\n that do not use varargs."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public static <E extends Enum<E>> EnumSet<E> range(E from, E to)",
                  "description": "Creates an enum set initially containing all of the elements in the\n range defined by the two specified endpoints.  The returned set will\n contain the endpoints themselves, which may be identical but must not\n be out of order."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public EnumSet<E> clone()",
                  "description": "Returns a copy of this set."
                }
              ]
            }
          ]
        },
        {
          "name": "EventListener",
          "methods": []
        },
        {
          "name": "EventListenerProxy<T",
          "methods": [
            {
              "name": "EventListenerProxy",
              "overloads": [
                {
                  "signature": "public EventListenerProxy(T listener)",
                  "description": "Creates a proxy for the specified listener."
                }
              ]
            },
            {
              "name": "getListener",
              "overloads": [
                {
                  "signature": "public T getListener()",
                  "description": "Returns the listener associated with the proxy."
                }
              ]
            }
          ]
        },
        {
          "name": "EventObject",
          "methods": [
            {
              "name": "EventObject",
              "overloads": [
                {
                  "signature": "public EventObject(Object source)",
                  "description": "Constructs a prototypical Event."
                }
              ]
            },
            {
              "name": "getSource",
              "overloads": [
                {
                  "signature": "public Object getSource()",
                  "description": "The object on which the Event initially occurred."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String representation of this EventObject."
                }
              ]
            }
          ]
        },
        {
          "name": "FormatFlagsConversionMismatchException",
          "methods": [
            {
              "name": "FormatFlagsConversionMismatchException",
              "overloads": [
                {
                  "signature": "public FormatFlagsConversionMismatchException(String f, char c)",
                  "description": "Constructs an instance of this class with the specified flag\n and conversion."
                }
              ]
            },
            {
              "name": "getFlags",
              "overloads": [
                {
                  "signature": "public String getFlags()",
                  "description": "Returns the incompatible flag."
                }
              ]
            },
            {
              "name": "getConversion",
              "overloads": [
                {
                  "signature": "public char getConversion()",
                  "description": "Returns the incompatible conversion."
                }
              ]
            }
          ]
        },
        {
          "name": "Formattable",
          "methods": [
            {
              "name": "formatTo",
              "overloads": [
                {
                  "signature": "void formatTo(Formatter formatter, int flags, int width, int precision)",
                  "description": "Formats the object using the provided formatter."
                }
              ]
            }
          ]
        },
        {
          "name": "FormattableFlags",
          "methods": []
        },
        {
          "name": "Formatter",
          "methods": [
            {
              "name": "Formatter",
              "overloads": [
                {
                  "signature": "public Formatter()",
                  "description": "Constructs a new formatter.\n\n  The destination of the formatted output is a StringBuilder\n which may be retrieved by invoking out() and whose\n current content may be converted into a string by invoking toString().  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(Appendable a)",
                  "description": "Constructs a new formatter with the specified destination.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(Locale l)",
                  "description": "Constructs a new formatter with the specified locale.\n\n  The destination of the formatted output is a StringBuilder\n which may be retrieved by invoking out() and whose current\n content may be converted into a string by invoking toString()."
                },
                {
                  "signature": "public Formatter(Appendable a, Locale l)",
                  "description": "Constructs a new formatter with the specified destination and locale."
                },
                {
                  "signature": "public Formatter(String fileName) throws FileNotFoundException",
                  "description": "Constructs a new formatter with the specified file name.\n\n  The charset used is the default charset for this\n instance of the Java virtual machine.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified file name and charset.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(String fileName, String csn, Locale l) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified file name, charset, and\n locale."
                },
                {
                  "signature": "public Formatter(String fileName, Charset charset, Locale l) throws IOException",
                  "description": "Constructs a new formatter with the specified file name, charset, and\n locale."
                },
                {
                  "signature": "public Formatter(File file) throws FileNotFoundException",
                  "description": "Constructs a new formatter with the specified file.\n\n  The charset used is the default charset for this\n instance of the Java virtual machine.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified file and charset.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(File file, String csn, Locale l) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified file, charset, and\n locale."
                },
                {
                  "signature": "public Formatter(File file, Charset charset, Locale l) throws IOException",
                  "description": "Constructs a new formatter with the specified file, charset, and\n locale."
                },
                {
                  "signature": "public Formatter(PrintStream ps)",
                  "description": "Constructs a new formatter with the specified print stream.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine.\n\n  Characters are written to the given PrintStream object and are therefore encoded using that object's\n charset."
                },
                {
                  "signature": "public Formatter(OutputStream os)",
                  "description": "Constructs a new formatter with the specified output stream.\n\n  The charset used is the default charset for this\n instance of the Java virtual machine.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(OutputStream os, String csn) throws UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified output stream and\n charset.\n\n  The locale used is the default locale for\n formatting for this instance of the Java\n virtual machine."
                },
                {
                  "signature": "public Formatter(OutputStream os, String csn, Locale l) throws UnsupportedEncodingException",
                  "description": "Constructs a new formatter with the specified output stream, charset,\n and locale."
                },
                {
                  "signature": "public Formatter(OutputStream os, Charset charset, Locale l)",
                  "description": "Constructs a new formatter with the specified output stream, charset,\n and locale."
                }
              ]
            },
            {
              "name": "locale",
              "overloads": [
                {
                  "signature": "public Locale locale()",
                  "description": "Returns the locale set by the construction of this formatter.\n\n  The format method\n for this object which has a locale argument does not change this value."
                }
              ]
            },
            {
              "name": "out",
              "overloads": [
                {
                  "signature": "public Appendable out()",
                  "description": "Returns the destination for the output."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the result of invoking toString() on the destination\n for the output.  For example, the following code formats text into a\n StringBuilder then retrieves the resultant string:\n\n    Formatter f = new Formatter();\n   f.format(\"Last reboot at %tc\", lastRebootDate);\n   String s = f.toString();\n   // -> s == \"Last reboot at Sat Jan 01 00:00:00 PST 2000\"\n \n\n  An invocation of this method behaves in exactly the same way as the\n invocation\n\n      out().toString() \n\n  Depending on the specification of toString for the Appendable, the returned string may or may not contain the characters\n written to the destination.  For instance, buffers typically return\n their contents in toString(), but streams cannot since the\n data is discarded."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes this formatter.  If the destination implements the Flushable interface, its flush method will be invoked.\n\n  Flushing a formatter writes any buffered output in the destination\n to the underlying stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes this formatter.  If the destination implements the Closeable interface, its close method will be invoked.\n\n  Closing a formatter allows it to release resources it may be holding\n (such as open files).  If the formatter is already closed, then invoking\n this method has no effect.\n\n  Attempting to invoke any methods except ioException() in\n this formatter after it has been closed will result in a FormatterClosedException."
                }
              ]
            },
            {
              "name": "ioException",
              "overloads": [
                {
                  "signature": "public IOException ioException()",
                  "description": "Returns the IOException last thrown by this formatter's Appendable.\n\n  If the destination's append() method never throws\n IOException, then this method will always return null."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public Formatter format(String format, Object... args)",
                  "description": "Writes a formatted string to this object's destination using the\n specified format string and arguments.  The locale used is the one\n defined during the construction of this formatter."
                },
                {
                  "signature": "public Formatter format(Locale l, String format, Object... args)",
                  "description": "Writes a formatted string to this object's destination using the\n specified locale, format string, and arguments."
                }
              ]
            }
          ]
        },
        {
          "name": "FormatterClosedException",
          "methods": [
            {
              "name": "FormatterClosedException",
              "overloads": [
                {
                  "signature": "public FormatterClosedException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "GregorianCalendar",
          "methods": [
            {
              "name": "GregorianCalendar",
              "overloads": [
                {
                  "signature": "public GregorianCalendar()",
                  "description": "Constructs a default GregorianCalendar using the current time\n in the default time zone with the default\n FORMAT locale."
                },
                {
                  "signature": "public GregorianCalendar(TimeZone zone)",
                  "description": "Constructs a GregorianCalendar based on the current time\n in the given time zone with the default\n FORMAT locale."
                },
                {
                  "signature": "public GregorianCalendar(Locale aLocale)",
                  "description": "Constructs a GregorianCalendar based on the current time\n in the default time zone with the given locale."
                },
                {
                  "signature": "public GregorianCalendar(TimeZone zone, Locale aLocale)",
                  "description": "Constructs a GregorianCalendar based on the current time\n in the given time zone with the given locale."
                },
                {
                  "signature": "public GregorianCalendar(int year, int month, int dayOfMonth)",
                  "description": "Constructs a GregorianCalendar with the given date set\n in the default time zone with the default locale."
                },
                {
                  "signature": "public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay, int minute)",
                  "description": "Constructs a GregorianCalendar with the given date\n and time set for the default time zone with the default locale."
                },
                {
                  "signature": "public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay, int minute, int second)",
                  "description": "Constructs a GregorianCalendar with the given date\n and time set for the default time zone with the default locale."
                }
              ]
            },
            {
              "name": "setGregorianChange",
              "overloads": [
                {
                  "signature": "public void setGregorianChange(Date date)",
                  "description": "Sets the GregorianCalendar change date. This is the point when the switch\n from Julian dates to Gregorian dates occurred. Default is October 15,\n 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.\n \n To obtain a pure Julian calendar, set the change date to\n Date(Long.MAX_VALUE).  To obtain a pure Gregorian calendar,\n set the change date to Date(Long.MIN_VALUE)."
                }
              ]
            },
            {
              "name": "getGregorianChange",
              "overloads": [
                {
                  "signature": "public final Date getGregorianChange()",
                  "description": "Gets the Gregorian Calendar change date.  This is the point when the\n switch from Julian dates to Gregorian dates occurred. Default is\n October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian\n calendar."
                }
              ]
            },
            {
              "name": "isLeapYear",
              "overloads": [
                {
                  "signature": "public boolean isLeapYear(int year)",
                  "description": "Determines if the given year is a leap year. Returns true if\n the given year is a leap year. To specify BC year numbers,\n 1 - year number must be given. For example, year BC 4 is\n specified as -3."
                }
              ]
            },
            {
              "name": "getCalendarType",
              "overloads": [
                {
                  "signature": "public String getCalendarType()",
                  "description": "Returns \"gregory\" as the calendar type."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this GregorianCalendar to the specified\n Object. The result is true if and\n only if the argument is a GregorianCalendar object\n that represents the same time value (millisecond offset from\n the Epoch) under the same\n Calendar parameters and Gregorian change date as\n this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Generates the hash code for this GregorianCalendar object."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public void add(int field, int amount)",
                  "description": "Adds the specified (signed) amount of time to the given calendar field,\n based on the calendar's rules.\n\n Add rule 1. The value of field\n after the call minus the value of field before the\n call is amount, modulo any overflow that has occurred in\n field. Overflow occurs when a field value exceeds its\n range and, as a result, the next larger field is incremented or\n decremented and the field value is adjusted back into its range.\n\n Add rule 2. If a smaller field is expected to be\n invariant, but it is impossible for it to be equal to its\n prior value because of changes in its minimum or maximum after\n field is changed, then its value is adjusted to be as close\n as possible to its expected value. A smaller field represents a\n smaller unit of time. HOUR is a smaller field than\n DAY_OF_MONTH. No adjustment is made to smaller fields\n that are not expected to be invariant. The calendar system\n determines what fields are expected to be invariant."
                }
              ]
            },
            {
              "name": "roll",
              "overloads": [
                {
                  "signature": "public void roll(int field, boolean up)",
                  "description": "Adds or subtracts (up/down) a single unit of time on the given time\n field without changing larger fields.\n \n Example: Consider a GregorianCalendar\n originally set to December 31, 1999. Calling roll(Calendar.MONTH, true)\n sets the calendar to January 31, 1999.  The YEAR field is unchanged\n because it is a larger field than MONTH."
                },
                {
                  "signature": "public void roll(int field, int amount)",
                  "description": "Adds a signed amount to the specified calendar field without changing larger fields.\n A negative roll amount means to subtract from field without changing\n larger fields. If the specified amount is 0, this method performs nothing.\n\n This method calls Calendar.complete() before adding the\n amount so that all the calendar fields are normalized. If there\n is any calendar field having an out-of-range value in non-lenient mode, then an\n IllegalArgumentException is thrown.\n\n \n Example: Consider a GregorianCalendar\n originally set to August 31, 1999. Calling roll(Calendar.MONTH,\n 8) sets the calendar to April 30, 1999. Using a\n GregorianCalendar, the DAY_OF_MONTH field cannot\n be 31 in the month April. DAY_OF_MONTH is set to the closest possible\n value, 30. The YEAR field maintains the value of 1999 because it\n is a larger field than MONTH.\n \n Example: Consider a GregorianCalendar\n originally set to Sunday June 6, 1999. Calling\n roll(Calendar.WEEK_OF_MONTH, -1) sets the calendar to\n Tuesday June 1, 1999, whereas calling\n add(Calendar.WEEK_OF_MONTH, -1) sets the calendar to\n Sunday May 30, 1999. This is because the roll rule imposes an\n additional constraint: The MONTH must not change when the\n WEEK_OF_MONTH is rolled. Taken together with add rule 1,\n the resultant date must be between Tuesday June 1 and Saturday June\n 5. According to add rule 2, the DAY_OF_WEEK, an invariant\n when changing the WEEK_OF_MONTH, is set to Tuesday, the\n closest possible value to Sunday (where Sunday is the first day of the\n week)."
                }
              ]
            },
            {
              "name": "getMinimum",
              "overloads": [
                {
                  "signature": "public int getMinimum(int field)",
                  "description": "Returns the minimum value for the given calendar field of this\n GregorianCalendar instance. The minimum value is\n defined as the smallest value returned by the get method for any possible time value,\n taking into consideration the current values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods."
                }
              ]
            },
            {
              "name": "getMaximum",
              "overloads": [
                {
                  "signature": "public int getMaximum(int field)",
                  "description": "Returns the maximum value for the given calendar field of this\n GregorianCalendar instance. The maximum value is\n defined as the largest value returned by the get method for any possible time value,\n taking into consideration the current values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods."
                }
              ]
            },
            {
              "name": "getGreatestMinimum",
              "overloads": [
                {
                  "signature": "public int getGreatestMinimum(int field)",
                  "description": "Returns the highest minimum value for the given calendar field\n of this GregorianCalendar instance. The highest\n minimum value is defined as the largest value returned by\n getActualMinimum(int) for any possible time value,\n taking into consideration the current values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods."
                }
              ]
            },
            {
              "name": "getLeastMaximum",
              "overloads": [
                {
                  "signature": "public int getLeastMaximum(int field)",
                  "description": "Returns the lowest maximum value for the given calendar field\n of this GregorianCalendar instance. The lowest\n maximum value is defined as the smallest value returned by\n getActualMaximum(int) for any possible time value,\n taking into consideration the current values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods."
                }
              ]
            },
            {
              "name": "getActualMinimum",
              "overloads": [
                {
                  "signature": "public int getActualMinimum(int field)",
                  "description": "Returns the minimum value that this calendar field could have,\n taking into consideration the given time value and the current\n values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods.\n\n For example, if the Gregorian change date is January 10,\n 1970 and the date of this GregorianCalendar is\n January 20, 1970, the actual minimum value of the\n DAY_OF_MONTH field is 10 because the previous date\n of January 10, 1970 is December 27, 1996 (in the Julian\n calendar). Therefore, December 28, 1969 to January 9, 1970\n don't exist."
                }
              ]
            },
            {
              "name": "getActualMaximum",
              "overloads": [
                {
                  "signature": "public int getActualMaximum(int field)",
                  "description": "Returns the maximum value that this calendar field could have,\n taking into consideration the given time value and the current\n values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods.\n For example, if the date of this instance is February 1, 2004,\n the actual maximum value of the DAY_OF_MONTH field\n is 29 because 2004 is a leap year, and if the date of this\n instance is February 1, 2005, it's 28.\n\n This method calculates the maximum value of WEEK_OF_YEAR based on the YEAR (calendar year) value, not the week year. Call getWeeksInWeekYear() to get the maximum value of \n WEEK_OF_YEAR in the week year of this GregorianCalendar."
                }
              ]
            },
            {
              "name": "isWeekDateSupported",
              "overloads": [
                {
                  "signature": "public final boolean isWeekDateSupported()",
                  "description": "Returns true indicating this GregorianCalendar\n supports week dates."
                }
              ]
            },
            {
              "name": "getWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeekYear()",
                  "description": "Returns the week year represented by this\n GregorianCalendar. The dates in the weeks between 1 and the\n maximum week number of the week year have the same week year value\n that may be one year before or after the YEAR\n (calendar year) value.\n\n This method calls Calendar.complete() before\n calculating the week year."
                }
              ]
            },
            {
              "name": "setWeekDate",
              "overloads": [
                {
                  "signature": "public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek)",
                  "description": "Sets this GregorianCalendar to the date given by the\n date specifiers - weekYear,\n weekOfYear, and dayOfWeek. weekOfYear\n follows the WEEK_OF_YEAR\n numbering.  The dayOfWeek value must be one of the\n DAY_OF_WEEK values: SUNDAY to SATURDAY.\n\n Note that the numeric day-of-week representation differs from\n the ISO 8601 standard, and that the weekOfYear\n numbering is compatible with the standard when \n getFirstDayOfWeek() is MONDAY and \n getMinimalDaysInFirstWeek() is 4.\n\n Unlike the set method, all of the calendar fields\n and the instant of time value are calculated upon return.\n\n If weekOfYear is out of the valid week-of-year\n range in weekYear, the weekYear\n and weekOfYear values are adjusted in lenient\n mode, or an IllegalArgumentException is thrown in\n non-lenient mode."
                }
              ]
            },
            {
              "name": "getWeeksInWeekYear",
              "overloads": [
                {
                  "signature": "public int getWeeksInWeekYear()",
                  "description": "Returns the number of weeks in the week year\n represented by this GregorianCalendar.\n\n For example, if this GregorianCalendar's date is\n December 31, 2008 with the ISO\n 8601 compatible setting, this method will return 53 for the\n period: December 29, 2008 to January 3, 2010 while getActualMaximum(WEEK_OF_YEAR) will return\n 52 for the period: December 31, 2007 to December 28, 2008."
                }
              ]
            },
            {
              "name": "computeFields",
              "overloads": [
                {
                  "signature": "protected void computeFields()",
                  "description": "Converts the time value (millisecond offset from the Epoch) to calendar field values.\n The time is not\n recomputed first; to recompute the time, then the fields, call the\n complete method."
                }
              ]
            },
            {
              "name": "computeTime",
              "overloads": [
                {
                  "signature": "protected void computeTime()",
                  "description": "Converts calendar field values to the time value (millisecond\n offset from the Epoch)."
                }
              ]
            },
            {
              "name": "toZonedDateTime",
              "overloads": [
                {
                  "signature": "public ZonedDateTime toZonedDateTime()",
                  "description": "Converts this object to a ZonedDateTime that represents\n the same point on the time-line as this GregorianCalendar.\n \n Since this object supports a Julian-Gregorian cutover date and\n ZonedDateTime does not, it is possible that the resulting year,\n month and day will have different values.  The result will represent the\n correct date in the ISO calendar system, which will also be the same value\n for Modified Julian Days."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static GregorianCalendar from(ZonedDateTime zdt)",
                  "description": "Obtains an instance of GregorianCalendar with the default locale\n from a ZonedDateTime object.\n \n Since ZonedDateTime does not support a Julian-Gregorian cutover\n date and uses ISO calendar system, the return GregorianCalendar is a pure\n Gregorian calendar and uses ISO 8601 standard for week definitions,\n which has MONDAY as the FirstDayOfWeek and 4 as the value of the\n MinimalDaysInFirstWeek.\n \n ZoneDateTime can store points on the time-line further in the\n future and further in the past than GregorianCalendar. In this\n scenario, this method will throw an IllegalArgumentException\n exception."
                }
              ]
            }
          ]
        },
        {
          "name": "HashMap<K,V>",
          "methods": [
            {
              "name": "HashMap",
              "overloads": [
                {
                  "signature": "public HashMap(int initialCapacity, float loadFactor)",
                  "description": "Constructs an empty HashMap with the specified initial\n capacity and load factor."
                },
                {
                  "signature": "public HashMap(int initialCapacity)",
                  "description": "Constructs an empty HashMap with the specified initial\n capacity and the default load factor (0.75)."
                },
                {
                  "signature": "public HashMap()",
                  "description": "Constructs an empty HashMap with the default initial capacity\n (16) and the default load factor (0.75)."
                },
                {
                  "signature": "public HashMap(Map<? extends K,? extends V> m)",
                  "description": "Constructs a new HashMap with the same mappings as the\n specified Map.  The HashMap is created with\n default load factor (0.75) and an initial capacity sufficient to\n hold the mappings in the specified Map."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this map."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this map contains no key-value mappings."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key==null ? k==null :\n key.equals(k)), then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the\n specified key."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map.\n If the map previously contained a mapping for the key, the old\n value is replaced."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for\n any of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for the specified key from this map if present."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "public V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \n\n Or to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \n\n The mapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n mapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "public V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "public V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this HashMap instance: the keys and\n values themselves are not cloned."
                }
              ]
            }
          ]
        },
        {
          "name": "HashSet<E>",
          "methods": [
            {
              "name": "HashSet",
              "overloads": [
                {
                  "signature": "public HashSet()",
                  "description": "Constructs a new, empty set; the backing HashMap instance has\n default initial capacity (16) and load factor (0.75)."
                },
                {
                  "signature": "public HashSet(Collection<? extends E> c)",
                  "description": "Constructs a new set containing the elements in the specified\n collection.  The HashMap is created with default load factor\n (0.75) and an initial capacity sufficient to contain the elements in\n the specified collection."
                },
                {
                  "signature": "public HashSet(int initialCapacity, float loadFactor)",
                  "description": "Constructs a new, empty set; the backing HashMap instance has\n the specified initial capacity and the specified load factor."
                },
                {
                  "signature": "public HashSet(int initialCapacity)",
                  "description": "Constructs a new, empty set; the backing HashMap instance has\n the specified initial capacity and default load factor (0.75)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this set.  The elements\n are returned in no particular order."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of elements in this set (its cardinality)."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this set contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this set contains the specified element.\n More formally, returns true if and only if this set\n contains an element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Adds the specified element to this set if it is not already present.\n More formally, adds the specified element e to this set if\n this set contains no element e2 such that\n Objects.equals(e, e2).\n If this set already contains the element, the call leaves the set\n unchanged and returns false."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes the specified element from this set if it is present.\n More formally, removes an element e such that\n Objects.equals(o, e),\n if this set contains such an element.  Returns true if\n this set contained the element (or equivalently, if this set\n changed as a result of the call).  (This set will not contain the\n element once the call returns.)"
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this set.\n The set will be empty after this call returns."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this HashSet instance: the elements\n themselves are not cloned."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n set.\n\n The Spliterator reports Spliterator.SIZED and\n Spliterator.DISTINCT.  Overriding implementations should document\n the reporting of additional characteristic values."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Description copied from class:AbstractCollection"
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Description copied from class:AbstractCollection"
                }
              ]
            }
          ]
        },
        {
          "name": "Hashtable<K,V>",
          "methods": [
            {
              "name": "Hashtable",
              "overloads": [
                {
                  "signature": "public Hashtable(int initialCapacity, float loadFactor)",
                  "description": "Constructs a new, empty hashtable with the specified initial\n capacity and the specified load factor."
                },
                {
                  "signature": "public Hashtable(int initialCapacity)",
                  "description": "Constructs a new, empty hashtable with the specified initial capacity\n and default load factor (0.75)."
                },
                {
                  "signature": "public Hashtable()",
                  "description": "Constructs a new, empty hashtable with a default initial capacity (11)\n and load factor (0.75)."
                },
                {
                  "signature": "public Hashtable(Map<? extends K,? extends V> t)",
                  "description": "Constructs a new hashtable with the same mappings as the given\n Map.  The hashtable is created with an initial capacity sufficient to\n hold the mappings in the given Map and a default load factor (0.75)."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of keys in this hashtable."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Tests if this hashtable maps no keys to values."
                }
              ]
            },
            {
              "name": "keys",
              "overloads": [
                {
                  "signature": "public Enumeration<K> keys()",
                  "description": "Returns an enumeration of the keys in this hashtable.\n Use the Enumeration methods on the returned object to fetch the keys\n sequentially. If the hashtable is structurally modified while enumerating\n over the keys then the results of enumerating are undefined."
                }
              ]
            },
            {
              "name": "elements",
              "overloads": [
                {
                  "signature": "public Enumeration<V> elements()",
                  "description": "Returns an enumeration of the values in this hashtable.\n Use the Enumeration methods on the returned object to fetch the elements\n sequentially. If the hashtable is structurally modified while enumerating\n over the values then the results of enumerating are undefined."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object value)",
                  "description": "Tests if some key maps into the specified value in this hashtable.\n This operation is more expensive than the containsKey method.\n\n Note that this method is identical in functionality to\n containsValue, (which is part of the\n Map interface in the collections framework)."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this hashtable maps one or more keys to this value.\n\n Note that this method is identical in functionality to contains (which predates the Map interface)."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Tests if the specified object is a key in this hashtable."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key.equals(k)),\n then this method returns v; otherwise it returns\n null.  (There can be at most one such mapping.)"
                }
              ]
            },
            {
              "name": "rehash",
              "overloads": [
                {
                  "signature": "protected void rehash()",
                  "description": "Increases the capacity of and internally reorganizes this\n hashtable, in order to accommodate and access its entries more\n efficiently.  This method is called automatically when the\n number of keys in the hashtable exceeds this hashtable's capacity\n and load factor."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Maps the specified key to the specified\n value in this hashtable. Neither the key nor the\n value can be null. \n\n The value can be retrieved by calling the get method\n with a key that is equal to the original key."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the key (and its corresponding value) from this\n hashtable. This method does nothing if the key is not in the hashtable."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> t)",
                  "description": "Copies all of the mappings from the specified map to this hashtable.\n These mappings will replace any mappings that this hashtable had for any\n of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Clears this hashtable so that it contains no keys."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates a shallow copy of this hashtable. All the structure of the\n hashtable itself is copied, but the keys and values are not cloned.\n This is a relatively expensive operation."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Hashtable object\n in the form of a set of entries, enclosed in braces and separated\n by the ASCII characters \" ,\" (comma and space). Each\n entry is rendered as the key, an equals sign =, and the\n associated element, where the toString method is used to\n convert the key and element to strings."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified Object with this Map for equality,\n as per the definition in the Map interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this Map as per the definition in the\n Map interface."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "public V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \n\n Or to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \n\n The mapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if the mapping\n function modified this map during computation."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "public V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if the remapping\n function modified this map during computation."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "public V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if the remapping\n function modified this map during computation."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if the remapping\n function modified this map during computation."
                }
              ]
            }
          ]
        },
        {
          "name": "HexFormat",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static HexFormat of()",
                  "description": "Returns a hexadecimal formatter with no delimiter and lowercase characters.\n The delimiter, prefix, and suffix are empty.\n The methods withDelimiter,\n withUpperCase, withLowerCase,\n withPrefix, and withSuffix\n return copies of formatters with new parameters."
                }
              ]
            },
            {
              "name": "ofDelimiter",
              "overloads": [
                {
                  "signature": "public static HexFormat ofDelimiter(String delimiter)",
                  "description": "Returns a hexadecimal formatter with the delimiter and lowercase characters.\n The prefix and suffix are empty.\n The methods withDelimiter,\n withUpperCase, withLowerCase,\n withPrefix, and withSuffix\n return copies of formatters with new parameters."
                }
              ]
            },
            {
              "name": "withDelimiter",
              "overloads": [
                {
                  "signature": "public HexFormat withDelimiter(String delimiter)",
                  "description": "Returns a copy of this HexFormat with the delimiter."
                }
              ]
            },
            {
              "name": "withPrefix",
              "overloads": [
                {
                  "signature": "public HexFormat withPrefix(String prefix)",
                  "description": "Returns a copy of this HexFormat with the prefix."
                }
              ]
            },
            {
              "name": "withSuffix",
              "overloads": [
                {
                  "signature": "public HexFormat withSuffix(String suffix)",
                  "description": "Returns a copy of this HexFormat with the suffix."
                }
              ]
            },
            {
              "name": "withUpperCase",
              "overloads": [
                {
                  "signature": "public HexFormat withUpperCase()",
                  "description": "Returns a copy of this HexFormat to use uppercase hexadecimal characters.\n The uppercase hexadecimal characters are \"0-9\", \"A-F\"."
                }
              ]
            },
            {
              "name": "withLowerCase",
              "overloads": [
                {
                  "signature": "public HexFormat withLowerCase()",
                  "description": "Returns a copy of this HexFormat to use lowercase hexadecimal characters.\n The lowercase hexadecimal characters are \"0-9\", \"a-f\"."
                }
              ]
            },
            {
              "name": "delimiter",
              "overloads": [
                {
                  "signature": "public String delimiter()",
                  "description": "Returns the delimiter between hexadecimal values in formatted hexadecimal strings."
                }
              ]
            },
            {
              "name": "prefix",
              "overloads": [
                {
                  "signature": "public String prefix()",
                  "description": "Returns the prefix used for each hexadecimal value in formatted hexadecimal strings."
                }
              ]
            },
            {
              "name": "suffix",
              "overloads": [
                {
                  "signature": "public String suffix()",
                  "description": "Returns the suffix used for each hexadecimal value in formatted hexadecimal strings."
                }
              ]
            },
            {
              "name": "isUpperCase",
              "overloads": [
                {
                  "signature": "public boolean isUpperCase()",
                  "description": "Returns true if the hexadecimal digits are uppercase,\n otherwise false."
                }
              ]
            },
            {
              "name": "formatHex",
              "overloads": [
                {
                  "signature": "public String formatHex(byte[] bytes)",
                  "description": "Returns a hexadecimal string formatted from a byte array.\n Each byte value is formatted as the prefix, two hexadecimal characters\n selected from uppercase or lowercase digits, and the suffix.\n A delimiter follows each formatted value, except the last.\n\n The behavior is equivalent to\n formatHex(bytes, 0, bytes.length))."
                },
                {
                  "signature": "public String formatHex(byte[] bytes, int fromIndex, int toIndex)",
                  "description": "Returns a hexadecimal string formatted from a byte array range.\n Each byte value is formatted as the prefix, two hexadecimal characters\n selected from uppercase or lowercase digits, and the suffix.\n A delimiter follows each formatted value, except the last."
                },
                {
                  "signature": "public <A extends Appendable> A formatHex(A out, byte[] bytes)",
                  "description": "Appends formatted hexadecimal strings from a byte array to the Appendable.\n Each byte value is formatted as the prefix, two hexadecimal characters\n selected from uppercase or lowercase digits, and the suffix.\n A delimiter follows each formatted value, except the last.\n The formatted hexadecimal strings are appended in zero or more calls to the Appendable methods."
                },
                {
                  "signature": "public <A extends Appendable> A formatHex(A out, byte[] bytes, int fromIndex, int toIndex)",
                  "description": "Appends formatted hexadecimal strings from a byte array range to the Appendable.\n Each byte value is formatted as the prefix, two hexadecimal characters\n selected from uppercase or lowercase digits, and the suffix.\n A delimiter follows each formatted value, except the last.\n The formatted hexadecimal strings are appended in zero or more calls to the Appendable methods."
                }
              ]
            },
            {
              "name": "parseHex",
              "overloads": [
                {
                  "signature": "public byte[] parseHex(CharSequence string)",
                  "description": "Returns a byte array containing hexadecimal values parsed from the string.\n\n Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n and the suffix. A delimiter follows each formatted value, except the last.\n The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n A valid string consists only of the above format."
                },
                {
                  "signature": "public byte[] parseHex(CharSequence string, int fromIndex, int toIndex)",
                  "description": "Returns a byte array containing hexadecimal values parsed from a range of the string.\n\n Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n and the suffix. A delimiter follows each formatted value, except the last.\n The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n A valid string consists only of the above format."
                },
                {
                  "signature": "public byte[] parseHex(char[] chars, int fromIndex, int toIndex)",
                  "description": "Returns a byte array containing hexadecimal values parsed from\n a range of the character array.\n\n Each byte value is parsed from the prefix, two case insensitive hexadecimal characters,\n and the suffix. A delimiter follows each formatted value, except the last.\n The delimiters, prefixes, and suffixes strings must be present; they may be empty strings.\n A valid character array range consists only of the above format."
                }
              ]
            },
            {
              "name": "toLowHexDigit",
              "overloads": [
                {
                  "signature": "public char toLowHexDigit(int value)",
                  "description": "Returns the hexadecimal character for the low 4 bits of the value considering it to be a byte.\n If the parameter isUpperCase() is true the\n character returned for values 10-15 is uppercase \"A-F\",\n otherwise the character returned is lowercase \"a-f\".\n The values in the range 0-9 are returned as \"0-9\"."
                }
              ]
            },
            {
              "name": "toHighHexDigit",
              "overloads": [
                {
                  "signature": "public char toHighHexDigit(int value)",
                  "description": "Returns the hexadecimal character for the high 4 bits of the value considering it to be a byte.\n If the parameter isUpperCase() is true the\n character returned for values 10-15 is uppercase \"A-F\",\n otherwise the character returned is lowercase \"a-f\".\n The values in the range 0-9 are returned as \"0-9\"."
                }
              ]
            },
            {
              "name": "toHexDigits",
              "overloads": [
                {
                  "signature": "public <A extends Appendable> A toHexDigits(A out, byte value)",
                  "description": "Appends two hexadecimal characters for the byte value to the Appendable.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The hexadecimal characters are appended in one or more calls to the\n Appendable methods. The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(byte value)",
                  "description": "Returns the two hexadecimal characters for the byte value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(char value)",
                  "description": "Returns the four hexadecimal characters for the char value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(short value)",
                  "description": "Returns the four hexadecimal characters for the short value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(int value)",
                  "description": "Returns the eight hexadecimal characters for the int value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(long value)",
                  "description": "Returns the sixteen hexadecimal characters for the long value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                },
                {
                  "signature": "public String toHexDigits(long value, int digits)",
                  "description": "Returns up to sixteen hexadecimal characters for the long value.\n Each nibble (4 bits) from most significant to least significant of the value\n is formatted as if by toLowHexDigit(nibble).\n The delimiter, prefix and suffix are not used."
                }
              ]
            },
            {
              "name": "isHexDigit",
              "overloads": [
                {
                  "signature": "public static boolean isHexDigit(int ch)",
                  "description": "Returns true if the character is a valid hexadecimal character or codepoint.\n The valid hexadecimal characters are:\n \n '0' ('\\u0030') through '9' ('\\u0039') inclusive,\n 'A' ('\\u0041') through 'F' ('\\u0046') inclusive, and\n 'a' ('\\u0061') through 'f' ('\\u0066') inclusive."
                }
              ]
            },
            {
              "name": "fromHexDigit",
              "overloads": [
                {
                  "signature": "public static int fromHexDigit(int ch)",
                  "description": "Returns the value for the hexadecimal character or codepoint.\n The value is:\n \n (ch - '0') for '0' through '9' inclusive,\n (ch - 'A' + 10) for 'A' through 'F' inclusive, and\n (ch - 'a' + 10) for 'a' through 'f' inclusive."
                }
              ]
            },
            {
              "name": "fromHexDigits",
              "overloads": [
                {
                  "signature": "public static int fromHexDigits(CharSequence string)",
                  "description": "Returns the int value parsed from a string of up to eight hexadecimal characters.\n The hexadecimal characters are parsed from most significant to least significant\n using fromHexDigit(int) to form an unsigned value.\n The value is zero extended to 32 bits and is returned as an int."
                },
                {
                  "signature": "public static int fromHexDigits(CharSequence string, int fromIndex, int toIndex)",
                  "description": "Returns the int value parsed from a string range of up to eight hexadecimal\n characters.\n The characters in the range fromIndex to toIndex, exclusive,\n are parsed from most significant to least significant\n using fromHexDigit(int) to form an unsigned value.\n The value is zero extended to 32 bits and is returned as an int."
                }
              ]
            },
            {
              "name": "fromHexDigitsToLong",
              "overloads": [
                {
                  "signature": "public static long fromHexDigitsToLong(CharSequence string)",
                  "description": "Returns the long value parsed from a string of up to sixteen hexadecimal characters.\n The hexadecimal characters are parsed from most significant to least significant\n using fromHexDigit(int) to form an unsigned value.\n The value is zero extended to 64 bits and is returned as a long."
                },
                {
                  "signature": "public static long fromHexDigitsToLong(CharSequence string, int fromIndex, int toIndex)",
                  "description": "Returns the long value parsed from a string range of up to sixteen hexadecimal\n characters.\n The characters in the range fromIndex to toIndex, exclusive,\n are parsed from most significant to least significant\n using fromHexDigit(int) to form an unsigned value.\n The value is zero extended to 64 bits and is returned as a long."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Returns true if the other object is a HexFormat\n with the same parameters."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this HexFormat."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a description of the formatter parameters for uppercase,\n delimiter, prefix, and suffix."
                }
              ]
            }
          ]
        },
        {
          "name": "IdentityHashMap<K,V>",
          "methods": [
            {
              "name": "IdentityHashMap",
              "overloads": [
                {
                  "signature": "public IdentityHashMap()",
                  "description": "Constructs a new, empty identity hash map with a default expected\n maximum size (21)."
                },
                {
                  "signature": "public IdentityHashMap(int expectedMaxSize)",
                  "description": "Constructs a new, empty map with the specified expected maximum size.\n Putting more than the expected number of key-value mappings into\n the map may cause the internal data structure to grow, which may be\n somewhat time-consuming."
                },
                {
                  "signature": "public IdentityHashMap(Map<? extends K,? extends V> m)",
                  "description": "Constructs a new identity hash map containing the keys-value mappings\n in the specified map."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this identity hash map."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this identity hash map contains no key-value\n mappings."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key == k),\n then this method returns v; otherwise it returns\n null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Tests whether the specified object reference is a key in this identity\n hash map."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Tests whether the specified object reference is a value in this identity\n hash map."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this identity\n hash map.  If the map previously contained a mapping for the key, the\n old value is replaced."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for\n any of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for this key from this map if present."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent identical object-reference mappings.  More formally, this\n map is equal to another map m if and only if\n this.entrySet().equals(m.entrySet()).\n\n Owing to the reference-equality-based semantics of this map it is\n possible that the symmetry and transitivity requirements of the\n Object.equals contract may be violated if this map is compared\n to a normal map.  However, the Object.equals contract is\n guaranteed to hold among IdentityHashMap instances."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map's\n entrySet() view.  This ensures that m1.equals(m2)\n implies that m1.hashCode()==m2.hashCode() for any two\n IdentityHashMap instances m1 and m2, as\n required by the general contract of Object.hashCode().\n\n Owing to the reference-equality-based semantics of the\n Map.Entry instances in the set returned by this map's\n entrySet method, it is possible that the contractual\n requirement of Object.hashCode mentioned in the previous\n paragraph will be violated if one of the two objects being compared is\n an IdentityHashMap instance and the other is a normal map."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this identity hash map: the keys and values\n themselves are not cloned."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns an identity-based set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are reflected in\n the set, and vice-versa.  If the map is modified while an iteration\n over the set is in progress, the results of the iteration are\n undefined.  The set supports element removal, which removes the\n corresponding mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll, and\n clear methods.  It does not support the add or\n addAll methods.\n\n While the object returned by this method implements the\n Set interface, it does not obey Set's general\n contract.  Like its backing map, the set returned by this method\n defines element equality as reference-equality rather than\n object-equality.  This affects the behavior of its contains,\n remove, containsAll, equals, and\n hashCode methods.\n\n The equals method of the returned set returns true\n only if the specified object is a set containing exactly the same\n object references as the returned set.  The symmetry and transitivity\n requirements of the Object.equals contract may be violated if\n the set returned by this method is compared to a normal set.  However,\n the Object.equals contract is guaranteed to hold among sets\n returned by this method.\n\n The hashCode method of the returned set returns the sum of\n the identity hashcodes of the elements in the set, rather than\n the sum of their hashcodes.  This is mandated by the change in the\n semantics of the equals method, in order to enforce the\n general contract of the Object.hashCode method among sets\n returned by this method."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress,\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear methods.  It does not\n support the add or addAll methods.\n\n While the object returned by this method implements the\n Collection interface, it does not obey\n Collection's general contract.  Like its backing map,\n the collection returned by this method defines element equality as\n reference-equality rather than object-equality.  This affects the\n behavior of its contains, remove and\n containsAll methods."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n Each element in the returned set is a reference-equality-based\n Map.Entry.  The set is backed by the map, so changes\n to the map are reflected in the set, and vice-versa.  If the\n map is modified while an iteration over the set is in progress,\n the results of the iteration are undefined.  The set supports\n element removal, which removes the corresponding mapping from\n the map, via the Iterator.remove, Set.remove,\n removeAll, retainAll and clear\n methods.  It does not support the add or\n addAll methods.\n\n Like the backing map, the Map.Entry objects in the set\n returned by this method define key and value equality as\n reference-equality rather than object-equality.  This affects the\n behavior of the equals and hashCode methods of these\n Map.Entry objects.  A reference-equality based Map.Entry\n e is equal to an object o if and only if o is a\n Map.Entry and e.getKey()==o.getKey() &&\n e.getValue()==o.getValue().  To accommodate these equals\n semantics, the hashCode method returns\n System.identityHashCode(e.getKey()) ^\n System.identityHashCode(e.getValue()).\n\n Owing to the reference-equality-based semantics of the\n Map.Entry instances in the set returned by this method,\n it is possible that the symmetry and transitivity requirements of\n the Object.equals(Object) contract may be violated if any of\n the entries in the set is compared to a normal map entry, or if\n the set returned by this method is compared to a set of normal map\n entries (such as would be returned by a call to this method on a normal\n map).  However, the Object.equals contract is guaranteed to\n hold among identity-based map entries, and among sets of such entries."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalFormatCodePointException",
          "methods": [
            {
              "name": "IllegalFormatCodePointException",
              "overloads": [
                {
                  "signature": "public IllegalFormatCodePointException(int c)",
                  "description": "Constructs an instance of this class with the specified illegal code\n point as defined by Character.isValidCodePoint(int)."
                }
              ]
            },
            {
              "name": "getCodePoint",
              "overloads": [
                {
                  "signature": "public int getCodePoint()",
                  "description": "Returns the illegal code point as defined by Character.isValidCodePoint(int)."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalFormatConversionException",
          "methods": [
            {
              "name": "IllegalFormatConversionException",
              "overloads": [
                {
                  "signature": "public IllegalFormatConversionException(char c, Class<?> arg)",
                  "description": "Constructs an instance of this class with the mismatched conversion and\n the corresponding argument class."
                }
              ]
            },
            {
              "name": "getConversion",
              "overloads": [
                {
                  "signature": "public char getConversion()",
                  "description": "Returns the inapplicable conversion."
                }
              ]
            },
            {
              "name": "getArgumentClass",
              "overloads": [
                {
                  "signature": "public Class<?> getArgumentClass()",
                  "description": "Returns the class of the mismatched argument."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalFormatException",
          "methods": []
        },
        {
          "name": "IllegalFormatFlagsException",
          "methods": [
            {
              "name": "IllegalFormatFlagsException",
              "overloads": [
                {
                  "signature": "public IllegalFormatFlagsException(String f)",
                  "description": "Constructs an instance of this class with the specified flags."
                }
              ]
            },
            {
              "name": "getFlags",
              "overloads": [
                {
                  "signature": "public String getFlags()",
                  "description": "Returns the set of flags which contains an illegal combination."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalFormatPrecisionException",
          "methods": [
            {
              "name": "IllegalFormatPrecisionException",
              "overloads": [
                {
                  "signature": "public IllegalFormatPrecisionException(int p)",
                  "description": "Constructs an instance of this class with the specified precision."
                }
              ]
            },
            {
              "name": "getPrecision",
              "overloads": [
                {
                  "signature": "public int getPrecision()",
                  "description": "Returns the precision. If the precision isn't representable by an\n int, then will return Integer.MIN_VALUE."
                }
              ]
            }
          ]
        },
        {
          "name": "IllegalFormatWidthException",
          "methods": [
            {
              "name": "IllegalFormatWidthException",
              "overloads": [
                {
                  "signature": "public IllegalFormatWidthException(int w)",
                  "description": "Constructs an instance of this class with the specified width."
                }
              ]
            },
            {
              "name": "getWidth",
              "overloads": [
                {
                  "signature": "public int getWidth()",
                  "description": "Returns the width. If the width is not representable by an int,\n then returns Integer.MIN_VALUE."
                }
              ]
            }
          ]
        },
        {
          "name": "IllformedLocaleException",
          "methods": [
            {
              "name": "IllformedLocaleException",
              "overloads": [
                {
                  "signature": "public IllformedLocaleException()",
                  "description": "Constructs a new IllformedLocaleException with no\n detail message and -1 as the error index."
                },
                {
                  "signature": "public IllformedLocaleException(String message)",
                  "description": "Constructs a new IllformedLocaleException with the\n given message and -1 as the error index."
                },
                {
                  "signature": "public IllformedLocaleException(String message, int errorIndex)",
                  "description": "Constructs a new IllformedLocaleException with the\n given message and the error index.  The error index is the approximate\n offset from the start of the ill-formed value to the point where the\n parse first detected an error.  A negative error index value indicates\n either the error index is not applicable or unknown."
                }
              ]
            },
            {
              "name": "getErrorIndex",
              "overloads": [
                {
                  "signature": "public int getErrorIndex()",
                  "description": "Returns the index where the error was found. A negative value indicates\n either the error index is not applicable or unknown."
                }
              ]
            }
          ]
        },
        {
          "name": "InputMismatchException",
          "methods": [
            {
              "name": "InputMismatchException",
              "overloads": [
                {
                  "signature": "public InputMismatchException()",
                  "description": "Constructs an InputMismatchException with null\n as its error message string."
                },
                {
                  "signature": "public InputMismatchException(String s)",
                  "description": "Constructs an InputMismatchException, saving a reference\n to the error message string s for later retrieval by the\n getMessage method."
                }
              ]
            }
          ]
        },
        {
          "name": "IntSummaryStatistics",
          "methods": [
            {
              "name": "IntSummaryStatistics",
              "overloads": [
                {
                  "signature": "public IntSummaryStatistics()",
                  "description": "Constructs an empty instance with zero count, zero sum,\n Integer.MAX_VALUE min, Integer.MIN_VALUE max and zero\n average."
                },
                {
                  "signature": "public IntSummaryStatistics(long count, int min, int max, long sum) throws IllegalArgumentException",
                  "description": "Constructs a non-empty instance with the specified count,\n min, max, and sum.\n\n If count is zero then the remaining arguments are ignored and\n an empty instance is constructed.\n\n If the arguments are inconsistent then an IllegalArgumentException\n is thrown.  The necessary consistent argument conditions are:\n \n   count >= 0\n   min <= max"
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "public void accept(int value)",
                  "description": "Records a new value into the summary information"
                }
              ]
            },
            {
              "name": "combine",
              "overloads": [
                {
                  "signature": "public void combine(IntSummaryStatistics other)",
                  "description": "Combines the state of another IntSummaryStatistics into this one."
                }
              ]
            },
            {
              "name": "getCount",
              "overloads": [
                {
                  "signature": "public final long getCount()",
                  "description": "Returns the count of values recorded."
                }
              ]
            },
            {
              "name": "getSum",
              "overloads": [
                {
                  "signature": "public final long getSum()",
                  "description": "Returns the sum of values recorded, or zero if no values have been\n recorded."
                }
              ]
            },
            {
              "name": "getMin",
              "overloads": [
                {
                  "signature": "public final int getMin()",
                  "description": "Returns the minimum value recorded, or Integer.MAX_VALUE if no\n values have been recorded."
                }
              ]
            },
            {
              "name": "getMax",
              "overloads": [
                {
                  "signature": "public final int getMax()",
                  "description": "Returns the maximum value recorded, or Integer.MIN_VALUE if no\n values have been recorded."
                }
              ]
            },
            {
              "name": "getAverage",
              "overloads": [
                {
                  "signature": "public final double getAverage()",
                  "description": "Returns the arithmetic mean of values recorded, or zero if no values have been\n recorded."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this object suitable for\n debugging. The exact presentation format is unspecified and may vary\n between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidPropertiesFormatException",
          "methods": [
            {
              "name": "InvalidPropertiesFormatException",
              "overloads": [
                {
                  "signature": "public InvalidPropertiesFormatException(Throwable cause)",
                  "description": "Constructs an InvalidPropertiesFormatException with the specified\n cause."
                },
                {
                  "signature": "public InvalidPropertiesFormatException(String message)",
                  "description": "Constructs an InvalidPropertiesFormatException with the specified\n detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "Iterator<E>",
          "methods": [
            {
              "name": "hasNext",
              "overloads": [
                {
                  "signature": "boolean hasNext()",
                  "description": "Returns true if the iteration has more elements.\n (In other words, returns true if next() would\n return an element rather than throwing an exception.)"
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "E next()",
                  "description": "Returns the next element in the iteration."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "default void remove()",
                  "description": "Removes from the underlying collection the last element returned\n by this iterator (optional operation).  This method can be called\n only once per call to next().\n \n The behavior of an iterator is unspecified if the underlying collection\n is modified while the iteration is in progress in any way other than by\n calling this method, unless an overriding class has specified a\n concurrent modification policy.\n \n The behavior of an iterator is unspecified if this method is called\n after a call to the forEachRemaining method."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(Consumer<? super E> action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n collection in any way (even by calling the remove method\n or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                }
              ]
            }
          ]
        },
        {
          "name": "LinkedHashMap<K,V>",
          "methods": [
            {
              "name": "LinkedHashMap",
              "overloads": [
                {
                  "signature": "public LinkedHashMap(int initialCapacity, float loadFactor)",
                  "description": "Constructs an empty insertion-ordered LinkedHashMap instance\n with the specified initial capacity and load factor."
                },
                {
                  "signature": "public LinkedHashMap(int initialCapacity)",
                  "description": "Constructs an empty insertion-ordered LinkedHashMap instance\n with the specified initial capacity and a default load factor (0.75)."
                },
                {
                  "signature": "public LinkedHashMap()",
                  "description": "Constructs an empty insertion-ordered LinkedHashMap instance\n with the default initial capacity (16) and load factor (0.75)."
                },
                {
                  "signature": "public LinkedHashMap(Map<? extends K,? extends V> m)",
                  "description": "Constructs an insertion-ordered LinkedHashMap instance with\n the same mappings as the specified map.  The LinkedHashMap\n instance is created with a default load factor (0.75) and an initial\n capacity sufficient to hold the mappings in the specified map."
                },
                {
                  "signature": "public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)",
                  "description": "Constructs an empty LinkedHashMap instance with the\n specified initial capacity, load factor and ordering mode."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key==null ? k==null :\n key.equals(k)), then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "removeEldestEntry",
              "overloads": [
                {
                  "signature": "protected boolean removeEldestEntry(Map.Entry<K,V> eldest)",
                  "description": "Returns true if this map should remove its eldest entry.\n This method is invoked by put and putAll after\n inserting a new entry into the map.  It provides the implementor\n with the opportunity to remove the eldest entry each time a new one\n is added.  This is useful if the map represents a cache: it allows\n the map to reduce memory consumption by deleting stale entries.\n\n Sample use: this override will allow the map to grow up to 100\n entries and then delete the eldest entry each time a new entry is\n added, maintaining a steady state of 100 entries.\n      private static final int MAX_ENTRIES = 100;\n\n     protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() > MAX_ENTRIES;\n     }\n \n\n This method typically does not modify the map in any way,\n instead allowing the map to modify itself as directed by its\n return value.  It is permitted for this method to modify\n the map directly, but if it does so, it must return\n false (indicating that the map should not attempt any\n further modification).  The effects of returning true\n after modifying the map from within this method are unspecified.\n\n This implementation merely returns false (so that this\n map acts like a normal map - the eldest element is never removed)."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations.\n Its Spliterator typically provides faster sequential\n performance but much poorer parallel performance than that of\n HashMap."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations.\n Its Spliterator typically provides faster sequential\n performance but much poorer parallel performance than that of\n HashMap."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations.\n Its Spliterator typically provides faster sequential\n performance but much poorer parallel performance than that of\n HashMap."
                }
              ]
            }
          ]
        },
        {
          "name": "LinkedHashSet<E>",
          "methods": [
            {
              "name": "LinkedHashSet",
              "overloads": [
                {
                  "signature": "public LinkedHashSet(int initialCapacity, float loadFactor)",
                  "description": "Constructs a new, empty linked hash set with the specified initial\n capacity and load factor."
                },
                {
                  "signature": "public LinkedHashSet(int initialCapacity)",
                  "description": "Constructs a new, empty linked hash set with the specified initial\n capacity and the default load factor (0.75)."
                },
                {
                  "signature": "public LinkedHashSet()",
                  "description": "Constructs a new, empty linked hash set with the default initial\n capacity (16) and load factor (0.75)."
                },
                {
                  "signature": "public LinkedHashSet(Collection<? extends E> c)",
                  "description": "Constructs a new linked hash set with the same elements as the\n specified collection.  The linked hash set is created with an initial\n capacity sufficient to hold the elements in the specified collection\n and the default load factor (0.75)."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this set.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.DISTINCT, and ORDERED.  Implementations\n should document the reporting of additional characteristic values."
                }
              ]
            }
          ]
        },
        {
          "name": "LinkedList<E>",
          "methods": [
            {
              "name": "LinkedList",
              "overloads": [
                {
                  "signature": "public LinkedList()",
                  "description": "Constructs an empty list."
                },
                {
                  "signature": "public LinkedList(Collection<? extends E> c)",
                  "description": "Constructs a list containing the elements of the specified\n collection, in the order they are returned by the collection's\n iterator."
                }
              ]
            },
            {
              "name": "getFirst",
              "overloads": [
                {
                  "signature": "public E getFirst()",
                  "description": "Returns the first element in this list."
                }
              ]
            },
            {
              "name": "getLast",
              "overloads": [
                {
                  "signature": "public E getLast()",
                  "description": "Returns the last element in this list."
                }
              ]
            },
            {
              "name": "removeFirst",
              "overloads": [
                {
                  "signature": "public E removeFirst()",
                  "description": "Removes and returns the first element from this list."
                }
              ]
            },
            {
              "name": "removeLast",
              "overloads": [
                {
                  "signature": "public E removeLast()",
                  "description": "Removes and returns the last element from this list."
                }
              ]
            },
            {
              "name": "addFirst",
              "overloads": [
                {
                  "signature": "public void addFirst(E e)",
                  "description": "Inserts the specified element at the beginning of this list."
                }
              ]
            },
            {
              "name": "addLast",
              "overloads": [
                {
                  "signature": "public void addLast(E e)",
                  "description": "Appends the specified element to the end of this list.\n\n This method is equivalent to add(E)."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this list contains the specified element.\n More formally, returns true if and only if this list contains\n at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of elements in this list."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Appends the specified element to the end of this list.\n\n This method is equivalent to addLast(E)."
                },
                {
                  "signature": "public void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this list.\n Shifts the element currently at that position (if any) and any\n subsequent elements to the right (adds one to their indices)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element from this list,\n if it is present.  If this list does not contain the element, it is\n unchanged.  More formally, removes the element with the lowest index\n i such that\n Objects.equals(o, get(i))\n (if such an element exists).  Returns true if this list\n contained the specified element (or equivalently, if this list\n changed as a result of the call)."
                },
                {
                  "signature": "public E remove(int index)",
                  "description": "Removes the element at the specified position in this list.  Shifts any\n subsequent elements to the left (subtracts one from their indices).\n Returns the element that was removed from the list."
                },
                {
                  "signature": "public E remove()",
                  "description": "Retrieves and removes the head (first element) of this list."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the specified\n collection's iterator.  The behavior of this operation is undefined if\n the specified collection is modified while the operation is in\n progress.  (Note that this will occur if the specified collection is\n this list, and it's nonempty.)"
                },
                {
                  "signature": "public boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.  Shifts the element\n currently at that position (if any) and any subsequent elements to\n the right (increases their indices).  The new elements will appear\n in the list in the order that they are returned by the\n specified collection's iterator."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this list.\n The list will be empty after this call returns."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public E get(int index)",
                  "description": "Returns the element at the specified position in this list."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with the\n specified element."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "public E peek()",
                  "description": "Retrieves, but does not remove, the head (first element) of this list."
                }
              ]
            },
            {
              "name": "element",
              "overloads": [
                {
                  "signature": "public E element()",
                  "description": "Retrieves, but does not remove, the head (first element) of this list."
                }
              ]
            },
            {
              "name": "poll",
              "overloads": [
                {
                  "signature": "public E poll()",
                  "description": "Retrieves and removes the head (first element) of this list."
                }
              ]
            },
            {
              "name": "offer",
              "overloads": [
                {
                  "signature": "public boolean offer(E e)",
                  "description": "Adds the specified element as the tail (last element) of this list."
                }
              ]
            },
            {
              "name": "offerFirst",
              "overloads": [
                {
                  "signature": "public boolean offerFirst(E e)",
                  "description": "Inserts the specified element at the front of this list."
                }
              ]
            },
            {
              "name": "offerLast",
              "overloads": [
                {
                  "signature": "public boolean offerLast(E e)",
                  "description": "Inserts the specified element at the end of this list."
                }
              ]
            },
            {
              "name": "peekFirst",
              "overloads": [
                {
                  "signature": "public E peekFirst()",
                  "description": "Retrieves, but does not remove, the first element of this list,\n or returns null if this list is empty."
                }
              ]
            },
            {
              "name": "peekLast",
              "overloads": [
                {
                  "signature": "public E peekLast()",
                  "description": "Retrieves, but does not remove, the last element of this list,\n or returns null if this list is empty."
                }
              ]
            },
            {
              "name": "pollFirst",
              "overloads": [
                {
                  "signature": "public E pollFirst()",
                  "description": "Retrieves and removes the first element of this list,\n or returns null if this list is empty."
                }
              ]
            },
            {
              "name": "pollLast",
              "overloads": [
                {
                  "signature": "public E pollLast()",
                  "description": "Retrieves and removes the last element of this list,\n or returns null if this list is empty."
                }
              ]
            },
            {
              "name": "push",
              "overloads": [
                {
                  "signature": "public void push(E e)",
                  "description": "Pushes an element onto the stack represented by this list.  In other\n words, inserts the element at the front of this list.\n\n This method is equivalent to addFirst(E)."
                }
              ]
            },
            {
              "name": "pop",
              "overloads": [
                {
                  "signature": "public E pop()",
                  "description": "Pops an element from the stack represented by this list.  In other\n words, removes and returns the first element of this list.\n\n This method is equivalent to removeFirst()."
                }
              ]
            },
            {
              "name": "removeFirstOccurrence",
              "overloads": [
                {
                  "signature": "public boolean removeFirstOccurrence(Object o)",
                  "description": "Removes the first occurrence of the specified element in this\n list (when traversing the list from head to tail).  If the list\n does not contain the element, it is unchanged."
                }
              ]
            },
            {
              "name": "removeLastOccurrence",
              "overloads": [
                {
                  "signature": "public boolean removeLastOccurrence(Object o)",
                  "description": "Removes the last occurrence of the specified element in this\n list (when traversing the list from head to tail).  If the list\n does not contain the element, it is unchanged."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "public ListIterator<E> listIterator(int index)",
                  "description": "Returns a list-iterator of the elements in this list (in proper\n sequence), starting at the specified position in the list.\n Obeys the general contract of List.listIterator(int).\n\n The list-iterator is fail-fast: if the list is structurally\n modified at any time after the Iterator is created, in any way except\n through the list-iterator's own remove or add\n methods, the list-iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future."
                }
              ]
            },
            {
              "name": "descendingIterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> descendingIterator()",
                  "description": "Description copied from interface:Deque"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this LinkedList. (The elements\n themselves are not cloned.)"
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this list\n in proper sequence (from first to last element).\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this list.  (In other words, this method must allocate\n a new array).  The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this list in\n proper sequence (from first to last element); the runtime type of\n the returned array is that of the specified array.  If the list fits\n in the specified array, it is returned therein.  Otherwise, a new\n array is allocated with the runtime type of the specified array and\n the size of this list.\n\n If the list fits in the specified array with room to spare (i.e.,\n the array has more elements than the list), the element in the array\n immediately following the end of the list is set to null.\n (This is useful in determining the length of the list only if\n the caller knows that the list does not contain any null elements.)\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a list known to contain only strings.\n The following code can be used to dump the list into a newly\n allocated array of String:\n\n      String[] y = x.toArray(new String[0]);\n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.\n\n The Spliterator reports Spliterator.SIZED and\n Spliterator.ORDERED.  Overriding implementations should document\n the reporting of additional characteristic values."
                }
              ]
            }
          ]
        },
        {
          "name": "List<E>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this list.  If this list contains\n more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this list contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this list contains the specified element.\n More formally, returns true if and only if this list contains\n at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list in proper sequence."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this list in proper\n sequence (from first to last element).\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this list.  (In other words, this method must\n allocate a new array even if this list is backed by an array).\n The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "<T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this list in\n proper sequence (from first to last element); the runtime type of\n the returned array is that of the specified array.  If the list fits\n in the specified array, it is returned therein.  Otherwise, a new\n array is allocated with the runtime type of the specified array and\n the size of this list.\n\n If the list fits in the specified array with room to spare (i.e.,\n the array has more elements than the list), the element in the array\n immediately following the end of the list is set to null.\n (This is useful in determining the length of the list only if\n the caller knows that the list does not contain any null elements.)\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a list known to contain only strings.\n The following code can be used to dump the list into a newly\n allocated array of String:\n\n \n     String[] y = x.toArray(new String[0]);\n \n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Appends the specified element to the end of this list (optional\n operation).\n\n Lists that support this operation may place limitations on what\n elements may be added to this list.  In particular, some\n lists will refuse to add null elements, and others will impose\n restrictions on the type of elements that may be added.  List\n classes should clearly specify in their documentation any restrictions\n on what elements may be added."
                },
                {
                  "signature": "void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this list\n (optional operation).  Shifts the element currently at that position\n (if any) and any subsequent elements to the right (adds one to their\n indices)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element from this list,\n if it is present (optional operation).  If this list does not contain\n the element, it is unchanged.  More formally, removes the element with\n the lowest index i such that\n Objects.equals(o, get(i))\n (if such an element exists).  Returns true if this list\n contained the specified element (or equivalently, if this list changed\n as a result of the call)."
                },
                {
                  "signature": "E remove(int index)",
                  "description": "Removes the element at the specified position in this list (optional\n operation).  Shifts any subsequent elements to the left (subtracts one\n from their indices).  Returns the element that was removed from the\n list."
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this list contains all of the elements of the\n specified collection."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the specified\n collection's iterator (optional operation).  The behavior of this\n operation is undefined if the specified collection is modified while\n the operation is in progress.  (Note that this will occur if the\n specified collection is this list, and it's nonempty.)"
                },
                {
                  "signature": "boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified collection into this\n list at the specified position (optional operation).  Shifts the\n element currently at that position (if any) and any subsequent\n elements to the right (increases their indices).  The new elements\n will appear in this list in the order that they are returned by the\n specified collection's iterator.  The behavior of this operation is\n undefined if the specified collection is modified while the\n operation is in progress.  (Note that this will occur if the specified\n collection is this list, and it's nonempty.)"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll(Collection<?> c)",
                  "description": "Removes from this list all of its elements that are contained in the\n specified collection (optional operation)."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this list that are contained in the\n specified collection (optional operation).  In other words, removes\n from this list all of its elements that are not contained in the\n specified collection."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "default void replaceAll(UnaryOperator<E> operator)",
                  "description": "Replaces each element of this list with the result of applying the\n operator to that element.  Errors or runtime exceptions thrown by\n the operator are relayed to the caller."
                }
              ]
            },
            {
              "name": "sort",
              "overloads": [
                {
                  "signature": "default void sort(Comparator<? super E> c)",
                  "description": "Sorts this list according to the order induced by the specified\n Comparator.  The sort is stable: this method must not\n reorder equal elements.\n\n All elements in this list must be mutually comparable using the\n specified comparator (that is, c.compare(e1, e2) must not throw\n a ClassCastException for any elements e1 and e2\n in the list).\n\n If the specified comparator is null then all elements in this\n list must implement the Comparable interface and the elements'\n natural ordering should be used.\n\n This list must be modifiable, but need not be resizable."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the elements from this list (optional operation).\n The list will be empty after this call returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this list for equality.  Returns\n true if and only if the specified object is also a list, both\n lists have the same size, and all corresponding pairs of elements in\n the two lists are equal.  (Two elements e1 and\n e2 are equal if Objects.equals(e1, e2).)\n In other words, two lists are defined to be\n equal if they contain the same elements in the same order.  This\n definition ensures that the equals method works properly across\n different implementations of the List interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this list.  The hash code of a list\n is defined to be the result of the following calculation:\n \n     int hashCode = 1;\n     for (E e : list)\n         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n \n This ensures that list1.equals(list2) implies that\n list1.hashCode()==list2.hashCode() for any two lists,\n list1 and list2, as required by the general\n contract of Object.hashCode()."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "E get(int index)",
                  "description": "Returns the element at the specified position in this list."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this list with the\n specified element (optional operation)."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "ListIterator<E> listIterator()",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence)."
                },
                {
                  "signature": "ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.\n The specified index indicates the first element that would be\n returned by an initial call to next.\n An initial call to previous would\n return the element with the specified index minus one."
                }
              ]
            },
            {
              "name": "subList",
              "overloads": [
                {
                  "signature": "List<E> subList(int fromIndex, int toIndex)",
                  "description": "Returns a view of the portion of this list between the specified\n fromIndex, inclusive, and toIndex, exclusive.  (If\n fromIndex and toIndex are equal, the returned list is\n empty.)  The returned list is backed by this list, so non-structural\n changes in the returned list are reflected in this list, and vice-versa.\n The returned list supports all of the optional list operations supported\n by this list.\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a list can be used as a range operation by passing a subList view\n instead of a whole list.  For example, the following idiom\n removes a range of elements from a list:\n \n      list.subList(from, to).clear();\n \n Similar idioms may be constructed for indexOf and\n lastIndexOf, and all of the algorithms in the\n Collections class can be applied to a subList.\n\n The semantics of the list returned by this method become undefined if\n the backing list (i.e., this list) is structurally modified in\n any way other than via the returned list.  (Structural modifications are\n those that change the size of this list, or otherwise perturb it in such\n a fashion that iterations in progress may yield incorrect results.)"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this list.\n\n The Spliterator reports Spliterator.SIZED and\n Spliterator.ORDERED.  Implementations should document the\n reporting of additional characteristic values."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <E> List<E> of()",
                  "description": "Returns an unmodifiable list containing zero elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1)",
                  "description": "Returns an unmodifiable list containing one element.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2)",
                  "description": "Returns an unmodifiable list containing two elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3)",
                  "description": "Returns an unmodifiable list containing three elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4)",
                  "description": "Returns an unmodifiable list containing four elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5)",
                  "description": "Returns an unmodifiable list containing five elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6)",
                  "description": "Returns an unmodifiable list containing six elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)",
                  "description": "Returns an unmodifiable list containing seven elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)",
                  "description": "Returns an unmodifiable list containing eight elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)",
                  "description": "Returns an unmodifiable list containing nine elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)",
                  "description": "Returns an unmodifiable list containing ten elements.\n\n See Unmodifiable Lists for details."
                },
                {
                  "signature": "@SafeVarargs static <E> List<E> of(E... elements)",
                  "description": "Returns an unmodifiable list containing an arbitrary number of elements.\n See Unmodifiable Lists for details."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <E> List<E> copyOf(Collection<? extends E> coll)",
                  "description": "Returns an unmodifiable List containing the elements of\n the given Collection, in its iteration order. The given Collection must not be null,\n and it must not contain any null elements. If the given Collection is subsequently\n modified, the returned List will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "ListIterator<E>",
          "methods": [
            {
              "name": "hasNext",
              "overloads": [
                {
                  "signature": "boolean hasNext()",
                  "description": "Returns true if this list iterator has more elements when\n traversing the list in the forward direction. (In other words,\n returns true if next() would return an element rather\n than throwing an exception.)"
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "E next()",
                  "description": "Returns the next element in the list and advances the cursor position.\n This method may be called repeatedly to iterate through the list,\n or intermixed with calls to previous() to go back and forth.\n (Note that alternating calls to next and previous\n will return the same element repeatedly.)"
                }
              ]
            },
            {
              "name": "hasPrevious",
              "overloads": [
                {
                  "signature": "boolean hasPrevious()",
                  "description": "Returns true if this list iterator has more elements when\n traversing the list in the reverse direction.  (In other words,\n returns true if previous() would return an element\n rather than throwing an exception.)"
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "E previous()",
                  "description": "Returns the previous element in the list and moves the cursor\n position backwards.  This method may be called repeatedly to\n iterate through the list backwards, or intermixed with calls to\n next() to go back and forth.  (Note that alternating calls\n to next and previous will return the same\n element repeatedly.)"
                }
              ]
            },
            {
              "name": "nextIndex",
              "overloads": [
                {
                  "signature": "int nextIndex()",
                  "description": "Returns the index of the element that would be returned by a\n subsequent call to next(). (Returns list size if the list\n iterator is at the end of the list.)"
                }
              ]
            },
            {
              "name": "previousIndex",
              "overloads": [
                {
                  "signature": "int previousIndex()",
                  "description": "Returns the index of the element that would be returned by a\n subsequent call to previous(). (Returns -1 if the list\n iterator is at the beginning of the list.)"
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "void remove()",
                  "description": "Removes from the list the last element that was returned by next() or previous() (optional operation).  This call can\n only be made once per call to next or previous.\n It can be made only if add(E) has not been\n called after the last call to next or previous."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "void set(E e)",
                  "description": "Replaces the last element returned by next() or\n previous() with the specified element (optional operation).\n This call can be made only if neither remove() nor add(E) have been called after the last call to next or\n previous."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "void add(E e)",
                  "description": "Inserts the specified element into the list (optional operation).\n The element is inserted immediately before the element that\n would be returned by next(), if any, and after the element\n that would be returned by previous(), if any.  (If the\n list contains no elements, the new element becomes the sole element\n on the list.)  The new element is inserted before the implicit\n cursor: a subsequent call to next would be unaffected, and a\n subsequent call to previous would return the new element.\n (This call increases by one the value that would be returned by a\n call to nextIndex or previousIndex.)"
                }
              ]
            }
          ]
        },
        {
          "name": "ListResourceBundle",
          "methods": [
            {
              "name": "ListResourceBundle",
              "overloads": [
                {
                  "signature": "public ListResourceBundle()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "handleGetObject",
              "overloads": [
                {
                  "signature": "public final Object handleGetObject(String key)",
                  "description": "Description copied from class:ResourceBundle"
                }
              ]
            },
            {
              "name": "getKeys",
              "overloads": [
                {
                  "signature": "public Enumeration<String> getKeys()",
                  "description": "Returns an Enumeration of the keys contained in\n this ResourceBundle and its parent bundles."
                }
              ]
            },
            {
              "name": "handleKeySet",
              "overloads": [
                {
                  "signature": "protected Set<String> handleKeySet()",
                  "description": "Returns a Set of the keys contained\n only in this ResourceBundle."
                }
              ]
            },
            {
              "name": "getContents",
              "overloads": [
                {
                  "signature": "protected abstract Object[][] getContents()",
                  "description": "Returns an array in which each item is a pair of objects in an\n Object array. The first element of each pair is\n the key, which must be a String, and the second\n element is the value associated with that key.  See the class\n description for details."
                }
              ]
            }
          ]
        },
        {
          "name": "Locale",
          "methods": [
            {
              "name": "Locale",
              "overloads": [
                {
                  "signature": "public Locale(String language, String country, String variant)",
                  "description": "Construct a locale from language, country and variant.\n This constructor normalizes the language value to lowercase and\n the country value to uppercase."
                },
                {
                  "signature": "public Locale(String language, String country)",
                  "description": "Construct a locale from language and country.\n This constructor normalizes the language value to lowercase and\n the country value to uppercase."
                },
                {
                  "signature": "public Locale(String language)",
                  "description": "Construct a locale from a language code.\n This constructor normalizes the language value to lowercase."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static Locale getDefault()",
                  "description": "Gets the current value of the default locale for this instance\n of the Java Virtual Machine.\n \n The Java Virtual Machine sets the default locale during startup\n based on the host environment. It is used by many locale-sensitive\n methods if no locale is explicitly specified.\n It can be changed using the\n setDefault method."
                },
                {
                  "signature": "public static Locale getDefault(Locale.Category category)",
                  "description": "Gets the current value of the default locale for the specified Category\n for this instance of the Java Virtual Machine.\n \n The Java Virtual Machine sets the default locale during startup based\n on the host environment. It is used by many locale-sensitive methods\n if no locale is explicitly specified. It can be changed using the\n setDefault(Locale.Category, Locale) method."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(Locale newLocale)",
                  "description": "Sets the default locale for this instance of the Java Virtual Machine.\n This does not affect the host locale.\n \n If there is a security manager, its checkPermission\n method is called with a PropertyPermission(\"user.language\", \"write\")\n permission before the default locale is changed.\n \n The Java Virtual Machine sets the default locale during startup\n based on the host environment. It is used by many locale-sensitive\n methods if no locale is explicitly specified.\n \n Since changing the default locale may affect many different areas\n of functionality, this method should only be used if the caller\n is prepared to reinitialize locale-sensitive code running\n within the same Java Virtual Machine.\n \n By setting the default locale with this method, all of the default\n locales for each Category are also set to the specified default locale."
                },
                {
                  "signature": "public static void setDefault(Locale.Category category, Locale newLocale)",
                  "description": "Sets the default locale for the specified Category for this instance\n of the Java Virtual Machine. This does not affect the host locale.\n \n If there is a security manager, its checkPermission method is called\n with a PropertyPermission(\"user.language\", \"write\") permission before\n the default locale is changed.\n \n The Java Virtual Machine sets the default locale during startup based\n on the host environment. It is used by many locale-sensitive methods\n if no locale is explicitly specified.\n \n Since changing the default locale may affect many different areas of\n functionality, this method should only be used if the caller is\n prepared to reinitialize locale-sensitive code running within the\n same Java Virtual Machine."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all installed locales.\n The returned array represents the union of locales supported\n by the Java runtime environment and by installed\n LocaleServiceProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getISOCountries",
              "overloads": [
                {
                  "signature": "public static String[] getISOCountries()",
                  "description": "Returns a list of all 2-letter country codes defined in ISO 3166.\n Can be used to create Locales.\n This method is equivalent to getISOCountries(Locale.IsoCountryCode type)\n with type  Locale.IsoCountryCode.PART1_ALPHA2.\n \n Note: The Locale class also supports other codes for\n country (region), such as 3-letter numeric UN M.49 area codes.\n Therefore, the list returned by this method does not contain ALL valid\n codes that can be used to create Locales.\n \n Note that this method does not return obsolete 2-letter country codes.\n ISO3166-3 codes which designate country codes for those obsolete codes,\n can be retrieved from getISOCountries(Locale.IsoCountryCode type) with\n type  Locale.IsoCountryCode.PART3."
                },
                {
                  "signature": "public static Set<String> getISOCountries(Locale.IsoCountryCode type)",
                  "description": "Returns a Set of ISO3166 country codes for the specified type."
                }
              ]
            },
            {
              "name": "getISOLanguages",
              "overloads": [
                {
                  "signature": "public static String[] getISOLanguages()",
                  "description": "Returns a list of all 2-letter language codes defined in ISO 639.\n Can be used to create Locales.\n \n Note:\n \n ISO 639 is not a stable standard some languages' codes have changed.\n The list this function returns includes both the new and the old codes for the\n languages whose codes have changed.\n The Locale class also supports language codes up to\n 8 characters in length.  Therefore, the list returned by this method does\n not contain ALL valid codes that can be used to create Locales."
                }
              ]
            },
            {
              "name": "getLanguage",
              "overloads": [
                {
                  "signature": "public String getLanguage()",
                  "description": "Returns the language code of this Locale."
                }
              ]
            },
            {
              "name": "getScript",
              "overloads": [
                {
                  "signature": "public String getScript()",
                  "description": "Returns the script for this locale, which should\n either be the empty string or an ISO 15924 4-letter script\n code. The first letter is uppercase and the rest are\n lowercase, for example, 'Latn', 'Cyrl'."
                }
              ]
            },
            {
              "name": "getCountry",
              "overloads": [
                {
                  "signature": "public String getCountry()",
                  "description": "Returns the country/region code for this locale, which should\n either be the empty string, an uppercase ISO 3166 2-letter code,\n or a UN M.49 3-digit code."
                }
              ]
            },
            {
              "name": "getVariant",
              "overloads": [
                {
                  "signature": "public String getVariant()",
                  "description": "Returns the variant code for this locale."
                }
              ]
            },
            {
              "name": "hasExtensions",
              "overloads": [
                {
                  "signature": "public boolean hasExtensions()",
                  "description": "Returns true if this Locale has any \n extensions."
                }
              ]
            },
            {
              "name": "stripExtensions",
              "overloads": [
                {
                  "signature": "public Locale stripExtensions()",
                  "description": "Returns a copy of this Locale with no \n extensions. If this Locale has no extensions, this Locale\n is returned."
                }
              ]
            },
            {
              "name": "getExtension",
              "overloads": [
                {
                  "signature": "public String getExtension(char key)",
                  "description": "Returns the extension (or private use) value associated with\n the specified key, or null if there is no extension\n associated with the key. To be well-formed, the key must be one\n of [0-9A-Za-z]. Keys are case-insensitive, so\n for example 'z' and 'Z' represent the same extension."
                }
              ]
            },
            {
              "name": "getExtensionKeys",
              "overloads": [
                {
                  "signature": "public Set<Character> getExtensionKeys()",
                  "description": "Returns the set of extension keys associated with this locale, or the\n empty set if it has no extensions. The returned set is unmodifiable.\n The keys will all be lower-case."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleAttributes",
              "overloads": [
                {
                  "signature": "public Set<String> getUnicodeLocaleAttributes()",
                  "description": "Returns the set of unicode locale attributes associated with\n this locale, or the empty set if it has no attributes. The\n returned set is unmodifiable."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleType",
              "overloads": [
                {
                  "signature": "public String getUnicodeLocaleType(String key)",
                  "description": "Returns the Unicode locale type associated with the specified Unicode locale key\n for this locale. Returns the empty string for keys that are defined with no type.\n Returns null if the key is not defined. Keys are case-insensitive. The key must\n be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is\n thrown."
                }
              ]
            },
            {
              "name": "getUnicodeLocaleKeys",
              "overloads": [
                {
                  "signature": "public Set<String> getUnicodeLocaleKeys()",
                  "description": "Returns the set of Unicode locale keys defined by this locale, or the empty set if\n this locale has none.  The returned set is immutable.  Keys are all lower case."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns a string representation of this Locale\n object, consisting of language, country, variant, script,\n and extensions as below:\n \n language + \"_\" + country + \"_\" + (variant + \"_#\" | \"#\") + script + \"_\" + extensions\n \n\n Language is always lower case, country is always upper case, script is always title\n case, and extensions are always lower case.  Extensions and private use subtags\n will be in canonical order as explained in toLanguageTag().\n\n When the locale has neither script nor extensions, the result is the same as in\n Java 6 and prior.\n\n If both the language and country fields are missing, this function will return\n the empty string, even if the variant, script, or extensions field is present (you\n can't have a locale with just a variant, the variant must accompany a well-formed\n language or country code).\n\n If script or extensions are present and variant is missing, no underscore is\n added before the \"#\".\n\n This behavior is designed to support debugging and to be compatible with\n previous uses of toString that expected language, country, and variant\n fields only.  To represent a Locale as a String for interchange purposes, use\n toLanguageTag().\n\n Examples: \n en\n de_DE\n _GB\n en_US_WIN\n de__POSIX\n zh_CN_#Hans\n zh_TW_#Hant_x-java\n th_TH_TH_#u-nu-thai"
                }
              ]
            },
            {
              "name": "toLanguageTag",
              "overloads": [
                {
                  "signature": "public String toLanguageTag()",
                  "description": "Returns a well-formed IETF BCP 47 language tag representing\n this locale.\n\n If this Locale has a language, country, or\n variant that does not satisfy the IETF BCP 47 language tag\n syntax requirements, this method handles these fields as\n described below:\n\n Language: If language is empty, or not well-formed (for example \"a\" or\n \"e2\"), it will be emitted as \"und\" (Undetermined).\n\n Country: If country is not well-formed (for example \"12\" or \"USA\"),\n it will be omitted.\n\n Variant: If variant is well-formed, each sub-segment\n (delimited by '-' or '_') is emitted as a subtag.  Otherwise:\n \n\n if all sub-segments match [0-9a-zA-Z]{1,8}\n (for example \"WIN\" or \"Oracle_JDK_Standard_Edition\"), the first\n ill-formed sub-segment and all following will be appended to\n the private use subtag.  The first appended subtag will be\n \"lvariant\", followed by the sub-segments in order, separated by\n hyphen. For example, \"x-lvariant-WIN\",\n \"Oracle-x-lvariant-JDK-Standard-Edition\".\n\n if any sub-segment does not match\n [0-9a-zA-Z]{1,8}, the variant will be truncated\n and the problematic sub-segment and all following sub-segments\n will be omitted.  If the remainder is non-empty, it will be\n emitted as a private use subtag as above (even if the remainder\n turns out to be well-formed).  For example,\n \"Solaris_isjustthecoolestthing\" is emitted as\n \"x-lvariant-Solaris\", not as \"solaris\".\n\n Special Conversions: Java supports some old locale\n representations, including deprecated ISO language codes,\n for compatibility. This method performs the following\n conversions:\n \n\n Deprecated ISO language codes \"iw\", \"ji\", and \"in\" are\n converted to \"he\", \"yi\", and \"id\", respectively.\n\n A locale with language \"no\", country \"NO\", and variant\n \"NY\", representing Norwegian Nynorsk (Norway), is converted\n to a language tag \"nn-NO\".\n\n Note: Although the language tag created by this\n method is well-formed (satisfies the syntax requirements\n defined by the IETF BCP 47 specification), it is not\n necessarily a valid BCP 47 language tag.  For example,\n    new Locale(\"xx\", \"YY\").toLanguageTag();\n\n will return \"xx-YY\", but the language subtag \"xx\" and the\n region subtag \"YY\" are invalid because they are not registered\n in the IANA Language Subtag Registry."
                }
              ]
            },
            {
              "name": "forLanguageTag",
              "overloads": [
                {
                  "signature": "public static Locale forLanguageTag(String languageTag)",
                  "description": "Returns a locale for the specified IETF BCP 47 language tag string.\n\n If the specified language tag contains any ill-formed subtags,\n the first such subtag and all following subtags are ignored.  Compare\n to Locale.Builder.setLanguageTag(java.lang.String) which throws an exception\n in this case.\n\n The following conversions are performed:\n\n The language code \"und\" is mapped to language \"\".\n\n The language codes \"iw\", \"ji\", and \"in\" are mapped to \"he\",\n \"yi\", and \"id\" respectively. (This is the same canonicalization\n that's done in Locale's constructors.) See\n Legacy language codes\n for more information.\n\n The portion of a private use subtag prefixed by \"lvariant\",\n if any, is removed and appended to the variant field in the\n result locale (without case normalization).  If it is then\n empty, the private use subtag is discarded:\n\n      Locale loc;\n     loc = Locale.forLanguageTag(\"en-US-x-lvariant-POSIX\");\n     loc.getVariant(); // returns \"POSIX\"\n     loc.getExtension('x'); // returns null\n\n     loc = Locale.forLanguageTag(\"de-POSIX-x-URP-lvariant-Abc-Def\");\n     loc.getVariant(); // returns \"POSIX_Abc_Def\"\n     loc.getExtension('x'); // returns \"urp\"\n \n\n When the languageTag argument contains an extlang subtag,\n the first such subtag is used as the language, and the primary\n language subtag and other extlang subtags are ignored:\n\n      Locale.forLanguageTag(\"ar-aao\").getLanguage(); // returns \"aao\"\n     Locale.forLanguageTag(\"en-abc-def-us\").toString(); // returns \"abc_US\"\n \n\n Case is normalized except for variant tags, which are left\n unchanged.  Language is normalized to lower case, script to\n title case, country to upper case, and extensions to lower\n case.\n\n If, after processing, the locale would exactly match either\n ja_JP_JP or th_TH_TH with no extensions, the appropriate\n extensions are added as though the constructor had been called:\n\n     Locale.forLanguageTag(\"ja-JP-x-lvariant-JP\").toLanguageTag();\n    // returns \"ja-JP-u-ca-japanese-x-lvariant-JP\"\n    Locale.forLanguageTag(\"th-TH-x-lvariant-TH\").toLanguageTag();\n    // returns \"th-TH-u-nu-thai-x-lvariant-TH\"\n \n\n This implements the 'Language-Tag' production of BCP47, and\n so supports legacy (regular and irregular, referred to as\n \"Type: grandfathered\" in BCP47) as well as\n private use language tags.  Stand alone private use tags are\n represented as empty language and extension 'x-whatever',\n and legacy tags are converted to their canonical replacements\n where they exist.\n\n Legacy tags with canonical replacements are as follows:\n\n \n Legacy tags with canonical replacements\n \n legacy tagmodern replacement\n \n \n art-lojbanjbo\n i-amiami\n i-bnnbnn\n i-hakhak\n i-klingontlh\n i-luxlb\n i-navajonv\n i-pwnpwn\n i-taotao\n i-taytay\n i-tsutsu\n no-boknb\n no-nynnn\n sgn-BE-FRsfb\n sgn-BE-NLvgt\n sgn-CH-DEsgg\n zh-guoyucmn\n zh-hakkahak\n zh-min-nannan\n zh-xianghsn\n \n \n\n Legacy tags with no modern replacement will be\n converted as follows:\n\n \n Legacy tags with no modern replacement\n \n legacy tagconverts to\n \n \n cel-gaulishxtg-x-cel-gaulish\n en-GB-oeden-GB-x-oed\n i-defaulten-x-i-default\n i-enochianund-x-i-enochian\n i-mingosee-x-i-mingo\n zh-minnan-x-zh-min\n \n \n\n For a list of all legacy tags, see the\n IANA Language Subtag Registry (search for \"Type: grandfathered\").\n\n Note: there is no guarantee that toLanguageTag\n and forLanguageTag will round-trip."
                }
              ]
            },
            {
              "name": "getISO3Language",
              "overloads": [
                {
                  "signature": "public String getISO3Language() throws MissingResourceException",
                  "description": "Returns a three-letter abbreviation of this locale's language.\n If the language matches an ISO 639-1 two-letter code, the\n corresponding ISO 639-2/T three-letter lowercase code is\n returned.  The ISO 639-2 language codes can be found on-line,\n see \"Codes for the Representation of Names of Languages Part 2:\n Alpha-3 Code\".  If the locale specifies a three-letter\n language, the language is returned as is.  If the locale does\n not specify a language the empty string is returned."
                }
              ]
            },
            {
              "name": "getISO3Country",
              "overloads": [
                {
                  "signature": "public String getISO3Country() throws MissingResourceException",
                  "description": "Returns a three-letter abbreviation for this locale's country.\n If the country matches an ISO 3166-1 alpha-2 code, the\n corresponding ISO 3166-1 alpha-3 uppercase code is returned.\n If the locale doesn't specify a country, this will be the empty\n string.\n\n The ISO 3166-1 codes can be found on-line."
                }
              ]
            },
            {
              "name": "getDisplayLanguage",
              "overloads": [
                {
                  "signature": "public final String getDisplayLanguage()",
                  "description": "Returns a name for the locale's language that is appropriate for display to the\n user.\n If possible, the name returned will be localized for the default\n DISPLAY locale.\n For example, if the locale is fr_FR and the default\n DISPLAY locale\n is en_US, getDisplayLanguage() will return \"French\"; if the locale is en_US and\n the default DISPLAY locale is fr_FR,\n getDisplayLanguage() will return \"anglais\".\n If the name returned cannot be localized for the default\n DISPLAY locale,\n (say, we don't have a Japanese name for Croatian),\n this function falls back on the English name, and uses the ISO code as a last-resort\n value.  If the locale doesn't specify a language, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayLanguage(Locale inLocale)",
                  "description": "Returns a name for the locale's language that is appropriate for display to the\n user.\n If possible, the name returned will be localized according to inLocale.\n For example, if the locale is fr_FR and inLocale\n is en_US, getDisplayLanguage() will return \"French\"; if the locale is en_US and\n inLocale is fr_FR, getDisplayLanguage() will return \"anglais\".\n If the name returned cannot be localized according to inLocale,\n (say, we don't have a Japanese name for Croatian),\n this function falls back on the English name, and finally\n on the ISO code as a last-resort value.  If the locale doesn't specify a language,\n this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayScript",
              "overloads": [
                {
                  "signature": "public String getDisplayScript()",
                  "description": "Returns a name for the locale's script that is appropriate for display to\n the user. If possible, the name will be localized for the default\n DISPLAY locale.  Returns\n the empty string if this locale doesn't specify a script code."
                },
                {
                  "signature": "public String getDisplayScript(Locale inLocale)",
                  "description": "Returns a name for the locale's script that is appropriate\n for display to the user. If possible, the name will be\n localized for the given locale. Returns the empty string if\n this locale doesn't specify a script code."
                }
              ]
            },
            {
              "name": "getDisplayCountry",
              "overloads": [
                {
                  "signature": "public final String getDisplayCountry()",
                  "description": "Returns a name for the locale's country that is appropriate for display to the\n user.\n If possible, the name returned will be localized for the default\n DISPLAY locale.\n For example, if the locale is fr_FR and the default\n DISPLAY locale\n is en_US, getDisplayCountry() will return \"France\"; if the locale is en_US and\n the default DISPLAY locale is fr_FR,\n getDisplayCountry() will return \"Etats-Unis\".\n If the name returned cannot be localized for the default\n DISPLAY locale,\n (say, we don't have a Japanese name for Croatia),\n this function falls back on the English name, and uses the ISO code as a last-resort\n value.  If the locale doesn't specify a country, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayCountry(Locale inLocale)",
                  "description": "Returns a name for the locale's country that is appropriate for display to the\n user.\n If possible, the name returned will be localized according to inLocale.\n For example, if the locale is fr_FR and inLocale\n is en_US, getDisplayCountry() will return \"France\"; if the locale is en_US and\n inLocale is fr_FR, getDisplayCountry() will return \"Etats-Unis\".\n If the name returned cannot be localized according to inLocale.\n (say, we don't have a Japanese name for Croatia),\n this function falls back on the English name, and finally\n on the ISO code as a last-resort value.  If the locale doesn't specify a country,\n this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayVariant",
              "overloads": [
                {
                  "signature": "public final String getDisplayVariant()",
                  "description": "Returns a name for the locale's variant code that is appropriate for display to the\n user.  If possible, the name will be localized for the default\n DISPLAY locale.  If the locale\n doesn't specify a variant code, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayVariant(Locale inLocale)",
                  "description": "Returns a name for the locale's variant code that is appropriate for display to the\n user.  If possible, the name will be localized for inLocale.  If the locale\n doesn't specify a variant code, this function returns the empty string."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public final String getDisplayName()",
                  "description": "Returns a name for the locale that is appropriate for display to the\n user. This will be the values returned by getDisplayLanguage(),\n getDisplayScript(), getDisplayCountry(), getDisplayVariant() and\n optional Unicode extensions\n assembled into a single string. The non-empty values are used in order, with\n the second and subsequent names in parentheses.  For example:\n \n language (script, country, variant(, extension)*)\n language (country(, extension)*)\n language (variant(, extension)*)\n script (country(, extension)*)\n country (extension)*\n \n depending on which fields are specified in the locale. The field\n separator in the above parentheses, denoted as a comma character, may\n be localized depending on the locale. If the language, script, country,\n and variant fields are all empty, this function returns the empty string."
                },
                {
                  "signature": "public String getDisplayName(Locale inLocale)",
                  "description": "Returns a name for the locale that is appropriate for display\n to the user.  This will be the values returned by\n getDisplayLanguage(), getDisplayScript(),getDisplayCountry()\n getDisplayVariant(), and optional \n Unicode extensions assembled into a single string. The non-empty\n values are used in order, with the second and subsequent names in\n parentheses.  For example:\n \n language (script, country, variant(, extension)*)\n language (country(, extension)*)\n language (variant(, extension)*)\n script (country(, extension)*)\n country (extension)*\n \n depending on which fields are specified in the locale. The field\n separator in the above parentheses, denoted as a comma character, may\n be localized depending on the locale. If the language, script, country,\n and variant fields are all empty, this function returns the empty string."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode.\n Since Locales are often used in hashtables, caches the value\n for speed."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Returns true if this Locale is equal to another object.  A Locale is\n deemed equal to another Locale with identical language, script, country,\n variant and extensions, and unequal to all other objects."
                }
              ]
            },
            {
              "name": "filter",
              "overloads": [
                {
                  "signature": "public static List<Locale> filter(List<Locale.LanguageRange> priorityList, Collection<Locale> locales, Locale.FilteringMode mode)",
                  "description": "Returns a list of matching Locale instances using the filtering\n mechanism defined in RFC 4647.\n\n This filter operation on the given locales ensures that only\n unique matching locale(s) are returned."
                },
                {
                  "signature": "public static List<Locale> filter(List<Locale.LanguageRange> priorityList, Collection<Locale> locales)",
                  "description": "Returns a list of matching Locale instances using the filtering\n mechanism defined in RFC 4647. This is equivalent to\n filter(List, Collection, FilteringMode) when mode is\n Locale.FilteringMode.AUTOSELECT_FILTERING.\n\n This filter operation on the given locales ensures that only\n unique matching locale(s) are returned."
                }
              ]
            },
            {
              "name": "filterTags",
              "overloads": [
                {
                  "signature": "public static List<String> filterTags(List<Locale.LanguageRange> priorityList, Collection<String> tags, Locale.FilteringMode mode)",
                  "description": "Returns a list of matching languages tags using the basic filtering\n mechanism defined in RFC 4647.\n\n This filter operation on the given tags ensures that only\n unique matching tag(s) are returned with preserved case. In case of\n duplicate matching tags with the case difference, the first matching\n tag with preserved case is returned.\n For example, \"de-ch\" is returned out of the duplicate matching tags\n \"de-ch\" and \"de-CH\", if \"de-ch\" is checked first for matching in the\n given tags. Note that if the given tags is an unordered\n Collection, the returned matching tag out of duplicate tags is\n subject to change, depending on the implementation of the\n Collection."
                },
                {
                  "signature": "public static List<String> filterTags(List<Locale.LanguageRange> priorityList, Collection<String> tags)",
                  "description": "Returns a list of matching languages tags using the basic filtering\n mechanism defined in RFC 4647. This is equivalent to\n filterTags(List, Collection, FilteringMode) when mode\n is Locale.FilteringMode.AUTOSELECT_FILTERING.\n\n This filter operation on the given tags ensures that only\n unique matching tag(s) are returned with preserved case. In case of\n duplicate matching tags with the case difference, the first matching\n tag with preserved case is returned.\n For example, \"de-ch\" is returned out of the duplicate matching tags\n \"de-ch\" and \"de-CH\", if \"de-ch\" is checked first for matching in the\n given tags. Note that if the given tags is an unordered\n Collection, the returned matching tag out of duplicate tags is\n subject to change, depending on the implementation of the\n Collection."
                }
              ]
            },
            {
              "name": "lookup",
              "overloads": [
                {
                  "signature": "public static Locale lookup(List<Locale.LanguageRange> priorityList, Collection<Locale> locales)",
                  "description": "Returns a Locale instance for the best-matching language\n tag using the lookup mechanism defined in RFC 4647."
                }
              ]
            },
            {
              "name": "lookupTag",
              "overloads": [
                {
                  "signature": "public static String lookupTag(List<Locale.LanguageRange> priorityList, Collection<String> tags)",
                  "description": "Returns the best-matching language tag using the lookup mechanism\n defined in RFC 4647.\n\n This lookup operation on the given tags ensures that the\n first matching tag with preserved case is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Locale.Builder",
          "methods": [
            {
              "name": "Builder",
              "overloads": [
                {
                  "signature": "public Builder()",
                  "description": "Constructs an empty Builder. The default value of all\n fields, extensions, and private use information is the\n empty string."
                }
              ]
            },
            {
              "name": "setLocale",
              "overloads": [
                {
                  "signature": "public Locale.Builder setLocale(Locale locale)",
                  "description": "Resets the Builder to match the provided\n locale.  Existing state is discarded.\n\n All fields of the locale must be well-formed, see Locale.\n\n Locales with any ill-formed fields cause\n IllformedLocaleException to be thrown, except for the\n following three cases which are accepted for compatibility\n reasons:\n Locale(\"ja\", \"JP\", \"JP\") is treated as \"ja-JP-u-ca-japanese\"\n Locale(\"th\", \"TH\", \"TH\") is treated as \"th-TH-u-nu-thai\"\n Locale(\"no\", \"NO\", \"NY\") is treated as \"nn-NO\""
                }
              ]
            },
            {
              "name": "setLanguageTag",
              "overloads": [
                {
                  "signature": "public Locale.Builder setLanguageTag(String languageTag)",
                  "description": "Resets the Builder to match the provided IETF BCP 47\n language tag.  Discards the existing state.  Null and the\n empty string cause the builder to be reset, like clear().  Legacy tags (see Locale.forLanguageTag(java.lang.String)) are converted to their canonical\n form before being processed.  Otherwise, the language tag\n must be well-formed (see Locale) or an exception is\n thrown (unlike Locale.forLanguageTag, which\n just discards ill-formed and following portions of the\n tag)."
                }
              ]
            },
            {
              "name": "setLanguage",
              "overloads": [
                {
                  "signature": "public Locale.Builder setLanguage(String language)",
                  "description": "Sets the language.  If language is the empty string or\n null, the language in this Builder is removed.  Otherwise,\n the language must be well-formed\n or an exception is thrown.\n\n The typical language value is a two or three-letter language\n code as defined in ISO639."
                }
              ]
            },
            {
              "name": "setScript",
              "overloads": [
                {
                  "signature": "public Locale.Builder setScript(String script)",
                  "description": "Sets the script. If script is null or the empty string,\n the script in this Builder is removed.\n Otherwise, the script must be well-formed or an\n exception is thrown.\n\n The typical script value is a four-letter script code as defined by ISO 15924."
                }
              ]
            },
            {
              "name": "setRegion",
              "overloads": [
                {
                  "signature": "public Locale.Builder setRegion(String region)",
                  "description": "Sets the region.  If region is null or the empty string, the region\n in this Builder is removed.  Otherwise,\n the region must be well-formed or an\n exception is thrown.\n\n The typical region value is a two-letter ISO 3166 code or a\n three-digit UN M.49 area code.\n\n The country value in the Locale created by the\n Builder is always normalized to upper case."
                }
              ]
            },
            {
              "name": "setVariant",
              "overloads": [
                {
                  "signature": "public Locale.Builder setVariant(String variant)",
                  "description": "Sets the variant.  If variant is null or the empty string, the\n variant in this Builder is removed.  Otherwise, it\n must consist of one or more well-formed\n subtags, or an exception is thrown.\n\n Note: This method checks if variant\n satisfies the IETF BCP 47 variant subtag's syntax requirements,\n and normalizes the value to lowercase letters.  However,\n the Locale class does not impose any syntactic\n restriction on variant, and the variant value in\n Locale is case sensitive.  To set such a variant,\n use a Locale constructor."
                }
              ]
            },
            {
              "name": "setExtension",
              "overloads": [
                {
                  "signature": "public Locale.Builder setExtension(char key, String value)",
                  "description": "Sets the extension for the given key. If the value is null or the\n empty string, the extension is removed.  Otherwise, the extension\n must be well-formed or an exception\n is thrown.\n\n Note: The key UNICODE_LOCALE_EXTENSION ('u') is used for the Unicode locale extension.\n Setting a value for this key replaces any existing Unicode locale key/type\n pairs with those defined in the extension.\n\n Note: The key PRIVATE_USE_EXTENSION ('x') is used for the private use code. To be\n well-formed, the value for this key needs only to have subtags of one to\n eight alphanumeric characters, not two to eight as in the general case."
                }
              ]
            },
            {
              "name": "setUnicodeLocaleKeyword",
              "overloads": [
                {
                  "signature": "public Locale.Builder setUnicodeLocaleKeyword(String key, String type)",
                  "description": "Sets the Unicode locale keyword type for the given key.  If the type\n is null, the Unicode keyword is removed.  Otherwise, the key must be\n non-null and both key and type must be well-formed or an exception\n is thrown.\n\n Keys and types are converted to lower case.\n\n Note:Setting the 'u' extension via setExtension(char, java.lang.String)\n replaces all Unicode locale keywords with those defined in the\n extension."
                }
              ]
            },
            {
              "name": "addUnicodeLocaleAttribute",
              "overloads": [
                {
                  "signature": "public Locale.Builder addUnicodeLocaleAttribute(String attribute)",
                  "description": "Adds a unicode locale attribute, if not already present, otherwise\n has no effect.  The attribute must not be null and must be well-formed or an exception\n is thrown."
                }
              ]
            },
            {
              "name": "removeUnicodeLocaleAttribute",
              "overloads": [
                {
                  "signature": "public Locale.Builder removeUnicodeLocaleAttribute(String attribute)",
                  "description": "Removes a unicode locale attribute, if present, otherwise has no\n effect.  The attribute must not be null and must be well-formed or an exception\n is thrown.\n\n Attribute comparison for removal is case-insensitive."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public Locale.Builder clear()",
                  "description": "Resets the builder to its initial, empty state."
                }
              ]
            },
            {
              "name": "clearExtensions",
              "overloads": [
                {
                  "signature": "public Locale.Builder clearExtensions()",
                  "description": "Resets the extensions to their initial, empty state.\n Language, script, region and variant are unchanged."
                }
              ]
            },
            {
              "name": "build",
              "overloads": [
                {
                  "signature": "public Locale build()",
                  "description": "Returns an instance of Locale created from the fields set\n on this builder.\n\n This applies the conversions listed in Locale.forLanguageTag(java.lang.String)\n when constructing a Locale. (Legacy tags are handled in\n setLanguageTag(java.lang.String).)"
                }
              ]
            }
          ]
        },
        {
          "name": "Locale.LanguageRange",
          "methods": [
            {
              "name": "LanguageRange",
              "overloads": [
                {
                  "signature": "public LanguageRange(String range)",
                  "description": "Constructs a LanguageRange using the given range.\n Note that no validation is done against the IANA Language Subtag\n Registry at time of construction.\n\n This is equivalent to LanguageRange(range, MAX_WEIGHT)."
                },
                {
                  "signature": "public LanguageRange(String range, double weight)",
                  "description": "Constructs a LanguageRange using the given range and\n weight. Note that no validation is done against the IANA\n Language Subtag Registry at time of construction."
                }
              ]
            },
            {
              "name": "getRange",
              "overloads": [
                {
                  "signature": "public String getRange()",
                  "description": "Returns the language range of this LanguageRange."
                }
              ]
            },
            {
              "name": "getWeight",
              "overloads": [
                {
                  "signature": "public double getWeight()",
                  "description": "Returns the weight of this LanguageRange."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static List<Locale.LanguageRange> parse(String ranges)",
                  "description": "Parses the given ranges to generate a Language Priority List.\n\n This method performs a syntactic check for each language range in\n the given ranges but doesn't do validation using the IANA\n Language Subtag Registry.\n\n The ranges to be given can take one of the following\n forms:\n\n    \"Accept-Language: ja,en;q=0.4\"  (weighted list with Accept-Language prefix)\n   \"ja,en;q=0.4\"                   (weighted list)\n   \"ja,en\"                         (prioritized list)\n \n\n In a weighted list, each language range is given a weight value.\n The weight value is identical to the \"quality value\" in\n RFC 2616, and it\n expresses how much the user prefers  the language. A weight value is\n specified after a corresponding language range followed by\n \";q=\", and the default weight value is MAX_WEIGHT\n when it is omitted.\n\n Unlike a weighted list, language ranges in a prioritized list\n are sorted in the descending order based on its priority. The first\n language range has the highest priority and meets the user's\n preference most.\n\n In either case, language ranges are sorted in descending order in\n the Language Priority List based on priority or weight. If a\n language range appears in the given ranges more than once,\n only the first one is included on the Language Priority List.\n\n The returned list consists of language ranges from the given\n ranges and their equivalents found in the IANA Language\n Subtag Registry. For example, if the given ranges is\n \"Accept-Language: iw,en-us;q=0.7,en;q=0.3\", the elements in\n the list to be returned are:\n\n   Range                                   Weight\n    \"iw\" (older tag for Hebrew)             1.0\n    \"he\" (new preferred code for Hebrew)    1.0\n    \"en-us\" (English, United States)        0.7\n    \"en\" (English)                          0.3\n \n\n Two language ranges, \"iw\" and \"he\", have the same\n highest priority in the list. By adding \"he\" to the user's\n Language Priority List, locale-matching method can find Hebrew as a\n matching locale (or language tag) even if the application or system\n offers only \"he\" as a supported locale (or language tag)."
                },
                {
                  "signature": "public static List<Locale.LanguageRange> parse(String ranges, Map<String,List<String>> map)",
                  "description": "Parses the given ranges to generate a Language Priority\n List, and then customizes the list using the given map.\n This method is equivalent to\n mapEquivalents(parse(ranges), map)."
                }
              ]
            },
            {
              "name": "mapEquivalents",
              "overloads": [
                {
                  "signature": "public static List<Locale.LanguageRange> mapEquivalents(List<Locale.LanguageRange> priorityList, Map<String,List<String>> map)",
                  "description": "Generates a new customized Language Priority List using the given\n priorityList and map. If the given map is\n empty, this method returns a copy of the given priorityList.\n\n In the map, a key represents a language range whereas a value is\n a list of equivalents of it. '*' cannot be used in the map.\n Each equivalent language range has the same weight value as its\n original language range.\n\n   An example of map:\n    Key                            Value\n      \"zh\" (Chinese)                 \"zh\",\n                                     \"zh-Hans\"(Simplified Chinese)\n      \"zh-HK\" (Chinese, Hong Kong)   \"zh-HK\"\n      \"zh-TW\" (Chinese, Taiwan)      \"zh-TW\"\n \n\n The customization is performed after modification using the IANA\n Language Subtag Registry.\n\n For example, if a user's Language Priority List consists of five\n language ranges (\"zh\", \"zh-CN\", \"en\",\n \"zh-TW\", and \"zh-HK\"), the newly generated Language\n Priority List which is customized using the above map example will\n consists of \"zh\", \"zh-Hans\", \"zh-CN\",\n \"zh-Hans-CN\", \"en\", \"zh-TW\", and\n \"zh-HK\".\n\n \"zh-HK\" and \"zh-TW\" aren't converted to\n \"zh-Hans-HK\" nor \"zh-Hans-TW\" even if they are\n included in the Language Priority List. In this example, mapping\n is used to clearly distinguish Simplified Chinese and Traditional\n Chinese.\n\n If the \"zh\"-to-\"zh\" mapping isn't included in the\n map, a simple replacement will be performed and the customized list\n won't include \"zh\" and \"zh-CN\"."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code value for the object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object. The result is true if\n and only if the argument is not null and is a\n LanguageRange object that contains the same range\n and weight values as this object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns an informative string representation of this LanguageRange\n object, consisting of language range and weight if the range is\n weighted and the weight is less than the max weight."
                }
              ]
            }
          ]
        },
        {
          "name": "LongSummaryStatistics",
          "methods": [
            {
              "name": "LongSummaryStatistics",
              "overloads": [
                {
                  "signature": "public LongSummaryStatistics()",
                  "description": "Constructs an empty instance with zero count, zero sum,\n Long.MAX_VALUE min, Long.MIN_VALUE max and zero\n average."
                },
                {
                  "signature": "public LongSummaryStatistics(long count, long min, long max, long sum) throws IllegalArgumentException",
                  "description": "Constructs a non-empty instance with the specified count,\n min, max, and sum.\n\n If count is zero then the remaining arguments are ignored and\n an empty instance is constructed.\n\n If the arguments are inconsistent then an IllegalArgumentException\n is thrown.  The necessary consistent argument conditions are:\n \n   count >= 0\n   min <= max"
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "public void accept(int value)",
                  "description": "Records a new int value into the summary information."
                },
                {
                  "signature": "public void accept(long value)",
                  "description": "Records a new long value into the summary information."
                }
              ]
            },
            {
              "name": "combine",
              "overloads": [
                {
                  "signature": "public void combine(LongSummaryStatistics other)",
                  "description": "Combines the state of another LongSummaryStatistics into this\n one."
                }
              ]
            },
            {
              "name": "getCount",
              "overloads": [
                {
                  "signature": "public final long getCount()",
                  "description": "Returns the count of values recorded."
                }
              ]
            },
            {
              "name": "getSum",
              "overloads": [
                {
                  "signature": "public final long getSum()",
                  "description": "Returns the sum of values recorded, or zero if no values have been\n recorded."
                }
              ]
            },
            {
              "name": "getMin",
              "overloads": [
                {
                  "signature": "public final long getMin()",
                  "description": "Returns the minimum value recorded, or Long.MAX_VALUE if no\n values have been recorded."
                }
              ]
            },
            {
              "name": "getMax",
              "overloads": [
                {
                  "signature": "public final long getMax()",
                  "description": "Returns the maximum value recorded, or Long.MIN_VALUE if no\n values have been recorded"
                }
              ]
            },
            {
              "name": "getAverage",
              "overloads": [
                {
                  "signature": "public final double getAverage()",
                  "description": "Returns the arithmetic mean of values recorded, or zero if no values have been\n recorded."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this object suitable for\n debugging. The exact presentation format is unspecified and may vary\n between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "Map.Entry<K,V>",
          "methods": [
            {
              "name": "getKey",
              "overloads": [
                {
                  "signature": "K getKey()",
                  "description": "Returns the key corresponding to this entry."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "V getValue()",
                  "description": "Returns the value corresponding to this entry.  If the mapping\n has been removed from the backing map (by the iterator's\n remove operation), the results of this call are undefined."
                }
              ]
            },
            {
              "name": "setValue",
              "overloads": [
                {
                  "signature": "V setValue(V value)",
                  "description": "Replaces the value corresponding to this entry with the specified\n value (optional operation).  (Writes through to the map.)  The\n behavior of this call is undefined if the mapping has already been\n removed from the map (by the iterator's remove operation)."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this entry for equality.\n Returns true if the given object is also a map entry and\n the two entries represent the same mapping.  More formally, two\n entries e1 and e2 represent the same mapping\n if     (e1.getKey()==null ?\n      e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &&\n     (e1.getValue()==null ?\n      e2.getValue()==null : e1.getValue().equals(e2.getValue()))\n \n This ensures that the equals method works properly across\n different implementations of the Map.Entry interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this map entry.  The hash code\n of a map entry e is defined to be:      (e.getKey()==null   ? 0 : e.getKey().hashCode()) ^\n     (e.getValue()==null ? 0 : e.getValue().hashCode())\n \n This ensures that e1.equals(e2) implies that\n e1.hashCode()==e2.hashCode() for any two Entries\n e1 and e2, as required by the general\n contract of Object.hashCode."
                }
              ]
            },
            {
              "name": "comparingByKey",
              "overloads": [
                {
                  "signature": "static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K,V>> comparingByKey()",
                  "description": "Returns a comparator that compares Map.Entry in natural order on key.\n\n The returned comparator is serializable and throws NullPointerException when comparing an entry with a null key."
                },
                {
                  "signature": "static <K, V> Comparator<Map.Entry<K,V>> comparingByKey(Comparator<? super K> cmp)",
                  "description": "Returns a comparator that compares Map.Entry by key using the given\n Comparator.\n\n The returned comparator is serializable if the specified comparator\n is also serializable."
                }
              ]
            },
            {
              "name": "comparingByValue",
              "overloads": [
                {
                  "signature": "static <K, V extends Comparable<? super V>> Comparator<Map.Entry<K,V>> comparingByValue()",
                  "description": "Returns a comparator that compares Map.Entry in natural order on value.\n\n The returned comparator is serializable and throws NullPointerException when comparing an entry with null values."
                },
                {
                  "signature": "static <K, V> Comparator<Map.Entry<K,V>> comparingByValue(Comparator<? super V> cmp)",
                  "description": "Returns a comparator that compares Map.Entry by value using the given\n Comparator.\n\n The returned comparator is serializable if the specified comparator\n is also serializable."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <K, V> Map.Entry<K,V> copyOf(Map.Entry<? extends K,? extends V> e)",
                  "description": "Returns a copy of the given Map.Entry. The returned instance is not\n associated with any map. The returned instance has the same characteristics\n as instances returned by the Map::entry method."
                }
              ]
            }
          ]
        },
        {
          "name": "Map<K,V>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of key-value mappings in this map.  If the\n map contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this map contains no key-value mappings."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the specified\n key.  More formally, returns true if and only if\n this map contains a mapping for a key k such that\n Objects.equals(key, k).  (There can be\n at most one such mapping.)"
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value.  More formally, returns true if and only if\n this map contains at least one mapping to a value v such that\n Objects.equals(value, v).  This operation\n will probably require time linear in the map size for most\n implementations of the Map interface."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that\n Objects.equals(key, k),\n then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contains no mapping for the key; it's also possible that the map\n explicitly maps the key to null.  The containsKey operation may be used to distinguish these two cases."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map\n (optional operation).  If the map previously contained a mapping for\n the key, the old value is replaced by the specified value.  (A map\n m is said to contain a mapping for a key k if and only\n if m.containsKey(k) would return\n true.)"
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "V remove(Object key)",
                  "description": "Removes the mapping for a key from this map if it is present\n (optional operation).   More formally, if this map contains a mapping\n from key k to value v such that\n Objects.equals(key, k), that mapping\n is removed.  (The map can contain at most one such mapping.)\n\n Returns the value to which this map previously associated the key,\n or null if the map contained no mapping for the key.\n\n If this map permits null values, then a return value of\n null does not necessarily indicate that the map\n contained no mapping for the key; it's also possible that the map\n explicitly mapped the key to null.\n\n The map will not contain a mapping for the specified key once the\n call returns."
                },
                {
                  "signature": "default boolean remove(Object key, Object value)",
                  "description": "Removes the entry for the specified key only if it is currently\n mapped to the specified value."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map\n (optional operation).  The effect of this call is equivalent to that\n of calling put(k, v) on this map once\n for each mapping from key k to value v in the\n specified map.  The behavior of this operation is undefined if the\n specified map is modified while the operation is in progress."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the mappings from this map (optional operation).\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent the same mappings.  More formally, two maps m1 and\n m2 represent the same mappings if\n m1.entrySet().equals(m2.entrySet()).  This ensures that the\n equals method works properly across different implementations\n of the Map interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map's\n entrySet() view.  This ensures that m1.equals(m2)\n implies that m1.hashCode()==m2.hashCode() for any two maps\n m1 and m2, as required by the general contract of\n Object.hashCode()."
                }
              ]
            },
            {
              "name": "getOrDefault",
              "overloads": [
                {
                  "signature": "default V getOrDefault(Object key, V defaultValue)",
                  "description": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "default void forEach(BiConsumer<? super K,? super V> action)",
                  "description": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.   Unless\n otherwise specified by the implementing class, actions are performed in\n the order of entry set iteration (if an iteration order is specified.)\n Exceptions thrown by the action are relayed to the caller."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "default void replaceAll(BiFunction<? super K,? super V,? extends V> function)",
                  "description": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.  Exceptions thrown by the function are\n relayed to the caller."
                }
              ]
            },
            {
              "name": "putIfAbsent",
              "overloads": [
                {
                  "signature": "default V putIfAbsent(K key, V value)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "default boolean replace(K key, V oldValue, V newValue)",
                  "description": "Replaces the entry for the specified key only if currently\n mapped to the specified value."
                },
                {
                  "signature": "default V replace(K key, V value)",
                  "description": "Replaces the entry for the specified key only if it is\n currently mapped to some value."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "default V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \n\n Or to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \n\n The mapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "default V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "default V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "default V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <K, V> Map<K,V> of()",
                  "description": "Returns an unmodifiable map containing zero mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1)",
                  "description": "Returns an unmodifiable map containing a single mapping.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2)",
                  "description": "Returns an unmodifiable map containing two mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3)",
                  "description": "Returns an unmodifiable map containing three mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)",
                  "description": "Returns an unmodifiable map containing four mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)",
                  "description": "Returns an unmodifiable map containing five mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)",
                  "description": "Returns an unmodifiable map containing six mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)",
                  "description": "Returns an unmodifiable map containing seven mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)",
                  "description": "Returns an unmodifiable map containing eight mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)",
                  "description": "Returns an unmodifiable map containing nine mappings.\n See Unmodifiable Maps for details."
                },
                {
                  "signature": "static <K, V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)",
                  "description": "Returns an unmodifiable map containing ten mappings.\n See Unmodifiable Maps for details."
                }
              ]
            },
            {
              "name": "ofEntries",
              "overloads": [
                {
                  "signature": "@SafeVarargs static <K, V> Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)",
                  "description": "Returns an unmodifiable map containing keys and values extracted from the given entries.\n The entries themselves are not stored in the map.\n See Unmodifiable Maps for details."
                }
              ]
            },
            {
              "name": "entry",
              "overloads": [
                {
                  "signature": "static <K, V> Map.Entry<K,V> entry(K k, V v)",
                  "description": "Returns an unmodifiable Map.Entry containing the given key and value.\n These entries are suitable for populating Map instances using the\n Map.ofEntries() method.\n The Entry instances created by this method have the following characteristics:\n\n \n They disallow null keys and values. Attempts to create them using a null\n key or value result in NullPointerException.\n They are unmodifiable. Calls to Entry.setValue()\n on a returned Entry result in UnsupportedOperationException.\n They are not serializable.\n They are value-based.\n Programmers should treat instances that are equal\n as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. This method is free to\n create new instances or reuse existing ones."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <K, V> Map<K,V> copyOf(Map<? extends K,? extends V> map)",
                  "description": "Returns an unmodifiable Map containing the entries\n of the given Map. The given Map must not be null, and it must not contain any\n null keys or values. If the given Map is subsequently modified, the returned\n Map will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "MissingFormatArgumentException",
          "methods": [
            {
              "name": "MissingFormatArgumentException",
              "overloads": [
                {
                  "signature": "public MissingFormatArgumentException(String s)",
                  "description": "Constructs an instance of this class with the unmatched format\n specifier."
                }
              ]
            },
            {
              "name": "getFormatSpecifier",
              "overloads": [
                {
                  "signature": "public String getFormatSpecifier()",
                  "description": "Returns the unmatched format specifier."
                }
              ]
            }
          ]
        },
        {
          "name": "MissingFormatWidthException",
          "methods": [
            {
              "name": "MissingFormatWidthException",
              "overloads": [
                {
                  "signature": "public MissingFormatWidthException(String s)",
                  "description": "Constructs an instance of this class with the specified format\n specifier."
                }
              ]
            },
            {
              "name": "getFormatSpecifier",
              "overloads": [
                {
                  "signature": "public String getFormatSpecifier()",
                  "description": "Returns the format specifier which does not have a width."
                }
              ]
            }
          ]
        },
        {
          "name": "MissingResourceException",
          "methods": [
            {
              "name": "MissingResourceException",
              "overloads": [
                {
                  "signature": "public MissingResourceException(String s, String className, String key)",
                  "description": "Constructs a MissingResourceException with the specified information.\n A detail message is a String that describes this particular exception."
                }
              ]
            },
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "public String getClassName()",
                  "description": "Gets parameter passed by constructor."
                }
              ]
            },
            {
              "name": "getKey",
              "overloads": [
                {
                  "signature": "public String getKey()",
                  "description": "Gets parameter passed by constructor."
                }
              ]
            }
          ]
        },
        {
          "name": "NavigableMap<K,V>",
          "methods": [
            {
              "name": "lowerEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> lowerEntry(K key)",
                  "description": "Returns a key-value mapping associated with the greatest key\n strictly less than the given key, or null if there is\n no such key."
                }
              ]
            },
            {
              "name": "lowerKey",
              "overloads": [
                {
                  "signature": "K lowerKey(K key)",
                  "description": "Returns the greatest key strictly less than the given key, or\n null if there is no such key."
                }
              ]
            },
            {
              "name": "floorEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> floorEntry(K key)",
                  "description": "Returns a key-value mapping associated with the greatest key\n less than or equal to the given key, or null if there\n is no such key."
                }
              ]
            },
            {
              "name": "floorKey",
              "overloads": [
                {
                  "signature": "K floorKey(K key)",
                  "description": "Returns the greatest key less than or equal to the given key,\n or null if there is no such key."
                }
              ]
            },
            {
              "name": "ceilingEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> ceilingEntry(K key)",
                  "description": "Returns a key-value mapping associated with the least key\n greater than or equal to the given key, or null if\n there is no such key."
                }
              ]
            },
            {
              "name": "ceilingKey",
              "overloads": [
                {
                  "signature": "K ceilingKey(K key)",
                  "description": "Returns the least key greater than or equal to the given key,\n or null if there is no such key."
                }
              ]
            },
            {
              "name": "higherEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> higherEntry(K key)",
                  "description": "Returns a key-value mapping associated with the least key\n strictly greater than the given key, or null if there\n is no such key."
                }
              ]
            },
            {
              "name": "higherKey",
              "overloads": [
                {
                  "signature": "K higherKey(K key)",
                  "description": "Returns the least key strictly greater than the given key, or\n null if there is no such key."
                }
              ]
            },
            {
              "name": "firstEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> firstEntry()",
                  "description": "Returns a key-value mapping associated with the least\n key in this map, or null if the map is empty."
                }
              ]
            },
            {
              "name": "lastEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> lastEntry()",
                  "description": "Returns a key-value mapping associated with the greatest\n key in this map, or null if the map is empty."
                }
              ]
            },
            {
              "name": "pollFirstEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> pollFirstEntry()",
                  "description": "Removes and returns a key-value mapping associated with\n the least key in this map, or null if the map is empty."
                }
              ]
            },
            {
              "name": "pollLastEntry",
              "overloads": [
                {
                  "signature": "Map.Entry<K,V> pollLastEntry()",
                  "description": "Removes and returns a key-value mapping associated with\n the greatest key in this map, or null if the map is empty."
                }
              ]
            },
            {
              "name": "descendingMap",
              "overloads": [
                {
                  "signature": "NavigableMap<K,V> descendingMap()",
                  "description": "Returns a reverse order view of the mappings contained in this map.\n The descending map is backed by this map, so changes to the map are\n reflected in the descending map, and vice-versa.  If either map is\n modified while an iteration over a collection view of either map\n is in progress (except through the iterator's own remove\n operation), the results of the iteration are undefined.\n\n The returned map has an ordering equivalent to\n Collections.reverseOrder(comparator()).\n The expression m.descendingMap().descendingMap() returns a\n view of m essentially equivalent to m."
                }
              ]
            },
            {
              "name": "navigableKeySet",
              "overloads": [
                {
                  "signature": "NavigableSet<K> navigableKeySet()",
                  "description": "Returns a NavigableSet view of the keys contained in this map.\n The set's iterator returns the keys in ascending order.\n The set is backed by the map, so changes to the map are reflected in\n the set, and vice-versa.  If the map is modified while an iteration\n over the set is in progress (except through the iterator's own \n remove operation), the results of the iteration are undefined.  The\n set supports element removal, which removes the corresponding mapping\n from the map, via the Iterator.remove, Set.remove,\n removeAll, retainAll, and clear operations.\n It does not support the add or addAll operations."
                }
              ]
            },
            {
              "name": "descendingKeySet",
              "overloads": [
                {
                  "signature": "NavigableSet<K> descendingKeySet()",
                  "description": "Returns a reverse order NavigableSet view of the keys contained in this map.\n The set's iterator returns the keys in descending order.\n The set is backed by the map, so changes to the map are reflected in\n the set, and vice-versa.  If the map is modified while an iteration\n over the set is in progress (except through the iterator's own \n remove operation), the results of the iteration are undefined.  The\n set supports element removal, which removes the corresponding mapping\n from the map, via the Iterator.remove, Set.remove,\n removeAll, retainAll, and clear operations.\n It does not support the add or addAll operations."
                }
              ]
            },
            {
              "name": "subMap",
              "overloads": [
                {
                  "signature": "NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
                  "description": "Returns a view of the portion of this map whose keys range from\n fromKey to toKey.  If fromKey and\n toKey are equal, the returned map is empty unless\n fromInclusive and toInclusive are both true.  The\n returned map is backed by this map, so changes in the returned map are\n reflected in this map, and vice-versa.  The returned map supports all\n optional map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside of its range, or to construct a\n submap either of whose endpoints lie outside its range."
                },
                {
                  "signature": "SortedMap<K,V> subMap(K fromKey, K toKey)",
                  "description": "Returns a view of the portion of this map whose keys range from\n fromKey, inclusive, to toKey, exclusive.  (If\n fromKey and toKey are equal, the returned map\n is empty.)  The returned map is backed by this map, so changes\n in the returned map are reflected in this map, and vice-versa.\n The returned map supports all optional map operations that this\n map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range.\n\n Equivalent to subMap(fromKey, true, toKey, false)."
                }
              ]
            },
            {
              "name": "headMap",
              "overloads": [
                {
                  "signature": "NavigableMap<K,V> headMap(K toKey, boolean inclusive)",
                  "description": "Returns a view of the portion of this map whose keys are less than (or\n equal to, if inclusive is true) toKey.  The returned\n map is backed by this map, so changes in the returned map are reflected\n in this map, and vice-versa.  The returned map supports all optional\n map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range."
                },
                {
                  "signature": "SortedMap<K,V> headMap(K toKey)",
                  "description": "Returns a view of the portion of this map whose keys are\n strictly less than toKey.  The returned map is backed\n by this map, so changes in the returned map are reflected in\n this map, and vice-versa.  The returned map supports all\n optional map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range.\n\n Equivalent to headMap(toKey, false)."
                }
              ]
            },
            {
              "name": "tailMap",
              "overloads": [
                {
                  "signature": "NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)",
                  "description": "Returns a view of the portion of this map whose keys are greater than (or\n equal to, if inclusive is true) fromKey.  The returned\n map is backed by this map, so changes in the returned map are reflected\n in this map, and vice-versa.  The returned map supports all optional\n map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range."
                },
                {
                  "signature": "SortedMap<K,V> tailMap(K fromKey)",
                  "description": "Returns a view of the portion of this map whose keys are\n greater than or equal to fromKey.  The returned map is\n backed by this map, so changes in the returned map are\n reflected in this map, and vice-versa.  The returned map\n supports all optional map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range.\n\n Equivalent to tailMap(fromKey, true)."
                }
              ]
            }
          ]
        },
        {
          "name": "NavigableSet<E>",
          "methods": [
            {
              "name": "lower",
              "overloads": [
                {
                  "signature": "E lower(E e)",
                  "description": "Returns the greatest element in this set strictly less than the\n given element, or null if there is no such element."
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "E floor(E e)",
                  "description": "Returns the greatest element in this set less than or equal to\n the given element, or null if there is no such element."
                }
              ]
            },
            {
              "name": "ceiling",
              "overloads": [
                {
                  "signature": "E ceiling(E e)",
                  "description": "Returns the least element in this set greater than or equal to\n the given element, or null if there is no such element."
                }
              ]
            },
            {
              "name": "higher",
              "overloads": [
                {
                  "signature": "E higher(E e)",
                  "description": "Returns the least element in this set strictly greater than the\n given element, or null if there is no such element."
                }
              ]
            },
            {
              "name": "pollFirst",
              "overloads": [
                {
                  "signature": "E pollFirst()",
                  "description": "Retrieves and removes the first (lowest) element,\n or returns null if this set is empty."
                }
              ]
            },
            {
              "name": "pollLast",
              "overloads": [
                {
                  "signature": "E pollLast()",
                  "description": "Retrieves and removes the last (highest) element,\n or returns null if this set is empty."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this set, in ascending order."
                }
              ]
            },
            {
              "name": "descendingSet",
              "overloads": [
                {
                  "signature": "NavigableSet<E> descendingSet()",
                  "description": "Returns a reverse order view of the elements contained in this set.\n The descending set is backed by this set, so changes to the set are\n reflected in the descending set, and vice-versa.  If either set is\n modified while an iteration over either set is in progress (except\n through the iterator's own remove operation), the results of\n the iteration are undefined.\n\n The returned set has an ordering equivalent to\n Collections.reverseOrder(comparator()).\n The expression s.descendingSet().descendingSet() returns a\n view of s essentially equivalent to s."
                }
              ]
            },
            {
              "name": "descendingIterator",
              "overloads": [
                {
                  "signature": "Iterator<E> descendingIterator()",
                  "description": "Returns an iterator over the elements in this set, in descending order.\n Equivalent in effect to descendingSet().iterator()."
                }
              ]
            },
            {
              "name": "subSet",
              "overloads": [
                {
                  "signature": "NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",
                  "description": "Returns a view of the portion of this set whose elements range from\n fromElement to toElement.  If fromElement and\n toElement are equal, the returned set is empty unless \n fromInclusive and toInclusive are both true.  The returned set\n is backed by this set, so changes in the returned set are reflected in\n this set, and vice-versa.  The returned set supports all optional set\n operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                },
                {
                  "signature": "SortedSet<E> subSet(E fromElement, E toElement)",
                  "description": "Returns a view of the portion of this set whose elements range\n from fromElement, inclusive, to toElement,\n exclusive.  (If fromElement and toElement are\n equal, the returned set is empty.)  The returned set is backed\n by this set, so changes in the returned set are reflected in\n this set, and vice-versa.  The returned set supports all\n optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range.\n\n Equivalent to subSet(fromElement, true, toElement, false)."
                }
              ]
            },
            {
              "name": "headSet",
              "overloads": [
                {
                  "signature": "NavigableSet<E> headSet(E toElement, boolean inclusive)",
                  "description": "Returns a view of the portion of this set whose elements are less than\n (or equal to, if inclusive is true) toElement.  The\n returned set is backed by this set, so changes in the returned set are\n reflected in this set, and vice-versa.  The returned set supports all\n optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                },
                {
                  "signature": "SortedSet<E> headSet(E toElement)",
                  "description": "Returns a view of the portion of this set whose elements are\n strictly less than toElement.  The returned set is\n backed by this set, so changes in the returned set are\n reflected in this set, and vice-versa.  The returned set\n supports all optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range.\n\n Equivalent to headSet(toElement, false)."
                }
              ]
            },
            {
              "name": "tailSet",
              "overloads": [
                {
                  "signature": "NavigableSet<E> tailSet(E fromElement, boolean inclusive)",
                  "description": "Returns a view of the portion of this set whose elements are greater\n than (or equal to, if inclusive is true) fromElement.\n The returned set is backed by this set, so changes in the returned set\n are reflected in this set, and vice-versa.  The returned set supports\n all optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                },
                {
                  "signature": "SortedSet<E> tailSet(E fromElement)",
                  "description": "Returns a view of the portion of this set whose elements are\n greater than or equal to fromElement.  The returned\n set is backed by this set, so changes in the returned set are\n reflected in this set, and vice-versa.  The returned set\n supports all optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range.\n\n Equivalent to tailSet(fromElement, true)."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchElementException",
          "methods": [
            {
              "name": "NoSuchElementException",
              "overloads": [
                {
                  "signature": "public NoSuchElementException()",
                  "description": "Constructs a NoSuchElementException with null\n as its error message string."
                },
                {
                  "signature": "public NoSuchElementException(String s, Throwable cause)",
                  "description": "Constructs a NoSuchElementException with the specified detail\n message and cause."
                },
                {
                  "signature": "public NoSuchElementException(Throwable cause)",
                  "description": "Constructs a NoSuchElementException with the specified cause.\n The detail message is set to (cause == null ? null :\n cause.toString()) (which typically contains the class and\n detail message of cause)."
                },
                {
                  "signature": "public NoSuchElementException(String s)",
                  "description": "Constructs a NoSuchElementException, saving a reference\n to the error message string s for later retrieval by the\n getMessage method."
                }
              ]
            }
          ]
        },
        {
          "name": "Objects",
          "methods": [
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public static boolean equals(Object a, Object b)",
                  "description": "Returns true if the arguments are equal to each other\n and false otherwise.\n Consequently, if both arguments are null, true\n is returned.  Otherwise, if the first argument is not \n null, equality is determined by calling the equals method of the first argument with the\n second argument of this method. Otherwise, false is\n returned."
                }
              ]
            },
            {
              "name": "deepEquals",
              "overloads": [
                {
                  "signature": "public static boolean deepEquals(Object a, Object b)",
                  "description": "Returns true if the arguments are deeply equal to each other\n and false otherwise.\n\n Two null values are deeply equal.  If both arguments are\n arrays, the algorithm in Arrays.deepEquals is used to determine equality.\n Otherwise, equality is determined by using the equals method of the first argument."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public static int hashCode(Object o)",
                  "description": "Returns the hash code of a non-null argument and 0 for\n a null argument."
                }
              ]
            },
            {
              "name": "hash",
              "overloads": [
                {
                  "signature": "public static int hash(Object... values)",
                  "description": "Generates a hash code for a sequence of input values. The hash\n code is generated as if all the input values were placed into an\n array, and that array were hashed by calling Arrays.hashCode(Object[]).\n\n This method is useful for implementing Object.hashCode() on objects containing multiple fields. For\n example, if an object that has three fields, x, \n y, and z, one could write:\n\n  @Override public int hashCode() {\n     return Objects.hash(x, y, z);\n }\n \n\n Warning: When a single object reference is supplied, the returned\n value does not equal the hash code of that object reference. This\n value can be computed by calling hashCode(Object)."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public static String toString(Object o)",
                  "description": "Returns the result of calling toString for a non-\n null argument and \"null\" for a null argument."
                },
                {
                  "signature": "public static String toString(Object o, String nullDefault)",
                  "description": "Returns the result of calling toString on the first\n argument if the first argument is not null and returns\n the second argument otherwise."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public static <T> int compare(T a, T b, Comparator<? super T> c)",
                  "description": "Returns 0 if the arguments are identical and \n c.compare(a, b) otherwise.\n Consequently, if both arguments are null 0\n is returned.\n\n Note that if one of the arguments is null, a \n NullPointerException may or may not be thrown depending on\n what ordering policy, if any, the Comparator\n chooses to have for null values."
                }
              ]
            },
            {
              "name": "requireNonNull",
              "overloads": [
                {
                  "signature": "public static <T> T requireNonNull(T obj)",
                  "description": "Checks that the specified object reference is not null. This\n method is designed primarily for doing parameter validation in methods\n and constructors, as demonstrated below:\n  public Foo(Bar bar) {\n     this.bar = Objects.requireNonNull(bar);\n }"
                },
                {
                  "signature": "public static <T> T requireNonNull(T obj, String message)",
                  "description": "Checks that the specified object reference is not null and\n throws a customized NullPointerException if it is. This method\n is designed primarily for doing parameter validation in methods and\n constructors with multiple parameters, as demonstrated below:\n  public Foo(Bar bar, Baz baz) {\n     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");\n     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");\n }"
                },
                {
                  "signature": "public static <T> T requireNonNull(T obj, Supplier<String> messageSupplier)",
                  "description": "Checks that the specified object reference is not null and\n throws a customized NullPointerException if it is.\n\n Unlike the method requireNonNull(Object, String),\n this method allows creation of the message to be deferred until\n after the null check is made. While this may confer a\n performance advantage in the non-null case, when deciding to\n call this method care should be taken that the costs of\n creating the message supplier are less than the cost of just\n creating the string message directly."
                }
              ]
            },
            {
              "name": "isNull",
              "overloads": [
                {
                  "signature": "public static boolean isNull(Object obj)",
                  "description": "Returns true if the provided reference is null otherwise\n returns false."
                }
              ]
            },
            {
              "name": "nonNull",
              "overloads": [
                {
                  "signature": "public static boolean nonNull(Object obj)",
                  "description": "Returns true if the provided reference is non-null\n otherwise returns false."
                }
              ]
            },
            {
              "name": "requireNonNullElse",
              "overloads": [
                {
                  "signature": "public static <T> T requireNonNullElse(T obj, T defaultObj)",
                  "description": "Returns the first argument if it is non-null and\n otherwise returns the non-null second argument."
                }
              ]
            },
            {
              "name": "requireNonNullElseGet",
              "overloads": [
                {
                  "signature": "public static <T> T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)",
                  "description": "Returns the first argument if it is non-null and otherwise\n returns the non-null value of supplier.get()."
                }
              ]
            },
            {
              "name": "checkIndex",
              "overloads": [
                {
                  "signature": "public static int checkIndex(int index, int length)",
                  "description": "Checks if the index is within the bounds of the range from\n 0 (inclusive) to length (exclusive).\n\n The index is defined to be out of bounds if any of the\n following inequalities is true:\n \n  index < 0\n  index >= length\n  length < 0, which is implied from the former inequalities"
                },
                {
                  "signature": "public static long checkIndex(long index, long length)",
                  "description": "Checks if the index is within the bounds of the range from\n 0 (inclusive) to length (exclusive).\n\n The index is defined to be out of bounds if any of the\n following inequalities is true:\n \n  index < 0\n  index >= length\n  length < 0, which is implied from the former inequalities"
                }
              ]
            },
            {
              "name": "checkFromToIndex",
              "overloads": [
                {
                  "signature": "public static int checkFromToIndex(int fromIndex, int toIndex, int length)",
                  "description": "Checks if the sub-range from fromIndex (inclusive) to\n toIndex (exclusive) is within the bounds of range from 0\n (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \n  fromIndex < 0\n  fromIndex > toIndex\n  toIndex > length\n  length < 0, which is implied from the former inequalities"
                },
                {
                  "signature": "public static long checkFromToIndex(long fromIndex, long toIndex, long length)",
                  "description": "Checks if the sub-range from fromIndex (inclusive) to\n toIndex (exclusive) is within the bounds of range from 0\n (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \n  fromIndex < 0\n  fromIndex > toIndex\n  toIndex > length\n  length < 0, which is implied from the former inequalities"
                }
              ]
            },
            {
              "name": "checkFromIndexSize",
              "overloads": [
                {
                  "signature": "public static int checkFromIndexSize(int fromIndex, int size, int length)",
                  "description": "Checks if the sub-range from fromIndex (inclusive) to\n fromIndex + size (exclusive) is within the bounds of range from\n 0 (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \n  fromIndex < 0\n  size < 0\n  fromIndex + size > length, taking into account integer overflow\n  length < 0, which is implied from the former inequalities"
                },
                {
                  "signature": "public static long checkFromIndexSize(long fromIndex, long size, long length)",
                  "description": "Checks if the sub-range from fromIndex (inclusive) to\n fromIndex + size (exclusive) is within the bounds of range from\n 0 (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \n  fromIndex < 0\n  size < 0\n  fromIndex + size > length, taking into account integer overflow\n  length < 0, which is implied from the former inequalities"
                }
              ]
            }
          ]
        },
        {
          "name": "Observable",
          "methods": [
            {
              "name": "Observable",
              "overloads": [
                {
                  "signature": "public Observable()",
                  "description": "Construct an Observable with zero Observers.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "addObserver",
              "overloads": [
                {
                  "signature": "public void addObserver(Observer o)",
                  "description": "Adds an observer to the set of observers for this object, provided\n that it is not the same as some observer already in the set.\n The order in which notifications will be delivered to multiple\n observers is not specified. See the class comment.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "deleteObserver",
              "overloads": [
                {
                  "signature": "public void deleteObserver(Observer o)",
                  "description": "Deletes an observer from the set of observers of this object.\n Passing null to this method will have no effect.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "notifyObservers",
              "overloads": [
                {
                  "signature": "public void notifyObservers()",
                  "description": "If this object has changed, as indicated by the\n hasChanged method, then notify all of its observers\n and then call the clearChanged method to\n indicate that this object has no longer changed.\n \n Each observer has its update method called with two\n arguments: this observable object and null. In other\n words, this method is equivalent to:\n \n notifyObservers(null)",
                  "deprecated": true
                },
                {
                  "signature": "public void notifyObservers(Object arg)",
                  "description": "If this object has changed, as indicated by the\n hasChanged method, then notify all of its observers\n and then call the clearChanged method to indicate\n that this object has no longer changed.\n \n Each observer has its update method called with two\n arguments: this observable object and the arg argument.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "deleteObservers",
              "overloads": [
                {
                  "signature": "public void deleteObservers()",
                  "description": "Clears the observer list so that this object no longer has any observers.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setChanged",
              "overloads": [
                {
                  "signature": "protected void setChanged()",
                  "description": "Marks this Observable object as having been changed; the\n hasChanged method will now return true.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "clearChanged",
              "overloads": [
                {
                  "signature": "protected void clearChanged()",
                  "description": "Indicates that this object has no longer changed, or that it has\n already notified all of its observers of its most recent change,\n so that the hasChanged method will now return false.\n This method is called automatically by the\n notifyObservers methods.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "hasChanged",
              "overloads": [
                {
                  "signature": "public boolean hasChanged()",
                  "description": "Tests if this object has changed.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "countObservers",
              "overloads": [
                {
                  "signature": "public int countObservers()",
                  "description": "Returns the number of observers of this Observable object.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Observer",
          "methods": [
            {
              "name": "update",
              "overloads": [
                {
                  "signature": "void update(Observable o, Object arg)",
                  "description": "This method is called whenever the observed object is changed. An\n application calls an Observable object's\n notifyObservers method to have all the object's\n observers notified of the change.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Optional<T>",
          "methods": [
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static <T> Optional<T> empty()",
                  "description": "Returns an empty Optional instance.  No value is present for this\n Optional."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static <T> Optional<T> of(T value)",
                  "description": "Returns an Optional describing the given non-null\n value."
                }
              ]
            },
            {
              "name": "ofNullable",
              "overloads": [
                {
                  "signature": "public static <T> Optional<T> ofNullable(T value)",
                  "description": "Returns an Optional describing the given value, if\n non-null, otherwise returns an empty Optional."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public T get()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                }
              ]
            },
            {
              "name": "isPresent",
              "overloads": [
                {
                  "signature": "public boolean isPresent()",
                  "description": "If a value is present, returns true, otherwise false."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "If a value is  not present, returns true, otherwise\n false."
                }
              ]
            },
            {
              "name": "ifPresent",
              "overloads": [
                {
                  "signature": "public void ifPresent(Consumer<? super T> action)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise does nothing."
                }
              ]
            },
            {
              "name": "ifPresentOrElse",
              "overloads": [
                {
                  "signature": "public void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise performs the given empty-based action."
                }
              ]
            },
            {
              "name": "filter",
              "overloads": [
                {
                  "signature": "public Optional<T> filter(Predicate<? super T> predicate)",
                  "description": "If a value is present, and the value matches the given predicate,\n returns an Optional describing the value, otherwise returns an\n empty Optional."
                }
              ]
            },
            {
              "name": "map",
              "overloads": [
                {
                  "signature": "public <U> Optional<U> map(Function<? super T,? extends U> mapper)",
                  "description": "If a value is present, returns an Optional describing (as if by\n ofNullable(T)) the result of applying the given mapping function to\n the value, otherwise returns an empty Optional.\n\n If the mapping function returns a null result then this method\n returns an empty Optional."
                }
              ]
            },
            {
              "name": "flatMap",
              "overloads": [
                {
                  "signature": "public <U> Optional<U> flatMap(Function<? super T,? extends Optional<? extends U>> mapper)",
                  "description": "If a value is present, returns the result of applying the given\n Optional-bearing mapping function to the value, otherwise returns\n an empty Optional.\n\n This method is similar to map(Function), but the mapping\n function is one whose result is already an Optional, and if\n invoked, flatMap does not wrap it within an additional\n Optional."
                }
              ]
            },
            {
              "name": "or",
              "overloads": [
                {
                  "signature": "public Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)",
                  "description": "If a value is present, returns an Optional describing the value,\n otherwise returns an Optional produced by the supplying function."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public Stream<T> stream()",
                  "description": "If a value is present, returns a sequential Stream containing\n only that value, otherwise returns an empty Stream."
                }
              ]
            },
            {
              "name": "orElse",
              "overloads": [
                {
                  "signature": "public T orElse(T other)",
                  "description": "If a value is present, returns the value, otherwise returns\n other."
                }
              ]
            },
            {
              "name": "orElseGet",
              "overloads": [
                {
                  "signature": "public T orElseGet(Supplier<? extends T> supplier)",
                  "description": "If a value is present, returns the value, otherwise returns the result\n produced by the supplying function."
                }
              ]
            },
            {
              "name": "orElseThrow",
              "overloads": [
                {
                  "signature": "public T orElseThrow()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                },
                {
                  "signature": "public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X",
                  "description": "If a value is present, returns the value, otherwise throws an exception\n produced by the exception supplying function."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this Optional.\n The other object is considered equal if:\n \n it is also an Optional and;\n both instances have no value present or;\n the present values are \"equal to\" each other via equals()."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of the value, if present, otherwise 0\n (zero) if no value is present."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this Optional\n suitable for debugging.  The exact presentation format is unspecified and\n may vary between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "OptionalDouble",
          "methods": [
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static OptionalDouble empty()",
                  "description": "Returns an empty OptionalDouble instance.  No value is present\n for this OptionalDouble."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static OptionalDouble of(double value)",
                  "description": "Returns an OptionalDouble describing the given value."
                }
              ]
            },
            {
              "name": "getAsDouble",
              "overloads": [
                {
                  "signature": "public double getAsDouble()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                }
              ]
            },
            {
              "name": "isPresent",
              "overloads": [
                {
                  "signature": "public boolean isPresent()",
                  "description": "If a value is present, returns true, otherwise false."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "If a value is not present, returns true, otherwise\n false."
                }
              ]
            },
            {
              "name": "ifPresent",
              "overloads": [
                {
                  "signature": "public void ifPresent(DoubleConsumer action)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise does nothing."
                }
              ]
            },
            {
              "name": "ifPresentOrElse",
              "overloads": [
                {
                  "signature": "public void ifPresentOrElse(DoubleConsumer action, Runnable emptyAction)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise performs the given empty-based action."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public DoubleStream stream()",
                  "description": "If a value is present, returns a sequential DoubleStream\n containing only that value, otherwise returns an empty\n DoubleStream."
                }
              ]
            },
            {
              "name": "orElse",
              "overloads": [
                {
                  "signature": "public double orElse(double other)",
                  "description": "If a value is present, returns the value, otherwise returns\n other."
                }
              ]
            },
            {
              "name": "orElseGet",
              "overloads": [
                {
                  "signature": "public double orElseGet(DoubleSupplier supplier)",
                  "description": "If a value is present, returns the value, otherwise returns the result\n produced by the supplying function."
                }
              ]
            },
            {
              "name": "orElseThrow",
              "overloads": [
                {
                  "signature": "public double orElseThrow()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                },
                {
                  "signature": "public <X extends Throwable> double orElseThrow(Supplier<? extends X> exceptionSupplier) throws X",
                  "description": "If a value is present, returns the value, otherwise throws an exception\n produced by the exception supplying function."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this\n OptionalDouble. The other object is considered equal if:\n \n it is also an OptionalDouble and;\n both instances have no value present or;\n the present values are \"equal to\" each other via\n Double.compare() == 0."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of the value, if present, otherwise 0\n (zero) if no value is present."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this OptionalDouble\n suitable for debugging.  The exact presentation format is unspecified and\n may vary between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "OptionalInt",
          "methods": [
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static OptionalInt empty()",
                  "description": "Returns an empty OptionalInt instance.  No value is present for\n this OptionalInt."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static OptionalInt of(int value)",
                  "description": "Returns an OptionalInt describing the given value."
                }
              ]
            },
            {
              "name": "getAsInt",
              "overloads": [
                {
                  "signature": "public int getAsInt()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                }
              ]
            },
            {
              "name": "isPresent",
              "overloads": [
                {
                  "signature": "public boolean isPresent()",
                  "description": "If a value is present, returns true, otherwise false."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "If a value is not present, returns true, otherwise\n false."
                }
              ]
            },
            {
              "name": "ifPresent",
              "overloads": [
                {
                  "signature": "public void ifPresent(IntConsumer action)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise does nothing."
                }
              ]
            },
            {
              "name": "ifPresentOrElse",
              "overloads": [
                {
                  "signature": "public void ifPresentOrElse(IntConsumer action, Runnable emptyAction)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise performs the given empty-based action."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public IntStream stream()",
                  "description": "If a value is present, returns a sequential IntStream containing\n only that value, otherwise returns an empty IntStream."
                }
              ]
            },
            {
              "name": "orElse",
              "overloads": [
                {
                  "signature": "public int orElse(int other)",
                  "description": "If a value is present, returns the value, otherwise returns\n other."
                }
              ]
            },
            {
              "name": "orElseGet",
              "overloads": [
                {
                  "signature": "public int orElseGet(IntSupplier supplier)",
                  "description": "If a value is present, returns the value, otherwise returns the result\n produced by the supplying function."
                }
              ]
            },
            {
              "name": "orElseThrow",
              "overloads": [
                {
                  "signature": "public int orElseThrow()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                },
                {
                  "signature": "public <X extends Throwable> int orElseThrow(Supplier<? extends X> exceptionSupplier) throws X",
                  "description": "If a value is present, returns the value, otherwise throws an exception\n produced by the exception supplying function."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this\n OptionalInt.  The other object is considered equal if:\n \n it is also an OptionalInt and;\n both instances have no value present or;\n the present values are \"equal to\" each other via ==."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of the value, if present, otherwise 0\n (zero) if no value is present."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this OptionalInt\n suitable for debugging.  The exact presentation format is unspecified and\n may vary between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "OptionalLong",
          "methods": [
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public static OptionalLong empty()",
                  "description": "Returns an empty OptionalLong instance.  No value is present for\n this OptionalLong."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static OptionalLong of(long value)",
                  "description": "Returns an OptionalLong describing the given value."
                }
              ]
            },
            {
              "name": "getAsLong",
              "overloads": [
                {
                  "signature": "public long getAsLong()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                }
              ]
            },
            {
              "name": "isPresent",
              "overloads": [
                {
                  "signature": "public boolean isPresent()",
                  "description": "If a value is present, returns true, otherwise false."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "If a value is not present, returns true, otherwise\n false."
                }
              ]
            },
            {
              "name": "ifPresent",
              "overloads": [
                {
                  "signature": "public void ifPresent(LongConsumer action)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise does nothing."
                }
              ]
            },
            {
              "name": "ifPresentOrElse",
              "overloads": [
                {
                  "signature": "public void ifPresentOrElse(LongConsumer action, Runnable emptyAction)",
                  "description": "If a value is present, performs the given action with the value,\n otherwise performs the given empty-based action."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public LongStream stream()",
                  "description": "If a value is present, returns a sequential LongStream containing\n only that value, otherwise returns an empty LongStream."
                }
              ]
            },
            {
              "name": "orElse",
              "overloads": [
                {
                  "signature": "public long orElse(long other)",
                  "description": "If a value is present, returns the value, otherwise returns\n other."
                }
              ]
            },
            {
              "name": "orElseGet",
              "overloads": [
                {
                  "signature": "public long orElseGet(LongSupplier supplier)",
                  "description": "If a value is present, returns the value, otherwise returns the result\n produced by the supplying function."
                }
              ]
            },
            {
              "name": "orElseThrow",
              "overloads": [
                {
                  "signature": "public long orElseThrow()",
                  "description": "If a value is present, returns the value, otherwise throws\n NoSuchElementException."
                },
                {
                  "signature": "public <X extends Throwable> long orElseThrow(Supplier<? extends X> exceptionSupplier) throws X",
                  "description": "If a value is present, returns the value, otherwise throws an exception\n produced by the exception supplying function."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Indicates whether some other object is \"equal to\" this\n OptionalLong.  The other object is considered equal if:\n \n it is also an OptionalLong and;\n both instances have no value present or;\n the present values are \"equal to\" each other via ==."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of the value, if present, otherwise 0\n (zero) if no value is present."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a non-empty string representation of this OptionalLong\n suitable for debugging.  The exact presentation format is unspecified and\n may vary between implementations and versions."
                }
              ]
            }
          ]
        },
        {
          "name": "PrimitiveIterator.OfDouble",
          "methods": [
            {
              "name": "nextDouble",
              "overloads": [
                {
                  "signature": "double nextDouble()",
                  "description": "Returns the next double element in the iteration."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(DoubleConsumer action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n source of elements in any way (even by calling the remove\n method or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                },
                {
                  "signature": "default void forEachRemaining(Consumer<? super Double> action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n collection in any way (even by calling the remove method\n or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "default Double next()",
                  "description": "Returns the next element in the iteration."
                }
              ]
            }
          ]
        },
        {
          "name": "PrimitiveIterator.OfInt",
          "methods": [
            {
              "name": "nextInt",
              "overloads": [
                {
                  "signature": "int nextInt()",
                  "description": "Returns the next int element in the iteration."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(IntConsumer action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n source of elements in any way (even by calling the remove\n method or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                },
                {
                  "signature": "default void forEachRemaining(Consumer<? super Integer> action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n collection in any way (even by calling the remove method\n or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "default Integer next()",
                  "description": "Returns the next element in the iteration."
                }
              ]
            }
          ]
        },
        {
          "name": "PrimitiveIterator.OfLong",
          "methods": [
            {
              "name": "nextLong",
              "overloads": [
                {
                  "signature": "long nextLong()",
                  "description": "Returns the next long element in the iteration."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(LongConsumer action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n source of elements in any way (even by calling the remove\n method or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                },
                {
                  "signature": "default void forEachRemaining(Consumer<? super Long> action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n collection in any way (even by calling the remove method\n or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "default Long next()",
                  "description": "Returns the next element in the iteration."
                }
              ]
            }
          ]
        },
        {
          "name": "PrimitiveIterator<T,T_CONS>",
          "methods": [
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "void forEachRemaining(T_CONS action)",
                  "description": "Performs the given action for each remaining element until all elements\n have been processed or the action throws an exception.  Actions are\n performed in the order of iteration, if that order is specified.\n Exceptions thrown by the action are relayed to the caller.\n \n The behavior of an iterator is unspecified if the action modifies the\n source of elements in any way (even by calling the remove\n method or other mutator methods of Iterator subtypes),\n unless an overriding class has specified a concurrent modification policy.\n \n Subsequent behavior of an iterator is unspecified if the action throws an\n exception."
                }
              ]
            }
          ]
        },
        {
          "name": "PriorityQueue<E>",
          "methods": [
            {
              "name": "PriorityQueue",
              "overloads": [
                {
                  "signature": "public PriorityQueue()",
                  "description": "Creates a PriorityQueue with the default initial\n capacity (11) that orders its elements according to their\n natural ordering."
                },
                {
                  "signature": "public PriorityQueue(int initialCapacity)",
                  "description": "Creates a PriorityQueue with the specified initial\n capacity that orders its elements according to their\n natural ordering."
                },
                {
                  "signature": "public PriorityQueue(Comparator<? super E> comparator)",
                  "description": "Creates a PriorityQueue with the default initial capacity and\n whose elements are ordered according to the specified comparator."
                },
                {
                  "signature": "public PriorityQueue(int initialCapacity, Comparator<? super E> comparator)",
                  "description": "Creates a PriorityQueue with the specified initial capacity\n that orders its elements according to the specified comparator."
                },
                {
                  "signature": "public PriorityQueue(Collection<? extends E> c)",
                  "description": "Creates a PriorityQueue containing the elements in the\n specified collection.  If the specified collection is an instance of\n a SortedSet or is another PriorityQueue, this\n priority queue will be ordered according to the same ordering.\n Otherwise, this priority queue will be ordered according to the\n natural ordering of its elements."
                },
                {
                  "signature": "public PriorityQueue(PriorityQueue<? extends E> c)",
                  "description": "Creates a PriorityQueue containing the elements in the\n specified priority queue.  This priority queue will be\n ordered according to the same ordering as the given priority\n queue."
                },
                {
                  "signature": "public PriorityQueue(SortedSet<? extends E> c)",
                  "description": "Creates a PriorityQueue containing the elements in the\n specified sorted set.   This priority queue will be ordered\n according to the same ordering as the given sorted set."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Inserts the specified element into this priority queue."
                }
              ]
            },
            {
              "name": "offer",
              "overloads": [
                {
                  "signature": "public boolean offer(E e)",
                  "description": "Inserts the specified element into this priority queue."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "public E peek()",
                  "description": "Description copied from interface:Queue"
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes a single instance of the specified element from this queue,\n if it is present.  More formally, removes an element e such\n that o.equals(e), if this queue contains one or more such\n elements.  Returns true if and only if this queue contained\n the specified element (or equivalently, if this queue changed as a\n result of the call)."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this queue contains the specified element.\n More formally, returns true if and only if this queue contains\n at least one element e such that o.equals(e)."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this queue.\n The elements are in no particular order.\n\n The returned array will be \"safe\" in that no references to it are\n maintained by this queue.  (In other words, this method must allocate\n a new array).  The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this queue; the\n runtime type of the returned array is that of the specified array.\n The returned array elements are in no particular order.\n If the queue fits in the specified array, it is returned therein.\n Otherwise, a new array is allocated with the runtime type of the\n specified array and the size of this queue.\n\n If the queue fits in the specified array with room to spare\n (i.e., the array has more elements than the queue), the element in\n the array immediately following the end of the collection is set to\n null.\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a queue known to contain only strings.\n The following code can be used to dump the queue into a newly\n allocated array of String:\n\n  String[] y = x.toArray(new String[0]);\n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this queue. The iterator\n does not return the elements in any particular order."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Description copied from interface:Collection"
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this priority queue.\n The queue will be empty after this call returns."
                }
              ]
            },
            {
              "name": "poll",
              "overloads": [
                {
                  "signature": "public E poll()",
                  "description": "Description copied from interface:Queue"
                }
              ]
            },
            {
              "name": "comparator",
              "overloads": [
                {
                  "signature": "public Comparator<? super E> comparator()",
                  "description": "Returns the comparator used to order the elements in this\n queue, or null if this queue is sorted according to\n the natural ordering of its elements."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public final Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n queue. The spliterator does not traverse elements in any particular order\n (the ORDERED characteristic is not reported).\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, and Spliterator.NONNULL.\n Overriding implementations should document the reporting of additional\n characteristic values."
                }
              ]
            },
            {
              "name": "removeIf",
              "overloads": [
                {
                  "signature": "public boolean removeIf(Predicate<? super E> filter)",
                  "description": "Description copied from interface:Collection"
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Description copied from class:AbstractCollection"
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "public boolean retainAll(Collection<?> c)",
                  "description": "Description copied from class:AbstractCollection"
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super E> action)",
                  "description": "Description copied from interface:Iterable"
                }
              ]
            }
          ]
        },
        {
          "name": "Properties",
          "methods": [
            {
              "name": "Properties",
              "overloads": [
                {
                  "signature": "public Properties()",
                  "description": "Creates an empty property list with no default values."
                },
                {
                  "signature": "public Properties(int initialCapacity)",
                  "description": "Creates an empty property list with no default values, and with an\n initial size accommodating the specified number of elements without the\n need to dynamically resize."
                },
                {
                  "signature": "public Properties(Properties defaults)",
                  "description": "Creates an empty property list with the specified defaults."
                }
              ]
            },
            {
              "name": "setProperty",
              "overloads": [
                {
                  "signature": "public Object setProperty(String key, String value)",
                  "description": "Calls the Hashtable method put. Provided for\n parallelism with the getProperty method. Enforces use of\n strings for property keys and values. The value returned is the\n result of the Hashtable call to put."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public void load(Reader reader) throws IOException",
                  "description": "Reads a property list (key and element pairs) from the input\n character stream in a simple line-oriented format.\n \n Properties are processed in terms of lines. There are two\n kinds of line, natural lines and logical lines.\n A natural line is defined as a line of\n characters that is terminated either by a set of line terminator\n characters (\\n or \\r or \\r\\n)\n or by the end of the stream. A natural line may be either a blank line,\n a comment line, or hold all or some of a key-element pair. A logical\n line holds all the data of a key-element pair, which may be spread\n out across several adjacent natural lines by escaping\n the line terminator sequence with a backslash character\n \\.  Note that a comment line cannot be extended\n in this manner; every natural line that is a comment must have\n its own comment indicator, as described below. Lines are read from\n input until the end of the stream is reached.\n\n \n A natural line that contains only white space characters is\n considered blank and is ignored.  A comment line has an ASCII\n '#' or '!' as its first non-white\n space character; comment lines are also ignored and do not\n encode key-element information.  In addition to line\n terminators, this format considers the characters space\n (' ', '\\u0020'), tab\n ('\\t', '\\u0009'), and form feed\n ('\\f', '\\u000C') to be white\n space.\n\n \n If a logical line is spread across several natural lines, the\n backslash escaping the line terminator sequence, the line\n terminator sequence, and any white space at the start of the\n following line have no affect on the key or element values.\n The remainder of the discussion of key and element parsing\n (when loading) will assume all the characters constituting\n the key and element appear on a single natural line after\n line continuation characters have been removed.  Note that\n it is not sufficient to only examine the character\n preceding a line terminator sequence to decide if the line\n terminator is escaped; there must be an odd number of\n contiguous backslashes for the line terminator to be escaped.\n Since the input is processed from left to right, a\n non-zero even number of 2n contiguous backslashes\n before a line terminator (or elsewhere) encodes n\n backslashes after escape processing.\n\n \n The key contains all of the characters in the line starting\n with the first non-white space character and up to, but not\n including, the first unescaped '=',\n ':', or white space character other than a line\n terminator. All of these key termination characters may be\n included in the key by escaping them with a preceding backslash\n character; for example,\n\n \\:\\=\n\n would be the two-character key \":=\".  Line\n terminator characters can be included using \\r and\n \\n escape sequences.  Any white space after the\n key is skipped; if the first non-white space character after\n the key is '=' or ':', then it is\n ignored and any white space characters after it are also\n skipped.  All remaining characters on the line become part of\n the associated element string; if there are no remaining\n characters, the element is the empty string\n \"\".  Once the raw character sequences\n constituting the key and element are identified, escape\n processing is performed as described above.\n\n \n As an example, each of the following three lines specifies the key\n \"Truth\" and the associated element value\n \"Beauty\":\n  Truth = Beauty\n  Truth:Beauty\n Truth                    :Beauty\n \n As another example, the following three lines specify a single\n property:\n  fruits                           apple, banana, pear, \\\n                                  cantaloupe, watermelon, \\\n                                  kiwi, mango\n \n The key is \"fruits\" and the associated element is:\n \"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\n Note that a space appears before each \\ so that a space\n will appear after each comma in the final result; the \\,\n line terminator, and leading white space on the continuation line are\n merely discarded and are not replaced by one or more other\n characters.\n \n As a third example, the line:\n cheeses\n \n specifies that the key is \"cheeses\" and the associated\n element is the empty string \"\".\n \n \n Characters in keys and elements can be represented in escape\n sequences similar to those used for character and string literals\n (see sections 3.3 and 3.10.6 of\n The Java Language Specification).\n\n The differences from the character escape sequences and Unicode\n escapes used for characters and strings are:\n\n \n  Octal escapes are not recognized.\n\n  The character sequence \\b does not\n represent a backspace character.\n\n  The method does not treat a backslash character,\n \\, before a non-valid escape character as an\n error; the backslash is silently dropped.  For example, in a\n Java string the sequence \"\\z\" would cause a\n compile time error.  In contrast, this method silently drops\n the backslash.  Therefore, this method treats the two character\n sequence \"\\b\" as equivalent to the single\n character 'b'.\n\n  Escapes are not necessary for single and double quotes;\n however, by the rule above, single and double quote characters\n preceded by a backslash still yield single and double quote\n characters, respectively.\n\n  Only a single 'u' character is allowed in a Unicode escape\n sequence.\n\n \n \n The specified stream remains open after this method returns."
                },
                {
                  "signature": "public void load(InputStream inStream) throws IOException",
                  "description": "Reads a property list (key and element pairs) from the input\n byte stream. The input stream is in a simple line-oriented\n format as specified in\n load(Reader) and is assumed to use\n the ISO 8859-1 character encoding; that is each byte is one Latin1\n character. Characters not in Latin1, and certain special characters,\n are represented in keys and elements using Unicode escapes as defined in\n section 3.3 of\n The Java Language Specification.\n \n The specified stream remains open after this method returns."
                }
              ]
            },
            {
              "name": "save",
              "overloads": [
                {
                  "signature": "@Deprecated public void save(OutputStream out, String comments)",
                  "description": "Calls the store(OutputStream out, String comments) method\n and suppresses IOExceptions that were thrown.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "store",
              "overloads": [
                {
                  "signature": "public void store(Writer writer, String comments) throws IOException",
                  "description": "Writes this property list (key and element pairs) in this\n Properties table to the output character stream in a\n format suitable for using the load(Reader)\n method.\n \n Properties from the defaults table of this Properties\n table (if any) are not written out by this method.\n \n If the comments argument is not null, then an ASCII #\n character, the comments string, and a line separator are first written\n to the output stream. Thus, the comments can serve as an\n identifying comment. Any one of a line feed ('\\n'), a carriage\n return ('\\r'), or a carriage return followed immediately by a line feed\n in comments is replaced by a line separator generated by the Writer\n and if the next character in comments is not character # or\n character ! then an ASCII # is written out\n after that line separator.\n \n Next, a comment line is always written, consisting of an ASCII\n # character, the current date and time (as if produced\n by the toString method of Date for the\n current time), and a line separator as generated by the Writer.\n \n Then every entry in this Properties table is\n written out, one per line. For each entry the key string is\n written, then an ASCII =, then the associated\n element string. For the key, all space characters are\n written with a preceding \\ character.  For the\n element, leading space characters, but not embedded or trailing\n space characters, are written with a preceding \\\n character. The key and element characters #,\n !, =, and : are written\n with a preceding backslash to ensure that they are properly loaded.\n \n After the entries have been written, the output stream is flushed.\n The output stream remains open after this method returns."
                },
                {
                  "signature": "public void store(OutputStream out, String comments) throws IOException",
                  "description": "Writes this property list (key and element pairs) in this\n Properties table to the output stream in a format suitable\n for loading into a Properties table using the\n load(InputStream) method.\n \n Properties from the defaults table of this Properties\n table (if any) are not written out by this method.\n \n This method outputs the comments, properties keys and values in\n the same format as specified in\n store(Writer),\n with the following differences:\n \n The stream is written using the ISO 8859-1 character encoding.\n\n Characters not in Latin-1 in the comments are written as\n \\uxxxx for their appropriate unicode\n hexadecimal value xxxx.\n\n Characters less than \\u0020 and characters greater\n than \\u007E in property keys or values are written\n as \\uxxxx for the appropriate hexadecimal\n value xxxx.\n \n \n After the entries have been written, the output stream is flushed.\n The output stream remains open after this method returns."
                }
              ]
            },
            {
              "name": "loadFromXML",
              "overloads": [
                {
                  "signature": "public void loadFromXML(InputStream in) throws IOException, InvalidPropertiesFormatException",
                  "description": "Loads all of the properties represented by the XML document on the\n specified input stream into this properties table.\n\n The XML document must have the following DOCTYPE declaration:\n  <!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n \n Furthermore, the document must satisfy the properties DTD described\n above.\n\n  An implementation is required to read XML documents that use the\n \"UTF-8\" or \"UTF-16\" encoding. An implementation may\n support additional encodings.\n\n The specified stream is closed after this method returns."
                }
              ]
            },
            {
              "name": "storeToXML",
              "overloads": [
                {
                  "signature": "public void storeToXML(OutputStream os, String comment) throws IOException",
                  "description": "Emits an XML document representing all of the properties contained\n in this table.\n\n  An invocation of this method of the form props.storeToXML(os,\n comment) behaves in exactly the same way as the invocation\n props.storeToXML(os, comment, \"UTF-8\");."
                },
                {
                  "signature": "public void storeToXML(OutputStream os, String comment, String encoding) throws IOException",
                  "description": "Emits an XML document representing all of the properties contained\n in this table, using the specified encoding.\n\n The XML document will have the following DOCTYPE declaration:\n  <!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n \n\n If the specified comment is null then no comment\n will be stored in the document.\n\n  An implementation is required to support writing of XML documents\n that use the \"UTF-8\" or \"UTF-16\" encoding. An\n implementation may support additional encodings.\n\n The specified stream remains open after this method returns.\n\n This method behaves the same as\n storeToXML(OutputStream os, String comment, Charset charset)\n except that it will look up the charset\n using the given encoding name."
                },
                {
                  "signature": "public void storeToXML(OutputStream os, String comment, Charset charset) throws IOException",
                  "description": "Emits an XML document representing all of the properties contained\n in this table, using the specified encoding.\n\n The XML document will have the following DOCTYPE declaration:\n  <!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n \n\n If the specified comment is null then no comment\n will be stored in the document.\n\n  An implementation is required to support writing of XML documents\n that use the \"UTF-8\" or \"UTF-16\" encoding. An\n implementation may support additional encodings.\n\n  Unmappable characters for the specified charset will be encoded as\n numeric character references.\n\n The specified stream remains open after this method returns."
                }
              ]
            },
            {
              "name": "getProperty",
              "overloads": [
                {
                  "signature": "public String getProperty(String key)",
                  "description": "Searches for the property with the specified key in this property list.\n If the key is not found in this property list, the default property list,\n and its defaults, recursively, are then checked. The method returns\n null if the property is not found."
                },
                {
                  "signature": "public String getProperty(String key, String defaultValue)",
                  "description": "Searches for the property with the specified key in this property list.\n If the key is not found in this property list, the default property list,\n and its defaults, recursively, are then checked. The method returns the\n default value argument if the property is not found."
                }
              ]
            },
            {
              "name": "propertyNames",
              "overloads": [
                {
                  "signature": "public Enumeration<?> propertyNames()",
                  "description": "Returns an enumeration of all the keys in this property list,\n including distinct keys in the default property list if a key\n of the same name has not already been found from the main\n properties list."
                }
              ]
            },
            {
              "name": "stringPropertyNames",
              "overloads": [
                {
                  "signature": "public Set<String> stringPropertyNames()",
                  "description": "Returns an unmodifiable set of keys from this property list\n where the key and its corresponding value are strings,\n including distinct keys in the default property list if a key\n of the same name has not already been found from the main\n properties list.  Properties whose key or value is not\n of type String are omitted.\n \n The returned set is not backed by this Properties object.\n Changes to this Properties object are not reflected in the\n returned set."
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public void list(PrintStream out)",
                  "description": "Prints this property list out to the specified output stream.\n This method is useful for debugging."
                },
                {
                  "signature": "public void list(PrintWriter out)",
                  "description": "Prints this property list out to the specified output stream.\n This method is useful for debugging."
                }
              ]
            }
          ]
        },
        {
          "name": "PropertyPermission",
          "methods": [
            {
              "name": "PropertyPermission",
              "overloads": [
                {
                  "signature": "public PropertyPermission(String name, String actions)",
                  "description": "Creates a new PropertyPermission object with the specified name.\n The name is the name of the system property, and\n actions contains a comma-separated list of the\n desired actions granted on the property. Possible actions are\n \"read\" and \"write\"."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this PropertyPermission object \"implies\" the specified\n permission.\n \n More specifically, this method returns true if:\n \n  p is an instanceof PropertyPermission,\n  p's actions are a subset of this\n object's actions, and\n  p's name is implied by this object's\n      name. For example, \"java.*\" implies \"java.home\"."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two PropertyPermission objects for equality. Checks that obj is\n a PropertyPermission, and has the same name and actions as this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object.\n The hash code used is the hash code of this permissions name, that is,\n getName().hashCode(), where getName is\n from the Permission superclass."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the \"canonical string representation\" of the actions.\n That is, this method always returns present actions in the following order:\n read, write. For example, if this PropertyPermission object\n allows both write and read actions, a call to getActions\n will return the string \"read,write\"."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing\n PropertyPermission objects."
                }
              ]
            }
          ]
        },
        {
          "name": "PropertyResourceBundle",
          "methods": [
            {
              "name": "PropertyResourceBundle",
              "overloads": [
                {
                  "signature": "public PropertyResourceBundle(InputStream stream) throws IOException",
                  "description": "Creates a property resource bundle from an InputStream. This constructor reads the property file in UTF-8 by default.\n If a MalformedInputException or an\n UnmappableCharacterException occurs on reading the\n input stream, then the PropertyResourceBundle instance resets to the state\n before the exception, re-reads the input stream in ISO-8859-1 and\n continues reading. If the system property\n java.util.PropertyResourceBundle.encoding is set to either\n \"ISO-8859-1\" or \"UTF-8\", the input stream is solely read in that encoding,\n and throws the exception if it encounters an invalid sequence. Other\n encoding values are ignored for this system property.\n The system property is read and evaluated when initializing this class.\n Changing or removing the property has no effect after the initialization."
                },
                {
                  "signature": "public PropertyResourceBundle(Reader reader) throws IOException",
                  "description": "Creates a property resource bundle from a Reader.  Unlike the constructor\n PropertyResourceBundle(InputStream),\n there is no limitation as to the encoding of the input property file."
                }
              ]
            },
            {
              "name": "handleGetObject",
              "overloads": [
                {
                  "signature": "public Object handleGetObject(String key)",
                  "description": "Description copied from class:ResourceBundle"
                }
              ]
            },
            {
              "name": "getKeys",
              "overloads": [
                {
                  "signature": "public Enumeration<String> getKeys()",
                  "description": "Returns an Enumeration of the keys contained in\n this ResourceBundle and its parent bundles."
                }
              ]
            },
            {
              "name": "handleKeySet",
              "overloads": [
                {
                  "signature": "protected Set<String> handleKeySet()",
                  "description": "Returns a Set of the keys contained\n only in this ResourceBundle."
                }
              ]
            }
          ]
        },
        {
          "name": "Queue<E>",
          "methods": [
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Inserts the specified element into this queue if it is possible to do so\n immediately without violating capacity restrictions, returning\n true upon success and throwing an IllegalStateException\n if no space is currently available."
                }
              ]
            },
            {
              "name": "offer",
              "overloads": [
                {
                  "signature": "boolean offer(E e)",
                  "description": "Inserts the specified element into this queue if it is possible to do\n so immediately without violating capacity restrictions.\n When using a capacity-restricted queue, this method is generally\n preferable to add(E), which can fail to insert an element only\n by throwing an exception."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "E remove()",
                  "description": "Retrieves and removes the head of this queue.  This method differs\n from poll() only in that it throws an exception if\n this queue is empty."
                }
              ]
            },
            {
              "name": "poll",
              "overloads": [
                {
                  "signature": "E poll()",
                  "description": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty."
                }
              ]
            },
            {
              "name": "element",
              "overloads": [
                {
                  "signature": "E element()",
                  "description": "Retrieves, but does not remove, the head of this queue.  This method\n differs from peek only in that it throws an exception\n if this queue is empty."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "E peek()",
                  "description": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty."
                }
              ]
            }
          ]
        },
        {
          "name": "Random",
          "methods": [
            {
              "name": "Random",
              "overloads": [
                {
                  "signature": "public Random()",
                  "description": "Creates a new random number generator. This constructor sets\n the seed of the random number generator to a value very likely\n to be distinct from any other invocation of this constructor."
                },
                {
                  "signature": "public Random(long seed)",
                  "description": "Creates a new random number generator using a single long seed.\n The seed is the initial value of the internal state of the pseudorandom\n number generator which is maintained by method next(int)."
                }
              ]
            },
            {
              "name": "setSeed",
              "overloads": [
                {
                  "signature": "public void setSeed(long seed)",
                  "description": "Sets the seed of this random number generator using a single\n long seed. The general contract of setSeed is\n that it alters the state of this random number generator object\n so as to be in exactly the same state as if it had just been\n created with the argument seed as a seed. The method\n setSeed is implemented by class Random by\n atomically updating the seed to\n  (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)\n and clearing the haveNextNextGaussian flag used by nextGaussian().\n\n The implementation of setSeed by class Random\n happens to use only 48 bits of the given seed. In general, however,\n an overriding method may use all 64 bits of the long\n argument as a seed value."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "protected int next(int bits)",
                  "description": "Generates the next pseudorandom number. Subclasses should\n override this, as this is used by all other methods.\n\n The general contract of next is that it returns an\n int value and if the argument bits is between\n 1 and 32 (inclusive), then that many low-order\n bits of the returned value will be (approximately) independently\n chosen bit values, each of which is (approximately) equally\n likely to be 0 or 1. The method next is\n implemented by class Random by atomically updating the seed to\n  (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)\n and returning\n  (int)(seed >>> (48 - bits)).\n\n This is a linear congruential pseudorandom number generator, as\n defined by D. H. Lehmer and described by Donald E. Knuth in\n The Art of Computer Programming, Volume 2, Third edition:\n Seminumerical Algorithms, section 3.2.1."
                }
              ]
            },
            {
              "name": "nextBytes",
              "overloads": [
                {
                  "signature": "public void nextBytes(byte[] bytes)",
                  "description": "Generates random bytes and places them into a user-supplied\n byte array.  The number of random bytes produced is equal to\n the length of the byte array."
                }
              ]
            },
            {
              "name": "nextInt",
              "overloads": [
                {
                  "signature": "public int nextInt()",
                  "description": "Returns the next pseudorandom, uniformly distributed int\n value from this random number generator's sequence. The general\n contract of nextInt is that one int value is\n pseudorandomly generated and returned. All 232 possible\n int values are produced with (approximately) equal probability."
                },
                {
                  "signature": "public int nextInt(int bound)",
                  "description": "Returns a pseudorandom, uniformly distributed int value\n between 0 (inclusive) and the specified value (exclusive), drawn from\n this random number generator's sequence.  The general contract of\n nextInt is that one int value in the specified range\n is pseudorandomly generated and returned.  All bound possible\n int values are produced with (approximately) equal\n probability."
                }
              ]
            },
            {
              "name": "nextLong",
              "overloads": [
                {
                  "signature": "public long nextLong()",
                  "description": "Returns the next pseudorandom, uniformly distributed long\n value from this random number generator's sequence. The general\n contract of nextLong is that one long value is\n pseudorandomly generated and returned."
                }
              ]
            },
            {
              "name": "nextBoolean",
              "overloads": [
                {
                  "signature": "public boolean nextBoolean()",
                  "description": "Returns the next pseudorandom, uniformly distributed\n boolean value from this random number generator's\n sequence. The general contract of nextBoolean is that one\n boolean value is pseudorandomly generated and returned.  The\n values true and false are produced with\n (approximately) equal probability."
                }
              ]
            },
            {
              "name": "nextFloat",
              "overloads": [
                {
                  "signature": "public float nextFloat()",
                  "description": "Returns the next pseudorandom, uniformly distributed float\n value between 0.0 and 1.0 from this random\n number generator's sequence.\n\n The general contract of nextFloat is that one\n float value, chosen (approximately) uniformly from the\n range 0.0f (inclusive) to 1.0f (exclusive), is\n pseudorandomly generated and returned. All 224 possible\n float values of the form mx2-24,\n where m is a positive integer less than 224, are\n produced with (approximately) equal probability."
                }
              ]
            },
            {
              "name": "nextDouble",
              "overloads": [
                {
                  "signature": "public double nextDouble()",
                  "description": "Returns the next pseudorandom, uniformly distributed\n double value between 0.0 and\n 1.0 from this random number generator's sequence.\n\n The general contract of nextDouble is that one\n double value, chosen (approximately) uniformly from the\n range 0.0d (inclusive) to 1.0d (exclusive), is\n pseudorandomly generated and returned."
                }
              ]
            },
            {
              "name": "nextGaussian",
              "overloads": [
                {
                  "signature": "public double nextGaussian()",
                  "description": "Returns the next pseudorandom, Gaussian (\"normally\") distributed\n double value with mean 0.0 and standard\n deviation 1.0 from this random number generator's sequence.\n \n The general contract of nextGaussian is that one\n double value, chosen from (approximately) the usual\n normal distribution with mean 0.0 and standard deviation\n 1.0, is pseudorandomly generated and returned."
                }
              ]
            },
            {
              "name": "ints",
              "overloads": [
                {
                  "signature": "public IntStream ints(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom int values.\n\n A pseudorandom int value is generated as if it's the result of\n calling the method nextInt()."
                },
                {
                  "signature": "public IntStream ints()",
                  "description": "Returns an effectively unlimited stream of pseudorandom int\n values.\n\n A pseudorandom int value is generated as if it's the result of\n calling the method nextInt()."
                },
                {
                  "signature": "public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number\n of pseudorandom int values, each conforming to the given\n origin (inclusive) and bound (exclusive).\n\n A pseudorandom int value is generated as if it's the result of\n calling the following method with the origin and bound:\n  \n int nextInt(int origin, int bound) {\n   int n = bound - origin;\n   if (n > 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r = nextInt();\n     } while (r < origin || r >= bound);\n     return r;\n   }\n }"
                },
                {
                  "signature": "public IntStream ints(int randomNumberOrigin, int randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n int values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom int value is generated as if it's the result of\n calling the following method with the origin and bound:\n  \n int nextInt(int origin, int bound) {\n   int n = bound - origin;\n   if (n > 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r = nextInt();\n     } while (r < origin || r >= bound);\n     return r;\n   }\n }"
                }
              ]
            },
            {
              "name": "longs",
              "overloads": [
                {
                  "signature": "public LongStream longs(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom long values.\n\n A pseudorandom long value is generated as if it's the result\n of calling the method nextLong()."
                },
                {
                  "signature": "public LongStream longs()",
                  "description": "Returns an effectively unlimited stream of pseudorandom long\n values.\n\n A pseudorandom long value is generated as if it's the result\n of calling the method nextLong()."
                },
                {
                  "signature": "public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom long, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n A pseudorandom long value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n long nextLong(long origin, long bound) {\n   long r = nextLong();\n   long n = bound - origin, m = n - 1;\n   if ((n & m) == 0L)  // power of two\n     r = (r & m) + origin;\n   else if (n > 0L) {  // reject over-represented candidates\n     for (long u = r >>> 1;            // ensure nonnegative\n          u + m - (r = u % n) < 0L;    // rejection check\n          u = nextLong() >>> 1) // retry\n         ;\n     r += origin;\n   }\n   else {              // range not representable as long\n     while (r < origin || r >= bound)\n       r = nextLong();\n   }\n   return r;\n }"
                },
                {
                  "signature": "public LongStream longs(long randomNumberOrigin, long randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n long values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom long value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n long nextLong(long origin, long bound) {\n   long r = nextLong();\n   long n = bound - origin, m = n - 1;\n   if ((n & m) == 0L)  // power of two\n     r = (r & m) + origin;\n   else if (n > 0L) {  // reject over-represented candidates\n     for (long u = r >>> 1;            // ensure nonnegative\n          u + m - (r = u % n) < 0L;    // rejection check\n          u = nextLong() >>> 1) // retry\n         ;\n     r += origin;\n   }\n   else {              // range not representable as long\n     while (r < origin || r >= bound)\n       r = nextLong();\n   }\n   return r;\n }"
                }
              ]
            },
            {
              "name": "doubles",
              "overloads": [
                {
                  "signature": "public DoubleStream doubles(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each between zero\n (inclusive) and one (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the method nextDouble()."
                },
                {
                  "signature": "public DoubleStream doubles()",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n double values, each between zero (inclusive) and one\n (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the method nextDouble()."
                },
                {
                  "signature": "public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n double nextDouble(double origin, double bound) {\n   double r = nextDouble();\n   r = r * (bound - origin) + origin;\n   if (r >= bound) // correct for rounding\n     r = Math.nextDown(bound);\n   return r;\n }"
                },
                {
                  "signature": "public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n double values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n double nextDouble(double origin, double bound) {\n   double r = nextDouble();\n   r = r * (bound - origin) + origin;\n   if (r >= bound) // correct for rounding\n     r = Math.nextDown(bound);\n   return r;\n }"
                }
              ]
            }
          ]
        },
        {
          "name": "RandomAccess",
          "methods": []
        },
        {
          "name": "ResourceBundle",
          "methods": [
            {
              "name": "ResourceBundle",
              "overloads": [
                {
                  "signature": "public ResourceBundle()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "getBaseBundleName",
              "overloads": [
                {
                  "signature": "public String getBaseBundleName()",
                  "description": "Returns the base name of this bundle, if known, or null if unknown.\n\n If not null, then this is the value of the baseName parameter\n that was passed to the ResourceBundle.getBundle(...) method\n when the resource bundle was loaded."
                }
              ]
            },
            {
              "name": "getString",
              "overloads": [
                {
                  "signature": "public final String getString(String key)",
                  "description": "Gets a string for the given key from this resource bundle or one of its parents.\n Calling this method is equivalent to calling\n \n (String) getObject(key)."
                }
              ]
            },
            {
              "name": "getStringArray",
              "overloads": [
                {
                  "signature": "public final String[] getStringArray(String key)",
                  "description": "Gets a string array for the given key from this resource bundle or one of its parents.\n Calling this method is equivalent to calling\n \n (String[]) getObject(key)."
                }
              ]
            },
            {
              "name": "getObject",
              "overloads": [
                {
                  "signature": "public final Object getObject(String key)",
                  "description": "Gets an object for the given key from this resource bundle or one of its parents.\n This method first tries to obtain the object from this resource bundle using\n handleGetObject.\n If not successful, and the parent resource bundle is not null,\n it calls the parent's getObject method.\n If still not successful, it throws a MissingResourceException."
                }
              ]
            },
            {
              "name": "getLocale",
              "overloads": [
                {
                  "signature": "public Locale getLocale()",
                  "description": "Returns the locale of this resource bundle. This method can be used after a\n call to getBundle() to determine whether the resource bundle returned really\n corresponds to the requested locale or is a fallback."
                }
              ]
            },
            {
              "name": "setParent",
              "overloads": [
                {
                  "signature": "protected void setParent(ResourceBundle parent)",
                  "description": "Sets the parent bundle of this bundle.\n The parent bundle is searched by getObject\n when this bundle does not contain a particular resource."
                }
              ]
            },
            {
              "name": "getBundle",
              "overloads": [
                {
                  "signature": "public static final ResourceBundle getBundle(String baseName)",
                  "description": "Gets a resource bundle using the specified base name, the default locale,\n and the caller module. Calling this method is equivalent to calling\n \n getBundle(baseName, Locale.getDefault(), callerModule),"
                },
                {
                  "signature": "public static final ResourceBundle getBundle(String baseName, ResourceBundle.Control control)",
                  "description": "Returns a resource bundle using the specified base name, the\n default locale and the specified control. Calling this method\n is equivalent to calling\n  getBundle(baseName, Locale.getDefault(),\n           this.getClass().getClassLoader(), control),\n \n except that getClassLoader() is run with the security\n privileges of ResourceBundle.  See getBundle for the\n complete description of the resource bundle loading process with a\n ResourceBundle.Control."
                },
                {
                  "signature": "public static final ResourceBundle getBundle(String baseName, Locale locale)",
                  "description": "Gets a resource bundle using the specified base name and locale,\n and the caller module. Calling this method is equivalent to calling\n \n getBundle(baseName, locale, callerModule),"
                },
                {
                  "signature": "public static ResourceBundle getBundle(String baseName, Module module)",
                  "description": "Gets a resource bundle using the specified base name and the default locale\n on behalf of the specified module. This method is equivalent to calling\n \n getBundle(baseName, Locale.getDefault(), module)"
                },
                {
                  "signature": "public static ResourceBundle getBundle(String baseName, Locale targetLocale, Module module)",
                  "description": "Gets a resource bundle using the specified base name and locale\n on behalf of the specified module.\n\n  Resource bundles in named modules may be encapsulated.  When\n the resource bundle is loaded from a\n service provider, the caller module\n must have an appropriate uses clause in its module descriptor\n to declare that the module uses of ResourceBundleProvider\n for the named resource bundle.\n Otherwise, it will load the resource bundles that are local in the\n given module as if calling Module.getResourceAsStream(String)\n or that are visible to the class loader of the given module\n as if calling ClassLoader.getResourceAsStream(String).\n When the resource bundle is loaded from the specified module, it is\n subject to the encapsulation rules specified by\n Module.getResourceAsStream.\n\n \n If the given module is an unnamed module, then this method is\n equivalent to calling getBundle(baseName, targetLocale, module.getClassLoader() to load\n resource bundles that are visible to the class loader of the given\n unnamed module. Custom ResourceBundleControlProvider\n implementations, if present, will only be invoked if the specified\n module is an unnamed module."
                },
                {
                  "signature": "public static final ResourceBundle getBundle(String baseName, Locale targetLocale, ResourceBundle.Control control)",
                  "description": "Returns a resource bundle using the specified base name, target\n locale and control, and the caller's class loader. Calling this\n method is equivalent to calling\n  getBundle(baseName, targetLocale, this.getClass().getClassLoader(),\n           control),\n \n except that getClassLoader() is run with the security\n privileges of ResourceBundle.  See getBundle for the\n complete description of the resource bundle loading process with a\n ResourceBundle.Control."
                },
                {
                  "signature": "public static ResourceBundle getBundle(String baseName, Locale locale, ClassLoader loader)",
                  "description": "Gets a resource bundle using the specified base name, locale, and class\n loader.\n\n When this method is called from a named module and the given\n loader is the class loader of the caller module, this is equivalent\n to calling:\n  getBundle(baseName, targetLocale, callerModule)\n \n\n otherwise, this is equivalent to calling:\n  getBundle(baseName, targetLocale, loader, control)\n \n where control is the default instance of ResourceBundle.Control unless\n a Control instance is provided by\n ResourceBundleControlProvider SPI.  Refer to the\n description of modifying the default\n behavior. The following describes the default behavior.\n\n \n Resource Bundle Search and Loading Strategy\n\n getBundle uses the base name, the specified locale, and\n the default locale (obtained from Locale.getDefault) to generate a sequence of candidate bundle names.  If the specified\n locale's language, script, country, and variant are all empty strings,\n then the base name is the only candidate bundle name.  Otherwise, a list\n of candidate locales is generated from the attribute values of the\n specified locale (language, script, country and variant) and appended to\n the base name.  Typically, this will look like the following:\n\n      baseName + \"_\" + language + \"_\" + script + \"_\" + country + \"_\" + variant\n     baseName + \"_\" + language + \"_\" + script + \"_\" + country\n     baseName + \"_\" + language + \"_\" + script\n     baseName + \"_\" + language + \"_\" + country + \"_\" + variant\n     baseName + \"_\" + language + \"_\" + country\n     baseName + \"_\" + language\n \n\n Candidate bundle names where the final component is an empty string\n are omitted, along with the underscore.  For example, if country is an\n empty string, the second and the fifth candidate bundle names above\n would be omitted.  Also, if script is an empty string, the candidate names\n including script are omitted.  For example, a locale with language \"de\"\n and variant \"JAVA\" will produce candidate names with base name\n \"MyResource\" below.\n\n      MyResource_de__JAVA\n     MyResource_de\n \n\n In the case that the variant contains one or more underscores ('_'), a\n sequence of bundle names generated by truncating the last underscore and\n the part following it is inserted after a candidate bundle name with the\n original variant.  For example, for a locale with language \"en\", script\n \"Latn, country \"US\" and variant \"WINDOWS_VISTA\", and bundle base name\n \"MyResource\", the list of candidate bundle names below is generated:\n\n  MyResource_en_Latn_US_WINDOWS_VISTA\n MyResource_en_Latn_US_WINDOWS\n MyResource_en_Latn_US\n MyResource_en_Latn\n MyResource_en_US_WINDOWS_VISTA\n MyResource_en_US_WINDOWS\n MyResource_en_US\n MyResource_en\n \n\n Note: For some Locales, the list of\n candidate bundle names contains extra names, or the order of bundle names\n is slightly modified.  See the description of the default implementation\n of getCandidateLocales for details.\n\n getBundle then iterates over the candidate bundle names\n to find the first one for which it can instantiate an actual\n resource bundle. It uses the default controls' getFormats method, which generates two bundle names for each generated\n name, the first a class name and the second a properties file name. For\n each candidate bundle name, it attempts to create a resource bundle:\n\n First, it attempts to load a class using the generated class name.\n If such a class can be found and loaded using the specified class\n loader, is assignment compatible with ResourceBundle, is accessible from\n ResourceBundle, and can be instantiated, getBundle creates a\n new instance of this class and uses it as the result resource\n bundle.\n\n Otherwise, getBundle attempts to locate a property\n resource file using the generated properties file name.  It generates a\n path name from the candidate bundle name by replacing all \".\" characters\n with \"/\" and appending the string \".properties\".  It attempts to find a\n \"resource\" with this name using ClassLoader.getResource.  (Note that a \"resource\" in the sense of\n getResource has nothing to do with the contents of a\n resource bundle, it is just a container of data, such as a file.)  If it\n finds a \"resource\", it attempts to create a new PropertyResourceBundle instance from its contents.  If successful, this\n instance becomes the result resource bundle.  \n\n This continues until a result resource bundle is instantiated or the\n list of candidate bundle names is exhausted.  If no matching resource\n bundle is found, the default control's getFallbackLocale method is called, which returns the current default\n locale.  A new sequence of candidate locale names is generated using this\n locale and searched again, as above.\n\n If still no result bundle is found, the base name alone is looked up. If\n this still fails, a MissingResourceException is thrown.\n\n  Once a result resource bundle has been found,\n its parent chain is instantiated.  If the result bundle already\n has a parent (perhaps because it was returned from a cache) the chain is\n complete.\n\n Otherwise, getBundle examines the remainder of the\n candidate locale list that was used during the pass that generated the\n result resource bundle.  (As before, candidate bundle names where the\n final component is an empty string are omitted.)  When it comes to the\n end of the candidate list, it tries the plain bundle name.  With each of the\n candidate bundle names it attempts to instantiate a resource bundle (first\n looking for a class and then a properties file, as described above).\n\n Whenever it succeeds, it calls the previously instantiated resource\n bundle's setParent method\n with the new resource bundle.  This continues until the list of names\n is exhausted or the current bundle already has a non-null parent.\n\n Once the parent chain is complete, the bundle is returned.\n\n Note: getBundle caches instantiated resource\n bundles and might return the same resource bundle instance multiple times.\n\n Note:The baseName argument should be a fully\n qualified class name. However, for compatibility with earlier versions,\n Java SE Runtime Environments do not verify this, and so it is\n possible to access PropertyResourceBundles by specifying a\n path name (using \"/\") instead of a fully qualified class name (using\n \".\").\n\n \n Example:\n \n The following class and property files are provided:\n \n     MyResources.class\n     MyResources.properties\n     MyResources_fr.properties\n     MyResources_fr_CH.class\n     MyResources_fr_CH.properties\n     MyResources_en.properties\n     MyResources_es_ES.class\n \n\n The contents of all files are valid (that is, public non-abstract\n subclasses of ResourceBundle for the \".class\" files,\n syntactically correct \".properties\" files).  The default locale is\n Locale(\"en\", \"GB\").\n\n Calling getBundle with the locale arguments below will\n instantiate resource bundles as follows:\n\n \n getBundle() locale to resource bundle mapping\n \n LocaleResource bundle\n \n \n Locale(\"fr\", \"CH\")MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class\n Locale(\"fr\", \"FR\")MyResources_fr.properties, parent MyResources.class\n Locale(\"de\", \"DE\")MyResources_en.properties, parent MyResources.class\n Locale(\"en\", \"US\")MyResources_en.properties, parent MyResources.class\n Locale(\"es\", \"ES\")MyResources_es_ES.class, parent MyResources.class\n \n \n\n The file MyResources_fr_CH.properties is never used because it is\n hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties\n is also hidden by MyResources.class."
                },
                {
                  "signature": "public static ResourceBundle getBundle(String baseName, Locale targetLocale, ClassLoader loader, ResourceBundle.Control control)",
                  "description": "Returns a resource bundle using the specified base name, target\n locale, class loader and control. Unlike the getBundle\n factory methods with no control argument, the given\n control specifies how to locate and instantiate resource\n bundles. Conceptually, the bundle loading process with the given\n control is performed in the following steps.\n\n \n This factory method looks up the resource bundle in the cache for\n the specified baseName, targetLocale and\n loader.  If the requested resource bundle instance is\n found in the cache and the time-to-live periods of the instance and\n all of its parent instances have not expired, the instance is returned\n to the caller. Otherwise, this factory method proceeds with the\n loading process below.\n\n The control.getFormats method is called to get resource bundle formats\n to produce bundle or resource names. The strings\n \"java.class\" and \"java.properties\"\n designate class-based and property-based resource bundles, respectively. Other strings\n starting with \"java.\" are reserved for future extensions\n and must not be used for application-defined formats. Other strings\n designate application-defined formats.\n\n The control.getCandidateLocales method is called with the target\n locale to get a list of candidate Locales for\n which resource bundles are searched.\n\n The control.newBundle method is called to\n instantiate a ResourceBundle for the base bundle name, a\n candidate locale, and a format. (Refer to the note on the cache\n lookup below.) This step is iterated over all combinations of the\n candidate locales and formats until the newBundle method\n returns a ResourceBundle instance or the iteration has\n used up all the combinations. For example, if the candidate locales\n are Locale(\"de\", \"DE\"), Locale(\"de\") and\n Locale(\"\") and the formats are \"java.class\"\n and \"java.properties\", then the following is the\n sequence of locale-format combinations to be used to call\n control.newBundle.\n\n \n locale-format combinations for newBundle\n \n \n Index\n Locale\n format\n \n \n \n \n 1\n Locale(\"de\", \"DE\")\n java.class\n \n \n 2\n Locale(\"de\", \"DE\")\n java.properties\n \n \n 3\n Locale(\"de\")\n java.class\n \n \n 4\n Locale(\"de\")\n java.properties\n \n \n 5\n Locale(\"\")\n java.class\n \n \n 6\n Locale(\"\")\n java.properties\n \n \n \n \n\n If the previous step has found no resource bundle, proceed to\n Step 6. If a bundle has been found that is a base bundle (a bundle\n for Locale(\"\")), and the candidate locale list only contained\n Locale(\"\"), return the bundle to the caller. If a bundle\n has been found that is a base bundle, but the candidate locale list\n contained locales other than Locale(\"\"), put the bundle on hold and\n proceed to Step 6. If a bundle has been found that is not a base\n bundle, proceed to Step 7.\n\n The control.getFallbackLocale method is called to get a fallback\n locale (alternative to the current target locale) to try further\n finding a resource bundle. If the method returns a non-null locale,\n it becomes the next target locale and the loading process starts over\n from Step 3. Otherwise, if a base bundle was found and put on hold in\n a previous Step 5, it is returned to the caller now. Otherwise, a\n MissingResourceException is thrown.\n\n At this point, we have found a resource bundle that's not the\n base bundle. If this bundle set its parent during its instantiation,\n it is returned to the caller. Otherwise, its parent chain is\n instantiated based on the list of candidate locales from which it was\n found. Finally, the bundle is returned to the caller.\n \n\n During the resource bundle loading process above, this factory\n method looks up the cache before calling the control.newBundle method.  If the time-to-live period of the\n resource bundle found in the cache has expired, the factory method\n calls the control.needsReload\n method to determine whether the resource bundle needs to be reloaded.\n If reloading is required, the factory method calls\n control.newBundle to reload the resource bundle.  If\n control.newBundle returns null, the factory\n method puts a dummy resource bundle in the cache as a mark of\n nonexistent resource bundles in order to avoid lookup overhead for\n subsequent requests. Such dummy resource bundles are under the same\n expiration control as specified by control.\n\n All resource bundles loaded are cached by default. Refer to\n control.getTimeToLive for details.\n\n The following is an example of the bundle loading process with the\n default ResourceBundle.Control implementation.\n\n Conditions:\n \n Base bundle name: foo.bar.Messages\n Requested Locale: Locale.ITALY\n Default Locale: Locale.FRENCH\n Available resource bundles:\n foo/bar/Messages_fr.properties and\n foo/bar/Messages.properties\n \n\n First, getBundle tries loading a resource bundle in\n the following sequence.\n\n \n class foo.bar.Messages_it_IT\n file foo/bar/Messages_it_IT.properties\n class foo.bar.Messages_it\n file foo/bar/Messages_it.properties\n class foo.bar.Messages\n file foo/bar/Messages.properties\n \n\n At this point, getBundle finds\n foo/bar/Messages.properties, which is put on hold\n because it's the base bundle.  getBundle calls control.getFallbackLocale(\"foo.bar.Messages\", Locale.ITALY) which\n returns Locale.FRENCH. Next, getBundle\n tries loading a bundle in the following sequence.\n\n \n class foo.bar.Messages_fr\n file foo/bar/Messages_fr.properties\n class foo.bar.Messages\n file foo/bar/Messages.properties\n \n\n getBundle finds\n foo/bar/Messages_fr.properties and creates a\n ResourceBundle instance. Then, getBundle\n sets up its parent chain from the list of the candidate locales.  Only\n foo/bar/Messages.properties is found in the list and\n getBundle creates a ResourceBundle instance\n that becomes the parent of the instance for\n foo/bar/Messages_fr.properties."
                }
              ]
            },
            {
              "name": "clearCache",
              "overloads": [
                {
                  "signature": "public static final void clearCache()",
                  "description": "Removes all resource bundles from the cache that have been loaded\n by the caller's module."
                },
                {
                  "signature": "public static final void clearCache(ClassLoader loader)",
                  "description": "Removes all resource bundles from the cache that have been loaded\n by the given class loader."
                }
              ]
            },
            {
              "name": "handleGetObject",
              "overloads": [
                {
                  "signature": "protected abstract Object handleGetObject(String key)",
                  "description": "Gets an object for the given key from this resource bundle.\n Returns null if this resource bundle does not contain an\n object for the given key."
                }
              ]
            },
            {
              "name": "getKeys",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<String> getKeys()",
                  "description": "Returns an enumeration of the keys."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(String key)",
                  "description": "Determines whether the given key is contained in\n this ResourceBundle or its parent bundles."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<String> keySet()",
                  "description": "Returns a Set of all keys contained in this\n ResourceBundle and its parent bundles."
                }
              ]
            },
            {
              "name": "handleKeySet",
              "overloads": [
                {
                  "signature": "protected Set<String> handleKeySet()",
                  "description": "Returns a Set of the keys contained only\n in this ResourceBundle.\n\n The default implementation returns a Set of the\n keys returned by the getKeys method except\n for the ones for which the handleGetObject method returns null. Once the\n Set has been created, the value is kept in this\n ResourceBundle in order to avoid producing the\n same Set in subsequent calls. Subclasses can\n override this method for faster handling."
                }
              ]
            }
          ]
        },
        {
          "name": "ResourceBundle.Control",
          "methods": [
            {
              "name": "Control",
              "overloads": [
                {
                  "signature": "protected Control()",
                  "description": "Sole constructor. (For invocation by subclass constructors,\n typically implicit.)"
                }
              ]
            },
            {
              "name": "getControl",
              "overloads": [
                {
                  "signature": "public static final ResourceBundle.Control getControl(List<String> formats)",
                  "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats. The formats must be equal to\n one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT. ResourceBundle.Control\n instances returned by this method are singletons and thread-safe.\n\n Specifying FORMAT_DEFAULT is equivalent to\n instantiating the ResourceBundle.Control class,\n except that this method returns a singleton."
                }
              ]
            },
            {
              "name": "getNoFallbackControl",
              "overloads": [
                {
                  "signature": "public static final ResourceBundle.Control getNoFallbackControl(List<String> formats)",
                  "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats and the getFallbackLocale\n method returns null. The formats must\n be equal to one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT.\n ResourceBundle.Control instances returned by this\n method are singletons and thread-safe."
                }
              ]
            },
            {
              "name": "getFormats",
              "overloads": [
                {
                  "signature": "public List<String> getFormats(String baseName)",
                  "description": "Returns a List of Strings containing\n formats to be used to load resource bundles for the given\n baseName. The ResourceBundle.getBundle\n factory method tries to load resource bundles with formats in the\n order specified by the list. The list returned by this method\n must have at least one String. The predefined\n formats are \"java.class\" for class-based resource\n bundles and \"java.properties\" for properties-based ones. Strings starting\n with \"java.\" are reserved for future extensions and\n must not be used by application-defined formats.\n\n It is not a requirement to return an immutable (unmodifiable)\n List.  However, the returned List must\n not be mutated after it has been returned by\n getFormats.\n\n The default implementation returns FORMAT_DEFAULT so\n that the ResourceBundle.getBundle factory method\n looks up first class-based resource bundles, then\n properties-based ones."
                }
              ]
            },
            {
              "name": "getCandidateLocales",
              "overloads": [
                {
                  "signature": "public List<Locale> getCandidateLocales(String baseName, Locale locale)",
                  "description": "Returns a List of Locales as candidate\n locales for baseName and locale. This\n method is called by the ResourceBundle.getBundle\n factory method each time the factory method tries finding a\n resource bundle for a target Locale.\n\n The sequence of the candidate locales also corresponds to the\n runtime resource lookup path (also known as the parent\n chain), if the corresponding resource bundles for the\n candidate locales exist and their parents are not defined by\n loaded resource bundles themselves.  The last element of the list\n must be a root locale if it is desired to\n have the base bundle as the terminal of the parent chain.\n\n If the given locale is equal to Locale.ROOT (the\n root locale), a List containing only the root\n Locale must be returned. In this case, the\n ResourceBundle.getBundle factory method loads only\n the base bundle as the resulting resource bundle.\n\n It is not a requirement to return an immutable (unmodifiable)\n List. However, the returned List must not\n be mutated after it has been returned by\n getCandidateLocales.\n\n The default implementation returns a List containing\n Locales using the rules described below.  In the\n description below, L, S, C and V\n respectively represent non-empty language, script, country, and\n variant.  For example, [L, C] represents a\n Locale that has non-empty values only for language and\n country.  The form L(\"xx\") represents the (non-empty)\n language value is \"xx\".  For all cases, Locales whose\n final component values are empty strings are omitted.\n\n For an input Locale with an empty script value,\n append candidate Locales by omitting the final component\n one by one as below:\n\n \n  [L, C, V] \n  [L, C] \n  [L] \n  Locale.ROOT \n \n\n For an input Locale with a non-empty script value,\n append candidate Locales by omitting the final component\n up to language, then append candidates generated from the\n Locale with country and variant restored:\n\n \n  [L, S, C, V]\n  [L, S, C]\n  [L, S]\n  [L, C, V]\n  [L, C]\n  [L]\n  Locale.ROOT\n \n\n For an input Locale with a variant value consisting\n of multiple subtags separated by underscore, generate candidate\n Locales by omitting the variant subtags one by one, then\n insert them after every occurrence of  Locales with the\n full variant value in the original list.  For example, if\n the variant consists of two subtags V1 and V2:\n\n \n  [L, S, C, V1, V2]\n  [L, S, C, V1]\n  [L, S, C]\n  [L, S]\n  [L, C, V1, V2]\n  [L, C, V1]\n  [L, C]\n  [L]\n  Locale.ROOT\n \n\n Special cases for Chinese.  When an input Locale has the\n language \"zh\" (Chinese) and an empty script value, either \"Hans\" (Simplified) or\n \"Hant\" (Traditional) might be supplied, depending on the country.\n When the country is \"CN\" (China) or \"SG\" (Singapore), \"Hans\" is supplied.\n When the country is \"HK\" (Hong Kong SAR China), \"MO\" (Macau SAR China),\n or \"TW\" (Taiwan), \"Hant\" is supplied.  For all other countries or when the country\n is empty, no script is supplied.  For example, for Locale(\"zh\", \"CN\")\n , the candidate list will be:\n \n  [L(\"zh\"), S(\"Hans\"), C(\"CN\")]\n  [L(\"zh\"), S(\"Hans\")]\n  [L(\"zh\"), C(\"CN\")]\n  [L(\"zh\")]\n  Locale.ROOT\n \n\n For Locale(\"zh\", \"TW\"), the candidate list will be:\n \n  [L(\"zh\"), S(\"Hant\"), C(\"TW\")]\n  [L(\"zh\"), S(\"Hant\")]\n  [L(\"zh\"), C(\"TW\")]\n  [L(\"zh\")]\n  Locale.ROOT\n \n\n Special cases for Norwegian.  Both Locale(\"no\", \"NO\",\n \"NY\") and Locale(\"nn\", \"NO\") represent Norwegian\n Nynorsk.  When a locale's language is \"nn\", the standard candidate\n list is generated up to [L(\"nn\")], and then the following\n candidates are added:\n\n  [L(\"no\"), C(\"NO\"), V(\"NY\")]\n  [L(\"no\"), C(\"NO\")]\n  [L(\"no\")]\n  Locale.ROOT\n \n\n If the locale is exactly Locale(\"no\", \"NO\", \"NY\"), it is first\n converted to Locale(\"nn\", \"NO\") and then the above procedure is\n followed.\n\n Also, Java treats the language \"no\" as a synonym of Norwegian\n Bokml \"nb\".  Except for the single case Locale(\"no\",\n \"NO\", \"NY\") (handled above), when an input Locale\n has language \"no\" or \"nb\", candidate Locales with\n language code \"no\" and \"nb\" are interleaved, first using the\n requested language, then using its synonym. For example,\n Locale(\"nb\", \"NO\", \"POSIX\") generates the following\n candidate list:\n\n \n  [L(\"nb\"), C(\"NO\"), V(\"POSIX\")]\n  [L(\"no\"), C(\"NO\"), V(\"POSIX\")]\n  [L(\"nb\"), C(\"NO\")]\n  [L(\"no\"), C(\"NO\")]\n  [L(\"nb\")]\n  [L(\"no\")]\n  Locale.ROOT\n \n\n Locale(\"no\", \"NO\", \"POSIX\") would generate the same list\n except that locales with \"no\" would appear before the corresponding\n locales with \"nb\".\n \n\n The default implementation uses an ArrayList that\n overriding implementations may modify before returning it to the\n caller. However, a subclass must not modify it after it has\n been returned by getCandidateLocales.\n\n For example, if the given baseName is \"Messages\"\n and the given locale is\n Locale(\"ja\",\"\",\"XX\"), then a\n List of Locales:\n      Locale(\"ja\", \"\", \"XX\")\n     Locale(\"ja\")\n     Locale.ROOT\n \n is returned. And if the resource bundles for the \"ja\" and\n \"\" Locales are found, then the runtime resource\n lookup path (parent chain) is:\n \n     Messages_ja -> Messages"
                }
              ]
            },
            {
              "name": "getFallbackLocale",
              "overloads": [
                {
                  "signature": "public Locale getFallbackLocale(String baseName, Locale locale)",
                  "description": "Returns a Locale to be used as a fallback locale for\n further resource bundle searches by the\n ResourceBundle.getBundle factory method. This method\n is called from the factory method every time when no resulting\n resource bundle has been found for baseName and\n locale, where locale is either the parameter for\n ResourceBundle.getBundle or the previous fallback\n locale returned by this method.\n\n The method returns null if no further fallback\n search is desired.\n\n The default implementation returns the default Locale if the given\n locale isn't the default one.  Otherwise,\n null is returned."
                }
              ]
            },
            {
              "name": "newBundle",
              "overloads": [
                {
                  "signature": "public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException",
                  "description": "Instantiates a resource bundle for the given bundle name of the\n given format and locale, using the given class loader if\n necessary. This method returns null if there is no\n resource bundle available for the given parameters. If a resource\n bundle can't be instantiated due to an unexpected error, the\n error must be reported by throwing an Error or\n Exception rather than simply returning\n null.\n\n If the reload flag is true, it\n indicates that this method is being called because the previously\n loaded resource bundle has expired."
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "public long getTimeToLive(String baseName, Locale locale)",
                  "description": "Returns the time-to-live (TTL) value for resource bundles that\n are loaded under this\n ResourceBundle.Control. Positive time-to-live values\n specify the number of milliseconds a bundle can remain in the\n cache without being validated against the source data from which\n it was constructed. The value 0 indicates that a bundle must be\n validated each time it is retrieved from the cache. TTL_DONT_CACHE specifies that loaded resource bundles are not\n put in the cache. TTL_NO_EXPIRATION_CONTROL specifies\n that loaded resource bundles are put in the cache with no\n expiration control.\n\n The expiration affects only the bundle loading process by the\n ResourceBundle.getBundle factory method.  That is,\n if the factory method finds a resource bundle in the cache that\n has expired, the factory method calls the needsReload method to determine whether the resource\n bundle needs to be reloaded. If needsReload returns\n true, the cached resource bundle instance is removed\n from the cache. Otherwise, the instance stays in the cache,\n updated with the new TTL value returned by this method.\n\n All cached resource bundles are subject to removal from the\n cache due to memory constraints of the runtime environment.\n Returning a large positive value doesn't mean to lock loaded\n resource bundles in the cache.\n\n The default implementation returns TTL_NO_EXPIRATION_CONTROL."
                }
              ]
            },
            {
              "name": "needsReload",
              "overloads": [
                {
                  "signature": "public boolean needsReload(String baseName, Locale locale, String format, ClassLoader loader, ResourceBundle bundle, long loadTime)",
                  "description": "Determines if the expired bundle in the cache needs\n to be reloaded based on the loading time given by\n loadTime or some other criteria. The method returns\n true if reloading is required; false\n otherwise. loadTime is a millisecond offset since\n the  Calendar\n Epoch.\n\n \n The calling ResourceBundle.getBundle factory method\n calls this method on the ResourceBundle.Control\n instance used for its current invocation, not on the instance\n used in the invocation that originally loaded the resource\n bundle.\n\n The default implementation compares loadTime and\n the last modified time of the source data of the resource\n bundle. If it's determined that the source data has been modified\n since loadTime, true is\n returned. Otherwise, false is returned. This\n implementation assumes that the given format is the\n same string as its file suffix if it's not one of the default\n formats, \"java.class\" or\n \"java.properties\"."
                }
              ]
            },
            {
              "name": "toBundleName",
              "overloads": [
                {
                  "signature": "public String toBundleName(String baseName, Locale locale)",
                  "description": "Converts the given baseName and locale\n to the bundle name. This method is called from the default\n implementation of the newBundle and needsReload\n methods.\n\n This implementation returns the following value:\n      baseName + \"_\" + language + \"_\" + script + \"_\" + country + \"_\" + variant\n \n where language, script, country,\n and variant are the language, script, country, and variant\n values of locale, respectively. Final component values that\n are empty Strings are omitted along with the preceding '_'.  When the\n script is empty, the script value is omitted along with the preceding '_'.\n If all of the values are empty strings, then baseName\n is returned.\n\n For example, if baseName is\n \"baseName\" and locale is\n Locale(\"ja\",\"\",\"XX\"), then\n \"baseName_ja__XX\" is returned. If the given\n locale is Locale(\"en\"), then\n \"baseName_en\" is returned.\n\n Overriding this method allows applications to use different\n conventions in the organization and packaging of localized\n resources."
                }
              ]
            },
            {
              "name": "toResourceName",
              "overloads": [
                {
                  "signature": "public final String toResourceName(String bundleName, String suffix)",
                  "description": "Converts the given bundleName to the form required\n by the ClassLoader.getResource\n method by replacing all occurrences of '.' in\n bundleName with '/' and appending a\n '.' and the given file suffix. For\n example, if bundleName is\n \"foo.bar.MyResources_ja_JP\" and suffix\n is \"properties\", then\n \"foo/bar/MyResources_ja_JP.properties\" is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Scanner",
          "methods": [
            {
              "name": "Scanner",
              "overloads": [
                {
                  "signature": "public Scanner(Readable source)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified source."
                },
                {
                  "signature": "public Scanner(InputStream source)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the underlying platform's\n default charset."
                },
                {
                  "signature": "public Scanner(InputStream source, String charsetName)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the specified charset."
                },
                {
                  "signature": "public Scanner(InputStream source, Charset charset)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified input stream. Bytes from the stream are converted\n into characters using the specified charset."
                },
                {
                  "signature": "public Scanner(File source) throws FileNotFoundException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform's\n default charset."
                },
                {
                  "signature": "public Scanner(File source, String charsetName) throws FileNotFoundException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset."
                },
                {
                  "signature": "public Scanner(File source, Charset charset) throws IOException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset."
                },
                {
                  "signature": "public Scanner(Path source) throws IOException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the underlying platform's\n default charset."
                },
                {
                  "signature": "public Scanner(Path source, String charsetName) throws IOException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset."
                },
                {
                  "signature": "public Scanner(Path source, Charset charset) throws IOException",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified file. Bytes from the file are converted into\n characters using the specified charset."
                },
                {
                  "signature": "public Scanner(String source)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified string."
                },
                {
                  "signature": "public Scanner(ReadableByteChannel source)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the underlying platform's\n default charset."
                },
                {
                  "signature": "public Scanner(ReadableByteChannel source, String charsetName)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the specified charset."
                },
                {
                  "signature": "public Scanner(ReadableByteChannel source, Charset charset)",
                  "description": "Constructs a new Scanner that produces values scanned\n from the specified channel. Bytes from the source are converted into\n characters using the specified charset."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes this scanner.\n\n  If this scanner has not yet been closed then if its underlying\n readable also implements the Closeable interface then the readable's close method\n will be invoked.  If this scanner is already closed then invoking this\n method will have no effect.\n\n Attempting to perform search operations after a scanner has\n been closed will result in an IllegalStateException."
                }
              ]
            },
            {
              "name": "ioException",
              "overloads": [
                {
                  "signature": "public IOException ioException()",
                  "description": "Returns the IOException last thrown by this\n Scanner's underlying Readable. This method\n returns null if no such exception exists."
                }
              ]
            },
            {
              "name": "delimiter",
              "overloads": [
                {
                  "signature": "public Pattern delimiter()",
                  "description": "Returns the Pattern this Scanner is currently\n using to match delimiters."
                }
              ]
            },
            {
              "name": "useDelimiter",
              "overloads": [
                {
                  "signature": "public Scanner useDelimiter(Pattern pattern)",
                  "description": "Sets this scanner's delimiting pattern to the specified pattern."
                },
                {
                  "signature": "public Scanner useDelimiter(String pattern)",
                  "description": "Sets this scanner's delimiting pattern to a pattern constructed from\n the specified String.\n\n  An invocation of this method of the form\n useDelimiter(pattern) behaves in exactly the same way as the\n invocation useDelimiter(Pattern.compile(pattern)).\n\n  Invoking the reset() method will set the scanner's delimiter\n to the default."
                }
              ]
            },
            {
              "name": "locale",
              "overloads": [
                {
                  "signature": "public Locale locale()",
                  "description": "Returns this scanner's locale.\n\n A scanner's locale affects many elements of its default\n primitive matching regular expressions; see\n localized numbers above."
                }
              ]
            },
            {
              "name": "useLocale",
              "overloads": [
                {
                  "signature": "public Scanner useLocale(Locale locale)",
                  "description": "Sets this scanner's locale to the specified locale.\n\n A scanner's locale affects many elements of its default\n primitive matching regular expressions; see\n localized numbers above.\n\n Invoking the reset() method will set the scanner's locale to\n the initial locale."
                }
              ]
            },
            {
              "name": "radix",
              "overloads": [
                {
                  "signature": "public int radix()",
                  "description": "Returns this scanner's default radix.\n\n A scanner's radix affects elements of its default\n number matching regular expressions; see\n localized numbers above."
                }
              ]
            },
            {
              "name": "useRadix",
              "overloads": [
                {
                  "signature": "public Scanner useRadix(int radix)",
                  "description": "Sets this scanner's default radix to the specified radix.\n\n A scanner's radix affects elements of its default\n number matching regular expressions; see\n localized numbers above.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown.\n\n Invoking the reset() method will set the scanner's radix to\n 10."
                }
              ]
            },
            {
              "name": "match",
              "overloads": [
                {
                  "signature": "public MatchResult match()",
                  "description": "Returns the match result of the last scanning operation performed\n by this scanner. This method throws IllegalStateException\n if no match has been performed, or if the last match was\n not successful.\n\n The various next methods of Scanner\n make a match result available if they complete without throwing an\n exception. For instance, after an invocation of the nextInt()\n method that returned an int, this method returns a\n MatchResult for the search of the\n Integer regular expression\n defined above. Similarly the findInLine(),\n findWithinHorizon(), and skip()\n methods will make a match available if they succeed."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this Scanner. The\n string representation of a Scanner contains information\n that may be useful for debugging. The exact format is unspecified."
                }
              ]
            },
            {
              "name": "hasNext",
              "overloads": [
                {
                  "signature": "public boolean hasNext()",
                  "description": "Returns true if this scanner has another token in its input.\n This method may block while waiting for input to scan.\n The scanner does not advance past any input."
                },
                {
                  "signature": "public boolean hasNext(String pattern)",
                  "description": "Returns true if the next token matches the pattern constructed from the\n specified string. The scanner does not advance past any input.\n\n  An invocation of this method of the form hasNext(pattern)\n behaves in exactly the same way as the invocation\n hasNext(Pattern.compile(pattern))."
                },
                {
                  "signature": "public boolean hasNext(Pattern pattern)",
                  "description": "Returns true if the next complete token matches the specified pattern.\n A complete token is prefixed and postfixed by input that matches\n the delimiter pattern. This method may block while waiting for input.\n The scanner does not advance past any input."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "public String next()",
                  "description": "Finds and returns the next complete token from this scanner.\n A complete token is preceded and followed by input that matches\n the delimiter pattern. This method may block while waiting for input\n to scan, even if a previous invocation of hasNext() returned\n true."
                },
                {
                  "signature": "public String next(String pattern)",
                  "description": "Returns the next token if it matches the pattern constructed from the\n specified string.  If the match is successful, the scanner advances\n past the input that matched the pattern.\n\n  An invocation of this method of the form next(pattern)\n behaves in exactly the same way as the invocation\n next(Pattern.compile(pattern))."
                },
                {
                  "signature": "public String next(Pattern pattern)",
                  "description": "Returns the next token if it matches the specified pattern. This\n method may block while waiting for input to scan, even if a previous\n invocation of hasNext(Pattern) returned true.\n If the match is successful, the scanner advances past the input that\n matched the pattern."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public void remove()",
                  "description": "The remove operation is not supported by this implementation of\n Iterator."
                }
              ]
            },
            {
              "name": "hasNextLine",
              "overloads": [
                {
                  "signature": "public boolean hasNextLine()",
                  "description": "Returns true if there is another line in the input of this scanner.\n This method may block while waiting for input. The scanner does not\n advance past any input."
                }
              ]
            },
            {
              "name": "nextLine",
              "overloads": [
                {
                  "signature": "public String nextLine()",
                  "description": "Advances this scanner past the current line and returns the input\n that was skipped.\n\n This method returns the rest of the current line, excluding any line\n separator at the end. The position is set to the beginning of the next\n line.\n\n Since this method continues to search through the input looking\n for a line separator, it may buffer all of the input searching for\n the line to skip if no line separators are present."
                }
              ]
            },
            {
              "name": "findInLine",
              "overloads": [
                {
                  "signature": "public String findInLine(String pattern)",
                  "description": "Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n An invocation of this method of the form findInLine(pattern)\n behaves in exactly the same way as the invocation\n findInLine(Pattern.compile(pattern))."
                },
                {
                  "signature": "public String findInLine(Pattern pattern)",
                  "description": "Attempts to find the next occurrence of the specified pattern ignoring\n delimiters. If the pattern is found before the next line separator, the\n scanner advances past the input that matched and returns the string that\n matched the pattern.\n If no such pattern is detected in the input up to the next line\n separator, then null is returned and the scanner's\n position is unchanged. This method may block waiting for input that\n matches the pattern.\n\n Since this method continues to search through the input looking\n for the specified pattern, it may buffer all of the input searching for\n the desired token if no line separators are present."
                }
              ]
            },
            {
              "name": "findWithinHorizon",
              "overloads": [
                {
                  "signature": "public String findWithinHorizon(String pattern, int horizon)",
                  "description": "Attempts to find the next occurrence of a pattern constructed from the\n specified string, ignoring delimiters.\n\n An invocation of this method of the form\n findWithinHorizon(pattern) behaves in exactly the same way as\n the invocation\n findWithinHorizon(Pattern.compile(pattern), horizon)."
                },
                {
                  "signature": "public String findWithinHorizon(Pattern pattern, int horizon)",
                  "description": "Attempts to find the next occurrence of the specified pattern.\n\n This method searches through the input up to the specified\n search horizon, ignoring delimiters. If the pattern is found the\n scanner advances past the input that matched and returns the string\n that matched the pattern. If no such pattern is detected then the\n null is returned and the scanner's position remains unchanged. This\n method may block waiting for input that matches the pattern.\n\n A scanner will never search more than horizon code\n points beyond its current position. Note that a match may be clipped\n by the horizon; that is, an arbitrary match result may have been\n different if the horizon had been larger. The scanner treats the\n horizon as a transparent, non-anchoring bound (see Matcher.useTransparentBounds(boolean) and Matcher.useAnchoringBounds(boolean)).\n\n If horizon is 0, then the horizon is ignored and\n this method continues to search through the input looking for the\n specified pattern without bound. In this case it may buffer all of\n the input searching for the pattern.\n\n If horizon is negative, then an IllegalArgumentException is\n thrown."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public Scanner skip(Pattern pattern)",
                  "description": "Skips input that matches the specified pattern, ignoring delimiters.\n This method will skip input if an anchored match of the specified\n pattern succeeds.\n\n If a match to the specified pattern is not found at the\n current position, then no input is skipped and a\n NoSuchElementException is thrown.\n\n Since this method seeks to match the specified pattern starting at\n the scanner's current position, patterns that can match a lot of\n input (\".*\", for example) may cause the scanner to buffer a large\n amount of input.\n\n Note that it is possible to skip something without risking a\n NoSuchElementException by using a pattern that can\n match nothing, e.g., sc.skip(\"[ \\t]*\")."
                },
                {
                  "signature": "public Scanner skip(String pattern)",
                  "description": "Skips input that matches a pattern constructed from the specified\n string.\n\n  An invocation of this method of the form skip(pattern)\n behaves in exactly the same way as the invocation\n skip(Pattern.compile(pattern))."
                }
              ]
            },
            {
              "name": "hasNextBoolean",
              "overloads": [
                {
                  "signature": "public boolean hasNextBoolean()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a boolean value using a case insensitive pattern\n created from the string \"true|false\".  The scanner does not\n advance past the input that matched."
                }
              ]
            },
            {
              "name": "nextBoolean",
              "overloads": [
                {
                  "signature": "public boolean nextBoolean()",
                  "description": "Scans the next token of the input into a boolean value and returns\n that value. This method will throw InputMismatchException\n if the next token cannot be translated into a valid boolean value.\n If the match is successful, the scanner advances past the input that\n matched."
                }
              ]
            },
            {
              "name": "hasNextByte",
              "overloads": [
                {
                  "signature": "public boolean hasNextByte()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a byte value in the default radix using the\n nextByte() method. The scanner does not advance past any input."
                },
                {
                  "signature": "public boolean hasNextByte(int radix)",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a byte value in the specified radix using the\n nextByte() method. The scanner does not advance past any input.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "nextByte",
              "overloads": [
                {
                  "signature": "public byte nextByte()",
                  "description": "Scans the next token of the input as a byte.\n\n  An invocation of this method of the form\n nextByte() behaves in exactly the same way as the\n invocation nextByte(radix), where radix\n is the default radix of this scanner."
                },
                {
                  "signature": "public byte nextByte(int radix)",
                  "description": "Scans the next token of the input as a byte.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid byte value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n  If the next token matches the Integer regular expression defined\n above then the token is converted into a byte value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Byte.parseByte with the\n specified radix.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "hasNextShort",
              "overloads": [
                {
                  "signature": "public boolean hasNextShort()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a short value in the default radix using the\n nextShort() method. The scanner does not advance past any input."
                },
                {
                  "signature": "public boolean hasNextShort(int radix)",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a short value in the specified radix using the\n nextShort() method. The scanner does not advance past any input.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "nextShort",
              "overloads": [
                {
                  "signature": "public short nextShort()",
                  "description": "Scans the next token of the input as a short.\n\n  An invocation of this method of the form\n nextShort() behaves in exactly the same way as the\n invocation nextShort(radix), where radix\n is the default radix of this scanner."
                },
                {
                  "signature": "public short nextShort(int radix)",
                  "description": "Scans the next token of the input as a short.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid short value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n  If the next token matches the Integer regular expression defined\n above then the token is converted into a short value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Short.parseShort with the\n specified radix.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "hasNextInt",
              "overloads": [
                {
                  "signature": "public boolean hasNextInt()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as an int value in the default radix using the\n nextInt() method. The scanner does not advance past any input."
                },
                {
                  "signature": "public boolean hasNextInt(int radix)",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as an int value in the specified radix using the\n nextInt() method. The scanner does not advance past any input.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "nextInt",
              "overloads": [
                {
                  "signature": "public int nextInt()",
                  "description": "Scans the next token of the input as an int.\n\n  An invocation of this method of the form\n nextInt() behaves in exactly the same way as the\n invocation nextInt(radix), where radix\n is the default radix of this scanner."
                },
                {
                  "signature": "public int nextInt(int radix)",
                  "description": "Scans the next token of the input as an int.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid int value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n  If the next token matches the Integer regular expression defined\n above then the token is converted into an int value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Integer.parseInt with the\n specified radix.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "hasNextLong",
              "overloads": [
                {
                  "signature": "public boolean hasNextLong()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a long value in the default radix using the\n nextLong() method. The scanner does not advance past any input."
                },
                {
                  "signature": "public boolean hasNextLong(int radix)",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a long value in the specified radix using the\n nextLong() method. The scanner does not advance past any input.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "nextLong",
              "overloads": [
                {
                  "signature": "public long nextLong()",
                  "description": "Scans the next token of the input as a long.\n\n  An invocation of this method of the form\n nextLong() behaves in exactly the same way as the\n invocation nextLong(radix), where radix\n is the default radix of this scanner."
                },
                {
                  "signature": "public long nextLong(int radix)",
                  "description": "Scans the next token of the input as a long.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid long value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n  If the next token matches the Integer regular expression defined\n above then the token is converted into a long value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Long.parseLong with the\n specified radix.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "hasNextFloat",
              "overloads": [
                {
                  "signature": "public boolean hasNextFloat()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a float value using the nextFloat()\n method. The scanner does not advance past any input."
                }
              ]
            },
            {
              "name": "nextFloat",
              "overloads": [
                {
                  "signature": "public float nextFloat()",
                  "description": "Scans the next token of the input as a float.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid float value as\n described below. If the translation is successful, the scanner advances\n past the input that matched.\n\n  If the next token matches the Float regular expression defined above\n then the token is converted into a float value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Float.parseFloat. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to Float.parseFloat as\n appropriate."
                }
              ]
            },
            {
              "name": "hasNextDouble",
              "overloads": [
                {
                  "signature": "public boolean hasNextDouble()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a double value using the nextDouble()\n method. The scanner does not advance past any input."
                }
              ]
            },
            {
              "name": "nextDouble",
              "overloads": [
                {
                  "signature": "public double nextDouble()",
                  "description": "Scans the next token of the input as a double.\n This method will throw InputMismatchException\n if the next token cannot be translated into a valid double value.\n If the translation is successful, the scanner advances past the input\n that matched.\n\n  If the next token matches the Float regular expression defined above\n then the token is converted into a double value as if by\n removing all locale specific prefixes, group separators, and locale\n specific suffixes, then mapping non-ASCII digits into ASCII\n digits via Character.digit, prepending a\n negative sign (-) if the locale specific negative prefixes and suffixes\n were present, and passing the resulting string to\n Double.parseDouble. If the token matches\n the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\"\n is passed to Double.parseDouble as\n appropriate."
                }
              ]
            },
            {
              "name": "hasNextBigInteger",
              "overloads": [
                {
                  "signature": "public boolean hasNextBigInteger()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigInteger in the default radix using the\n nextBigInteger() method. The scanner does not advance past any\n input."
                },
                {
                  "signature": "public boolean hasNextBigInteger(int radix)",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigInteger in the specified radix using\n the nextBigInteger() method. The scanner does not advance past\n any input.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "nextBigInteger",
              "overloads": [
                {
                  "signature": "public BigInteger nextBigInteger()",
                  "description": "Scans the next token of the input as a BigInteger.\n\n  An invocation of this method of the form\n nextBigInteger() behaves in exactly the same way as the\n invocation nextBigInteger(radix), where radix\n is the default radix of this scanner."
                },
                {
                  "signature": "public BigInteger nextBigInteger(int radix)",
                  "description": "Scans the next token of the input as a BigInteger.\n\n  If the next token matches the Integer regular expression defined\n above then the token is converted into a BigInteger value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the Character.digit, and passing the\n resulting string to the BigInteger(String, int) constructor with the specified radix.\n\n If the radix is less than Character.MIN_RADIX\n or greater than Character.MAX_RADIX, then an\n IllegalArgumentException is thrown."
                }
              ]
            },
            {
              "name": "hasNextBigDecimal",
              "overloads": [
                {
                  "signature": "public boolean hasNextBigDecimal()",
                  "description": "Returns true if the next token in this scanner's input can be\n interpreted as a BigDecimal using the\n nextBigDecimal() method. The scanner does not advance past any\n input."
                }
              ]
            },
            {
              "name": "nextBigDecimal",
              "overloads": [
                {
                  "signature": "public BigDecimal nextBigDecimal()",
                  "description": "Scans the next token of the input as a BigDecimal.\n\n  If the next token matches the Decimal regular expression defined\n above then the token is converted into a BigDecimal value as if\n by removing all group separators, mapping non-ASCII digits into ASCII\n digits via the Character.digit, and passing the\n resulting string to the BigDecimal(String)\n constructor."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public Scanner reset()",
                  "description": "Resets this scanner.\n\n  Resetting a scanner discards all of its explicit state\n information which may have been changed by invocations of\n useDelimiter(),\n useLocale(), or\n useRadix().\n\n  An invocation of this method of the form\n scanner.reset() behaves in exactly the same way as the\n invocation\n\n \n   scanner.useDelimiter(\"\\\\p{javaWhitespace}+\")\n          .useLocale(Locale.getDefault(Locale.Category.FORMAT))\n          .useRadix(10);"
                }
              ]
            },
            {
              "name": "tokens",
              "overloads": [
                {
                  "signature": "public Stream<String> tokens()",
                  "description": "Returns a stream of delimiter-separated tokens from this scanner. The\n stream contains the same tokens that would be returned, starting from\n this scanner's current state, by calling the next() method\n repeatedly until the hasNext() method returns false.\n\n The resulting stream is sequential and ordered. All stream elements are\n non-null.\n\n Scanning starts upon initiation of the terminal stream operation, using the\n current state of this scanner. Subsequent calls to any methods on this scanner\n other than close() and ioException() may return undefined results\n or may cause undefined effects on the returned stream. The returned stream's source\n Spliterator is fail-fast and will, on a best-effort basis, throw a\n ConcurrentModificationException if any such calls are detected\n during stream pipeline execution.\n\n After stream pipeline execution completes, this scanner is left in an indeterminate\n state and cannot be reused.\n\n If this scanner contains a resource that must be released, this scanner\n should be closed, either by calling its close() method, or by\n closing the returned stream. Closing the stream will close the underlying scanner.\n IllegalStateException is thrown if the scanner has been closed when this\n method is called, or if this scanner is closed during stream pipeline execution.\n\n This method might block waiting for more input."
                }
              ]
            },
            {
              "name": "findAll",
              "overloads": [
                {
                  "signature": "public Stream<MatchResult> findAll(Pattern pattern)",
                  "description": "Returns a stream of match results from this scanner. The stream\n contains the same results in the same order that would be returned by\n calling findWithinHorizon(pattern, 0) and then match()\n successively as long as findWithinHorizon()\n finds matches.\n\n The resulting stream is sequential and ordered. All stream elements are\n non-null.\n\n Scanning starts upon initiation of the terminal stream operation, using the\n current state of this scanner. Subsequent calls to any methods on this scanner\n other than close() and ioException() may return undefined results\n or may cause undefined effects on the returned stream. The returned stream's source\n Spliterator is fail-fast and will, on a best-effort basis, throw a\n ConcurrentModificationException if any such calls are detected\n during stream pipeline execution.\n\n After stream pipeline execution completes, this scanner is left in an indeterminate\n state and cannot be reused.\n\n If this scanner contains a resource that must be released, this scanner\n should be closed, either by calling its close() method, or by\n closing the returned stream. Closing the stream will close the underlying scanner.\n IllegalStateException is thrown if the scanner has been closed when this\n method is called, or if this scanner is closed during stream pipeline execution.\n\n As with the findWithinHorizon() methods, this method\n might block waiting for additional input, and it might buffer an unbounded amount of\n input searching for a match."
                },
                {
                  "signature": "public Stream<MatchResult> findAll(String patString)",
                  "description": "Returns a stream of match results that match the provided pattern string.\n The effect is equivalent to the following code:\n\n \n     scanner.findAll(Pattern.compile(patString))"
                }
              ]
            }
          ]
        },
        {
          "name": "ServiceConfigurationError",
          "methods": [
            {
              "name": "ServiceConfigurationError",
              "overloads": [
                {
                  "signature": "public ServiceConfigurationError(String msg)",
                  "description": "Constructs a new instance with the specified message."
                },
                {
                  "signature": "public ServiceConfigurationError(String msg, Throwable cause)",
                  "description": "Constructs a new instance with the specified message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "ServiceLoader.Provider<S>",
          "methods": [
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "Class<? extends S> type()",
                  "description": "Returns the provider type. There is no guarantee that this type is\n accessible or that it has a public no-args constructor. The get() method should be used to obtain the provider instance.\n\n  When a module declares that the provider class is created by a\n provider factory then this method returns the return type of its\n public static \"provider()\" method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "S get()",
                  "description": "Returns an instance of the provider."
                }
              ]
            }
          ]
        },
        {
          "name": "ServiceLoader<S>",
          "methods": [
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<S> iterator()",
                  "description": "Returns an iterator to lazily load and instantiate the available\n providers of this loader's service.\n\n  To achieve laziness the actual work of locating and instantiating\n providers is done by the iterator itself. Its hasNext and next methods can therefore throw a\n ServiceConfigurationError for any of the reasons specified in\n the Errors section above. To write robust code it\n is only necessary to catch ServiceConfigurationError when using\n the iterator. If an error is thrown then subsequent invocations of the\n iterator will make a best effort to locate and instantiate the next\n available provider, but in general such recovery cannot be guaranteed.\n\n  Caching: The iterator returned by this method first yields all of\n the elements of the provider cache, in the order that they were loaded.\n It then lazily loads and instantiates any remaining service providers,\n adding each one to the cache in turn. If this loader's provider caches are\n cleared by invoking the reload method then existing\n iterators for this service loader should be discarded.\n The  hasNext and next methods of the iterator throw ConcurrentModificationException\n if used after the provider cache has been cleared.\n\n  The iterator returned by this method does not support removal.\n Invoking its remove method will\n cause an UnsupportedOperationException to be thrown."
                }
              ]
            },
            {
              "name": "stream",
              "overloads": [
                {
                  "signature": "public Stream<ServiceLoader.Provider<S>> stream()",
                  "description": "Returns a stream to lazily load available providers of this loader's\n service. The stream elements are of type Provider, the\n Provider's get method must be invoked to\n get or instantiate the provider.\n\n  To achieve laziness the actual work of locating providers is done\n when processing the stream. If a service provider cannot be loaded for any\n of the reasons specified in the Errors section\n above then ServiceConfigurationError is thrown by whatever method\n caused the service provider to be loaded. \n\n  Caching: When processing the stream then providers that were previously\n loaded by stream operations are processed first, in load order. It then\n lazily loads any remaining service providers. If this loader's provider\n caches are cleared by invoking the reload method then\n existing streams for this service loader should be discarded. The returned\n stream's source spliterator is fail-fast and\n will throw ConcurrentModificationException if the provider cache\n has been cleared. \n\n  The following examples demonstrate usage. The first example creates\n a stream of CodecFactory objects, the second example is the same\n except that it sorts the providers by provider class name (and so locate\n all providers).\n \n    Stream<CodecFactory> providers = ServiceLoader.load(CodecFactory.class)\n            .stream()\n            .map(Provider::get);\n\n    Stream<CodecFactory> providers = ServiceLoader.load(CodecFactory.class)\n            .stream()\n            .sorted(Comparator.comparing(p -> p.type().getName()))\n            .map(Provider::get);"
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public static <S> ServiceLoader<S> load(Class<S> service, ClassLoader loader)",
                  "description": "Creates a new service loader for the given service. The service loader\n uses the given class loader as the starting point to locate service\n providers for the service. The service loader's iterator and stream locate providers in both named\n and unnamed modules, as follows:\n\n \n     Step 1: Locate providers in named modules. \n\n    Service providers are located in all named modules of the class\n   loader or to any class loader reachable via parent delegation. \n\n    In addition, if the class loader is not the bootstrap or platform class loader, then service\n   providers may be located in the named modules of other class loaders.\n   Specifically, if the class loader, or any class loader reachable via\n   parent delegation, has a module in a module\n   layer, then service providers in all modules in the module layer are\n   located.  \n\n    For example, suppose there is a module layer where each module is\n   in its own class loader (see defineModulesWithManyLoaders). If this ServiceLoader.load method\n   is invoked to locate providers using any of the class loaders created for\n   the module layer, then it will locate all of the providers in the module\n   layer, irrespective of their defining class loader. \n\n    Ordering: The service loader will first locate any service providers\n   in modules defined to the class loader, then its parent class loader,\n   its parent parent, and so on to the bootstrap class loader. If a class\n   loader has modules in a module layer then all providers in that module\n   layer are located (irrespective of their class loader) before the\n   providers in the parent class loader are located. The ordering of\n   modules in same class loader, or the ordering of modules in a module\n   layer, is not defined. \n\n    If a module declares more than one provider then the providers\n   are located in the order that its module descriptor lists the\n   providers. Providers added dynamically by instrumentation agents (see\n   redefineModule)\n   are always located after providers declared by the module.  \n\n     Step 2: Locate providers in unnamed modules. \n\n    Service providers in unnamed modules are located if their class names\n   are listed in provider-configuration files located by the class loader's\n   getResources method. \n\n    The ordering is based on the order that the class loader's \n   getResources method finds the service configuration files and within\n   that, the order that the class names are listed in the file. \n\n    In a provider-configuration file, any mention of a service provider\n   that is deployed in a named module is ignored. This is to avoid\n   duplicates that would otherwise arise when a named module has both a\n   provides directive and a provider-configuration file that mention\n   the same service provider. \n\n    The provider class must be visible to the class loader."
                },
                {
                  "signature": "public static <S> ServiceLoader<S> load(Class<S> service)",
                  "description": "Creates a new service loader for the given service type, using the\n current thread's context class loader.\n\n  An invocation of this convenience method of the form\n \n     ServiceLoader.load(service)\n \n\n is equivalent to\n\n \n     ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())"
                },
                {
                  "signature": "public static <S> ServiceLoader<S> load(ModuleLayer layer, Class<S> service)",
                  "description": "Creates a new service loader for the given service type to load service\n providers from modules in the given module layer and its ancestors. It\n does not locate providers in unnamed modules. The ordering that the service\n loader's iterator and stream locate\n providers and yield elements is as follows:\n\n \n    Providers are located in a module layer before locating providers\n   in parent layers. Traversal of parent layers is depth-first with each\n   layer visited at most once. For example, suppose L0 is the boot layer, L1\n   and L2 are modules layers with L0 as their parent. Now suppose that L3 is\n   created with L1 and L2 as the parents (in that order). Using a service\n   loader to locate providers with L3 as the context will locate providers\n   in the following order: L3, L1, L0, L2. \n\n    If a module declares more than one provider then the providers\n   are located in the order that its module descriptor\n   lists the providers. Providers added dynamically by instrumentation\n   agents are always located after providers declared by the module. \n\n    The ordering of modules in a module layer is not defined."
                }
              ]
            },
            {
              "name": "loadInstalled",
              "overloads": [
                {
                  "signature": "public static <S> ServiceLoader<S> loadInstalled(Class<S> service)",
                  "description": "Creates a new service loader for the given service type, using the\n platform class loader.\n\n  This convenience method is equivalent to: \n\n \n     ServiceLoader.load(service, ClassLoader.getPlatformClassLoader())\n \n\n  This method is intended for use when only installed providers are\n desired.  The resulting service will only find and load providers that\n have been installed into the current Java virtual machine; providers on\n the application's module path or class path will be ignored."
                }
              ]
            },
            {
              "name": "findFirst",
              "overloads": [
                {
                  "signature": "public Optional<S> findFirst()",
                  "description": "Load the first available service provider of this loader's service. This\n convenience method is equivalent to invoking the iterator() method and obtaining the first element. It therefore\n returns the first element from the provider cache if possible, it\n otherwise attempts to load and instantiate the first provider.\n\n  The following example loads the first available service provider. If\n no service providers are located then it uses a default implementation.\n \n    CodecFactory factory = ServiceLoader.load(CodecFactory.class)\n                                        .findFirst()\n                                        .orElse(DEFAULT_CODECSET_FACTORY);"
                }
              ]
            },
            {
              "name": "reload",
              "overloads": [
                {
                  "signature": "public void reload()",
                  "description": "Clear this loader's provider cache so that all providers will be\n reloaded.\n\n  After invoking this method, subsequent invocations of the iterator or stream methods will lazily\n locate providers (and instantiate in the case of iterator)\n from scratch, just as is done by a newly-created service loader.\n\n  This method is intended for use in situations in which new service\n providers can be installed into a running Java virtual machine."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this service."
                }
              ]
            }
          ]
        },
        {
          "name": "Set<E>",
          "methods": [
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "int size()",
                  "description": "Returns the number of elements in this set (its cardinality).  If this\n set contains more than Integer.MAX_VALUE elements, returns\n Integer.MAX_VALUE."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "boolean isEmpty()",
                  "description": "Returns true if this set contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "boolean contains(Object o)",
                  "description": "Returns true if this set contains the specified element.\n More formally, returns true if and only if this set\n contains an element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this set.  The elements are\n returned in no particular order (unless this set is an instance of some\n class that provides a guarantee)."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this set.\n If this set makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the\n elements in the same order.\n\n The returned array will be \"safe\" in that no references to it\n are maintained by this set.  (In other words, this method must\n allocate a new array even if this set is backed by an array).\n The caller is thus free to modify the returned array.\n\n This method acts as bridge between array-based and collection-based\n APIs."
                },
                {
                  "signature": "<T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this set; the\n runtime type of the returned array is that of the specified array.\n If the set fits in the specified array, it is returned therein.\n Otherwise, a new array is allocated with the runtime type of the\n specified array and the size of this set.\n\n If this set fits in the specified array with room to spare\n (i.e., the array has more elements than this set), the element in\n the array immediately following the end of the set is set to\n null.  (This is useful in determining the length of this\n set only if the caller knows that this set does not contain\n any null elements.)\n\n If this set makes any guarantees as to what order its elements\n are returned by its iterator, this method must return the elements\n in the same order.\n\n Like the toArray() method, this method acts as bridge between\n array-based and collection-based APIs.  Further, this method allows\n precise control over the runtime type of the output array, and may,\n under certain circumstances, be used to save allocation costs.\n\n Suppose x is a set known to contain only strings.\n The following code can be used to dump the set into a newly allocated\n array of String:\n\n      String[] y = x.toArray(new String[0]);\n\n Note that toArray(new Object[0]) is identical in function to\n toArray()."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "boolean add(E e)",
                  "description": "Adds the specified element to this set if it is not already present\n (optional operation).  More formally, adds the specified element\n e to this set if the set contains no element e2\n such that\n Objects.equals(e, e2).\n If this set already contains the element, the call leaves the set\n unchanged and returns false.  In combination with the\n restriction on constructors, this ensures that sets never contain\n duplicate elements.\n\n The stipulation above does not imply that sets must accept all\n elements; sets may refuse to add any particular element, including\n null, and throw an exception, as described in the\n specification for Collection.add.\n Individual set implementations should clearly document any\n restrictions on the elements that they may contain."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(Object o)",
                  "description": "Removes the specified element from this set if it is present\n (optional operation).  More formally, removes an element e\n such that\n Objects.equals(o, e), if\n this set contains such an element.  Returns true if this set\n contained the element (or equivalently, if this set changed as a\n result of the call).  (This set will not contain the element once the\n call returns.)"
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this set contains all of the elements of the\n specified collection.  If the specified collection is also a set, this\n method returns true if it is a subset of this set."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this set if\n they're not already present (optional operation).  If the specified\n collection is also a set, the addAll operation effectively\n modifies this set so that its value is the union of the two\n sets.  The behavior of this operation is undefined if the specified\n collection is modified while the operation is in progress."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this set that are contained in the\n specified collection (optional operation).  In other words, removes\n from this set all of its elements that are not contained in the\n specified collection.  If the specified collection is also a set, this\n operation effectively modifies this set so that its value is the\n intersection of the two sets."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll(Collection<?> c)",
                  "description": "Removes from this set all of its elements that are contained in the\n specified collection (optional operation).  If the specified\n collection is also a set, this operation effectively modifies this\n set so that its value is the asymmetric set difference of\n the two sets."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "void clear()",
                  "description": "Removes all of the elements from this set (optional operation).\n The set will be empty after this call returns."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object o)",
                  "description": "Compares the specified object with this set for equality.  Returns\n true if the specified object is also a set, the two sets\n have the same size, and every member of the specified set is\n contained in this set (or equivalently, every member of this set is\n contained in the specified set).  This definition ensures that the\n equals method works properly across different implementations of the\n set interface."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns the hash code value for this set.  The hash code of a set is\n defined to be the sum of the hash codes of the elements in the set,\n where the hash code of a null element is defined to be zero.\n This ensures that s1.equals(s2) implies that\n s1.hashCode()==s2.hashCode() for any two sets s1\n and s2, as required by the general contract of\n Object.hashCode()."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this set.\n\n The Spliterator reports Spliterator.DISTINCT.\n Implementations should document the reporting of additional\n characteristic values."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "static <E> Set<E> of()",
                  "description": "Returns an unmodifiable set containing zero elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1)",
                  "description": "Returns an unmodifiable set containing one element.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2)",
                  "description": "Returns an unmodifiable set containing two elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3)",
                  "description": "Returns an unmodifiable set containing three elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4)",
                  "description": "Returns an unmodifiable set containing four elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5)",
                  "description": "Returns an unmodifiable set containing five elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6)",
                  "description": "Returns an unmodifiable set containing six elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)",
                  "description": "Returns an unmodifiable set containing seven elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)",
                  "description": "Returns an unmodifiable set containing eight elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)",
                  "description": "Returns an unmodifiable set containing nine elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "static <E> Set<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)",
                  "description": "Returns an unmodifiable set containing ten elements.\n See Unmodifiable Sets for details."
                },
                {
                  "signature": "@SafeVarargs static <E> Set<E> of(E... elements)",
                  "description": "Returns an unmodifiable set containing an arbitrary number of elements.\n See Unmodifiable Sets for details."
                }
              ]
            },
            {
              "name": "copyOf",
              "overloads": [
                {
                  "signature": "static <E> Set<E> copyOf(Collection<? extends E> coll)",
                  "description": "Returns an unmodifiable Set containing the elements\n of the given Collection. The given Collection must not be null, and it must not\n contain any null elements. If the given Collection contains duplicate elements,\n an arbitrary element of the duplicates is preserved. If the given Collection is\n subsequently modified, the returned Set will not reflect such modifications."
                }
              ]
            }
          ]
        },
        {
          "name": "SimpleTimeZone",
          "methods": [
            {
              "name": "SimpleTimeZone",
              "overloads": [
                {
                  "signature": "public SimpleTimeZone(int rawOffset, String ID)",
                  "description": "Constructs a SimpleTimeZone with the given base time zone offset from GMT\n and time zone ID with no daylight saving time schedule."
                },
                {
                  "signature": "public SimpleTimeZone(int rawOffset, String ID, int startMonth, int startDay, int startDayOfWeek, int startTime, int endMonth, int endDay, int endDayOfWeek, int endTime)",
                  "description": "Constructs a SimpleTimeZone with the given base time zone offset from\n GMT, time zone ID, and rules for starting and ending the daylight\n time.\n Both startTime and endTime are specified to be\n represented in the wall clock time. The amount of daylight saving is\n assumed to be 3600000 milliseconds (i.e., one hour). This constructor is\n equivalent to:\n \n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    3600000)"
                },
                {
                  "signature": "public SimpleTimeZone(int rawOffset, String ID, int startMonth, int startDay, int startDayOfWeek, int startTime, int endMonth, int endDay, int endDayOfWeek, int endTime, int dstSavings)",
                  "description": "Constructs a SimpleTimeZone with the given base time zone offset from\n GMT, time zone ID, and rules for starting and ending the daylight\n time.\n Both startTime and endTime are assumed to be\n represented in the wall clock time. This constructor is equivalent to:\n \n     SimpleTimeZone(rawOffset,\n                    ID,\n                    startMonth,\n                    startDay,\n                    startDayOfWeek,\n                    startTime,\n                    SimpleTimeZone.WALL_TIME,\n                    endMonth,\n                    endDay,\n                    endDayOfWeek,\n                    endTime,\n                    SimpleTimeZone.WALL_TIME,\n                    dstSavings)"
                },
                {
                  "signature": "public SimpleTimeZone(int rawOffset, String ID, int startMonth, int startDay, int startDayOfWeek, int startTime, int startTimeMode, int endMonth, int endDay, int endDayOfWeek, int endTime, int endTimeMode, int dstSavings)",
                  "description": "Constructs a SimpleTimeZone with the given base time zone offset from\n GMT, time zone ID, and rules for starting and ending the daylight\n time.\n This constructor takes the full set of the start and end rules\n parameters, including modes of startTime and\n endTime. The mode specifies either wall\n time or standard time or UTC\n time."
                }
              ]
            },
            {
              "name": "setStartYear",
              "overloads": [
                {
                  "signature": "public void setStartYear(int year)",
                  "description": "Sets the daylight saving time starting year."
                }
              ]
            },
            {
              "name": "setStartRule",
              "overloads": [
                {
                  "signature": "public void setStartRule(int startMonth, int startDay, int startDayOfWeek, int startTime)",
                  "description": "Sets the daylight saving time start rule. For example, if daylight saving\n time starts on the first Sunday in April at 2 am in local wall clock\n time, you can set the start rule by calling:\n setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);"
                },
                {
                  "signature": "public void setStartRule(int startMonth, int startDay, int startTime)",
                  "description": "Sets the daylight saving time start rule to a fixed date within a month.\n This method is equivalent to:\n setStartRule(startMonth, startDay, 0, startTime)"
                },
                {
                  "signature": "public void setStartRule(int startMonth, int startDay, int startDayOfWeek, int startTime, boolean after)",
                  "description": "Sets the daylight saving time start rule to a weekday before or after the given date within\n a month, e.g., the first Monday on or after the 8th."
                }
              ]
            },
            {
              "name": "setEndRule",
              "overloads": [
                {
                  "signature": "public void setEndRule(int endMonth, int endDay, int endDayOfWeek, int endTime)",
                  "description": "Sets the daylight saving time end rule. For example, if daylight saving time\n ends on the last Sunday in October at 2 am in wall clock time,\n you can set the end rule by calling:\n setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2*60*60*1000);"
                },
                {
                  "signature": "public void setEndRule(int endMonth, int endDay, int endTime)",
                  "description": "Sets the daylight saving time end rule to a fixed date within a month.\n This method is equivalent to:\n setEndRule(endMonth, endDay, 0, endTime)"
                },
                {
                  "signature": "public void setEndRule(int endMonth, int endDay, int endDayOfWeek, int endTime, boolean after)",
                  "description": "Sets the daylight saving time end rule to a weekday before or after the given date within\n a month, e.g., the first Monday on or after the 8th."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset(long date)",
                  "description": "Returns the offset of this time zone from UTC at the given\n time. If daylight saving time is in effect at the given time,\n the offset value is adjusted with the amount of daylight\n saving."
                },
                {
                  "signature": "public int getOffset(int era, int year, int month, int day, int dayOfWeek, int millis)",
                  "description": "Returns the difference in milliseconds between local time and\n UTC, taking into account both the raw offset and the effect of\n daylight saving, for the specified date and time.  This method\n assumes that the start and end month are distinct.  It also\n uses a default GregorianCalendar object as its\n underlying calendar, such as for determining leap years.  Do\n not use the result of this method with a calendar other than a\n default GregorianCalendar.\n\n Note:  In general, clients should use\n Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET)\n instead of calling this method."
                }
              ]
            },
            {
              "name": "getRawOffset",
              "overloads": [
                {
                  "signature": "public int getRawOffset()",
                  "description": "Gets the GMT offset for this time zone."
                }
              ]
            },
            {
              "name": "setRawOffset",
              "overloads": [
                {
                  "signature": "public void setRawOffset(int offsetMillis)",
                  "description": "Sets the base time zone offset to GMT.\n This is the offset to add to UTC to get local time."
                }
              ]
            },
            {
              "name": "setDSTSavings",
              "overloads": [
                {
                  "signature": "public void setDSTSavings(int millisSavedDuringDST)",
                  "description": "Sets the amount of time in milliseconds that the clock is advanced\n during daylight saving time."
                }
              ]
            },
            {
              "name": "getDSTSavings",
              "overloads": [
                {
                  "signature": "public int getDSTSavings()",
                  "description": "Returns the amount of time in milliseconds that the clock is\n advanced during daylight saving time."
                }
              ]
            },
            {
              "name": "useDaylightTime",
              "overloads": [
                {
                  "signature": "public boolean useDaylightTime()",
                  "description": "Queries if this time zone uses daylight saving time."
                }
              ]
            },
            {
              "name": "observesDaylightTime",
              "overloads": [
                {
                  "signature": "public boolean observesDaylightTime()",
                  "description": "Returns true if this SimpleTimeZone observes\n Daylight Saving Time. This method is equivalent to useDaylightTime()."
                }
              ]
            },
            {
              "name": "inDaylightTime",
              "overloads": [
                {
                  "signature": "public boolean inDaylightTime(Date date)",
                  "description": "Queries if the given date is in daylight saving time."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a clone of this SimpleTimeZone instance."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Generates the hash code for the SimpleDateFormat object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the equality of two SimpleTimeZone objects."
                }
              ]
            },
            {
              "name": "hasSameRules",
              "overloads": [
                {
                  "signature": "public boolean hasSameRules(TimeZone other)",
                  "description": "Returns true if this zone has the same rules and offset as another zone."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this time zone."
                }
              ]
            }
          ]
        },
        {
          "name": "SortedMap<K,V>",
          "methods": [
            {
              "name": "comparator",
              "overloads": [
                {
                  "signature": "Comparator<? super K> comparator()",
                  "description": "Returns the comparator used to order the keys in this map, or\n null if this map uses the natural ordering of its keys."
                }
              ]
            },
            {
              "name": "subMap",
              "overloads": [
                {
                  "signature": "SortedMap<K,V> subMap(K fromKey, K toKey)",
                  "description": "Returns a view of the portion of this map whose keys range from\n fromKey, inclusive, to toKey, exclusive.  (If\n fromKey and toKey are equal, the returned map\n is empty.)  The returned map is backed by this map, so changes\n in the returned map are reflected in this map, and vice-versa.\n The returned map supports all optional map operations that this\n map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range."
                }
              ]
            },
            {
              "name": "headMap",
              "overloads": [
                {
                  "signature": "SortedMap<K,V> headMap(K toKey)",
                  "description": "Returns a view of the portion of this map whose keys are\n strictly less than toKey.  The returned map is backed\n by this map, so changes in the returned map are reflected in\n this map, and vice-versa.  The returned map supports all\n optional map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range."
                }
              ]
            },
            {
              "name": "tailMap",
              "overloads": [
                {
                  "signature": "SortedMap<K,V> tailMap(K fromKey)",
                  "description": "Returns a view of the portion of this map whose keys are\n greater than or equal to fromKey.  The returned map is\n backed by this map, so changes in the returned map are\n reflected in this map, and vice-versa.  The returned map\n supports all optional map operations that this map supports.\n\n The returned map will throw an IllegalArgumentException\n on an attempt to insert a key outside its range."
                }
              ]
            },
            {
              "name": "firstKey",
              "overloads": [
                {
                  "signature": "K firstKey()",
                  "description": "Returns the first (lowest) key currently in this map."
                }
              ]
            },
            {
              "name": "lastKey",
              "overloads": [
                {
                  "signature": "K lastKey()",
                  "description": "Returns the last (highest) key currently in this map."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set's iterator returns the keys in ascending order.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection's iterator returns the values in ascending order\n of the corresponding keys.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set's iterator returns the entries in ascending key order.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            }
          ]
        },
        {
          "name": "SortedSet<E>",
          "methods": [
            {
              "name": "comparator",
              "overloads": [
                {
                  "signature": "Comparator<? super E> comparator()",
                  "description": "Returns the comparator used to order the elements in this set,\n or null if this set uses the natural ordering of its elements."
                }
              ]
            },
            {
              "name": "subSet",
              "overloads": [
                {
                  "signature": "SortedSet<E> subSet(E fromElement, E toElement)",
                  "description": "Returns a view of the portion of this set whose elements range\n from fromElement, inclusive, to toElement,\n exclusive.  (If fromElement and toElement are\n equal, the returned set is empty.)  The returned set is backed\n by this set, so changes in the returned set are reflected in\n this set, and vice-versa.  The returned set supports all\n optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                }
              ]
            },
            {
              "name": "headSet",
              "overloads": [
                {
                  "signature": "SortedSet<E> headSet(E toElement)",
                  "description": "Returns a view of the portion of this set whose elements are\n strictly less than toElement.  The returned set is\n backed by this set, so changes in the returned set are\n reflected in this set, and vice-versa.  The returned set\n supports all optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                }
              ]
            },
            {
              "name": "tailSet",
              "overloads": [
                {
                  "signature": "SortedSet<E> tailSet(E fromElement)",
                  "description": "Returns a view of the portion of this set whose elements are\n greater than or equal to fromElement.  The returned\n set is backed by this set, so changes in the returned set are\n reflected in this set, and vice-versa.  The returned set\n supports all optional set operations that this set supports.\n\n The returned set will throw an IllegalArgumentException\n on an attempt to insert an element outside its range."
                }
              ]
            },
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "E first()",
                  "description": "Returns the first (lowest) element currently in this set."
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "E last()",
                  "description": "Returns the last (highest) element currently in this set."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "default Spliterator<E> spliterator()",
                  "description": "Creates a Spliterator over the elements in this sorted set.\n\n The Spliterator reports Spliterator.DISTINCT,\n Spliterator.SORTED and Spliterator.ORDERED.\n Implementations should document the reporting of additional\n characteristic values.\n\n The spliterator's comparator (see\n Spliterator.getComparator()) must be null if\n the sorted set's comparator (see comparator()) is null.\n Otherwise, the spliterator's comparator must be the same as or impose the\n same total ordering as the sorted set's comparator."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterator.OfDouble",
          "methods": [
            {
              "name": "tryAdvance",
              "overloads": [
                {
                  "signature": "default boolean tryAdvance(Consumer<? super Double> action)",
                  "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is Spliterator.ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(Consumer<? super Double> action)",
                  "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is Spliterator.ORDERED, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterator.OfInt",
          "methods": [
            {
              "name": "tryAdvance",
              "overloads": [
                {
                  "signature": "default boolean tryAdvance(Consumer<? super Integer> action)",
                  "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is Spliterator.ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(Consumer<? super Integer> action)",
                  "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is Spliterator.ORDERED, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterator.OfLong",
          "methods": [
            {
              "name": "tryAdvance",
              "overloads": [
                {
                  "signature": "default boolean tryAdvance(Consumer<? super Long> action)",
                  "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is Spliterator.ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(Consumer<? super Long> action)",
                  "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is Spliterator.ORDERED, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterator.OfPrimitive<T,T_CONS,T_SPLITR",
          "methods": [
            {
              "name": "tryAdvance",
              "overloads": [
                {
                  "signature": "boolean tryAdvance(T_CONS action)",
                  "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is Spliterator.ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(T_CONS action)",
                  "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the\n action throws an exception.  If this Spliterator is Spliterator.ORDERED,\n actions are performed in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterator<T>",
          "methods": [
            {
              "name": "tryAdvance",
              "overloads": [
                {
                  "signature": "boolean tryAdvance(Consumer<? super T> action)",
                  "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "forEachRemaining",
              "overloads": [
                {
                  "signature": "default void forEachRemaining(Consumer<? super T> action)",
                  "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is ORDERED, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller.\n \n Subsequent behavior of a spliterator is unspecified if the action throws\n an exception."
                }
              ]
            },
            {
              "name": "trySplit",
              "overloads": [
                {
                  "signature": "Spliterator<T> trySplit()",
                  "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \n the value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\n if this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n \n\n This method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations."
                }
              ]
            },
            {
              "name": "estimateSize",
              "overloads": [
                {
                  "signature": "long estimateSize()",
                  "description": "Returns an estimate of the number of elements that would be\n encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is SIZED and has not yet been partially\n traversed or split, or this Spliterator is SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of trySplit()."
                }
              ]
            },
            {
              "name": "getExactSizeIfKnown",
              "overloads": [
                {
                  "signature": "default long getExactSizeIfKnown()",
                  "description": "Convenience method that returns estimateSize() if this\n Spliterator is SIZED, else -1."
                }
              ]
            },
            {
              "name": "characteristics",
              "overloads": [
                {
                  "signature": "int characteristics()",
                  "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED,\n NONNULL, IMMUTABLE, CONCURRENT,\n SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."
                }
              ]
            },
            {
              "name": "hasCharacteristics",
              "overloads": [
                {
                  "signature": "default boolean hasCharacteristics(int characteristics)",
                  "description": "Returns true if this Spliterator's characteristics() contain all of the given characteristics."
                }
              ]
            },
            {
              "name": "getComparator",
              "overloads": [
                {
                  "signature": "default Comparator<? super T> getComparator()",
                  "description": "If this Spliterator's source is SORTED by a Comparator,\n returns that Comparator. If the source is SORTED in\n natural order, returns null.  Otherwise,\n if the source is not SORTED, throws IllegalStateException."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterators",
          "methods": [
            {
              "name": "emptySpliterator",
              "overloads": [
                {
                  "signature": "public static <T> Spliterator<T> emptySpliterator()",
                  "description": "Creates an empty Spliterator\n\n The empty spliterator reports Spliterator.SIZED and\n Spliterator.SUBSIZED.  Calls to\n Spliterator.trySplit() always return null."
                }
              ]
            },
            {
              "name": "emptyIntSpliterator",
              "overloads": [
                {
                  "signature": "public static Spliterator.OfInt emptyIntSpliterator()",
                  "description": "Creates an empty Spliterator.OfInt\n\n The empty spliterator reports Spliterator.SIZED and\n Spliterator.SUBSIZED.  Calls to\n Spliterator.trySplit() always return null."
                }
              ]
            },
            {
              "name": "emptyLongSpliterator",
              "overloads": [
                {
                  "signature": "public static Spliterator.OfLong emptyLongSpliterator()",
                  "description": "Creates an empty Spliterator.OfLong\n\n The empty spliterator reports Spliterator.SIZED and\n Spliterator.SUBSIZED.  Calls to\n Spliterator.trySplit() always return null."
                }
              ]
            },
            {
              "name": "emptyDoubleSpliterator",
              "overloads": [
                {
                  "signature": "public static Spliterator.OfDouble emptyDoubleSpliterator()",
                  "description": "Creates an empty Spliterator.OfDouble\n\n The empty spliterator reports Spliterator.SIZED and\n Spliterator.SUBSIZED.  Calls to\n Spliterator.trySplit() always return null."
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public static <T> Spliterator<T> spliterator(Object[] array, int additionalCharacteristics)",
                  "description": "Creates a Spliterator covering the elements of a given array,\n using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(Object[]).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static <T> Spliterator<T> spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)",
                  "description": "Creates a Spliterator covering a range of elements of a given\n array, using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(Object[]).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfInt spliterator(int[] array, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfInt covering the elements of a given array,\n using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(int[]).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfInt covering a range of elements of a\n given array, using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(int[], int, int).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfLong spliterator(long[] array, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfLong covering the elements of a given array,\n using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(long[]).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfLong covering a range of elements of a\n given array, using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(long[], int, int).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report.  (For example, if it is\n known the array will not be further modified, specify IMMUTABLE;\n if the array data is considered to have an encounter order, specify\n ORDERED).  The method Arrays.spliterator(long[], int, int) can\n often be used instead, which returns a spliterator that reports\n SIZED, SUBSIZED, IMMUTABLE, and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliterator(double[] array, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfDouble covering the elements of a given array,\n using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(double[]).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report; it is common to\n additionally specify IMMUTABLE and ORDERED."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)",
                  "description": "Creates a Spliterator.OfDouble covering a range of elements of a\n given array, using a customized set of spliterator characteristics.\n\n This method is provided as an implementation convenience for\n Spliterators which store portions of their elements in arrays, and need\n fine control over Spliterator characteristics.  Most other situations in\n which a Spliterator for an array is needed should use\n Arrays.spliterator(double[], int, int).\n\n The returned spliterator always reports the characteristics\n SIZED and SUBSIZED.  The caller may provide additional\n characteristics for the spliterator to report.  (For example, if it is\n known the array will not be further modified, specify IMMUTABLE;\n if the array data is considered to have an encounter order, specify\n ORDERED).  The method Arrays.spliterator(long[], int, int) can\n often be used instead, which returns a spliterator that reports\n SIZED, SUBSIZED, IMMUTABLE, and ORDERED."
                },
                {
                  "signature": "public static <T> Spliterator<T> spliterator(Collection<? extends T> c, int characteristics)",
                  "description": "Creates a Spliterator using the given collection's\n Collection.iterator() as the source of elements, and\n reporting its Collection.size() as its initial size.\n\n The spliterator is\n late-binding, inherits\n the fail-fast properties of the collection's iterator, and\n implements trySplit to permit limited parallelism."
                },
                {
                  "signature": "public static <T> Spliterator<T> spliterator(Iterator<? extends T> iterator, long size, int characteristics)",
                  "description": "Creates a Spliterator using a given Iterator\n as the source of elements, and with a given initially reported size.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned, or the initially reported\n size is not equal to the actual number of elements in the source."
                },
                {
                  "signature": "public static Spliterator.OfInt spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)",
                  "description": "Creates a Spliterator.OfInt using a given\n IntStream.IntIterator as the source of elements, and with a given\n initially reported size.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned, or the initially reported\n size is not equal to the actual number of elements in the source."
                },
                {
                  "signature": "public static Spliterator.OfLong spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)",
                  "description": "Creates a Spliterator.OfLong using a given\n LongStream.LongIterator as the source of elements, and with a\n given initially reported size.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned, or the initially reported\n size is not equal to the actual number of elements in the source."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)",
                  "description": "Creates a Spliterator.OfDouble using a given\n DoubleStream.DoubleIterator as the source of elements, and with a\n given initially reported size.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned, or the initially reported\n size is not equal to the actual number of elements in the source."
                }
              ]
            },
            {
              "name": "spliteratorUnknownSize",
              "overloads": [
                {
                  "signature": "public static <T> Spliterator<T> spliteratorUnknownSize(Iterator<? extends T> iterator, int characteristics)",
                  "description": "Creates a Spliterator using a given Iterator\n as the source of elements, with no initial size estimate.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned."
                },
                {
                  "signature": "public static Spliterator.OfInt spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)",
                  "description": "Creates a Spliterator.OfInt using a given\n IntStream.IntIterator as the source of elements, with no initial\n size estimate.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned."
                },
                {
                  "signature": "public static Spliterator.OfLong spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)",
                  "description": "Creates a Spliterator.OfLong using a given\n LongStream.LongIterator as the source of elements, with no\n initial size estimate.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned."
                },
                {
                  "signature": "public static Spliterator.OfDouble spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)",
                  "description": "Creates a Spliterator.OfDouble using a given\n DoubleStream.DoubleIterator as the source of elements, with no\n initial size estimate.\n\n The spliterator is not\n late-binding, inherits\n the fail-fast properties of the iterator, and implements\n trySplit to permit limited parallelism.\n\n Traversal of elements should be accomplished through the spliterator.\n The behaviour of splitting and traversal is undefined if the iterator is\n operated on after the spliterator is returned."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public static <T> Iterator<T> iterator(Spliterator<? extends T> spliterator)",
                  "description": "Creates an Iterator from a Spliterator.\n\n Traversal of elements should be accomplished through the iterator.\n The behaviour of traversal is undefined if the spliterator is operated\n after the iterator is returned."
                },
                {
                  "signature": "public static PrimitiveIterator.OfInt iterator(Spliterator.OfInt spliterator)",
                  "description": "Creates an PrimitiveIterator.OfInt from a\n Spliterator.OfInt.\n\n Traversal of elements should be accomplished through the iterator.\n The behaviour of traversal is undefined if the spliterator is operated\n after the iterator is returned."
                },
                {
                  "signature": "public static PrimitiveIterator.OfLong iterator(Spliterator.OfLong spliterator)",
                  "description": "Creates an PrimitiveIterator.OfLong from a\n Spliterator.OfLong.\n\n Traversal of elements should be accomplished through the iterator.\n The behaviour of traversal is undefined if the spliterator is operated\n after the iterator is returned."
                },
                {
                  "signature": "public static PrimitiveIterator.OfDouble iterator(Spliterator.OfDouble spliterator)",
                  "description": "Creates an PrimitiveIterator.OfDouble from a\n Spliterator.OfDouble.\n\n Traversal of elements should be accomplished through the iterator.\n The behaviour of traversal is undefined if the spliterator is operated\n after the iterator is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterators.AbstractDoubleSpliterator",
          "methods": [
            {
              "name": "AbstractDoubleSpliterator",
              "overloads": [
                {
                  "signature": "protected AbstractDoubleSpliterator(long est, int additionalCharacteristics)",
                  "description": "Creates a spliterator reporting the given estimated size and\n characteristics."
                }
              ]
            },
            {
              "name": "trySplit",
              "overloads": [
                {
                  "signature": "public Spliterator.OfDouble trySplit()",
                  "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is Spliterator.ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \n the value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\n if this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n \n\n This method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations.\n\n This implementation permits limited parallelism."
                }
              ]
            },
            {
              "name": "estimateSize",
              "overloads": [
                {
                  "signature": "public long estimateSize()",
                  "description": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is Spliterator.SIZED and has not yet been partially\n traversed or split, or this Spliterator is Spliterator.SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of Spliterator.trySplit()."
                }
              ]
            },
            {
              "name": "characteristics",
              "overloads": [
                {
                  "signature": "public int characteristics()",
                  "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from Spliterator.ORDERED, Spliterator.DISTINCT, Spliterator.SORTED, Spliterator.SIZED,\n Spliterator.NONNULL, Spliterator.IMMUTABLE, Spliterator.CONCURRENT,\n Spliterator.SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterators.AbstractIntSpliterator",
          "methods": [
            {
              "name": "AbstractIntSpliterator",
              "overloads": [
                {
                  "signature": "protected AbstractIntSpliterator(long est, int additionalCharacteristics)",
                  "description": "Creates a spliterator reporting the given estimated size and\n characteristics."
                }
              ]
            },
            {
              "name": "trySplit",
              "overloads": [
                {
                  "signature": "public Spliterator.OfInt trySplit()",
                  "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is Spliterator.ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \n the value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\n if this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n \n\n This method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations.\n\n This implementation permits limited parallelism."
                }
              ]
            },
            {
              "name": "estimateSize",
              "overloads": [
                {
                  "signature": "public long estimateSize()",
                  "description": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is Spliterator.SIZED and has not yet been partially\n traversed or split, or this Spliterator is Spliterator.SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of Spliterator.trySplit()."
                }
              ]
            },
            {
              "name": "characteristics",
              "overloads": [
                {
                  "signature": "public int characteristics()",
                  "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from Spliterator.ORDERED, Spliterator.DISTINCT, Spliterator.SORTED, Spliterator.SIZED,\n Spliterator.NONNULL, Spliterator.IMMUTABLE, Spliterator.CONCURRENT,\n Spliterator.SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterators.AbstractLongSpliterator",
          "methods": [
            {
              "name": "AbstractLongSpliterator",
              "overloads": [
                {
                  "signature": "protected AbstractLongSpliterator(long est, int additionalCharacteristics)",
                  "description": "Creates a spliterator reporting the given estimated size and\n characteristics."
                }
              ]
            },
            {
              "name": "trySplit",
              "overloads": [
                {
                  "signature": "public Spliterator.OfLong trySplit()",
                  "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is Spliterator.ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \n the value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\n if this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n \n\n This method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations.\n\n This implementation permits limited parallelism."
                }
              ]
            },
            {
              "name": "estimateSize",
              "overloads": [
                {
                  "signature": "public long estimateSize()",
                  "description": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is Spliterator.SIZED and has not yet been partially\n traversed or split, or this Spliterator is Spliterator.SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of Spliterator.trySplit()."
                }
              ]
            },
            {
              "name": "characteristics",
              "overloads": [
                {
                  "signature": "public int characteristics()",
                  "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from Spliterator.ORDERED, Spliterator.DISTINCT, Spliterator.SORTED, Spliterator.SIZED,\n Spliterator.NONNULL, Spliterator.IMMUTABLE, Spliterator.CONCURRENT,\n Spliterator.SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."
                }
              ]
            }
          ]
        },
        {
          "name": "Spliterators.AbstractSpliterator<T>",
          "methods": [
            {
              "name": "AbstractSpliterator",
              "overloads": [
                {
                  "signature": "protected AbstractSpliterator(long est, int additionalCharacteristics)",
                  "description": "Creates a spliterator reporting the given estimated size and\n additionalCharacteristics."
                }
              ]
            },
            {
              "name": "trySplit",
              "overloads": [
                {
                  "signature": "public Spliterator<T> trySplit()",
                  "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is Spliterator.ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \n the value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\n if this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n \n\n This method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations.\n\n This implementation permits limited parallelism."
                }
              ]
            },
            {
              "name": "estimateSize",
              "overloads": [
                {
                  "signature": "public long estimateSize()",
                  "description": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is Spliterator.SIZED and has not yet been partially\n traversed or split, or this Spliterator is Spliterator.SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of Spliterator.trySplit()."
                }
              ]
            },
            {
              "name": "characteristics",
              "overloads": [
                {
                  "signature": "public int characteristics()",
                  "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from Spliterator.ORDERED, Spliterator.DISTINCT, Spliterator.SORTED, Spliterator.SIZED,\n Spliterator.NONNULL, Spliterator.IMMUTABLE, Spliterator.CONCURRENT,\n Spliterator.SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."
                }
              ]
            }
          ]
        },
        {
          "name": "SplittableRandom",
          "methods": [
            {
              "name": "SplittableRandom",
              "overloads": [
                {
                  "signature": "public SplittableRandom(long seed)",
                  "description": "Creates a new SplittableRandom instance using the specified\n initial seed. SplittableRandom instances created with the same\n seed in the same program generate identical sequences of values."
                },
                {
                  "signature": "public SplittableRandom()",
                  "description": "Creates a new SplittableRandom instance that is likely to\n generate sequences of values that are statistically independent\n of those of any other instances in the current program; and\n may, and typically does, vary across program invocations."
                }
              ]
            },
            {
              "name": "split",
              "overloads": [
                {
                  "signature": "public SplittableRandom split()",
                  "description": "Constructs and returns a new SplittableRandom instance that\n shares no mutable state with this instance. However, with very\n high probability, the set of values collectively generated by\n the two objects has the same statistical properties as if the\n same quantity of values were generated by a single thread using\n a single SplittableRandom object.  Either or both of the two\n objects may be further split using the split() method,\n and the same expected statistical properties apply to the\n entire set of generators constructed by such recursive\n splitting."
                },
                {
                  "signature": "public SplittableRandom split(RandomGenerator.SplittableGenerator source)",
                  "description": "Returns a new pseudorandom number generator, split off from this one,\n that implements the RandomGenerator and\n RandomGenerator.SplittableGenerator interfaces."
                }
              ]
            },
            {
              "name": "nextLong",
              "overloads": [
                {
                  "signature": "public long nextLong()",
                  "description": "Description copied from interface:RandomGenerator"
                }
              ]
            },
            {
              "name": "nextBytes",
              "overloads": [
                {
                  "signature": "public void nextBytes(byte[] bytes)",
                  "description": "Fills a user-supplied byte array with generated byte values\n pseudorandomly chosen uniformly from the range of values between -128\n (inclusive) and 127 (inclusive)."
                }
              ]
            },
            {
              "name": "splits",
              "overloads": [
                {
                  "signature": "public Stream<RandomGenerator.SplittableGenerator> splits()",
                  "description": "Returns an effectively unlimited stream of new pseudorandom number\n generators, each of which implements the RandomGenerator.SplittableGenerator\n interface.\n\n  This pseudorandom number generator may be used as a source of\n pseudorandom bits used to initialize the state the new ones."
                },
                {
                  "signature": "public Stream<RandomGenerator.SplittableGenerator> splits(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number of new\n pseudorandom number generators, each of which implements the\n RandomGenerator.SplittableGenerator interface.\n\n  This pseudorandom number generator may be used as a source of\n pseudorandom bits used to initialize the state the new ones."
                },
                {
                  "signature": "public Stream<RandomGenerator.SplittableGenerator> splits(RandomGenerator.SplittableGenerator source)",
                  "description": "Returns an effectively unlimited stream of new pseudorandom number\n generators, each of which implements the RandomGenerator.SplittableGenerator\n interface."
                },
                {
                  "signature": "public Stream<RandomGenerator.SplittableGenerator> splits(long streamSize, RandomGenerator.SplittableGenerator source)",
                  "description": "Returns a stream producing the given streamSize number of new\n pseudorandom number generators, each of which implements the\n RandomGenerator.SplittableGenerator interface."
                }
              ]
            },
            {
              "name": "ints",
              "overloads": [
                {
                  "signature": "public IntStream ints(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number\n of pseudorandom int values from this generator and/or\n one split from it."
                },
                {
                  "signature": "public IntStream ints()",
                  "description": "Returns an effectively unlimited stream of pseudorandom int\n values from this generator and/or one split from it."
                },
                {
                  "signature": "public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number\n of pseudorandom int values from this generator and/or one split\n from it; each value conforms to the given origin (inclusive) and bound\n (exclusive)."
                },
                {
                  "signature": "public IntStream ints(int randomNumberOrigin, int randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n int values from this generator and/or one split from it; each value\n conforms to the given origin (inclusive) and bound (exclusive)."
                }
              ]
            },
            {
              "name": "longs",
              "overloads": [
                {
                  "signature": "public LongStream longs(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number\n of pseudorandom long values from this generator and/or\n one split from it."
                },
                {
                  "signature": "public LongStream longs()",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n long values from this generator and/or one split from it."
                },
                {
                  "signature": "public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom long values from this generator and/or one split\n from it; each value conforms to the given origin (inclusive) and bound\n (exclusive)."
                },
                {
                  "signature": "public LongStream longs(long randomNumberOrigin, long randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n long values from this generator and/or one split from it; each value\n conforms to the given origin (inclusive) and bound (exclusive)."
                }
              ]
            },
            {
              "name": "doubles",
              "overloads": [
                {
                  "signature": "public DoubleStream doubles(long streamSize)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values from this generator and/or one split\n from it; each value is between zero (inclusive) and one (exclusive)."
                },
                {
                  "signature": "public DoubleStream doubles()",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n double values from this generator and/or one split from it; each value\n is between zero (inclusive) and one (exclusive)."
                },
                {
                  "signature": "public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)",
                  "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values from this generator and/or one split\n from it; each value conforms to the given origin (inclusive) and bound\n (exclusive)."
                },
                {
                  "signature": "public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound)",
                  "description": "Returns an effectively unlimited stream of pseudorandom \n double values from this generator and/or one split from it; each value\n conforms to the given origin (inclusive) and bound (exclusive)."
                }
              ]
            }
          ]
        },
        {
          "name": "Stack<E>",
          "methods": [
            {
              "name": "Stack",
              "overloads": [
                {
                  "signature": "public Stack()",
                  "description": "Creates an empty Stack."
                }
              ]
            },
            {
              "name": "push",
              "overloads": [
                {
                  "signature": "public E push(E item)",
                  "description": "Pushes an item onto the top of this stack. This has exactly\n the same effect as:\n  addElement(item)"
                }
              ]
            },
            {
              "name": "pop",
              "overloads": [
                {
                  "signature": "public E pop()",
                  "description": "Removes the object at the top of this stack and returns that\n object as the value of this function."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "public E peek()",
                  "description": "Looks at the object at the top of this stack without removing it\n from the stack."
                }
              ]
            },
            {
              "name": "empty",
              "overloads": [
                {
                  "signature": "public boolean empty()",
                  "description": "Tests if this stack is empty."
                }
              ]
            },
            {
              "name": "search",
              "overloads": [
                {
                  "signature": "public int search(Object o)",
                  "description": "Returns the 1-based position where an object is on this stack.\n If the object o occurs as an item in this stack, this\n method returns the distance from the top of the stack of the\n occurrence nearest the top of the stack; the topmost item on the\n stack is considered to be at distance 1. The equals\n method is used to compare o to the\n items in this stack."
                }
              ]
            }
          ]
        },
        {
          "name": "StringJoiner",
          "methods": [
            {
              "name": "StringJoiner",
              "overloads": [
                {
                  "signature": "public StringJoiner(CharSequence delimiter)",
                  "description": "Constructs a StringJoiner with no characters in it, with no\n prefix or suffix, and a copy of the supplied\n delimiter.\n If no characters are added to the StringJoiner and methods\n accessing the value of it are invoked, it will not return a\n prefix or suffix (or properties thereof) in the result,\n unless setEmptyValue has first been called."
                },
                {
                  "signature": "public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)",
                  "description": "Constructs a StringJoiner with no characters in it using copies\n of the supplied prefix, delimiter and suffix.\n If no characters are added to the StringJoiner and methods\n accessing the string value of it are invoked, it will return the\n prefix + suffix (or properties thereof) in the result, unless\n setEmptyValue has first been called."
                }
              ]
            },
            {
              "name": "setEmptyValue",
              "overloads": [
                {
                  "signature": "public StringJoiner setEmptyValue(CharSequence emptyValue)",
                  "description": "Sets the sequence of characters to be used when determining the string\n representation of this StringJoiner and no elements have been\n added yet, that is, when it is empty.  A copy of the emptyValue\n parameter is made for this purpose. Note that once an add method has been\n called, the StringJoiner is no longer considered empty, even if\n the element(s) added correspond to the empty String."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the current value, consisting of the prefix, the values\n added so far separated by the delimiter, and the suffix,\n unless no elements have been added in which case, the\n prefix + suffix or the emptyValue characters are returned."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public StringJoiner add(CharSequence newElement)",
                  "description": "Adds a copy of the given CharSequence value as the next\n element of the StringJoiner value. If newElement is\n null, then \"null\" is added."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public StringJoiner merge(StringJoiner other)",
                  "description": "Adds the contents of the given StringJoiner without prefix and\n suffix as the next element if it is non-empty. If the given \n StringJoiner is empty, the call has no effect.\n\n A StringJoiner is empty if add()\n has never been called, and if merge() has never been called\n with a non-empty StringJoiner argument.\n\n If the other StringJoiner is using a different delimiter,\n then elements from the other StringJoiner are concatenated with\n that delimiter and the result is appended to this StringJoiner\n as a single element."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Returns the length of the String representation\n of this StringJoiner. Note that if\n no add methods have been called, then the length of the String\n representation (either prefix + suffix or emptyValue)\n will be returned. The value should be equivalent to\n toString().length()."
                }
              ]
            }
          ]
        },
        {
          "name": "StringTokenizer",
          "methods": [
            {
              "name": "StringTokenizer",
              "overloads": [
                {
                  "signature": "public StringTokenizer(String str, String delim, boolean returnDelims)",
                  "description": "Constructs a string tokenizer for the specified string. All\n characters in the delim argument are the delimiters\n for separating tokens.\n \n If the returnDelims flag is true, then\n the delimiter characters are also returned as tokens. Each\n delimiter is returned as a string of length one. If the flag is\n false, the delimiter characters are skipped and only\n serve as separators between tokens.\n \n Note that if delim is null, this constructor does\n not throw an exception. However, trying to invoke other methods on the\n resulting StringTokenizer may result in a\n NullPointerException."
                },
                {
                  "signature": "public StringTokenizer(String str, String delim)",
                  "description": "Constructs a string tokenizer for the specified string. The\n characters in the delim argument are the delimiters\n for separating tokens. Delimiter characters themselves will not\n be treated as tokens.\n \n Note that if delim is null, this constructor does\n not throw an exception. However, trying to invoke other methods on the\n resulting StringTokenizer may result in a\n NullPointerException."
                },
                {
                  "signature": "public StringTokenizer(String str)",
                  "description": "Constructs a string tokenizer for the specified string. The\n tokenizer uses the default delimiter set, which is\n \"\\t\\n\\r\\f\": the space character,\n the tab character, the newline character, the carriage-return character,\n and the form-feed character. Delimiter characters themselves will\n not be treated as tokens."
                }
              ]
            },
            {
              "name": "hasMoreTokens",
              "overloads": [
                {
                  "signature": "public boolean hasMoreTokens()",
                  "description": "Tests if there are more tokens available from this tokenizer's string.\n If this method returns true, then a subsequent call to\n nextToken with no argument will successfully return a token."
                }
              ]
            },
            {
              "name": "nextToken",
              "overloads": [
                {
                  "signature": "public String nextToken()",
                  "description": "Returns the next token from this string tokenizer."
                },
                {
                  "signature": "public String nextToken(String delim)",
                  "description": "Returns the next token in this string tokenizer's string. First,\n the set of characters considered to be delimiters by this\n StringTokenizer object is changed to be the characters in\n the string delim. Then the next token in the string\n after the current position is returned. The current position is\n advanced beyond the recognized token.  The new delimiter set\n remains the default after this call."
                }
              ]
            },
            {
              "name": "hasMoreElements",
              "overloads": [
                {
                  "signature": "public boolean hasMoreElements()",
                  "description": "Returns the same value as the hasMoreTokens\n method. It exists so that this class can implement the\n Enumeration interface."
                }
              ]
            },
            {
              "name": "nextElement",
              "overloads": [
                {
                  "signature": "public Object nextElement()",
                  "description": "Returns the same value as the nextToken method,\n except that its declared return value is Object rather than\n String. It exists so that this class can implement the\n Enumeration interface."
                }
              ]
            },
            {
              "name": "countTokens",
              "overloads": [
                {
                  "signature": "public int countTokens()",
                  "description": "Calculates the number of times that this tokenizer's\n nextToken method can be called before it generates an\n exception. The current position is not advanced."
                }
              ]
            }
          ]
        },
        {
          "name": "Timer",
          "methods": [
            {
              "name": "Timer",
              "overloads": [
                {
                  "signature": "public Timer()",
                  "description": "Creates a new timer.  The associated thread does not\n run as a daemon."
                },
                {
                  "signature": "public Timer(boolean isDaemon)",
                  "description": "Creates a new timer whose associated thread may be specified to\n run as a daemon.\n A daemon thread is called for if the timer will be used to\n schedule repeating \"maintenance activities\", which must be\n performed as long as the application is running, but should not\n prolong the lifetime of the application."
                },
                {
                  "signature": "public Timer(String name)",
                  "description": "Creates a new timer whose associated thread has the specified name.\n The associated thread does not\n run as a daemon."
                },
                {
                  "signature": "public Timer(String name, boolean isDaemon)",
                  "description": "Creates a new timer whose associated thread has the specified name,\n and may be specified to\n run as a daemon."
                }
              ]
            },
            {
              "name": "schedule",
              "overloads": [
                {
                  "signature": "public void schedule(TimerTask task, long delay)",
                  "description": "Schedules the specified task for execution after the specified delay."
                },
                {
                  "signature": "public void schedule(TimerTask task, Date time)",
                  "description": "Schedules the specified task for execution at the specified time.  If\n the time is in the past, the task is scheduled for immediate execution."
                },
                {
                  "signature": "public void schedule(TimerTask task, long delay, long period)",
                  "description": "Schedules the specified task for repeated fixed-delay execution,\n beginning after the specified delay.  Subsequent executions take place\n at approximately regular intervals separated by the specified period.\n\n In fixed-delay execution, each execution is scheduled relative to\n the actual execution time of the previous execution.  If an execution\n is delayed for any reason (such as garbage collection or other\n background activity), subsequent executions will be delayed as well.\n In the long run, the frequency of execution will generally be slightly\n lower than the reciprocal of the specified period (assuming the system\n clock underlying Object.wait(long) is accurate).\n\n Fixed-delay execution is appropriate for recurring activities\n that require \"smoothness.\"  In other words, it is appropriate for\n activities where it is more important to keep the frequency accurate\n in the short run than in the long run.  This includes most animation\n tasks, such as blinking a cursor at regular intervals.  It also includes\n tasks wherein regular activity is performed in response to human\n input, such as automatically repeating a character as long as a key\n is held down."
                },
                {
                  "signature": "public void schedule(TimerTask task, Date firstTime, long period)",
                  "description": "Schedules the specified task for repeated fixed-delay execution,\n beginning at the specified time. Subsequent executions take place at\n approximately regular intervals, separated by the specified period.\n\n In fixed-delay execution, each execution is scheduled relative to\n the actual execution time of the previous execution.  If an execution\n is delayed for any reason (such as garbage collection or other\n background activity), subsequent executions will be delayed as well.\n In the long run, the frequency of execution will generally be slightly\n lower than the reciprocal of the specified period (assuming the system\n clock underlying Object.wait(long) is accurate).  As a\n consequence of the above, if the scheduled first time is in the past,\n it is scheduled for immediate execution.\n\n Fixed-delay execution is appropriate for recurring activities\n that require \"smoothness.\"  In other words, it is appropriate for\n activities where it is more important to keep the frequency accurate\n in the short run than in the long run.  This includes most animation\n tasks, such as blinking a cursor at regular intervals.  It also includes\n tasks wherein regular activity is performed in response to human\n input, such as automatically repeating a character as long as a key\n is held down."
                }
              ]
            },
            {
              "name": "scheduleAtFixedRate",
              "overloads": [
                {
                  "signature": "public void scheduleAtFixedRate(TimerTask task, long delay, long period)",
                  "description": "Schedules the specified task for repeated fixed-rate execution,\n beginning after the specified delay.  Subsequent executions take place\n at approximately regular intervals, separated by the specified period.\n\n In fixed-rate execution, each execution is scheduled relative to the\n scheduled execution time of the initial execution.  If an execution is\n delayed for any reason (such as garbage collection or other background\n activity), two or more executions will occur in rapid succession to\n \"catch up.\"  In the long run, the frequency of execution will be\n exactly the reciprocal of the specified period (assuming the system\n clock underlying Object.wait(long) is accurate).\n\n Fixed-rate execution is appropriate for recurring activities that\n are sensitive to absolute time, such as ringing a chime every\n hour on the hour, or running scheduled maintenance every day at a\n particular time.  It is also appropriate for recurring activities\n where the total time to perform a fixed number of executions is\n important, such as a countdown timer that ticks once every second for\n ten seconds.  Finally, fixed-rate execution is appropriate for\n scheduling multiple repeating timer tasks that must remain synchronized\n with respect to one another."
                },
                {
                  "signature": "public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)",
                  "description": "Schedules the specified task for repeated fixed-rate execution,\n beginning at the specified time. Subsequent executions take place at\n approximately regular intervals, separated by the specified period.\n\n In fixed-rate execution, each execution is scheduled relative to the\n scheduled execution time of the initial execution.  If an execution is\n delayed for any reason (such as garbage collection or other background\n activity), two or more executions will occur in rapid succession to\n \"catch up.\"  In the long run, the frequency of execution will be\n exactly the reciprocal of the specified period (assuming the system\n clock underlying Object.wait(long) is accurate).  As a\n consequence of the above, if the scheduled first time is in the past,\n then any \"missed\" executions will be scheduled for immediate \"catch up\"\n execution.\n\n Fixed-rate execution is appropriate for recurring activities that\n are sensitive to absolute time, such as ringing a chime every\n hour on the hour, or running scheduled maintenance every day at a\n particular time.  It is also appropriate for recurring activities\n where the total time to perform a fixed number of executions is\n important, such as a countdown timer that ticks once every second for\n ten seconds.  Finally, fixed-rate execution is appropriate for\n scheduling multiple repeating timer tasks that must remain synchronized\n with respect to one another."
                }
              ]
            },
            {
              "name": "cancel",
              "overloads": [
                {
                  "signature": "public void cancel()",
                  "description": "Terminates this timer, discarding any currently scheduled tasks.\n Does not interfere with a currently executing task (if it exists).\n Once a timer has been terminated, its execution thread terminates\n gracefully, and no more tasks may be scheduled on it.\n\n Note that calling this method from within the run method of a\n timer task that was invoked by this timer absolutely guarantees that\n the ongoing task execution is the last task execution that will ever\n be performed by this timer.\n\n This method may be called repeatedly; the second and subsequent\n calls have no effect."
                }
              ]
            },
            {
              "name": "purge",
              "overloads": [
                {
                  "signature": "public int purge()",
                  "description": "Removes all cancelled tasks from this timer's task queue.  Calling\n this method has no effect on the behavior of the timer, but\n eliminates the references to the cancelled tasks from the queue.\n If there are no external references to these tasks, they become\n eligible for garbage collection.\n\n Most programs will have no need to call this method.\n It is designed for use by the rare application that cancels a large\n number of tasks.  Calling this method trades time for space: the\n runtime of the method may be proportional to n + c log n, where n\n is the number of tasks in the queue and c is the number of cancelled\n tasks.\n\n Note that it is permissible to call this method from within\n a task scheduled on this timer."
                }
              ]
            }
          ]
        },
        {
          "name": "TimerTask",
          "methods": [
            {
              "name": "TimerTask",
              "overloads": [
                {
                  "signature": "protected TimerTask()",
                  "description": "Creates a new timer task."
                }
              ]
            },
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "public abstract void run()",
                  "description": "The action to be performed by this timer task."
                }
              ]
            },
            {
              "name": "cancel",
              "overloads": [
                {
                  "signature": "public boolean cancel()",
                  "description": "Cancels this timer task.  If the task has been scheduled for one-time\n execution and has not yet run, or has not yet been scheduled, it will\n never run.  If the task has been scheduled for repeated execution, it\n will never run again.  (If the task is running when this call occurs,\n the task will run to completion, but will never run again.)\n\n Note that calling this method from within the run method of\n a repeating timer task absolutely guarantees that the timer task will\n not run again.\n\n This method may be called repeatedly; the second and subsequent\n calls have no effect."
                }
              ]
            },
            {
              "name": "scheduledExecutionTime",
              "overloads": [
                {
                  "signature": "public long scheduledExecutionTime()",
                  "description": "Returns the scheduled execution time of the most recent\n actual execution of this task.  (If this method is invoked\n while task execution is in progress, the return value is the scheduled\n execution time of the ongoing task execution.)\n\n This method is typically invoked from within a task's run method, to\n determine whether the current execution of the task is sufficiently\n timely to warrant performing the scheduled activity:\n \n   public void run() {\n       if (System.currentTimeMillis() - scheduledExecutionTime() >=\n           MAX_TARDINESS)\n               return;  // Too late; skip this execution.\n       // Perform the task\n   }\n \n This method is typically not used in conjunction with\n fixed-delay execution repeating tasks, as their scheduled\n execution times are allowed to drift over time, and so are not terribly\n significant."
                }
              ]
            }
          ]
        },
        {
          "name": "TimeZone",
          "methods": [
            {
              "name": "TimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public abstract int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds)",
                  "description": "Gets the time zone offset, for current date, modified in case of\n daylight savings. This is the offset to add to UTC to get local time.\n \n This method returns a historically correct offset if an\n underlying TimeZone implementation subclass\n supports historical Daylight Saving Time schedule and GMT\n offset changes."
                },
                {
                  "signature": "public int getOffset(long date)",
                  "description": "Returns the offset of this time zone from UTC at the specified\n date. If Daylight Saving Time is in effect at the specified\n date, the offset value is adjusted with the amount of daylight\n saving.\n \n This method returns a historically correct offset value if an\n underlying TimeZone implementation subclass supports historical\n Daylight Saving Time schedule and GMT offset changes."
                }
              ]
            },
            {
              "name": "setRawOffset",
              "overloads": [
                {
                  "signature": "public abstract void setRawOffset(int offsetMillis)",
                  "description": "Sets the base time zone offset to GMT.\n This is the offset to add to UTC to get local time.\n \n If an underlying TimeZone implementation subclass\n supports historical GMT offset changes, the specified GMT\n offset is set as the latest GMT offset and the difference from\n the known latest GMT offset value is used to adjust all\n historical GMT offset values."
                }
              ]
            },
            {
              "name": "getRawOffset",
              "overloads": [
                {
                  "signature": "public abstract int getRawOffset()",
                  "description": "Returns the amount of time in milliseconds to add to UTC to get\n standard time in this time zone. Because this value is not\n affected by daylight saving time, it is called raw\n offset.\n \n If an underlying TimeZone implementation subclass\n supports historical GMT offset changes, the method returns the\n raw offset value of the current date. In Honolulu, for example,\n its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and\n this method always returns -36000000 milliseconds (i.e., -10\n hours)."
                }
              ]
            },
            {
              "name": "getID",
              "overloads": [
                {
                  "signature": "public String getID()",
                  "description": "Gets the ID of this time zone."
                }
              ]
            },
            {
              "name": "setID",
              "overloads": [
                {
                  "signature": "public void setID(String ID)",
                  "description": "Sets the time zone ID. This does not change any other data in\n the time zone object."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public final String getDisplayName()",
                  "description": "Returns a long standard time name of this TimeZone suitable for\n presentation to the user in the default locale.\n\n This method is equivalent to:\n  getDisplayName(false, LONG,\n                Locale.getDefault(Locale.Category.DISPLAY))"
                },
                {
                  "signature": "public final String getDisplayName(Locale locale)",
                  "description": "Returns a long standard time name of this TimeZone suitable for\n presentation to the user in the specified locale.\n\n This method is equivalent to:\n  getDisplayName(false, LONG, locale)"
                },
                {
                  "signature": "public final String getDisplayName(boolean daylight, int style)",
                  "description": "Returns a name in the specified style of this TimeZone\n suitable for presentation to the user in the default locale. If the\n specified daylight is true, a Daylight Saving Time name\n is returned (even if this TimeZone doesn't observe Daylight Saving\n Time). Otherwise, a Standard Time name is returned.\n\n This method is equivalent to:\n  getDisplayName(daylight, style,\n                Locale.getDefault(Locale.Category.DISPLAY))"
                },
                {
                  "signature": "public String getDisplayName(boolean daylight, int style, Locale locale)",
                  "description": "Returns a name in the specified style of this TimeZone\n suitable for presentation to the user in the specified \n locale. If the specified daylight is true, a Daylight\n Saving Time name is returned (even if this TimeZone doesn't\n observe Daylight Saving Time). Otherwise, a Standard Time name is\n returned.\n\n When looking up a time zone name, the default\n Locale search path of ResourceBundle derived\n from the specified locale is used. (No fallback\n Locale search is performed.) If a time zone name in any\n Locale of the search path, including Locale.ROOT, is\n found, the name is returned. Otherwise, a string in the\n normalized custom ID format is returned."
                }
              ]
            },
            {
              "name": "getDSTSavings",
              "overloads": [
                {
                  "signature": "public int getDSTSavings()",
                  "description": "Returns the amount of time to be added to local standard time\n to get local wall clock time.\n\n The default implementation returns 3600000 milliseconds\n (i.e., one hour) if a call to useDaylightTime()\n returns true. Otherwise, 0 (zero) is returned.\n\n If an underlying TimeZone implementation subclass\n supports historical and future Daylight Saving Time schedule\n changes, this method returns the amount of saving time of the\n last known Daylight Saving Time rule that can be a future\n prediction.\n\n If the amount of saving time at any given time stamp is\n required, construct a Calendar with this \n TimeZone and the time stamp, and call Calendar.get(Calendar.DST_OFFSET)."
                }
              ]
            },
            {
              "name": "useDaylightTime",
              "overloads": [
                {
                  "signature": "public abstract boolean useDaylightTime()",
                  "description": "Queries if this TimeZone uses Daylight Saving Time.\n\n If an underlying TimeZone implementation subclass\n supports historical and future Daylight Saving Time schedule\n changes, this method refers to the last known Daylight Saving Time\n rule that can be a future prediction and may not be the same as\n the current rule. Consider calling observesDaylightTime()\n if the current rule should also be taken into account."
                }
              ]
            },
            {
              "name": "observesDaylightTime",
              "overloads": [
                {
                  "signature": "public boolean observesDaylightTime()",
                  "description": "Returns true if this TimeZone is currently in\n Daylight Saving Time, or if a transition from Standard Time to\n Daylight Saving Time occurs at any future time.\n\n The default implementation returns true if\n useDaylightTime() or inDaylightTime(new Date())\n returns true."
                }
              ]
            },
            {
              "name": "inDaylightTime",
              "overloads": [
                {
                  "signature": "public abstract boolean inDaylightTime(Date date)",
                  "description": "Queries if the given date is in Daylight Saving Time in\n this time zone."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public static TimeZone getTimeZone(String ID)",
                  "description": "Gets the TimeZone for the given ID."
                },
                {
                  "signature": "public static TimeZone getTimeZone(ZoneId zoneId)",
                  "description": "Gets the TimeZone for the given zoneId."
                }
              ]
            },
            {
              "name": "toZoneId",
              "overloads": [
                {
                  "signature": "public ZoneId toZoneId()",
                  "description": "Converts this TimeZone object to a ZoneId."
                }
              ]
            },
            {
              "name": "getAvailableIDs",
              "overloads": [
                {
                  "signature": "public static String[] getAvailableIDs(int rawOffset)",
                  "description": "Gets the available IDs according to the given time zone offset in milliseconds."
                },
                {
                  "signature": "public static String[] getAvailableIDs()",
                  "description": "Gets all the available IDs supported."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static TimeZone getDefault()",
                  "description": "Gets the default TimeZone of the Java virtual machine. If the\n cached default TimeZone is available, its clone is returned.\n Otherwise, the method takes the following steps to determine the default\n time zone.\n\n \n Use the user.timezone property value as the default\n time zone ID if it's available.\n Detect the platform time zone ID. The source of the\n platform time zone and ID mapping may vary with implementation.\n Use GMT as the last resort if the given or detected\n time zone ID is unknown.\n \n\n The default TimeZone created from the ID is cached,\n and its clone is returned. The user.timezone property\n value is set to the ID upon return."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(TimeZone zone)",
                  "description": "Sets the TimeZone that is returned by the getDefault\n method. zone is cached. If zone is null, the cached\n default TimeZone is cleared. This method doesn't change the value\n of the user.timezone property."
                }
              ]
            },
            {
              "name": "hasSameRules",
              "overloads": [
                {
                  "signature": "public boolean hasSameRules(TimeZone other)",
                  "description": "Returns true if this zone has the same rule and offset as another zone.\n That is, if this zone differs only in ID, if at all.  Returns false\n if the other zone is null."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates a copy of this TimeZone."
                }
              ]
            }
          ]
        },
        {
          "name": "TooManyListenersException",
          "methods": [
            {
              "name": "TooManyListenersException",
              "overloads": [
                {
                  "signature": "public TooManyListenersException()",
                  "description": "Constructs a TooManyListenersException with no detail message.\n A detail message is a String that describes this particular exception."
                },
                {
                  "signature": "public TooManyListenersException(String s)",
                  "description": "Constructs a TooManyListenersException with the specified detail message.\n A detail message is a String that describes this particular exception."
                }
              ]
            }
          ]
        },
        {
          "name": "TreeMap<K,V>",
          "methods": [
            {
              "name": "TreeMap",
              "overloads": [
                {
                  "signature": "public TreeMap()",
                  "description": "Constructs a new, empty tree map, using the natural ordering of its\n keys.  All keys inserted into the map must implement the Comparable interface.  Furthermore, all such keys must be\n mutually comparable: k1.compareTo(k2) must not throw\n a ClassCastException for any keys k1 and\n k2 in the map.  If the user attempts to put a key into the\n map that violates this constraint (for example, the user attempts to\n put a string key into a map whose keys are integers), the\n put(Object key, Object value) call will throw a\n ClassCastException."
                },
                {
                  "signature": "public TreeMap(Comparator<? super K> comparator)",
                  "description": "Constructs a new, empty tree map, ordered according to the given\n comparator.  All keys inserted into the map must be mutually\n comparable by the given comparator: comparator.compare(k1,\n k2) must not throw a ClassCastException for any keys\n k1 and k2 in the map.  If the user attempts to put\n a key into the map that violates this constraint, the put(Object\n key, Object value) call will throw a\n ClassCastException."
                },
                {
                  "signature": "public TreeMap(Map<? extends K,? extends V> m)",
                  "description": "Constructs a new tree map containing the same mappings as the given\n map, ordered according to the natural ordering of its keys.\n All keys inserted into the new map must implement the Comparable interface.  Furthermore, all such keys must be\n mutually comparable: k1.compareTo(k2) must not throw\n a ClassCastException for any keys k1 and\n k2 in the map.  This method runs in n*log(n) time."
                },
                {
                  "signature": "public TreeMap(SortedMap<K,? extends V> m)",
                  "description": "Constructs a new tree map containing the same mappings and\n using the same ordering as the specified sorted map.  This\n method runs in linear time."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this map."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the specified\n key."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value.  More formally, returns true if and only if\n this map contains at least one mapping to a value v such\n that (value==null ? v==null : value.equals(v)).  This\n operation will probably require time linear in the map size for\n most implementations."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that key compares\n equal to k according to the map's ordering, then this\n method returns v; otherwise it returns null.\n (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "comparator",
              "overloads": [
                {
                  "signature": "public Comparator<? super K> comparator()",
                  "description": "Description copied from interface:SortedMap"
                }
              ]
            },
            {
              "name": "firstKey",
              "overloads": [
                {
                  "signature": "public K firstKey()",
                  "description": "Description copied from interface:SortedMap"
                }
              ]
            },
            {
              "name": "lastKey",
              "overloads": [
                {
                  "signature": "public K lastKey()",
                  "description": "Description copied from interface:SortedMap"
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> map)",
                  "description": "Copies all of the mappings from the specified map to this map.\n These mappings replace any mappings that this map had for any\n of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map.\n If the map previously contained a mapping for the key, the old\n value is replaced."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "public V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \n\n Or to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \n\n The mapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n mapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "public V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "public V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation.\n\n This method will, on a best-effort basis, throw a\n ConcurrentModificationException if it is detected that the\n remapping function modifies this map during computation."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for this key from this TreeMap if present."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this TreeMap instance. (The keys and\n values themselves are not cloned.)"
                }
              ]
            },
            {
              "name": "firstEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> firstEntry()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "lastEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> lastEntry()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "pollFirstEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> pollFirstEntry()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "pollLastEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> pollLastEntry()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "lowerEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> lowerEntry(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "lowerKey",
              "overloads": [
                {
                  "signature": "public K lowerKey(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "floorEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> floorEntry(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "floorKey",
              "overloads": [
                {
                  "signature": "public K floorKey(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "ceilingEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> ceilingEntry(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "ceilingKey",
              "overloads": [
                {
                  "signature": "public K ceilingKey(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "higherEntry",
              "overloads": [
                {
                  "signature": "public Map.Entry<K,V> higherEntry(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "higherKey",
              "overloads": [
                {
                  "signature": "public K higherKey(K key)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n\n The set's iterator returns the keys in ascending order.\n The set's spliterator is\n late-binding,\n fail-fast, and additionally reports Spliterator.SORTED\n and Spliterator.ORDERED with an encounter order that is ascending\n key order.  The spliterator's comparator (see\n Spliterator.getComparator()) is null if\n the tree map's comparator (see comparator()) is null.\n Otherwise, the spliterator's comparator is the same as or imposes the\n same total ordering as the tree map's comparator.\n\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "navigableKeySet",
              "overloads": [
                {
                  "signature": "public NavigableSet<K> navigableKeySet()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "descendingKeySet",
              "overloads": [
                {
                  "signature": "public NavigableSet<K> descendingKeySet()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n\n The collection's iterator returns the values in ascending order\n of the corresponding keys. The collection's spliterator is\n late-binding,\n fail-fast, and additionally reports Spliterator.ORDERED\n with an encounter order that is ascending order of the corresponding\n keys.\n\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n\n The set's iterator returns the entries in ascending key order. The\n set's spliterator is\n late-binding,\n fail-fast, and additionally reports Spliterator.SORTED and\n Spliterator.ORDERED with an encounter order that is ascending key\n order.\n\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            },
            {
              "name": "descendingMap",
              "overloads": [
                {
                  "signature": "public NavigableMap<K,V> descendingMap()",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "subMap",
              "overloads": [
                {
                  "signature": "public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
                  "description": "Description copied from interface:NavigableMap"
                },
                {
                  "signature": "public SortedMap<K,V> subMap(K fromKey, K toKey)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "headMap",
              "overloads": [
                {
                  "signature": "public NavigableMap<K,V> headMap(K toKey, boolean inclusive)",
                  "description": "Description copied from interface:NavigableMap"
                },
                {
                  "signature": "public SortedMap<K,V> headMap(K toKey)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            },
            {
              "name": "tailMap",
              "overloads": [
                {
                  "signature": "public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)",
                  "description": "Description copied from interface:NavigableMap"
                },
                {
                  "signature": "public SortedMap<K,V> tailMap(K fromKey)",
                  "description": "Description copied from interface:NavigableMap"
                }
              ]
            }
          ]
        },
        {
          "name": "TreeSet<E>",
          "methods": [
            {
              "name": "TreeSet",
              "overloads": [
                {
                  "signature": "public TreeSet()",
                  "description": "Constructs a new, empty tree set, sorted according to the\n natural ordering of its elements.  All elements inserted into\n the set must implement the Comparable interface.\n Furthermore, all such elements must be mutually\n comparable: e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the set.  If the user attempts to add an element\n to the set that violates this constraint (for example, the user\n attempts to add a string element to a set whose elements are\n integers), the add call will throw a\n ClassCastException."
                },
                {
                  "signature": "public TreeSet(Comparator<? super E> comparator)",
                  "description": "Constructs a new, empty tree set, sorted according to the specified\n comparator.  All elements inserted into the set must be mutually\n comparable by the specified comparator: comparator.compare(e1,\n e2) must not throw a ClassCastException for any elements\n e1 and e2 in the set.  If the user attempts to add\n an element to the set that violates this constraint, the\n add call will throw a ClassCastException."
                },
                {
                  "signature": "public TreeSet(Collection<? extends E> c)",
                  "description": "Constructs a new tree set containing the elements in the specified\n collection, sorted according to the natural ordering of its\n elements.  All elements inserted into the set must implement the\n Comparable interface.  Furthermore, all such elements must be\n mutually comparable: e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the set."
                },
                {
                  "signature": "public TreeSet(SortedSet<E> s)",
                  "description": "Constructs a new tree set containing the same elements and\n using the same ordering as the specified sorted set."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this set in ascending order."
                }
              ]
            },
            {
              "name": "descendingIterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> descendingIterator()",
                  "description": "Returns an iterator over the elements in this set in descending order."
                }
              ]
            },
            {
              "name": "descendingSet",
              "overloads": [
                {
                  "signature": "public NavigableSet<E> descendingSet()",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of elements in this set (its cardinality)."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this set contains no elements."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this set contains the specified element.\n More formally, returns true if and only if this set\n contains an element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Adds the specified element to this set if it is not already present.\n More formally, adds the specified element e to this set if\n the set contains no element e2 such that\n Objects.equals(e, e2).\n If this set already contains the element, the call leaves the set\n unchanged and returns false."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes the specified element from this set if it is present.\n More formally, removes an element e such that\n Objects.equals(o, e),\n if this set contains such an element.  Returns true if\n this set contained the element (or equivalently, if this set\n changed as a result of the call).  (This set will not contain the\n element once the call returns.)"
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this set.\n The set will be empty after this call returns."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Adds all of the elements in the specified collection to this set."
                }
              ]
            },
            {
              "name": "subSet",
              "overloads": [
                {
                  "signature": "public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)",
                  "description": "Description copied from interface:NavigableSet"
                },
                {
                  "signature": "public SortedSet<E> subSet(E fromElement, E toElement)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "headSet",
              "overloads": [
                {
                  "signature": "public NavigableSet<E> headSet(E toElement, boolean inclusive)",
                  "description": "Description copied from interface:NavigableSet"
                },
                {
                  "signature": "public SortedSet<E> headSet(E toElement)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "tailSet",
              "overloads": [
                {
                  "signature": "public NavigableSet<E> tailSet(E fromElement, boolean inclusive)",
                  "description": "Description copied from interface:NavigableSet"
                },
                {
                  "signature": "public SortedSet<E> tailSet(E fromElement)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "comparator",
              "overloads": [
                {
                  "signature": "public Comparator<? super E> comparator()",
                  "description": "Description copied from interface:SortedSet"
                }
              ]
            },
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "public E first()",
                  "description": "Description copied from interface:SortedSet"
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "public E last()",
                  "description": "Description copied from interface:SortedSet"
                }
              ]
            },
            {
              "name": "lower",
              "overloads": [
                {
                  "signature": "public E lower(E e)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "floor",
              "overloads": [
                {
                  "signature": "public E floor(E e)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "ceiling",
              "overloads": [
                {
                  "signature": "public E ceiling(E e)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "higher",
              "overloads": [
                {
                  "signature": "public E higher(E e)",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "pollFirst",
              "overloads": [
                {
                  "signature": "public E pollFirst()",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "pollLast",
              "overloads": [
                {
                  "signature": "public E pollLast()",
                  "description": "Description copied from interface:NavigableSet"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a shallow copy of this TreeSet instance. (The elements\n themselves are not cloned.)"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n set.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.DISTINCT, Spliterator.SORTED, and\n Spliterator.ORDERED.  Overriding implementations should document\n the reporting of additional characteristic values.\n\n The spliterator's comparator (see\n Spliterator.getComparator()) is null if\n the tree set's comparator (see comparator()) is null.\n Otherwise, the spliterator's comparator is the same as or imposes the\n same total ordering as the tree set's comparator."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownFormatConversionException",
          "methods": [
            {
              "name": "UnknownFormatConversionException",
              "overloads": [
                {
                  "signature": "public UnknownFormatConversionException(String s)",
                  "description": "Constructs an instance of this class with the unknown conversion."
                }
              ]
            },
            {
              "name": "getConversion",
              "overloads": [
                {
                  "signature": "public String getConversion()",
                  "description": "Returns the unknown conversion."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownFormatFlagsException",
          "methods": [
            {
              "name": "UnknownFormatFlagsException",
              "overloads": [
                {
                  "signature": "public UnknownFormatFlagsException(String f)",
                  "description": "Constructs an instance of this class with the specified flags."
                }
              ]
            },
            {
              "name": "getFlags",
              "overloads": [
                {
                  "signature": "public String getFlags()",
                  "description": "Returns the set of flags which contains an unknown flag."
                }
              ]
            }
          ]
        },
        {
          "name": "UUID",
          "methods": [
            {
              "name": "UUID",
              "overloads": [
                {
                  "signature": "public UUID(long mostSigBits, long leastSigBits)",
                  "description": "Constructs a new UUID using the specified data.  \n mostSigBits is used for the most significant 64 bits of the \n UUID and leastSigBits becomes the least significant 64 bits of\n the UUID."
                }
              ]
            },
            {
              "name": "randomUUID",
              "overloads": [
                {
                  "signature": "public static UUID randomUUID()",
                  "description": "Static factory to retrieve a type 4 (pseudo randomly generated) UUID.\n\n The UUID is generated using a cryptographically strong pseudo\n random number generator."
                }
              ]
            },
            {
              "name": "nameUUIDFromBytes",
              "overloads": [
                {
                  "signature": "public static UUID nameUUIDFromBytes(byte[] name)",
                  "description": "Static factory to retrieve a type 3 (name based) UUID based on\n the specified byte array."
                }
              ]
            },
            {
              "name": "fromString",
              "overloads": [
                {
                  "signature": "public static UUID fromString(String name)",
                  "description": "Creates a UUID from the string standard representation as\n described in the toString() method."
                }
              ]
            },
            {
              "name": "getLeastSignificantBits",
              "overloads": [
                {
                  "signature": "public long getLeastSignificantBits()",
                  "description": "Returns the least significant 64 bits of this UUID's 128 bit value."
                }
              ]
            },
            {
              "name": "getMostSignificantBits",
              "overloads": [
                {
                  "signature": "public long getMostSignificantBits()",
                  "description": "Returns the most significant 64 bits of this UUID's 128 bit value."
                }
              ]
            },
            {
              "name": "version",
              "overloads": [
                {
                  "signature": "public int version()",
                  "description": "The version number associated with this UUID.  The version\n number describes how this UUID was generated.\n\n The version number has the following meaning:\n \n 1    Time-based UUID\n 2    DCE security UUID\n 3    Name-based UUID\n 4    Randomly generated UUID"
                }
              ]
            },
            {
              "name": "variant",
              "overloads": [
                {
                  "signature": "public int variant()",
                  "description": "The variant number associated with this UUID.  The variant\n number describes the layout of the UUID.\n\n The variant number has the following meaning:\n \n 0    Reserved for NCS backward compatibility\n 2    IETFRFC4122\n (Leach-Salz), used by this class\n 6    Reserved, Microsoft Corporation backward compatibility\n 7    Reserved for future definition"
                }
              ]
            },
            {
              "name": "timestamp",
              "overloads": [
                {
                  "signature": "public long timestamp()",
                  "description": "The timestamp value associated with this UUID.\n\n  The 60 bit timestamp value is constructed from the time_low,\n time_mid, and time_hi fields of this UUID.  The resulting\n timestamp is measured in 100-nanosecond units since midnight,\n October 15, 1582 UTC.\n\n  The timestamp value is only meaningful in a time-based UUID, which\n has version type 1.  If this UUID is not a time-based UUID then\n this method throws UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "clockSequence",
              "overloads": [
                {
                  "signature": "public int clockSequence()",
                  "description": "The clock sequence value associated with this UUID.\n\n  The 14 bit clock sequence value is constructed from the clock\n sequence field of this UUID.  The clock sequence field is used to\n guarantee temporal uniqueness in a time-based UUID.\n\n  The clockSequence value is only meaningful in a time-based\n UUID, which has version type 1.  If this UUID is not a time-based UUID\n then this method throws UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "node",
              "overloads": [
                {
                  "signature": "public long node()",
                  "description": "The node value associated with this UUID.\n\n  The 48 bit node value is constructed from the node field of this\n UUID.  This field is intended to hold the IEEE 802 address of the machine\n that generated this UUID to guarantee spatial uniqueness.\n\n  The node value is only meaningful in a time-based UUID, which has\n version type 1.  If this UUID is not a time-based UUID then this method\n throws UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String object representing this UUID.\n\n  The UUID string representation is as described by this BNF:\n  \n UUID                   = <time_low> \"-\" <time_mid> \"-\"\n                          <time_high_and_version> \"-\"\n                          <variant_and_sequence> \"-\"\n                          <node>\n time_low               = 4*<hexOctet>\n time_mid               = 2*<hexOctet>\n time_high_and_version  = 2*<hexOctet>\n variant_and_sequence   = 2*<hexOctet>\n node                   = 6*<hexOctet>\n hexOctet               = <hexDigit><hexDigit>\n hexDigit               =\n       \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n       | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n       | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\""
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this UUID."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object to the specified object.  The result is \n true if and only if the argument is not null, is a UUID\n object, has the same variant, and contains the same value, bit for bit,\n as this UUID."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(UUID val)",
                  "description": "Compares this UUID with the specified UUID.\n\n  The first of two UUIDs is greater than the second if the most\n significant field in which the UUIDs differ is greater for the first\n UUID."
                }
              ]
            }
          ]
        },
        {
          "name": "Vector<E>",
          "methods": [
            {
              "name": "Vector",
              "overloads": [
                {
                  "signature": "public Vector(int initialCapacity, int capacityIncrement)",
                  "description": "Constructs an empty vector with the specified initial capacity and\n capacity increment."
                },
                {
                  "signature": "public Vector(int initialCapacity)",
                  "description": "Constructs an empty vector with the specified initial capacity and\n with its capacity increment equal to zero."
                },
                {
                  "signature": "public Vector()",
                  "description": "Constructs an empty vector so that its internal data array\n has size 10 and its standard capacity increment is\n zero."
                },
                {
                  "signature": "public Vector(Collection<? extends E> c)",
                  "description": "Constructs a vector containing the elements of the specified\n collection, in the order they are returned by the collection's\n iterator."
                }
              ]
            },
            {
              "name": "copyInto",
              "overloads": [
                {
                  "signature": "public void copyInto(Object[] anArray)",
                  "description": "Copies the components of this vector into the specified array.\n The item at index k in this vector is copied into\n component k of anArray."
                }
              ]
            },
            {
              "name": "trimToSize",
              "overloads": [
                {
                  "signature": "public void trimToSize()",
                  "description": "Trims the capacity of this vector to be the vector's current\n size. If the capacity of this vector is larger than its current\n size, then the capacity is changed to equal the size by replacing\n its internal data array, kept in the field elementData,\n with a smaller one. An application can use this operation to\n minimize the storage of a vector."
                }
              ]
            },
            {
              "name": "ensureCapacity",
              "overloads": [
                {
                  "signature": "public void ensureCapacity(int minCapacity)",
                  "description": "Increases the capacity of this vector, if necessary, to ensure\n that it can hold at least the number of components specified by\n the minimum capacity argument.\n\n If the current capacity of this vector is less than\n minCapacity, then its capacity is increased by replacing its\n internal data array, kept in the field elementData, with a\n larger one.  The size of the new data array will be the old size plus\n capacityIncrement, unless the value of\n capacityIncrement is less than or equal to zero, in which case\n the new capacity will be twice the old capacity; but if this new size\n is still smaller than minCapacity, then the new capacity will\n be minCapacity."
                }
              ]
            },
            {
              "name": "setSize",
              "overloads": [
                {
                  "signature": "public void setSize(int newSize)",
                  "description": "Sets the size of this vector. If the new size is greater than the\n current size, new null items are added to the end of\n the vector. If the new size is less than the current size, all\n components at index newSize and greater are discarded."
                }
              ]
            },
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public int capacity()",
                  "description": "Returns the current capacity of this vector."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of components in this vector."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Tests if this vector has no components."
                }
              ]
            },
            {
              "name": "elements",
              "overloads": [
                {
                  "signature": "public Enumeration<E> elements()",
                  "description": "Returns an enumeration of the components of this vector. The\n returned Enumeration object will generate all items in\n this vector. The first item generated is the item at index 0,\n then the item at index 1, and so on. If the vector is\n structurally modified while enumerating over the elements then the\n results of enumerating are undefined."
                }
              ]
            },
            {
              "name": "contains",
              "overloads": [
                {
                  "signature": "public boolean contains(Object o)",
                  "description": "Returns true if this vector contains the specified element.\n More formally, returns true if and only if this vector\n contains at least one element e such that\n Objects.equals(o, e)."
                }
              ]
            },
            {
              "name": "indexOf",
              "overloads": [
                {
                  "signature": "public int indexOf(Object o)",
                  "description": "Returns the index of the first occurrence of the specified element\n in this vector, or -1 if this vector does not contain the element.\n More formally, returns the lowest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                },
                {
                  "signature": "public int indexOf(Object o, int index)",
                  "description": "Returns the index of the first occurrence of the specified element in\n this vector, searching forwards from index, or returns -1 if\n the element is not found.\n More formally, returns the lowest index i such that\n (i >= index && Objects.equals(o, get(i))),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "lastIndexOf",
              "overloads": [
                {
                  "signature": "public int lastIndexOf(Object o)",
                  "description": "Returns the index of the last occurrence of the specified element\n in this vector, or -1 if this vector does not contain the element.\n More formally, returns the highest index i such that\n Objects.equals(o, get(i)),\n or -1 if there is no such index."
                },
                {
                  "signature": "public int lastIndexOf(Object o, int index)",
                  "description": "Returns the index of the last occurrence of the specified element in\n this vector, searching backwards from index, or returns -1 if\n the element is not found.\n More formally, returns the highest index i such that\n (i <= index && Objects.equals(o, get(i))),\n or -1 if there is no such index."
                }
              ]
            },
            {
              "name": "elementAt",
              "overloads": [
                {
                  "signature": "public E elementAt(int index)",
                  "description": "Returns the component at the specified index.\n\n This method is identical in functionality to the get(int)\n method (which is part of the List interface)."
                }
              ]
            },
            {
              "name": "firstElement",
              "overloads": [
                {
                  "signature": "public E firstElement()",
                  "description": "Returns the first component (the item at index 0) of\n this vector."
                }
              ]
            },
            {
              "name": "lastElement",
              "overloads": [
                {
                  "signature": "public E lastElement()",
                  "description": "Returns the last component of the vector."
                }
              ]
            },
            {
              "name": "setElementAt",
              "overloads": [
                {
                  "signature": "public void setElementAt(E obj, int index)",
                  "description": "Sets the component at the specified index of this\n vector to be the specified object. The previous component at that\n position is discarded.\n\n The index must be a value greater than or equal to 0\n and less than the current size of the vector.\n\n This method is identical in functionality to the\n set(int, E)\n method (which is part of the List interface). Note that the\n set method reverses the order of the parameters, to more closely\n match array usage.  Note also that the set method returns the\n old value that was stored at the specified position."
                }
              ]
            },
            {
              "name": "removeElementAt",
              "overloads": [
                {
                  "signature": "public void removeElementAt(int index)",
                  "description": "Deletes the component at the specified index. Each component in\n this vector with an index greater or equal to the specified\n index is shifted downward to have an index one\n smaller than the value it had previously. The size of this vector\n is decreased by 1.\n\n The index must be a value greater than or equal to 0\n and less than the current size of the vector.\n\n This method is identical in functionality to the remove(int)\n method (which is part of the List interface).  Note that the\n remove method returns the old value that was stored at the\n specified position."
                }
              ]
            },
            {
              "name": "insertElementAt",
              "overloads": [
                {
                  "signature": "public void insertElementAt(E obj, int index)",
                  "description": "Inserts the specified object as a component in this vector at the\n specified index. Each component in this vector with\n an index greater or equal to the specified index is\n shifted upward to have an index one greater than the value it had\n previously.\n\n The index must be a value greater than or equal to 0\n and less than or equal to the current size of the vector. (If the\n index is equal to the current size of the vector, the new element\n is appended to the Vector.)\n\n This method is identical in functionality to the\n add(int, E)\n method (which is part of the List interface).  Note that the\n add method reverses the order of the parameters, to more closely\n match array usage."
                }
              ]
            },
            {
              "name": "addElement",
              "overloads": [
                {
                  "signature": "public void addElement(E obj)",
                  "description": "Adds the specified component to the end of this vector,\n increasing its size by one. The capacity of this vector is\n increased if its size becomes greater than its capacity.\n\n This method is identical in functionality to the\n add(E)\n method (which is part of the List interface)."
                }
              ]
            },
            {
              "name": "removeElement",
              "overloads": [
                {
                  "signature": "public boolean removeElement(Object obj)",
                  "description": "Removes the first (lowest-indexed) occurrence of the argument\n from this vector. If the object is found in this vector, each\n component in the vector with an index greater or equal to the\n object's index is shifted downward to have an index one smaller\n than the value it had previously.\n\n This method is identical in functionality to the\n remove(Object) method (which is part of the\n List interface)."
                }
              ]
            },
            {
              "name": "removeAllElements",
              "overloads": [
                {
                  "signature": "public void removeAllElements()",
                  "description": "Removes all components from this vector and sets its size to zero.\n\n This method is identical in functionality to the clear()\n method (which is part of the List interface)."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Returns a clone of this vector. The copy will contain a\n reference to a clone of the internal data array, not a reference\n to the original internal data array of this Vector object."
                }
              ]
            },
            {
              "name": "toArray",
              "overloads": [
                {
                  "signature": "public Object[] toArray()",
                  "description": "Returns an array containing all of the elements in this Vector\n in the correct order."
                },
                {
                  "signature": "public <T> T[] toArray(T[] a)",
                  "description": "Returns an array containing all of the elements in this Vector in the\n correct order; the runtime type of the returned array is that of the\n specified array.  If the Vector fits in the specified array, it is\n returned therein.  Otherwise, a new array is allocated with the runtime\n type of the specified array and the size of this Vector.\n\n If the Vector fits in the specified array with room to spare\n (i.e., the array has more elements than the Vector),\n the element in the array immediately following the end of the\n Vector is set to null.  (This is useful in determining the length\n of the Vector only if the caller knows that the Vector\n does not contain any null elements.)"
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public E get(int index)",
                  "description": "Returns the element at the specified position in this Vector."
                }
              ]
            },
            {
              "name": "set",
              "overloads": [
                {
                  "signature": "public E set(int index, E element)",
                  "description": "Replaces the element at the specified position in this Vector with the\n specified element."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public boolean add(E e)",
                  "description": "Appends the specified element to the end of this Vector."
                },
                {
                  "signature": "public void add(int index, E element)",
                  "description": "Inserts the specified element at the specified position in this Vector.\n Shifts the element currently at that position (if any) and any\n subsequent elements to the right (adds one to their indices)."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public boolean remove(Object o)",
                  "description": "Removes the first occurrence of the specified element in this Vector\n If the Vector does not contain the element, it is unchanged.  More\n formally, removes the element with the lowest index i such that\n Objects.equals(o, get(i)) (if such\n an element exists)."
                },
                {
                  "signature": "public E remove(int index)",
                  "description": "Removes the element at the specified position in this Vector.\n Shifts any subsequent elements to the left (subtracts one from their\n indices).  Returns the element that was removed from the Vector."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the elements from this Vector.  The Vector will\n be empty after this call returns (unless it throws an exception)."
                }
              ]
            },
            {
              "name": "containsAll",
              "overloads": [
                {
                  "signature": "public boolean containsAll(Collection<?> c)",
                  "description": "Returns true if this Vector contains all of the elements in the\n specified Collection."
                }
              ]
            },
            {
              "name": "addAll",
              "overloads": [
                {
                  "signature": "public boolean addAll(Collection<? extends E> c)",
                  "description": "Appends all of the elements in the specified Collection to the end of\n this Vector, in the order that they are returned by the specified\n Collection's Iterator.  The behavior of this operation is undefined if\n the specified Collection is modified while the operation is in progress.\n (This implies that the behavior of this call is undefined if the\n specified Collection is this Vector, and this Vector is nonempty.)"
                },
                {
                  "signature": "public boolean addAll(int index, Collection<? extends E> c)",
                  "description": "Inserts all of the elements in the specified Collection into this\n Vector at the specified position.  Shifts the element currently at\n that position (if any) and any subsequent elements to the right\n (increases their indices).  The new elements will appear in the Vector\n in the order that they are returned by the specified Collection's\n iterator."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "public boolean removeAll(Collection<?> c)",
                  "description": "Removes from this Vector all of its elements that are contained in the\n specified Collection."
                }
              ]
            },
            {
              "name": "retainAll",
              "overloads": [
                {
                  "signature": "public boolean retainAll(Collection<?> c)",
                  "description": "Retains only the elements in this Vector that are contained in the\n specified Collection.  In other words, removes from this Vector all\n of its elements that are not contained in the specified Collection."
                }
              ]
            },
            {
              "name": "removeIf",
              "overloads": [
                {
                  "signature": "public boolean removeIf(Predicate<? super E> filter)",
                  "description": "Description copied from interface:Collection"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares the specified Object with this Vector for equality.  Returns\n true if and only if the specified Object is also a List, both Lists\n have the same size, and all corresponding pairs of elements in the two\n Lists are equal.  (Two elements e1 and\n e2 are equal if Objects.equals(e1, e2).)\n In other words, two Lists are defined to be\n equal if they contain the same elements in the same order."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this Vector."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this Vector, containing\n the String representation of each element."
                }
              ]
            },
            {
              "name": "subList",
              "overloads": [
                {
                  "signature": "public List<E> subList(int fromIndex, int toIndex)",
                  "description": "Returns a view of the portion of this List between fromIndex,\n inclusive, and toIndex, exclusive.  (If fromIndex and toIndex are\n equal, the returned List is empty.)  The returned List is backed by this\n List, so changes in the returned List are reflected in this List, and\n vice-versa.  The returned List supports all of the optional List\n operations supported by this List.\n\n This method eliminates the need for explicit range operations (of\n the sort that commonly exist for arrays).  Any operation that expects\n a List can be used as a range operation by operating on a subList view\n instead of a whole List.  For example, the following idiom\n removes a range of elements from a List:\n       list.subList(from, to).clear();\n \n Similar idioms may be constructed for indexOf and lastIndexOf,\n and all of the algorithms in the Collections class can be applied to\n a subList.\n\n The semantics of the List returned by this method become undefined if\n the backing list (i.e., this List) is structurally modified in\n any way other than via the returned List.  (Structural modifications are\n those that change the size of the List, or otherwise perturb it in such\n a fashion that iterations in progress may yield incorrect results.)"
                }
              ]
            },
            {
              "name": "removeRange",
              "overloads": [
                {
                  "signature": "protected void removeRange(int fromIndex, int toIndex)",
                  "description": "Removes from this list all of the elements whose index is between\n fromIndex, inclusive, and toIndex, exclusive.\n Shifts any succeeding elements to the left (reduces their index).\n This call shortens the list by (toIndex - fromIndex) elements.\n (If toIndex==fromIndex, this operation has no effect.)"
                }
              ]
            },
            {
              "name": "listIterator",
              "overloads": [
                {
                  "signature": "public ListIterator<E> listIterator(int index)",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.\n The specified index indicates the first element that would be\n returned by an initial call to next.\n An initial call to previous would\n return the element with the specified index minus one.\n\n The returned list iterator is fail-fast."
                },
                {
                  "signature": "public ListIterator<E> listIterator()",
                  "description": "Returns a list iterator over the elements in this list (in proper\n sequence).\n\n The returned list iterator is fail-fast."
                }
              ]
            },
            {
              "name": "iterator",
              "overloads": [
                {
                  "signature": "public Iterator<E> iterator()",
                  "description": "Returns an iterator over the elements in this list in proper sequence.\n\n The returned iterator is fail-fast."
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(Consumer<? super E> action)",
                  "description": "Description copied from interface:Iterable"
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public void replaceAll(UnaryOperator<E> operator)",
                  "description": "Description copied from interface:List"
                }
              ]
            },
            {
              "name": "spliterator",
              "overloads": [
                {
                  "signature": "public Spliterator<E> spliterator()",
                  "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, and Spliterator.ORDERED.\n Overriding implementations should document the reporting of additional\n characteristic values."
                }
              ]
            }
          ]
        },
        {
          "name": "WeakHashMap<K,V>",
          "methods": [
            {
              "name": "WeakHashMap",
              "overloads": [
                {
                  "signature": "public WeakHashMap(int initialCapacity, float loadFactor)",
                  "description": "Constructs a new, empty WeakHashMap with the given initial\n capacity and the given load factor."
                },
                {
                  "signature": "public WeakHashMap(int initialCapacity)",
                  "description": "Constructs a new, empty WeakHashMap with the given initial\n capacity and the default load factor (0.75)."
                },
                {
                  "signature": "public WeakHashMap()",
                  "description": "Constructs a new, empty WeakHashMap with the default initial\n capacity (16) and load factor (0.75)."
                },
                {
                  "signature": "public WeakHashMap(Map<? extends K,? extends V> m)",
                  "description": "Constructs a new WeakHashMap with the same mappings as the\n specified map.  The WeakHashMap is created with the default\n load factor (0.75) and an initial capacity sufficient to hold the\n mappings in the specified map."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the number of key-value mappings in this map.\n This result is a snapshot, and may not reflect unprocessed\n entries that will be removed before next attempted access\n because they are no longer referenced."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public boolean isEmpty()",
                  "description": "Returns true if this map contains no key-value mappings.\n This result is a snapshot, and may not reflect unprocessed\n entries that will be removed before next attempted access\n because they are no longer referenced."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public V get(Object key)",
                  "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that\n Objects.equals(key, k),\n then this method returns v; otherwise\n it returns null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."
                }
              ]
            },
            {
              "name": "containsKey",
              "overloads": [
                {
                  "signature": "public boolean containsKey(Object key)",
                  "description": "Returns true if this map contains a mapping for the\n specified key."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public V put(K key, V value)",
                  "description": "Associates the specified value with the specified key in this map.\n If the map previously contained a mapping for this key, the old\n value is replaced."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<? extends K,? extends V> m)",
                  "description": "Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for any\n of the keys currently in the specified map."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public V remove(Object key)",
                  "description": "Removes the mapping for a key from this weak hash map if it is present.\n More formally, if this map contains a mapping from key k to\n value v such that (key==null ?  k==null :\n key.equals(k)), that mapping is removed.  (The map can contain\n at most one such mapping.)\n\n Returns the value to which this map previously associated the key,\n or null if the map contained no mapping for the key.  A\n return value of null does not necessarily indicate\n that the map contained no mapping for the key; it's also possible\n that the map explicitly mapped the key to null.\n\n The map will not contain a mapping for the specified key once the\n call returns."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."
                }
              ]
            },
            {
              "name": "containsValue",
              "overloads": [
                {
                  "signature": "public boolean containsValue(Object value)",
                  "description": "Returns true if this map maps one or more keys to the\n specified value."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<K> keySet()",
                  "description": "Returns a Set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation), the results of\n the iteration are undefined.  The set supports element removal,\n which removes the corresponding mapping from the map, via the\n Iterator.remove, Set.remove,\n removeAll, retainAll, and clear\n operations.  It does not support the add or addAll\n operations."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<V> values()",
                  "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress\n (except through the iterator's own remove operation),\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear operations.  It does not\n support the add or addAll operations."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<K,V>> entrySet()",
                  "description": "Returns a Set view of the mappings contained in this map.\n The set is backed by the map, so changes to the map are\n reflected in the set, and vice-versa.  If the map is modified\n while an iteration over the set is in progress (except through\n the iterator's own remove operation, or through the\n setValue operation on a map entry returned by the\n iterator) the results of the iteration are undefined.  The set\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll and\n clear operations.  It does not support the\n add or addAll operations."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.io",
      "description": "Input/output classes",
      "classes": [
        {
          "name": "BufferedInputStream",
          "methods": [
            {
              "name": "BufferedInputStream",
              "overloads": [
                {
                  "signature": "public BufferedInputStream(InputStream in)",
                  "description": "Creates a BufferedInputStream\n and saves its  argument, the input stream\n in, for later use. An internal\n buffer array is created and  stored in buf."
                },
                {
                  "signature": "public BufferedInputStream(InputStream in, int size)",
                  "description": "Creates a BufferedInputStream\n with the specified buffer size,\n and saves its  argument, the input stream\n in, for later use.  An internal\n buffer array of length  size\n is created and stored in buf."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "See\n the general contract of the read\n method of InputStream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads bytes from this byte-input stream into the specified byte array,\n starting at the given offset.\n\n  This method implements the general contract of the corresponding\n read method of\n the InputStream class.  As an additional\n convenience, it attempts to read as many bytes as possible by repeatedly\n invoking the read method of the underlying stream.  This\n iterated read continues until one of the following\n conditions becomes true: \n\n    The specified number of bytes have been read,\n\n    The read method of the underlying stream returns\n   -1, indicating end-of-file, or\n\n    The available method of the underlying stream\n   returns zero, indicating that further input requests would block.\n\n  If the first read on the underlying stream returns\n -1 to indicate end-of-file then this method returns\n -1.  Otherwise this method returns the number of bytes\n actually read.\n\n  Subclasses of this class are encouraged, but not required, to\n attempt to read as many bytes as possible in the same fashion."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "See the general contract of the skip\n method of InputStream."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method returns the sum of the number of bytes remaining to be read in\n the buffer (count - pos) and the result of calling the\n in.available()."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "See the general contract of the mark\n method of InputStream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "See the general contract of the reset\n method of InputStream.\n \n If markpos is -1\n (no mark has been set or the mark has been\n invalidated), an IOException\n is thrown. Otherwise, pos is\n set equal to markpos."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark\n and reset methods. The markSupported\n method of BufferedInputStream returns\n true."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n Once the stream has been closed, further read(), available(), reset(),\n or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedOutputStream",
          "methods": [
            {
              "name": "BufferedOutputStream",
              "overloads": [
                {
                  "signature": "public BufferedOutputStream(OutputStream out)",
                  "description": "Creates a new buffered output stream to write data to the\n specified underlying output stream."
                },
                {
                  "signature": "public BufferedOutputStream(OutputStream out, int size)",
                  "description": "Creates a new buffered output stream to write data to the\n specified underlying output stream with the specified buffer\n size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this buffered output stream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this buffered output stream.\n\n  Ordinarily this method stores bytes from the given array into this\n stream's buffer, flushing the buffer to the underlying output stream as\n needed.  If the requested length is at least as large as this stream's\n buffer, however, then this method will flush the buffer and write the\n bytes directly to the underlying output stream.  Thus redundant\n BufferedOutputStreams will not copy data unnecessarily."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this buffered output stream. This forces any buffered\n output bytes to be written out to the underlying output stream."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedReader",
          "methods": [
            {
              "name": "BufferedReader",
              "overloads": [
                {
                  "signature": "public BufferedReader(Reader in, int sz)",
                  "description": "Creates a buffering character-input stream that uses an input buffer of\n the specified size."
                },
                {
                  "signature": "public BufferedReader(Reader in)",
                  "description": "Creates a buffering character-input stream that uses a default-sized\n input buffer."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  This method implements the general contract of the corresponding\n read method of the\n Reader class.  As an additional convenience, it\n attempts to read as many characters as possible by repeatedly invoking\n the read method of the underlying stream.  This iterated\n read continues until one of the following conditions becomes\n true:\n \n\n    The specified number of characters have been read,\n\n    The read method of the underlying stream returns\n   -1, indicating end-of-file, or\n\n    The ready method of the underlying stream\n   returns false, indicating that further input requests\n   would block.\n\n \n If the first read on the underlying stream returns\n -1 to indicate end-of-file then this method returns\n -1.  Otherwise this method returns the number of characters\n actually read.\n\n  Subclasses of this class are encouraged, but not required, to\n attempt to read as many characters as possible in the same fashion.\n\n  Ordinarily this method takes characters from this stream's character\n buffer, filling it from the underlying stream as necessary.  If,\n however, the buffer is empty, the mark is not valid, and the requested\n length is at least as large as the buffer, then this method will read\n characters directly from the underlying stream into the given array.\n Thus redundant BufferedReaders will not copy data\n unnecessarily."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine() throws IOException",
                  "description": "Reads a line of text.  A line is considered to be terminated by any one\n of a line feed ('\\n'), a carriage return ('\\r'), a carriage return\n followed immediately by a line feed, or by reaching the end-of-file\n (EOF)."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  A buffered character\n stream is ready if the buffer is not empty, or if the underlying\n character stream is ready."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            },
            {
              "name": "lines",
              "overloads": [
                {
                  "signature": "public Stream<String> lines()",
                  "description": "Returns a Stream, the elements of which are lines read from\n this BufferedReader.  The Stream is lazily populated,\n i.e., read only occurs during the\n terminal\n stream operation.\n\n  The reader must not be operated on during the execution of the\n terminal stream operation. Otherwise, the result of the terminal stream\n operation is undefined.\n\n  After execution of the terminal stream operation there are no\n guarantees that the reader will be at a specific position from which to\n read the next character or line.\n\n  If an IOException is thrown when accessing the underlying\n BufferedReader, it is wrapped in an UncheckedIOException which will be thrown from the Stream\n method that caused the read to take place. This method will return a\n Stream if invoked on a BufferedReader that is closed. Any operation on\n that stream that requires reading from the BufferedReader after it is\n closed, will cause an UncheckedIOException to be thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferedWriter",
          "methods": [
            {
              "name": "BufferedWriter",
              "overloads": [
                {
                  "signature": "public BufferedWriter(Writer out)",
                  "description": "Creates a buffered character-output stream that uses a default-sized\n output buffer."
                },
                {
                  "signature": "public BufferedWriter(Writer out, int sz)",
                  "description": "Creates a new buffered character-output stream that uses an output\n buffer of the given size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters.\n\n  Ordinarily this method stores characters from the given array into\n this stream's buffer, flushing the buffer to the underlying stream as\n needed.  If the requested length is at least as large as the buffer,\n however, then this method will flush the buffer and write the characters\n directly to the underlying stream.  Thus redundant\n BufferedWriters will not copy data unnecessarily."
                },
                {
                  "signature": "public void write(String s, int off, int len) throws IOException",
                  "description": "Writes a portion of a String."
                }
              ]
            },
            {
              "name": "newLine",
              "overloads": [
                {
                  "signature": "public void newLine() throws IOException",
                  "description": "Writes a line separator.  The line separator string is defined by the\n system property line.separator, and is not necessarily a single\n newline ('\\n') character."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "ByteArrayInputStream",
          "methods": [
            {
              "name": "ByteArrayInputStream",
              "overloads": [
                {
                  "signature": "public ByteArrayInputStream(byte[] buf)",
                  "description": "Creates a ByteArrayInputStream\n so that it  uses buf as its\n buffer array.\n The buffer array is not copied.\n The initial value of pos\n is 0 and the initial value\n of  count is the length of\n buf."
                },
                {
                  "signature": "public ByteArrayInputStream(byte[] buf, int offset, int length)",
                  "description": "Creates ByteArrayInputStream\n that uses buf as its\n buffer array. The initial value of pos\n is offset and the initial value\n of count is the minimum of offset+length\n and buf.length.\n The buffer array is not copied. The buffer's mark is\n set to the specified offset."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read()",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned.\n \n This read method\n cannot block."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len)",
                  "description": "Reads up to len bytes of data into an array of bytes from this\n input stream.  If pos equals count, then -1 is\n returned to indicate end of file.  Otherwise, the  number k of\n bytes read is equal to the smaller of len and count-pos.\n If k is positive, then bytes buf[pos] through\n buf[pos+k-1] are copied into b[off] through\n b[off+k-1] in the manner performed by System.arraycopy.\n The value k is added into pos and k is returned.\n \n Unlike the overridden method\n of InputStream, this method returns -1 instead of zero\n if the end of the stream has been reached and len == 0.\n \n This read method cannot block."
                }
              ]
            },
            {
              "name": "readAllBytes",
              "overloads": [
                {
                  "signature": "public byte[] readAllBytes()",
                  "description": "Description copied from class:InputStream"
                }
              ]
            },
            {
              "name": "readNBytes",
              "overloads": [
                {
                  "signature": "public int readNBytes(byte[] b, int off, int len)",
                  "description": "Description copied from class:InputStream"
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n)",
                  "description": "Skips n bytes of input from this input stream. Fewer\n bytes might be skipped if the end of the input stream is reached.\n The actual number k\n of bytes to be skipped is equal to the smaller\n of n and  count-pos.\n The value k is added into pos\n and k is returned."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available()",
                  "description": "Returns the number of remaining bytes that can be read (or skipped over)\n from this input stream.\n \n The value returned is count - pos,\n which is the number of bytes remaining to be read from the input buffer."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this InputStream supports mark/reset. The\n markSupported method of ByteArrayInputStream\n always returns true."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit)",
                  "description": "Set the current marked position in the stream.\n ByteArrayInputStream objects are marked at position zero by\n default when constructed.  They may be marked at another\n position within the buffer by this method.\n \n If no mark has been set, then the value of the mark is the\n offset passed to the constructor (or 0 if the offset was not\n supplied).\n\n  Note: The readAheadLimit for this class\n  has no meaning."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the buffer to the marked position.  The marked position\n is 0 unless another position was marked or an offset was specified\n in the constructor."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a ByteArrayInputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteArrayOutputStream",
          "methods": [
            {
              "name": "ByteArrayOutputStream",
              "overloads": [
                {
                  "signature": "public ByteArrayOutputStream()",
                  "description": "Creates a new ByteArrayOutputStream. The buffer capacity is\n initially 32 bytes, though its size increases if necessary."
                },
                {
                  "signature": "public ByteArrayOutputStream(int size)",
                  "description": "Creates a new ByteArrayOutputStream, with a buffer capacity of\n the specified size, in bytes."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b)",
                  "description": "Writes the specified byte to this ByteArrayOutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len)",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this ByteArrayOutputStream."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(byte[] b)",
                  "description": "Writes the complete contents of the specified byte array\n to this ByteArrayOutputStream."
                }
              ]
            },
            {
              "name": "writeTo",
              "overloads": [
                {
                  "signature": "public void writeTo(OutputStream out) throws IOException",
                  "description": "Writes the complete contents of this ByteArrayOutputStream to\n the specified output stream argument, as if by calling the output\n stream's write method using out.write(buf, 0, count)."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the count field of this ByteArrayOutputStream\n to zero, so that all currently accumulated output in the\n output stream is discarded. The output stream can be used again,\n reusing the already allocated buffer space."
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public byte[] toByteArray()",
                  "description": "Creates a newly allocated byte array. Its size is the current\n size of this output stream and the valid contents of the buffer\n have been copied into it."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the current size of the buffer."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts the buffer's contents into a string decoding bytes using the\n platform's default character set. The length of the new String\n is a function of the character set, and hence may not be equal to the\n size of the buffer.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with the default replacement string for the platform's\n default character set. The CharsetDecoder\n class should be used when more control over the decoding process is\n required."
                },
                {
                  "signature": "public String toString(String charsetName) throws UnsupportedEncodingException",
                  "description": "Converts the buffer's contents into a string by decoding the bytes using\n the named charset.\n\n  This method is equivalent to #toString(charset) that takes a\n charset.\n\n  An invocation of this method of the form\n\n  \n      ByteArrayOutputStream b = ...\n      b.toString(\"UTF-8\")\n      \n \n\n behaves in exactly the same way as the expression\n\n  \n      ByteArrayOutputStream b = ...\n      b.toString(StandardCharsets.UTF_8)"
                },
                {
                  "signature": "public String toString(Charset charset)",
                  "description": "Converts the buffer's contents into a string by decoding the bytes using\n the specified charset. The length of the new\n String is a function of the charset, and hence may not be equal\n to the length of the byte array.\n\n  This method always replaces malformed-input and unmappable-character\n sequences with the charset's default replacement string. The CharsetDecoder class should be used when more control\n over the decoding process is required."
                },
                {
                  "signature": "@Deprecated public String toString(int hibyte)",
                  "description": "Creates a newly allocated string. Its size is the current size of\n the output stream and the valid contents of the buffer have been\n copied into it. Each character c in the resulting string is\n constructed from the corresponding element b in the byte\n array such that:\n \n     c == (char)(((hibyte & 0xff) << 8) | (b & 0xff))",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a ByteArrayOutputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "CharArrayReader",
          "methods": [
            {
              "name": "CharArrayReader",
              "overloads": [
                {
                  "signature": "public CharArrayReader(char[] buf)",
                  "description": "Creates a CharArrayReader from the specified array of chars."
                },
                {
                  "signature": "public CharArrayReader(char[] buf, int offset, int length)",
                  "description": "Creates a CharArrayReader from the specified array of chars.\n\n  The resulting reader will start reading at the given\n offset.  The total number of char values that can be\n read from this reader will be either length or\n buf.length-offset, whichever is smaller."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters. If the stream is already at its end before this method\n is invoked, then no characters are skipped and zero is returned.\n\n The n parameter may be negative, even though the\n skip method of the Reader superclass throws\n an exception in this case. If n is negative, then\n this method does nothing and returns 0."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  Character-array readers\n are always ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark, or to the beginning if it has\n never been marked."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated with\n it.  Once the stream has been closed, further read(), ready(),\n mark(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "CharArrayWriter",
          "methods": [
            {
              "name": "CharArrayWriter",
              "overloads": [
                {
                  "signature": "public CharArrayWriter()",
                  "description": "Creates a new CharArrayWriter."
                },
                {
                  "signature": "public CharArrayWriter(int initialSize)",
                  "description": "Creates a new CharArrayWriter with the specified initial size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Writes a character to the buffer."
                },
                {
                  "signature": "public void write(char[] c, int off, int len)",
                  "description": "Writes characters to the buffer."
                },
                {
                  "signature": "public void write(String str, int off, int len)",
                  "description": "Write a portion of a string to the buffer."
                }
              ]
            },
            {
              "name": "writeTo",
              "overloads": [
                {
                  "signature": "public void writeTo(Writer out) throws IOException",
                  "description": "Writes the contents of the buffer to another character stream."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public CharArrayWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public CharArrayWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when\n csq is not null, behaves in\n exactly the same way as the invocation\n\n      out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public CharArrayWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the buffer so that you can use it again without\n throwing away the already allocated buffer."
                }
              ]
            },
            {
              "name": "toCharArray",
              "overloads": [
                {
                  "signature": "public char[] toCharArray()",
                  "description": "Returns a copy of the input data."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public int size()",
                  "description": "Returns the current size of the buffer."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts input data to a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flush the stream.\n\n  The flush method of CharArrayWriter does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Close the stream.  This method does not release the buffer, since its\n contents might still be required. Note: Invoking this method in this class\n will have no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "CharConversionException",
          "methods": [
            {
              "name": "CharConversionException",
              "overloads": [
                {
                  "signature": "public CharConversionException()",
                  "description": "This provides no detailed message."
                },
                {
                  "signature": "public CharConversionException(String s)",
                  "description": "This provides a detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter.Status[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter.Status valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Closeable",
          "methods": [
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes this stream and releases any system resources associated\n with it. If the stream is already closed then invoking this\n method has no effect.\n\n  As noted in AutoCloseable.close(), cases where the\n close may fail require careful attention. It is strongly advised\n to relinquish the underlying resources and to internally\n mark the Closeable as closed, prior to throwing\n the IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "Console",
          "methods": [
            {
              "name": "writer",
              "overloads": [
                {
                  "signature": "public PrintWriter writer()",
                  "description": "Retrieves the unique PrintWriter object\n associated with this console."
                }
              ]
            },
            {
              "name": "reader",
              "overloads": [
                {
                  "signature": "public Reader reader()",
                  "description": "Retrieves the unique Reader object associated\n with this console.\n \n This method is intended to be used by sophisticated applications, for\n example, a Scanner object which utilizes the rich\n parsing/scanning functionality provided by the Scanner:\n  Console con = System.console();\n if (con != null) {\n     Scanner sc = new Scanner(con.reader());\n     ...\n }\n \n \n For simple applications requiring only line-oriented reading, use\n readLine(java.lang.String, java.lang.Object...).\n \n The bulk read operations read(char[]) ,\n read(char[], int, int)  and\n read(java.nio.CharBuffer)\n on the returned object will not read in characters beyond the line\n bound for each invocation, even if the destination buffer has space for\n more characters. The Reader's read methods may block if a\n line bound has not been entered or reached on the console's input device.\n A line bound is considered to be any one of a line feed ('\\n'),\n a carriage return ('\\r'), a carriage return followed immediately\n by a linefeed, or an end of stream."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public Console format(String fmt, Object... args)",
                  "description": "Writes a formatted string to this console's output stream using\n the specified format string and arguments."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public Console printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this console's\n output stream using the specified format string and arguments.\n\n  An invocation of this method of the form\n con.printf(format, args) behaves in exactly the same way\n as the invocation of\n con.format(format, args)."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine(String fmt, Object... args)",
                  "description": "Provides a formatted prompt, then reads a single line of text from the\n console."
                },
                {
                  "signature": "public String readLine()",
                  "description": "Reads a single line of text from the console."
                }
              ]
            },
            {
              "name": "readPassword",
              "overloads": [
                {
                  "signature": "public char[] readPassword(String fmt, Object... args)",
                  "description": "Provides a formatted prompt, then reads a password or passphrase from\n the console with echoing disabled."
                },
                {
                  "signature": "public char[] readPassword()",
                  "description": "Reads a password or passphrase from the console with echoing disabled"
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the console and forces any buffered output to be written\n immediately ."
                }
              ]
            },
            {
              "name": "charset",
              "overloads": [
                {
                  "signature": "public Charset charset()",
                  "description": "Returns the Charset object used for\n the Console.\n \n The returned charset corresponds to the input and output source\n (e.g., keyboard and/or display) specified by the host environment or user.\n It may not necessarily be the same as the default charset returned from\n Charset.defaultCharset()."
                }
              ]
            }
          ]
        },
        {
          "name": "DataInput",
          "methods": [
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "void readFully(byte[] b) throws IOException",
                  "description": "Reads some bytes from an input\n stream and stores them into the buffer\n array b. The number of bytes\n read is equal\n to the length of b.\n \n This method blocks until one of the\n following conditions occurs:\n \n b.length\n bytes of input data are available, in which\n case a normal return is made.\n\n End of\n file is detected, in which case an EOFException\n is thrown.\n\n An I/O error occurs, in\n which case an IOException other\n than EOFException is thrown.\n \n \n If b is null,\n a NullPointerException is thrown.\n If b.length is zero, then\n no bytes are read. Otherwise, the first\n byte read is stored into element b[0],\n the next one into b[1], and\n so on.\n If an exception is thrown from\n this method, then it may be that some but\n not all bytes of b have been\n updated with data from the input stream."
                },
                {
                  "signature": "void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "Reads len\n bytes from\n an input stream.\n \n This method\n blocks until one of the following conditions\n occurs:\n \n len bytes\n of input data are available, in which case\n a normal return is made.\n\n End of file\n is detected, in which case an EOFException\n is thrown.\n\n An I/O error occurs, in\n which case an IOException other\n than EOFException is thrown.\n \n \n If b is null,\n a NullPointerException is thrown.\n If off is negative, or len\n is negative, or off+len is\n greater than the length of the array b,\n then an IndexOutOfBoundsException\n is thrown.\n If len is zero,\n then no bytes are read. Otherwise, the first\n byte read is stored into element b[off],\n the next one into b[off+1],\n and so on. The number of bytes read is,\n at most, equal to len."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "int skipBytes(int n) throws IOException",
                  "description": "Makes an attempt to skip over\n n bytes\n of data from the input\n stream, discarding the skipped bytes. However,\n it may skip\n over some smaller number of\n bytes, possibly zero. This may result from\n any of a\n number of conditions; reaching\n end of file before n bytes\n have been skipped is\n only one possibility.\n This method never throws an EOFException.\n The actual\n number of bytes skipped is returned."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "boolean readBoolean() throws IOException",
                  "description": "Reads one input byte and returns\n true if that byte is nonzero,\n false if that byte is zero.\n This method is suitable for reading\n the byte written by the writeBoolean\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "byte readByte() throws IOException",
                  "description": "Reads and returns one input byte.\n The byte is treated as a signed value in\n the range -128 through 127,\n inclusive.\n This method is suitable for\n reading the byte written by the writeByte\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "int readUnsignedByte() throws IOException",
                  "description": "Reads one input byte, zero-extends\n it to type int, and returns\n the result, which is therefore in the range\n 0\n through 255.\n This method is suitable for reading\n the byte written by the writeByte\n method of interface DataOutput\n if the argument to writeByte\n was intended to be a value in the range\n 0 through 255."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "short readShort() throws IOException",
                  "description": "Reads two input bytes and returns\n a short value. Let a\n be the first byte read and b\n be the second byte. The value\n returned\n is:\n (short)((a << 8) | (b & 0xff))\n \n This method\n is suitable for reading the bytes written\n by the writeShort method of\n interface DataOutput."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "int readUnsignedShort() throws IOException",
                  "description": "Reads two input bytes and returns\n an int value in the range 0\n through 65535. Let a\n be the first byte read and\n b\n be the second byte. The value returned is:\n (((a & 0xff) << 8) | (b & 0xff))\n \n This method is suitable for reading the bytes\n written by the writeShort method\n of interface DataOutput  if\n the argument to writeShort\n was intended to be a value in the range\n 0 through 65535."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "char readChar() throws IOException",
                  "description": "Reads two input bytes and returns a char value.\n Let a\n be the first byte read and b\n be the second byte. The value\n returned is:\n (char)((a << 8) | (b & 0xff))\n \n This method\n is suitable for reading bytes written by\n the writeChar method of interface\n DataOutput."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "int readInt() throws IOException",
                  "description": "Reads four input bytes and returns an\n int value. Let a-d\n be the first through fourth bytes read. The value returned is:\n \n (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n  ((c & 0xff) <<  8) | (d & 0xff))\n \n This method is suitable\n for reading bytes written by the writeInt\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "long readLong() throws IOException",
                  "description": "Reads eight input bytes and returns\n a long value. Let a-h\n be the first through eighth bytes read.\n The value returned is:\n \n (((long)(a & 0xff) << 56) |\n  ((long)(b & 0xff) << 48) |\n  ((long)(c & 0xff) << 40) |\n  ((long)(d & 0xff) << 32) |\n  ((long)(e & 0xff) << 24) |\n  ((long)(f & 0xff) << 16) |\n  ((long)(g & 0xff) <<  8) |\n  ((long)(h & 0xff)))\n \n \n This method is suitable\n for reading bytes written by the writeLong\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "float readFloat() throws IOException",
                  "description": "Reads four input bytes and returns\n a float value. It does this\n by first constructing an int\n value in exactly the manner\n of the readInt\n method, then converting this int\n value to a float in\n exactly the manner of the method Float.intBitsToFloat.\n This method is suitable for reading\n bytes written by the writeFloat\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "double readDouble() throws IOException",
                  "description": "Reads eight input bytes and returns\n a double value. It does this\n by first constructing a long\n value in exactly the manner\n of the readLong\n method, then converting this long\n value to a double in exactly\n the manner of the method Double.longBitsToDouble.\n This method is suitable for reading\n bytes written by the writeDouble\n method of interface DataOutput."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "String readLine() throws IOException",
                  "description": "Reads the next line of text from the input stream.\n It reads successive bytes, converting\n each byte separately into a character,\n until it encounters a line terminator or\n end of\n file; the characters read are then\n returned as a String. Note\n that because this\n method processes bytes,\n it does not support input of the full Unicode\n character set.\n \n If end of file is encountered\n before even one byte can be read, then null\n is returned. Otherwise, each byte that is\n read is converted to type char\n by zero-extension. If the character '\\n'\n is encountered, it is discarded and reading\n ceases. If the character '\\r'\n is encountered, it is discarded and, if\n the following byte converts  to the\n character '\\n', then that is\n discarded also; reading then ceases. If\n end of file is encountered before either\n of the characters '\\n' and\n '\\r' is encountered, reading\n ceases. Once reading has ceased, a String\n is returned that contains all the characters\n read and not discarded, taken in order.\n Note that every character in this string\n will have a value less than \\u0100,\n that is, (char)256."
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "String readUTF() throws IOException",
                  "description": "Reads in a string that has been encoded using a\n modified UTF-8\n format.\n The general contract of readUTF\n is that it reads a representation of a Unicode\n character string encoded in modified\n UTF-8 format; this string of characters\n is then returned as a String.\n \n First, two bytes are read and used to\n construct an unsigned 16-bit integer in\n exactly the manner of the readUnsignedShort\n method . This integer value is called the\n UTF length and specifies the number\n of additional bytes to be read. These bytes\n are then converted to characters by considering\n them in groups. The length of each group\n is computed from the value of the first\n byte of the group. The byte following a\n group, if any, is the first byte of the\n next group.\n \n If the first byte of a group\n matches the bit pattern 0xxxxxxx\n (where x means \"may be 0\n or 1\"), then the group consists\n of just that byte. The byte is zero-extended\n to form a character.\n \n If the first byte\n of a group matches the bit pattern 110xxxxx,\n then the group consists of that byte a\n and a second byte b. If there\n is no byte b (because byte\n a was the last of the bytes\n to be read), or if byte b does\n not match the bit pattern 10xxxxxx,\n then a UTFDataFormatException\n is thrown. Otherwise, the group is converted\n to the character:\n (char)(((a & 0x1F) << 6) | (b & 0x3F))\n \n If the first byte of a group\n matches the bit pattern 1110xxxx,\n then the group consists of that byte a\n and two more bytes b and c.\n If there is no byte c (because\n byte a was one of the last\n two of the bytes to be read), or either\n byte b or byte c\n does not match the bit pattern 10xxxxxx,\n then a UTFDataFormatException\n is thrown. Otherwise, the group is converted\n to the character:\n \n (char)(((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F))\n \n If the first byte of a group matches the\n pattern 1111xxxx or the pattern\n 10xxxxxx, then a UTFDataFormatException\n is thrown.\n \n If end of file is encountered\n at any time during this entire process,\n then an EOFException is thrown.\n \n After every group has been converted to\n a character by this process, the characters\n are gathered, in the same order in which\n their corresponding groups were read from\n the input stream, to form a String,\n which is returned.\n \n The writeUTF\n method of interface DataOutput\n may be used to write data that is suitable\n for reading by this method."
                }
              ]
            }
          ]
        },
        {
          "name": "DataInputStream",
          "methods": [
            {
              "name": "DataInputStream",
              "overloads": [
                {
                  "signature": "public DataInputStream(InputStream in)",
                  "description": "Creates a DataInputStream that uses the specified\n underlying InputStream."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public final int read(byte[] b) throws IOException",
                  "description": "Reads some number of bytes from the contained input stream and\n stores them into the buffer array b. The number of\n bytes actually read is returned as an integer. This method blocks\n until input data is available, end of file is detected, or an\n exception is thrown.\n\n If b is null, a NullPointerException is\n thrown. If the length of b is zero, then no bytes are\n read and 0 is returned; otherwise, there is an attempt\n to read at least one byte. If no byte is available because the\n stream is at end of file, the value -1 is returned;\n otherwise, at least one byte is read and stored into b.\n\n The first byte read is stored into element b[0], the\n next one into b[1], and so on. The number of bytes read\n is, at most, equal to the length of b. Let k\n be the number of bytes actually read; these bytes will be stored in\n elements b[0] through b[k-1], leaving\n elements b[k] through b[b.length-1]\n unaffected.\n\n The read(b) method has the same effect as:\n  read(b, 0, b.length)"
                },
                {
                  "signature": "public final int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from the contained\n input stream into an array of bytes.  An attempt is made to read\n as many as len bytes, but a smaller number may be read,\n possibly zero. The number of bytes actually read is returned as an\n integer.\n\n  This method blocks until input data is available, end of file is\n detected, or an exception is thrown.\n\n  If len is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at end of\n file, the value -1 is returned; otherwise, at least one\n byte is read and stored into b.\n\n  The first byte read is stored into element b[off], the\n next one into b[off+1], and so on. The number of bytes read\n is, at most, equal to len. Let k be the number of\n bytes actually read; these bytes will be stored in elements\n b[off] through b[off+k-1],\n leaving elements b[off+k] through\n b[off+len-1] unaffected.\n\n  In every case, elements b[0] through\n b[off] and elements b[off+len] through\n b[b.length-1] are unaffected."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public final void readFully(byte[] b) throws IOException",
                  "description": "See the general contract of the readFully\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                },
                {
                  "signature": "public final void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "See the general contract of the readFully\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public final int skipBytes(int n) throws IOException",
                  "description": "See the general contract of the skipBytes\n method of DataInput.\n \n Bytes for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public final boolean readBoolean() throws IOException",
                  "description": "See the general contract of the readBoolean\n method of DataInput.\n \n Bytes for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public final byte readByte() throws IOException",
                  "description": "See the general contract of the readByte\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public final int readUnsignedByte() throws IOException",
                  "description": "See the general contract of the readUnsignedByte\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public final short readShort() throws IOException",
                  "description": "See the general contract of the readShort\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public final int readUnsignedShort() throws IOException",
                  "description": "See the general contract of the readUnsignedShort\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public final char readChar() throws IOException",
                  "description": "See the general contract of the readChar\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public final int readInt() throws IOException",
                  "description": "See the general contract of the readInt\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public final long readLong() throws IOException",
                  "description": "See the general contract of the readLong\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public final float readFloat() throws IOException",
                  "description": "See the general contract of the readFloat\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public final double readDouble() throws IOException",
                  "description": "See the general contract of the readDouble\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "@Deprecated public final String readLine() throws IOException",
                  "description": "See the general contract of the readLine\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public final String readUTF() throws IOException",
                  "description": "See the general contract of the readUTF\n method of DataInput.\n \n Bytes\n for this operation are read from the contained\n input stream."
                },
                {
                  "signature": "public static final String readUTF(DataInput in) throws IOException",
                  "description": "Reads from the\n stream in a representation\n of a Unicode  character string encoded in\n modified UTF-8 format;\n this string of characters is then returned as a String.\n The details of the modified UTF-8 representation\n are  exactly the same as for the readUTF\n method of DataInput."
                }
              ]
            }
          ]
        },
        {
          "name": "DataOutput",
          "methods": [
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "void write(int b) throws IOException",
                  "description": "Writes to the output stream the eight\n low-order bits of the argument b.\n The 24 high-order  bits of b\n are ignored."
                },
                {
                  "signature": "void write(byte[] b) throws IOException",
                  "description": "Writes to the output stream all the bytes in array b.\n If b is null,\n a NullPointerException is thrown.\n If b.length is zero, then\n no bytes are written. Otherwise, the byte\n b[0] is written first, then\n b[1], and so on; the last byte\n written is b[b.length-1]."
                },
                {
                  "signature": "void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from array\n b, in order,  to\n the output stream.  If b\n is null, a NullPointerException\n is thrown.  If off is negative,\n or len is negative, or off+len\n is greater than the length of the array\n b, then an IndexOutOfBoundsException\n is thrown.  If len is zero,\n then no bytes are written. Otherwise, the\n byte b[off] is written first,\n then b[off+1], and so on; the\n last byte written is b[off+len-1]."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean value to this output stream.\n If the argument v\n is true, the value (byte)1\n is written; if v is false,\n the  value (byte)0 is written.\n The byte written by this method may\n be read by the readBoolean\n method of interface DataInput,\n which will then return a boolean\n equal to v."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "void writeByte(int v) throws IOException",
                  "description": "Writes to the output stream the eight low-order\n bits of the argument v.\n The 24 high-order bits of v\n are ignored. (This means  that writeByte\n does exactly the same thing as write\n for an integer argument.) The byte written\n by this method may be read by the readByte\n method of interface DataInput,\n which will then return a byte\n equal to (byte)v."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "void writeShort(int v) throws IOException",
                  "description": "Writes two bytes to the output\n stream to represent the value of the argument.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n  \n The bytes written by this method may be\n read by the readShort method\n of interface DataInput, which\n will then return a short equal\n to (short)v."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "void writeChar(int v) throws IOException",
                  "description": "Writes a char value, which\n is comprised of two bytes, to the\n output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 8))\n (byte)(0xff & v)\n \n The bytes written by this method may be\n read by the readChar method\n of interface DataInput, which\n will then return a char equal\n to (char)v."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "void writeInt(int v) throws IOException",
                  "description": "Writes an int value, which is\n comprised of four bytes, to the output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n \n The bytes written by this method may be read\n by the readInt method of interface\n DataInput, which will then\n return an int equal to v."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "void writeLong(long v) throws IOException",
                  "description": "Writes a long value, which is\n comprised of eight bytes, to the output stream.\n The byte values to be written, in the  order\n shown, are:\n \n (byte)(0xff & (v >> 56))\n (byte)(0xff & (v >> 48))\n (byte)(0xff & (v >> 40))\n (byte)(0xff & (v >> 32))\n (byte)(0xff & (v >> 24))\n (byte)(0xff & (v >> 16))\n (byte)(0xff & (v >>  8))\n (byte)(0xff & v)\n \n The bytes written by this method may be\n read by the readLong method\n of interface DataInput, which\n will then return a long equal\n to v."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "void writeFloat(float v) throws IOException",
                  "description": "Writes a float value,\n which is comprised of four bytes, to the output stream.\n It does this as if it first converts this\n float value to an int\n in exactly the manner of the Float.floatToIntBits\n method  and then writes the int\n value in exactly the manner of the  writeInt\n method.  The bytes written by this method\n may be read by the readFloat\n method of interface DataInput,\n which will then return a float\n equal to v."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "void writeDouble(double v) throws IOException",
                  "description": "Writes a double value,\n which is comprised of eight bytes, to the output stream.\n It does this as if it first converts this\n double value to a long\n in exactly the manner of the Double.doubleToLongBits\n method  and then writes the long\n value in exactly the manner of the  writeLong\n method. The bytes written by this method\n may be read by the readDouble\n method of interface DataInput,\n which will then return a double\n equal to v."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "void writeBytes(String s) throws IOException",
                  "description": "Writes a string to the output stream.\n For every character in the string\n s,  taken in order, one byte\n is written to the output stream.  If\n s is null, a NullPointerException\n is thrown.  If s.length\n is zero, then no bytes are written. Otherwise,\n the character s[0] is written\n first, then s[1], and so on;\n the last character written is s[s.length-1].\n For each character, one byte is written,\n the low-order byte, in exactly the manner\n of the writeByte method . The\n high-order eight bits of each character\n in the string are ignored."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "void writeChars(String s) throws IOException",
                  "description": "Writes every character in the string s,\n to the output stream, in order,\n two bytes per character. If s\n is null, a NullPointerException\n is thrown.  If s.length\n is zero, then no characters are written.\n Otherwise, the character s[0]\n is written first, then s[1],\n and so on; the last character written is\n s[s.length-1]. For each character,\n two bytes are actually written, high-order\n byte first, in exactly the manner of the\n writeChar method."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "void writeUTF(String s) throws IOException",
                  "description": "Writes two bytes of length information\n to the output stream, followed\n by the\n modified UTF-8\n representation\n of  every character in the string s.\n If s is null,\n a NullPointerException is thrown.\n Each character in the string s\n is converted to a group of one, two, or\n three bytes, depending on the value of the\n character.\n If a character c\n is in the range \\u0001 through\n \\u007f, it is represented\n by one byte:\n (byte)c   \n If a character c is \\u0000\n or is in the range \\u0080\n through \\u07ff, then it is\n represented by two bytes, to be written\n in the order shown: \n (byte)(0xc0 | (0x1f & (c >> 6)))\n (byte)(0x80 | (0x3f & c))\n   If a character\n c is in the range \\u0800\n through uffff, then it is\n represented by three bytes, to be written\n in the order shown: \n (byte)(0xe0 | (0x0f & (c >> 12)))\n (byte)(0x80 | (0x3f & (c >>  6)))\n (byte)(0x80 | (0x3f & c))\n    First,\n the total number of bytes needed to represent\n all the characters of s is\n calculated. If this number is larger than\n 65535, then a UTFDataFormatException\n is thrown. Otherwise, this length is written\n to the output stream in exactly the manner\n of the writeShort method;\n after this, the one-, two-, or three-byte\n representation of each character in the\n string s is written.  The\n bytes written by this method may be read\n by the readUTF method of interface\n DataInput, which will then\n return a String equal to s."
                }
              ]
            }
          ]
        },
        {
          "name": "DataOutputStream",
          "methods": [
            {
              "name": "DataOutputStream",
              "overloads": [
                {
                  "signature": "public DataOutputStream(OutputStream out)",
                  "description": "Creates a new data output stream to write data to the specified\n underlying output stream. The counter written is\n set to zero."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte (the low eight bits of the argument\n b) to the underlying output stream. If no exception\n is thrown, the counter written is incremented by\n 1.\n \n Implements the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to the underlying output stream.\n If no exception is thrown, the counter written is\n incremented by len."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this data output stream. This forces any buffered output\n bytes to be written out to the stream.\n \n The flush method of DataOutputStream\n calls the flush method of its underlying output stream."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public final void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean to the underlying output stream as\n a 1-byte value. The value true is written out as the\n value (byte)1; the value false is\n written out as the value (byte)0. If no exception is\n thrown, the counter written is incremented by\n 1."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public final void writeByte(int v) throws IOException",
                  "description": "Writes out a byte to the underlying output stream as\n a 1-byte value. If no exception is thrown, the counter\n written is incremented by 1."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public final void writeShort(int v) throws IOException",
                  "description": "Writes a short to the underlying output stream as two\n bytes, high byte first. If no exception is thrown, the counter\n written is incremented by 2."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public final void writeChar(int v) throws IOException",
                  "description": "Writes a char to the underlying output stream as a\n 2-byte value, high byte first. If no exception is thrown, the\n counter written is incremented by 2."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public final void writeInt(int v) throws IOException",
                  "description": "Writes an int to the underlying output stream as four\n bytes, high byte first. If no exception is thrown, the counter\n written is incremented by 4."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public final void writeLong(long v) throws IOException",
                  "description": "Writes a long to the underlying output stream as eight\n bytes, high byte first. In no exception is thrown, the counter\n written is incremented by 8."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public final void writeFloat(float v) throws IOException",
                  "description": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the underlying\n output stream as a 4-byte quantity, high byte first. If no\n exception is thrown, the counter written is\n incremented by 4."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public final void writeDouble(double v) throws IOException",
                  "description": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the underlying\n output stream as an 8-byte quantity, high byte first. If no\n exception is thrown, the counter written is\n incremented by 8."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public final void writeBytes(String s) throws IOException",
                  "description": "Writes out the string to the underlying output stream as a\n sequence of bytes. Each character in the string is written out, in\n sequence, by discarding its high eight bits. If no exception is\n thrown, the counter written is incremented by the\n length of s."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public final void writeChars(String s) throws IOException",
                  "description": "Writes a string to the underlying output stream as a sequence of\n characters. Each character is written to the data output stream as\n if by the writeChar method. If no exception is\n thrown, the counter written is incremented by twice\n the length of s."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public final void writeUTF(String str) throws IOException",
                  "description": "Writes a string to the underlying output stream using\n modified UTF-8\n encoding in a machine-independent manner.\n \n First, two bytes are written to the output stream as if by the\n writeShort method giving the number of bytes to\n follow. This value is the number of bytes actually written out,\n not the length of the string. Following the length, each character\n of the string is output, in sequence, using the modified UTF-8 encoding\n for the character. If no exception is thrown, the counter\n written is incremented by the total number of\n bytes written to the output stream. This will be at least two\n plus the length of str, and at most two plus\n thrice the length of str."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public final int size()",
                  "description": "Returns the current value of the counter written,\n the number of bytes written to this data output stream so far.\n If the counter overflows, it will be wrapped to Integer.MAX_VALUE."
                }
              ]
            }
          ]
        },
        {
          "name": "EOFException",
          "methods": [
            {
              "name": "EOFException",
              "overloads": [
                {
                  "signature": "public EOFException()",
                  "description": "Constructs an EOFException with null\n as its error detail message."
                },
                {
                  "signature": "public EOFException(String s)",
                  "description": "Constructs an EOFException with the specified detail\n message. The string s may later be retrieved by the\n Throwable.getMessage() method of class\n java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "Externalizable",
          "methods": [
            {
              "name": "writeExternal",
              "overloads": [
                {
                  "signature": "void writeExternal(ObjectOutput out) throws IOException",
                  "description": "The object implements the writeExternal method to save its contents\n by calling the methods of DataOutput for its primitive values or\n calling the writeObject method of ObjectOutput for objects, strings,\n and arrays."
                }
              ]
            },
            {
              "name": "readExternal",
              "overloads": [
                {
                  "signature": "void readExternal(ObjectInput in) throws IOException, ClassNotFoundException",
                  "description": "The object implements the readExternal method to restore its\n contents by calling the methods of DataInput for primitive\n types and readObject for objects, strings and arrays.  The\n readExternal method must read the values in the same sequence\n and with the same types as were written by writeExternal."
                }
              ]
            }
          ]
        },
        {
          "name": "File",
          "methods": [
            {
              "name": "File",
              "overloads": [
                {
                  "signature": "public File(String pathname)",
                  "description": "Creates a new File instance by converting the given\n pathname string into an abstract pathname.  If the given string is\n the empty string, then the result is the empty abstract pathname."
                },
                {
                  "signature": "public File(String parent, String child)",
                  "description": "Creates a new File instance from a parent pathname string\n and a child pathname string.\n\n  If parent is null then the new\n File instance is created as if by invoking the\n single-argument File constructor on the given\n child pathname string.\n\n  Otherwise the parent pathname string is taken to denote\n a directory, and the child pathname string is taken to\n denote either a directory or a file.  If the child pathname\n string is absolute then it is converted into a relative pathname in a\n system-dependent way.  If parent is the empty string then\n the new File instance is created by converting\n child into an abstract pathname and resolving the result\n against a system-dependent default directory.  Otherwise each pathname\n string is converted into an abstract pathname and the child abstract\n pathname is resolved against the parent."
                },
                {
                  "signature": "public File(File parent, String child)",
                  "description": "Creates a new File instance from a parent abstract\n pathname and a child pathname string.\n\n  If parent is null then the new\n File instance is created as if by invoking the\n single-argument File constructor on the given\n child pathname string.\n\n  Otherwise the parent abstract pathname is taken to\n denote a directory, and the child pathname string is taken\n to denote either a directory or a file.  If the child\n pathname string is absolute then it is converted into a relative\n pathname in a system-dependent way.  If parent is the empty\n abstract pathname then the new File instance is created by\n converting child into an abstract pathname and resolving\n the result against a system-dependent default directory.  Otherwise each\n pathname string is converted into an abstract pathname and the child\n abstract pathname is resolved against the parent."
                },
                {
                  "signature": "public File(URI uri)",
                  "description": "Creates a new File instance by converting the given\n file: URI into an abstract pathname.\n\n  The exact form of a file: URI is system-dependent, hence\n the transformation performed by this constructor is also\n system-dependent.\n\n  For a given abstract pathname f it is guaranteed that\n\n \n new File(f.toURI()).equals(f.getAbsoluteFile())\n \n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  This relationship typically does not hold,\n however, when a file: URI that is created in a virtual machine\n on one operating system is converted into an abstract pathname in a\n virtual machine on a different operating system."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the file or directory denoted by this abstract\n pathname.  This is just the last name in the pathname's name\n sequence.  If the pathname's name sequence is empty, then the empty\n string is returned."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public String getParent()",
                  "description": "Returns the pathname string of this abstract pathname's parent, or\n null if this pathname does not name a parent directory.\n\n  The parent of an abstract pathname consists of the\n pathname's prefix, if any, and each name in the pathname's name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory."
                }
              ]
            },
            {
              "name": "getParentFile",
              "overloads": [
                {
                  "signature": "public File getParentFile()",
                  "description": "Returns the abstract pathname of this abstract pathname's parent,\n or null if this pathname does not name a parent\n directory.\n\n  The parent of an abstract pathname consists of the\n pathname's prefix, if any, and each name in the pathname's name\n sequence except for the last.  If the name sequence is empty then\n the pathname does not name a parent directory."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Converts this abstract pathname into a pathname string.  The resulting\n string uses the default name-separator character to\n separate the names in the name sequence."
                }
              ]
            },
            {
              "name": "isAbsolute",
              "overloads": [
                {
                  "signature": "public boolean isAbsolute()",
                  "description": "Tests whether this abstract pathname is absolute.  The definition of\n absolute pathname is system dependent.  On UNIX systems, a pathname is\n absolute if its prefix is \"/\".  On Microsoft Windows systems, a\n pathname is absolute if its prefix is a drive specifier followed by\n \"\\\\\", or if its prefix is \"\\\\\\\\\"."
                }
              ]
            },
            {
              "name": "getAbsolutePath",
              "overloads": [
                {
                  "signature": "public String getAbsolutePath()",
                  "description": "Returns the absolute pathname string of this abstract pathname.\n\n  If this abstract pathname is already absolute, then the pathname\n string is simply returned as if by the getPath()\n method.  If this abstract pathname is the empty abstract pathname then\n the pathname string of the current user directory, which is named by the\n system property user.dir, is returned.  Otherwise this\n pathname is resolved in a system-dependent way.  On UNIX systems, a\n relative pathname is made absolute by resolving it against the current\n user directory.  On Microsoft Windows systems, a relative pathname is made absolute\n by resolving it against the current directory of the drive named by the\n pathname, if any; if not, it is resolved against the current user\n directory."
                }
              ]
            },
            {
              "name": "getAbsoluteFile",
              "overloads": [
                {
                  "signature": "public File getAbsoluteFile()",
                  "description": "Returns the absolute form of this abstract pathname.  Equivalent to\n newFile(this.getAbsolutePath())."
                }
              ]
            },
            {
              "name": "getCanonicalPath",
              "overloads": [
                {
                  "signature": "public String getCanonicalPath() throws IOException",
                  "description": "Returns the canonical pathname string of this abstract pathname.\n\n  A canonical pathname is both absolute and unique.  The precise\n definition of canonical form is system-dependent.  This method first\n converts this pathname to absolute form if necessary, as if by invoking the\n getAbsolutePath() method, and then maps it to its unique form in a\n system-dependent way.  This typically involves removing redundant names\n such as \".\" and \"..\" from the pathname, resolving\n symbolic links (on UNIX platforms), and converting drive letters to a\n standard case (on Microsoft Windows platforms).\n\n  Every pathname that denotes an existing file or directory has a\n unique canonical form.  Every pathname that denotes a nonexistent file\n or directory also has a unique canonical form.  The canonical form of\n the pathname of a nonexistent file or directory may be different from\n the canonical form of the same pathname after the file or directory is\n created.  Similarly, the canonical form of the pathname of an existing\n file or directory may be different from the canonical form of the same\n pathname after the file or directory is deleted."
                }
              ]
            },
            {
              "name": "getCanonicalFile",
              "overloads": [
                {
                  "signature": "public File getCanonicalFile() throws IOException",
                  "description": "Returns the canonical form of this abstract pathname.  Equivalent to\n newFile(this.getCanonicalPath())."
                }
              ]
            },
            {
              "name": "toURL",
              "overloads": [
                {
                  "signature": "@Deprecated public URL toURL() throws MalformedURLException",
                  "description": "Converts this abstract pathname into a file: URL.  The\n exact form of the URL is system-dependent.  If it can be determined that\n the file denoted by this abstract pathname is a directory, then the\n resulting URL will end with a slash.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toURI",
              "overloads": [
                {
                  "signature": "public URI toURI()",
                  "description": "Constructs a file: URI that represents this abstract pathname.\n\n  The exact form of the URI is system-dependent.  If it can be\n determined that the file denoted by this abstract pathname is a\n directory, then the resulting URI will end with a slash.\n\n  For a given abstract pathname f, it is guaranteed that\n\n \n new File(f.toURI()).equals(\n f.getAbsoluteFile())\n \n\n so long as the original abstract pathname, the URI, and the new abstract\n pathname are all created in (possibly different invocations of) the same\n Java virtual machine.  Due to the system-dependent nature of abstract\n pathnames, however, this relationship typically does not hold when a\n file: URI that is created in a virtual machine on one operating\n system is converted into an abstract pathname in a virtual machine on a\n different operating system.\n\n  Note that when this abstract pathname represents a UNC pathname then\n all components of the UNC (including the server name component) are encoded\n in the URI path. The authority component is undefined, meaning\n that it is represented as null. The Path class defines the\n toUri method to encode the server name in the authority\n component of the resulting URI. The toPath method\n may be used to obtain a Path representing this abstract pathname."
                }
              ]
            },
            {
              "name": "canRead",
              "overloads": [
                {
                  "signature": "public boolean canRead()",
                  "description": "Tests whether the application can read the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to read\n files that are marked as unreadable. Consequently this method may return\n true even though the file does not have read permissions."
                }
              ]
            },
            {
              "name": "canWrite",
              "overloads": [
                {
                  "signature": "public boolean canWrite()",
                  "description": "Tests whether the application can modify the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Consequently this method may return\n true even though the file is marked read-only."
                }
              ]
            },
            {
              "name": "exists",
              "overloads": [
                {
                  "signature": "public boolean exists()",
                  "description": "Tests whether the file or directory denoted by this abstract pathname\n exists."
                }
              ]
            },
            {
              "name": "isDirectory",
              "overloads": [
                {
                  "signature": "public boolean isDirectory()",
                  "description": "Tests whether the file denoted by this abstract pathname is a\n directory.\n\n  Where it is required to distinguish an I/O exception from the case\n that the file is not a directory, or where several attributes of the\n same file are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "isFile",
              "overloads": [
                {
                  "signature": "public boolean isFile()",
                  "description": "Tests whether the file denoted by this abstract pathname is a normal\n file.  A file is normal if it is not a directory and, in\n addition, satisfies other system-dependent criteria.  Any non-directory\n file created by a Java application is guaranteed to be a normal file.\n\n  Where it is required to distinguish an I/O exception from the case\n that the file is not a normal file, or where several attributes of the\n same file are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "isHidden",
              "overloads": [
                {
                  "signature": "public boolean isHidden()",
                  "description": "Tests whether the file named by this abstract pathname is a hidden\n file.  The exact definition of hidden is system-dependent.  On\n UNIX systems, a file is considered to be hidden if its name begins with\n a period character ('.').  On Microsoft Windows systems, a file is\n considered to be hidden if it has been marked as such in the filesystem."
                }
              ]
            },
            {
              "name": "lastModified",
              "overloads": [
                {
                  "signature": "public long lastModified()",
                  "description": "Returns the time that the file denoted by this abstract pathname was\n last modified."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public long length()",
                  "description": "Returns the length of the file denoted by this abstract pathname.\n The return value is unspecified if this pathname denotes a directory.\n\n  Where it is required to distinguish an I/O exception from the case\n that 0L is returned, or where several attributes of the same file\n are required at the same time, then the Files.readAttributes method may be used."
                }
              ]
            },
            {
              "name": "createNewFile",
              "overloads": [
                {
                  "signature": "public boolean createNewFile() throws IOException",
                  "description": "Atomically creates a new, empty file named by this abstract pathname if\n and only if a file with this name does not yet exist.  The check for the\n existence of the file and the creation of the file if it does not exist\n are a single operation that is atomic with respect to all other\n filesystem activities that might affect the file.\n \n Note: this method should not be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n FileLock\n facility should be used instead."
                }
              ]
            },
            {
              "name": "delete",
              "overloads": [
                {
                  "signature": "public boolean delete()",
                  "description": "Deletes the file or directory denoted by this abstract pathname.  If\n this pathname denotes a directory, then the directory must be empty in\n order to be deleted.\n\n  Note that the Files class defines the delete method to throw an IOException\n when a file cannot be deleted. This is useful for error reporting and to\n diagnose why a file cannot be deleted."
                }
              ]
            },
            {
              "name": "deleteOnExit",
              "overloads": [
                {
                  "signature": "public void deleteOnExit()",
                  "description": "Requests that the file or directory denoted by this abstract\n pathname be deleted when the virtual machine terminates.\n Files (or directories) are deleted in the reverse order that\n they are registered. Invoking this method to delete a file or\n directory that is already registered for deletion has no effect.\n Deletion will be attempted only for normal termination of the\n virtual machine, as defined by the Java Language Specification.\n\n  Once deletion has been requested, it is not possible to cancel the\n request.  This method should therefore be used with care.\n\n \n Note: this method should not be used for file-locking, as\n the resulting protocol cannot be made to work reliably. The\n FileLock\n facility should be used instead."
                }
              ]
            },
            {
              "name": "list",
              "overloads": [
                {
                  "signature": "public String[] list()",
                  "description": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname.\n\n  If this abstract pathname does not denote a directory, then this\n method returns null.  Otherwise an array of strings is\n returned, one for each file or directory in the directory.  Names\n denoting the directory itself and the directory's parent directory are\n not included in the result.  Each string is a file name rather than a\n complete path.\n\n  There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n  Note that the Files class defines the newDirectoryStream method to\n open a directory and iterate over the names of the files in the directory.\n This may use less resources when working with very large directories, and\n may be more responsive when working with remote directories."
                },
                {
                  "signature": "public String[] list(FilenameFilter filter)",
                  "description": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname that satisfy the specified\n filter.  The behavior of this method is the same as that of the\n list() method, except that the strings in the returned array\n must satisfy the filter.  If the given filter is null\n then all names are accepted.  Otherwise, a name satisfies the filter if\n and only if the value true results when the FilenameFilter.accept(File,String) method\n of the filter is invoked on this abstract pathname and the name of a\n file or directory in the directory that it denotes."
                }
              ]
            },
            {
              "name": "listFiles",
              "overloads": [
                {
                  "signature": "public File[] listFiles()",
                  "description": "Returns an array of abstract pathnames denoting the files in the\n directory denoted by this abstract pathname.\n\n  If this abstract pathname does not denote a directory, then this\n method returns null.  Otherwise an array of File objects\n is returned, one for each file or directory in the directory.  Pathnames\n denoting the directory itself and the directory's parent directory are\n not included in the result.  Each resulting abstract pathname is\n constructed from this abstract pathname using the File(File,String) constructor.  Therefore if this\n pathname is absolute then each resulting pathname is absolute; if this\n pathname is relative then each resulting pathname will be relative to\n the same directory.\n\n  There is no guarantee that the name strings in the resulting array\n will appear in any specific order; they are not, in particular,\n guaranteed to appear in alphabetical order.\n\n  Note that the Files class defines the newDirectoryStream method\n to open a directory and iterate over the names of the files in the\n directory. This may use less resources when working with very large\n directories."
                },
                {
                  "signature": "public File[] listFiles(FilenameFilter filter)",
                  "description": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the listFiles() method, except that the pathnames in\n the returned array must satisfy the filter.  If the given filter\n is null then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value true results when\n the FilenameFilter.accept(File,String) method of the filter is\n invoked on this abstract pathname and the name of a file or directory in\n the directory that it denotes."
                },
                {
                  "signature": "public File[] listFiles(FileFilter filter)",
                  "description": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.  The behavior of this method is the same\n as that of the listFiles() method, except that the pathnames in\n the returned array must satisfy the filter.  If the given filter\n is null then all pathnames are accepted.  Otherwise, a pathname\n satisfies the filter if and only if the value true results when\n the FileFilter.accept(File) method of the\n filter is invoked on the pathname."
                }
              ]
            },
            {
              "name": "mkdir",
              "overloads": [
                {
                  "signature": "public boolean mkdir()",
                  "description": "Creates the directory named by this abstract pathname."
                }
              ]
            },
            {
              "name": "mkdirs",
              "overloads": [
                {
                  "signature": "public boolean mkdirs()",
                  "description": "Creates the directory named by this abstract pathname, including any\n necessary but nonexistent parent directories.  Note that if this\n operation fails it may have succeeded in creating some of the necessary\n parent directories."
                }
              ]
            },
            {
              "name": "renameTo",
              "overloads": [
                {
                  "signature": "public boolean renameTo(File dest)",
                  "description": "Renames the file denoted by this abstract pathname.\n\n  Many aspects of the behavior of this method are inherently\n platform-dependent: The rename operation might not be able to move a\n file from one filesystem to another, it might not be atomic, and it\n might not succeed if a file with the destination abstract pathname\n already exists.  The return value should always be checked to make sure\n that the rename operation was successful.  As instances of File\n are immutable, this File object is not changed to name the destination\n file or directory.\n\n  Note that the Files class defines the move method to move or rename a file in a\n platform independent manner."
                }
              ]
            },
            {
              "name": "setLastModified",
              "overloads": [
                {
                  "signature": "public boolean setLastModified(long time)",
                  "description": "Sets the last-modified time of the file or directory named by this\n abstract pathname.\n\n  All platforms support file-modification times to the nearest second,\n but some provide more precision.  The argument will be truncated to fit\n the supported precision.  If the operation succeeds and no intervening\n operations on the file take place, then the next invocation of the\n lastModified() method will return the (possibly\n truncated) time argument that was passed to this method."
                }
              ]
            },
            {
              "name": "setReadOnly",
              "overloads": [
                {
                  "signature": "public boolean setReadOnly()",
                  "description": "Marks the file or directory named by this abstract pathname so that\n only read operations are allowed. After invoking this method the file\n or directory will not change until it is either deleted or marked\n to allow write access. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to modify\n files that are marked read-only. Whether or not a read-only file or\n directory may be deleted depends upon the underlying system."
                }
              ]
            },
            {
              "name": "setWritable",
              "overloads": [
                {
                  "signature": "public boolean setWritable(boolean writable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setWritable(boolean writable)",
                  "description": "A convenience method to set the owner's write permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to modify files that\n disallow write operations.\n\n  An invocation of this method of the form file.setWritable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setWritable(arg, true)"
                }
              ]
            },
            {
              "name": "setReadable",
              "overloads": [
                {
                  "signature": "public boolean setReadable(boolean readable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that are\n marked as unreadable.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setReadable(boolean readable)",
                  "description": "A convenience method to set the owner's read permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to read files that are\n marked as unreadable.\n\n An invocation of this method of the form file.setReadable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setReadable(arg, true)"
                }
              ]
            },
            {
              "name": "setExecutable",
              "overloads": [
                {
                  "signature": "public boolean setExecutable(boolean executable, boolean ownerOnly)",
                  "description": "Sets the owner's or everybody's execute permission for this abstract\n pathname. On some platforms it may be possible to start the Java virtual\n machine with special privileges that allow it to execute files that are\n not marked executable.\n\n  The Files class defines methods that operate on\n file attributes including file permissions. This may be used when finer\n manipulation of file permissions is required."
                },
                {
                  "signature": "public boolean setExecutable(boolean executable)",
                  "description": "A convenience method to set the owner's execute permission for this\n abstract pathname. On some platforms it may be possible to start the Java\n virtual machine with special privileges that allow it to execute files\n that are not marked executable.\n\n An invocation of this method of the form file.setExcutable(arg)\n behaves in exactly the same way as the invocation\n\n \n     file.setExecutable(arg, true)"
                }
              ]
            },
            {
              "name": "canExecute",
              "overloads": [
                {
                  "signature": "public boolean canExecute()",
                  "description": "Tests whether the application can execute the file denoted by this\n abstract pathname. On some platforms it may be possible to start the\n Java virtual machine with special privileges that allow it to execute\n files that are not marked executable. Consequently this method may return\n true even though the file does not have execute permissions."
                }
              ]
            },
            {
              "name": "listRoots",
              "overloads": [
                {
                  "signature": "public static File[] listRoots()",
                  "description": "List the available filesystem roots.\n\n  A particular Java platform may support zero or more\n hierarchically-organized file systems.  Each file system has a\n root directory from which all other files in that file system\n can be reached.  Windows platforms, for example, have a root directory\n for each active drive; UNIX platforms have a single root directory,\n namely \"/\".  The set of available filesystem roots is affected\n by various system-level operations such as the insertion or ejection of\n removable media and the disconnecting or unmounting of physical or\n virtual disk drives.\n\n  This method returns an array of File objects that denote the\n root directories of the available filesystem roots.  It is guaranteed\n that the canonical pathname of any file physically present on the local\n machine will begin with one of the roots returned by this method.\n\n  The canonical pathname of a file that resides on some other machine\n and is accessed via a remote-filesystem protocol such as SMB or NFS may\n or may not begin with one of the roots returned by this method.  If the\n pathname of a remote file is syntactically indistinguishable from the\n pathname of a local file then it will begin with one of the roots\n returned by this method.  Thus, for example, File objects\n denoting the root directories of the mapped network drives of a Windows\n platform will be returned by this method, while File objects\n containing UNC pathnames will not be returned by this method.\n\n  Unlike most methods in this class, this method does not throw\n security exceptions.  If a security manager exists and its SecurityManager.checkRead(String) method denies read access to a\n particular root directory, then that directory will not appear in the\n result."
                }
              ]
            },
            {
              "name": "getTotalSpace",
              "overloads": [
                {
                  "signature": "public long getTotalSpace()",
                  "description": "Returns the size of the partition named by this\n abstract pathname. If the total number of bytes in the partition is\n greater than Long.MAX_VALUE, then Long.MAX_VALUE will be\n returned."
                }
              ]
            },
            {
              "name": "getFreeSpace",
              "overloads": [
                {
                  "signature": "public long getFreeSpace()",
                  "description": "Returns the number of unallocated bytes in the partition named by this abstract path name.  If the\n number of unallocated bytes in the partition is greater than\n Long.MAX_VALUE, then Long.MAX_VALUE will be returned.\n\n  The returned number of unallocated bytes is a hint, but not\n a guarantee, that it is possible to use most or any of these\n bytes.  The number of unallocated bytes is most likely to be\n accurate immediately after this call.  It is likely to be made\n inaccurate by any external I/O operations including those made\n on the system outside of this virtual machine.  This method\n makes no guarantee that write operations to this file system\n will succeed."
                }
              ]
            },
            {
              "name": "getUsableSpace",
              "overloads": [
                {
                  "signature": "public long getUsableSpace()",
                  "description": "Returns the number of bytes available to this virtual machine on the\n partition named by this abstract pathname.  If\n the number of available bytes in the partition is greater than\n Long.MAX_VALUE, then Long.MAX_VALUE will be returned.\n When possible, this method checks for write permissions and other\n operating system restrictions and will therefore usually provide a more\n accurate estimate of how much new data can actually be written than\n getFreeSpace().\n\n  The returned number of available bytes is a hint, but not a\n guarantee, that it is possible to use most or any of these bytes.  The\n number of available bytes is most likely to be accurate immediately\n after this call.  It is likely to be made inaccurate by any external\n I/O operations including those made on the system outside of this\n virtual machine.  This method makes no guarantee that write operations\n to this file system will succeed."
                }
              ]
            },
            {
              "name": "createTempFile",
              "overloads": [
                {
                  "signature": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException",
                  "description": "Creates a new empty file in the specified directory, using the\n given prefix and suffix strings to generate its name.  If this method\n returns successfully then it is guaranteed that:\n\n \n  The file denoted by the returned abstract pathname did not exist\n      before this method was invoked, and\n  Neither this method nor any of its variants will return the same\n      abstract pathname again in the current invocation of the virtual\n      machine.\n \n\n This method provides only part of a temporary-file facility.  To arrange\n for a file created by this method to be deleted automatically, use the\n deleteOnExit() method.\n\n  The prefix argument must be at least three characters\n long.  It is recommended that the prefix be a short, meaningful string\n such as \"hjb\" or \"mail\".  The\n suffix argument may be null, in which case the\n suffix \".tmp\" will be used.\n\n  To create the new file, the prefix and the suffix may first be\n adjusted to fit the limitations of the underlying platform.  If the\n prefix is too long then it will be truncated, but its first three\n characters will always be preserved.  If the suffix is too long then it\n too will be truncated, but if it begins with a period character\n ('.') then the period and the first three characters\n following it will always be preserved.  Once these adjustments have been\n made the name of the new file will be generated by concatenating the\n prefix, five or more internally-generated characters, and the suffix.\n\n  If the directory argument is null then the\n system-dependent default temporary-file directory will be used.  The\n default temporary-file directory is specified by the system property\n java.io.tmpdir.  On UNIX systems the default value of this\n property is typically \"/tmp\" or \"/var/tmp\"; on\n Microsoft Windows systems it is typically \"C:\\\\WINNT\\\\TEMP\".  A different\n value may be given to this system property when the Java virtual machine\n is invoked, but programmatic changes to this property are not guaranteed\n to have any effect upon the temporary directory used by this method."
                },
                {
                  "signature": "public static File createTempFile(String prefix, String suffix) throws IOException",
                  "description": "Creates an empty file in the default temporary-file directory, using\n the given prefix and suffix to generate its name. Invoking this method\n is equivalent to invoking createTempFile(prefix,suffix,null).\n\n  The Files.createTempFile method provides an alternative method to create an\n empty file in the temporary-file directory. Files created by that method\n may have more restrictive access permissions to files created by this\n method and so may be more suited to security-sensitive applications."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(File pathname)",
                  "description": "Compares two abstract pathnames lexicographically.  The ordering\n defined by this method depends upon the underlying system.  On UNIX\n systems, alphabetic case is significant in comparing pathnames; on\n Microsoft Windows systems it is not."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Tests this abstract pathname for equality with the given object.\n Returns true if and only if the argument is not\n null and is an abstract pathname that is the same as this\n abstract pathname.  Whether or not two abstract\n pathnames are equal depends upon the underlying operating system.\n On UNIX systems, alphabetic case is significant in comparing pathnames;\n on Microsoft Windows systems it is not."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Computes a hash code for this abstract pathname.  Because equality of\n abstract pathnames is inherently system-dependent, so is the computation\n of their hash codes.  On UNIX systems, the hash code of an abstract\n pathname is equal to the exclusive or of the hash code\n of its pathname string and the decimal value\n 1234321.  On Microsoft Windows systems, the hash\n code is equal to the exclusive or of the hash code of\n its pathname string converted to lower case and the decimal\n value 1234321.  Locale is not taken into account on\n lowercasing the pathname string."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the pathname string of this abstract pathname.  This is just the\n string returned by the getPath() method."
                }
              ]
            },
            {
              "name": "toPath",
              "overloads": [
                {
                  "signature": "public Path toPath()",
                  "description": "Returns a java.nio.file.Path object constructed from\n this abstract path. The resulting Path is associated with the\n default-filesystem.\n\n  The first invocation of this method works as if invoking it were\n equivalent to evaluating the expression:\n  FileSystems.getDefault().getPath(this.getPath());\n \n Subsequent invocations of this method return the same Path.\n\n  If this abstract pathname is the empty abstract pathname then this\n method returns a Path that may be used to access the current\n user directory."
                }
              ]
            }
          ]
        },
        {
          "name": "FileDescriptor",
          "methods": [
            {
              "name": "FileDescriptor",
              "overloads": [
                {
                  "signature": "public FileDescriptor()",
                  "description": "Constructs an (invalid) FileDescriptor object.\n The fd or handle is set later."
                }
              ]
            },
            {
              "name": "valid",
              "overloads": [
                {
                  "signature": "public boolean valid()",
                  "description": "Tests if this file descriptor object is valid."
                }
              ]
            },
            {
              "name": "sync",
              "overloads": [
                {
                  "signature": "public void sync() throws SyncFailedException",
                  "description": "Force all system buffers to synchronize with the underlying\n device.  This method returns after all modified data and\n attributes of this FileDescriptor have been written to the\n relevant device(s).  In particular, if this FileDescriptor\n refers to a physical storage medium, such as a file in a file\n system, sync will not return until all in-memory modified copies\n of buffers associated with this FileDescriptor have been\n written to the physical medium.\n\n sync is meant to be used by code that requires physical\n storage (such as a file) to be in a known state  For\n example, a class that provided a simple transaction facility\n might use sync to ensure that all changes to a file caused\n by a given transaction were recorded on a storage medium.\n\n sync only affects buffers downstream of this FileDescriptor.  If\n any in-memory buffering is being done by the application (for\n example, by a BufferedOutputStream object), those buffers must\n be flushed into the FileDescriptor (for example, by invoking\n OutputStream.flush) before that data will be affected by sync."
                }
              ]
            }
          ]
        },
        {
          "name": "FileFilter",
          "methods": [
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "boolean accept(File pathname)",
                  "description": "Tests whether or not the specified abstract pathname should be\n included in a pathname list."
                }
              ]
            }
          ]
        },
        {
          "name": "FileInputStream",
          "methods": [
            {
              "name": "FileInputStream",
              "overloads": [
                {
                  "signature": "public FileInputStream(String name) throws FileNotFoundException",
                  "description": "Creates a FileInputStream by\n opening a connection to an actual file,\n the file named by the path name name\n in the file system.  A new FileDescriptor\n object is created to represent this file\n connection.\n \n First, if there is a security\n manager, its checkRead method\n is called with the name argument\n as its argument.\n \n If the named file does not exist, is a directory rather than a regular\n file, or for some other reason cannot be opened for reading then a\n FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileInputStream(File file) throws FileNotFoundException",
                  "description": "Creates a FileInputStream by\n opening a connection to an actual file,\n the file named by the File\n object file in the file system.\n A new FileDescriptor object\n is created to represent this file connection.\n \n First, if there is a security manager,\n its checkRead method  is called\n with the path represented by the file\n argument as its argument.\n \n If the named file does not exist, is a directory rather than a regular\n file, or for some other reason cannot be opened for reading then a\n FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileInputStream(FileDescriptor fdObj)",
                  "description": "Creates a FileInputStream by using the file descriptor\n fdObj, which represents an existing connection to an\n actual file in the file system.\n \n If there is a security manager, its checkRead method is\n called with the file descriptor fdObj as its argument to\n see if it's ok to read the file descriptor. If read access is denied\n to the file descriptor a SecurityException is thrown.\n \n If fdObj is null then a NullPointerException\n is thrown.\n \n This constructor does not throw an exception if fdObj\n is invalid.\n However, if the methods are invoked on the resulting stream to attempt\n I/O on the stream, an IOException is thrown."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data from this input stream. This method blocks\n if no input is yet available."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this input\n stream into an array of bytes. This method blocks until some input\n is available."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. If len is not zero, the method\n blocks until some input is available; otherwise, no\n bytes are read and 0 is returned."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from the\n input stream.\n\n The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. If n is negative, the method\n will try to skip backwards. In case the backing file does not support\n backward skip at its current position, an IOException is\n thrown. The actual number of bytes skipped is returned. If it skips\n forwards, it returns a positive value. If it skips backwards, it\n returns a negative value.\n\n This method may skip more bytes than what are remaining in the\n backing file. This produces no exception and the number of bytes skipped\n may include some number of bytes that were beyond the EOF of the\n backing file. Attempting to read from the stream after skipping past\n the end will result in -1 indicating the end of the file."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of remaining bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. Returns 0 when the file\n position is beyond EOF. The next invocation might be the same thread\n or another thread. A single read or skip of this many bytes will not\n block, but may read or skip fewer bytes.\n\n  In some cases, a non-blocking read (or skip) may appear to be\n blocked when it is merely slow, for example when reading large\n files over slow networks."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this file input stream and releases any system resources\n associated with the stream.\n\n  If this stream has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the FileDescriptor\n object  that represents the connection to\n the actual file in the file system being\n used by this FileInputStream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file input stream.\n\n  The initial position of the returned channel will be equal to the\n number of bytes read from the file so far.  Reading bytes from this\n stream will increment the channel's position.  Changing the channel's\n position, either explicitly or by reading, will change this stream's\n file position."
                }
              ]
            }
          ]
        },
        {
          "name": "FilenameFilter",
          "methods": [
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "boolean accept(File dir, String name)",
                  "description": "Tests if a specified file should be included in a file list."
                }
              ]
            }
          ]
        },
        {
          "name": "FileNotFoundException",
          "methods": [
            {
              "name": "FileNotFoundException",
              "overloads": [
                {
                  "signature": "public FileNotFoundException()",
                  "description": "Constructs a FileNotFoundException with\n null as its error detail message."
                },
                {
                  "signature": "public FileNotFoundException(String s)",
                  "description": "Constructs a FileNotFoundException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "FileOutputStream",
          "methods": [
            {
              "name": "FileOutputStream",
              "overloads": [
                {
                  "signature": "public FileOutputStream(String name) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file with the\n specified name. A new FileDescriptor object is\n created to represent this file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with name as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(String name, boolean append) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file with the specified\n name.  If the second argument is true, then\n bytes will be written to the end of the file rather than the beginning.\n A new FileDescriptor object is created to represent this\n file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with name as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(File file) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file represented by\n the specified File object. A new\n FileDescriptor object is created to represent this\n file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with the path represented by the file\n argument as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(File file, boolean append) throws FileNotFoundException",
                  "description": "Creates a file output stream to write to the file represented by\n the specified File object. If the second argument is\n true, then bytes will be written to the end of the file\n rather than the beginning. A new FileDescriptor object is\n created to represent this file connection.\n \n First, if there is a security manager, its checkWrite\n method is called with the path represented by the file\n argument as its argument.\n \n If the file exists but is a directory rather than a regular file, does\n not exist but cannot be created, or cannot be opened for any other\n reason then a FileNotFoundException is thrown."
                },
                {
                  "signature": "public FileOutputStream(FileDescriptor fdObj)",
                  "description": "Creates a file output stream to write to the specified file\n descriptor, which represents an existing connection to an actual\n file in the file system.\n \n First, if there is a security manager, its checkWrite\n method is called with the file descriptor fdObj\n argument as its argument.\n \n If fdObj is null then a NullPointerException\n is thrown.\n \n This constructor does not throw an exception if fdObj\n is invalid.\n However, if the methods are invoked on the resulting stream to attempt\n I/O on the stream, an IOException is thrown."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this file output stream. Implements\n the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this file output stream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this file output stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this file output stream and releases any system resources\n associated with this stream. This file output stream may no longer\n be used for writing bytes.\n\n  If this stream has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the file descriptor associated with this stream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file output stream.\n\n  The initial position of the returned channel will be equal to the\n number of bytes written to the file so far unless this stream is in\n append mode, in which case it will be equal to the size of the file.\n Writing bytes to this stream will increment the channel's position\n accordingly.  Changing the channel's position, either explicitly or by\n writing, will change this stream's file position."
                }
              ]
            }
          ]
        },
        {
          "name": "FilePermission",
          "methods": [
            {
              "name": "FilePermission",
              "overloads": [
                {
                  "signature": "public FilePermission(String path, String actions)",
                  "description": "Creates a new FilePermission object with the specified actions.\n path is the pathname of a file or directory, and actions\n contains a comma-separated list of the desired actions granted on the\n file or directory. Possible actions are\n \"read\", \"write\", \"execute\", \"delete\", and \"readlink\".\n\n A pathname that ends in \"/*\" (where \"/\" is\n the file separator character, File.separatorChar)\n indicates all the files and directories contained in that directory.\n A pathname that ends with \"/-\" indicates (recursively) all files and\n subdirectories contained in that directory. The special pathname\n \"<<ALL FILES>>\" matches any file.\n\n A pathname consisting of a single \"*\" indicates all the files\n in the current directory, while a pathname consisting of a single \"-\"\n indicates all the files in the current directory and\n (recursively) all files and subdirectories contained in the current\n directory.\n\n A pathname containing an empty string represents an empty path."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this FilePermission object \"implies\" the specified permission.\n \n More specifically, this method returns true if:\n \n  p is an instanceof FilePermission,\n  p's actions are a proper subset of this\n object's actions, and\n  p's pathname is implied by this object's\n      pathname. For example, \"/tmp/*\" implies \"/tmp/foo\", since\n      \"/tmp/*\" encompasses all files in the \"/tmp\" directory,\n      including the one named \"foo\".\n \n \n Precisely, a simple pathname implies another simple pathname\n if and only if they are equal. A simple pathname never implies\n a wildcard pathname. A wildcard pathname implies another wildcard\n pathname if and only if all simple pathnames implied by the latter\n are implied by the former. A wildcard pathname implies a simple\n pathname if and only if\n \n     if the wildcard flag is \"*\", the simple pathname's path\n     must be right inside the wildcard pathname's path.\n     if the wildcard flag is \"-\", the simple pathname's path\n     must be recursively inside the wildcard pathname's path.\n \n \n \"<<ALL FILES>>\" implies every other pathname. No pathname,\n except for \"<<ALL FILES>>\" itself, implies\n \"<<ALL FILES>>\"."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two FilePermission objects for equality. Checks that obj is\n a FilePermission, and has the same pathname and actions as this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the \"canonical string representation\" of the actions.\n That is, this method always returns present actions in the following order:\n read, write, execute, delete, readlink. For example, if this FilePermission\n object allows both write and read actions, a call to getActions\n will return the string \"read,write\"."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing FilePermission\n objects.\n \n FilePermission objects must be stored in a manner that allows them\n to be inserted into the collection in any order, but that also enables the\n PermissionCollection implies\n method to be implemented in an efficient (and consistent) manner.\n\n For example, if you have two FilePermissions:\n \n   \"/tmp/-\", \"read\"\n   \"/tmp/scratch/foo\", \"write\"\n \n\n and you are calling the implies method with the FilePermission:\n\n    \"/tmp/scratch/foo\", \"read,write\",\n \n\n then the implies function must\n take into account both the \"/tmp/-\" and \"/tmp/scratch/foo\"\n permissions, so the effective permission is \"read,write\",\n and implies returns true. The \"implies\" semantics for\n FilePermissions are handled properly by the PermissionCollection object\n returned by this newPermissionCollection method."
                }
              ]
            }
          ]
        },
        {
          "name": "FileReader",
          "methods": [
            {
              "name": "FileReader",
              "overloads": [
                {
                  "signature": "public FileReader(String fileName) throws FileNotFoundException",
                  "description": "Creates a new FileReader, given the name of the file to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(File file) throws FileNotFoundException",
                  "description": "Creates a new FileReader, given the File to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(FileDescriptor fd)",
                  "description": "Creates a new FileReader, given the FileDescriptor to read,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileReader(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new FileReader, given the name of the file to read\n and the charset."
                },
                {
                  "signature": "public FileReader(File file, Charset charset) throws IOException",
                  "description": "Creates a new FileReader, given the File to read and\n the charset."
                }
              ]
            }
          ]
        },
        {
          "name": "FileWriter",
          "methods": [
            {
              "name": "FileWriter",
              "overloads": [
                {
                  "signature": "public FileWriter(String fileName) throws IOException",
                  "description": "Constructs a FileWriter given a file name, using the platform's\n default charset"
                },
                {
                  "signature": "public FileWriter(String fileName, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given a file name and a boolean indicating\n whether to append the data written, using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(File file) throws IOException",
                  "description": "Constructs a FileWriter given the File to write,\n using the platform's\n default charset"
                },
                {
                  "signature": "public FileWriter(File file, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given the File to write and\n a boolean indicating whether to append the data written, using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(FileDescriptor fd)",
                  "description": "Constructs a FileWriter given a file descriptor,\n using the platform's\n default charset."
                },
                {
                  "signature": "public FileWriter(String fileName, Charset charset) throws IOException",
                  "description": "Constructs a FileWriter given a file name and\n charset."
                },
                {
                  "signature": "public FileWriter(String fileName, Charset charset, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given a file name,\n charset and a boolean indicating\n whether to append the data written."
                },
                {
                  "signature": "public FileWriter(File file, Charset charset) throws IOException",
                  "description": "Constructs a FileWriter given the File to write and\n charset."
                },
                {
                  "signature": "public FileWriter(File file, Charset charset, boolean append) throws IOException",
                  "description": "Constructs a FileWriter given the File to write,\n charset and a boolean indicating\n whether to append the data written."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterInputStream",
          "methods": [
            {
              "name": "FilterInputStream",
              "overloads": [
                {
                  "signature": "protected FilterInputStream(InputStream in)",
                  "description": "Creates a FilterInputStream\n by assigning the  argument in\n to the field this.in so as\n to remember it for later use."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n \n This method\n simply performs in.read() and returns the result."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this\n input stream into an array of bytes. This method blocks until some\n input is available.\n \n This method simply performs the call\n read(b, 0, b.length) and returns\n the  result. It is important that it does\n not do in.read(b) instead;\n certain subclasses of  FilterInputStream\n depend on the implementation strategy actually\n used."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. If len is not zero, the method\n blocks until some input is available; otherwise, no\n bytes are read and 0 is returned.\n \n This method simply performs in.read(b, off, len)\n and returns the result."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from the\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. The actual number of bytes skipped is\n returned.\n \n This method simply performs in.skip(n)."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n caller of a method for this input stream. The next caller might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method returns the result of in.available()."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n This\n method simply performs in.close()."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent\n call to the reset method repositions this stream at\n the last marked position so that subsequent reads re-read the same bytes.\n \n The readlimit argument tells this input stream to\n allow that many bytes to be read before the mark position gets\n invalidated.\n \n This method simply performs in.mark(readlimit)."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n \n This method\n simply performs in.reset().\n \n Stream marks are intended to be used in\n situations where you need to read ahead a little to see what's in\n the stream. Often this is most easily done by invoking some\n general parser. If the stream is of the type handled by the\n parse, it just chugs along happily. If the stream is not of\n that type, the parser should toss an exception when it fails.\n If this happens within readlimit bytes, it allows the outer\n code to reset the stream and try another parser."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark\n and reset methods.\n This method\n simply performs in.markSupported()."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterOutputStream",
          "methods": [
            {
              "name": "FilterOutputStream",
              "overloads": [
                {
                  "signature": "public FilterOutputStream(OutputStream out)",
                  "description": "Creates an output stream filter built on top of the specified\n underlying output stream."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this output stream.\n \n The write method of FilterOutputStream\n calls the write method of its underlying output stream,\n that is, it performs out.write(b).\n \n Implements the abstract write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes to this output stream.\n \n The write method of FilterOutputStream\n calls its write method of three arguments with the\n arguments b, 0, and\n b.length.\n \n Note that this method does not call the one-argument\n write method of its underlying output stream with\n the single argument b."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified\n byte array starting at offset off to\n this output stream.\n \n The write method of FilterOutputStream\n calls the write method of one argument on each\n byte to output.\n \n Note that this method does not call the write method\n of its underlying output stream with the same arguments. Subclasses\n of FilterOutputStream should provide a more efficient\n implementation of this method."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out to the stream.\n \n The flush method of FilterOutputStream\n calls the flush method of its underlying output stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this output stream and releases any system resources\n associated with the stream.\n \n When not already closed, the close method of \n FilterOutputStream calls its flush method, and then\n calls the close method of its underlying output stream."
                }
              ]
            }
          ]
        },
        {
          "name": "FilterReader",
          "methods": [
            {
              "name": "FilterReader",
              "overloads": [
                {
                  "signature": "protected FilterReader(Reader in)",
                  "description": "Creates a new filtered reader."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters.  This method will block until some characters are\n available, an I/O error occurs, or the end of the stream is reached.\n If the stream is already at its end before this method is invoked,\n then no characters are skipped and zero is returned."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            }
          ]
        },
        {
          "name": "FilterWriter",
          "methods": [
            {
              "name": "FilterWriter",
              "overloads": [
                {
                  "signature": "protected FilterWriter(Writer out)",
                  "description": "Create a new filtered writer."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "Flushable",
          "methods": [
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "void flush() throws IOException",
                  "description": "Flushes this stream by writing any buffered output to the underlying\n stream."
                }
              ]
            }
          ]
        },
        {
          "name": "InputStream",
          "methods": [
            {
              "name": "InputStream",
              "overloads": [
                {
                  "signature": "public InputStream()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "nullInputStream",
              "overloads": [
                {
                  "signature": "public static InputStream nullInputStream()",
                  "description": "Returns a new InputStream that reads no bytes. The returned\n stream is initially open.  The stream is closed by calling the\n close() method.  Subsequent calls to close() have no\n effect.\n\n  While the stream is open, the available(), read(),\n read(byte[]), read(byte[], int, int),\n readAllBytes(), readNBytes(byte[], int, int),\n readNBytes(int), skip(long), skipNBytes(long),\n and transferTo() methods all behave as if end of stream has been\n reached.  After the stream has been closed, these methods all throw\n IOException.\n\n  The markSupported() method returns false.  The\n mark() method does nothing, and the reset() method\n throws IOException."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public abstract int read() throws IOException",
                  "description": "Reads the next byte of data from the input stream. The value byte is\n returned as an int in the range 0 to\n 255. If no byte is available because the end of the stream\n has been reached, the value -1 is returned. This method\n blocks until input data is available, the end of the stream is detected,\n or an exception is thrown.\n\n  A subclass must provide an implementation of this method."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads some number of bytes from the input stream and stores them into\n the buffer array b. The number of bytes actually read is\n returned as an integer.  This method blocks until input data is\n available, end of file is detected, or an exception is thrown.\n\n  If the length of b is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at the\n end of the file, the value -1 is returned; otherwise, at\n least one byte is read and stored into b.\n\n  The first byte read is stored into element b[0], the\n next one into b[1], and so on. The number of bytes read is,\n at most, equal to the length of b. Let k be the\n number of bytes actually read; these bytes will be stored in elements\n b[0] through b[k-1],\n leaving elements b[k] through\n b[b.length-1] unaffected.\n\n  The read(b) method for class InputStream\n has the same effect as:  read(b, 0, b.length)"
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from the input stream into\n an array of bytes.  An attempt is made to read as many as\n len bytes, but a smaller number may be read.\n The number of bytes actually read is returned as an integer.\n\n  This method blocks until input data is available, end of file is\n detected, or an exception is thrown.\n\n  If len is zero, then no bytes are read and\n 0 is returned; otherwise, there is an attempt to read at\n least one byte. If no byte is available because the stream is at end of\n file, the value -1 is returned; otherwise, at least one\n byte is read and stored into b.\n\n  The first byte read is stored into element b[off], the\n next one into b[off+1], and so on. The number of bytes read\n is, at most, equal to len. Let k be the number of\n bytes actually read; these bytes will be stored in elements\n b[off] through b[off+k-1],\n leaving elements b[off+k] through\n b[off+len-1] unaffected.\n\n  In every case, elements b[0] through\n b[off-1] and elements b[off+len] through\n b[b.length-1] are unaffected.\n\n  The read(b, off, len) method\n for class InputStream simply calls the method\n read() repeatedly. If the first such call results in an\n IOException, that exception is returned from the call to\n the read(b, off, len) method.  If\n any subsequent call to read() results in a\n IOException, the exception is caught and treated as if it\n were end of file; the bytes read up to that point are stored into\n b and the number of bytes read before the exception\n occurred is returned. The default implementation of this method blocks\n until the requested amount of input data len has been read,\n end of file is detected, or an exception is thrown. Subclasses are\n encouraged to provide a more efficient implementation of this method."
                }
              ]
            },
            {
              "name": "readAllBytes",
              "overloads": [
                {
                  "signature": "public byte[] readAllBytes() throws IOException",
                  "description": "Reads all remaining bytes from the input stream. This method blocks until\n all remaining bytes have been read and end of stream is detected, or an\n exception is thrown. This method does not close the input stream.\n\n  When this stream reaches end of stream, further invocations of this\n method will return an empty byte array.\n\n  Note that this method is intended for simple cases where it is\n convenient to read all bytes into a byte array. It is not intended for\n reading input streams with large amounts of data.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes have been read. Consequently the input\n stream may not be at end of stream and may be in an inconsistent state.\n It is strongly recommended that the stream be promptly closed if an I/O\n error occurs."
                }
              ]
            },
            {
              "name": "readNBytes",
              "overloads": [
                {
                  "signature": "public byte[] readNBytes(int len) throws IOException",
                  "description": "Reads up to a specified number of bytes from the input stream. This\n method blocks until the requested number of bytes has been read, end\n of stream is detected, or an exception is thrown. This method does not\n close the input stream.\n\n  The length of the returned array equals the number of bytes read\n from the stream. If len is zero, then no bytes are read and\n an empty byte array is returned. Otherwise, up to len bytes\n are read from the stream. Fewer than len bytes may be read if\n end of stream is encountered.\n\n  When this stream reaches end of stream, further invocations of this\n method will return an empty byte array.\n\n  Note that this method is intended for simple cases where it is\n convenient to read the specified number of bytes into a byte array. The\n total amount of memory allocated by this method is proportional to the\n number of bytes read from the stream which is bounded by len.\n Therefore, the method may be safely called with very large values of\n len provided sufficient memory is available.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes have been read. Consequently the input\n stream may not be at end of stream and may be in an inconsistent state.\n It is strongly recommended that the stream be promptly closed if an I/O\n error occurs."
                },
                {
                  "signature": "public int readNBytes(byte[] b, int off, int len) throws IOException",
                  "description": "Reads the requested number of bytes from the input stream into the given\n byte array. This method blocks until len bytes of input data have\n been read, end of stream is detected, or an exception is thrown. The\n number of bytes actually read, possibly zero, is returned. This method\n does not close the input stream.\n\n  In the case where end of stream is reached before len bytes\n have been read, then the actual number of bytes read will be returned.\n When this stream reaches end of stream, further invocations of this\n method will return zero.\n\n  If len is zero, then no bytes are read and 0 is\n returned; otherwise, there is an attempt to read up to len bytes.\n\n  The first byte read is stored into element b[off], the next\n one in to b[off+1], and so on. The number of bytes read is, at\n most, equal to len. Let k be the number of bytes actually\n read; these bytes will be stored in elements b[off] through\n b[off+k-1], leaving elements b[off+k\n ] through b[off+len-1] unaffected.\n\n  The behavior for the case where the input stream is asynchronously\n closed, or the thread interrupted during the read, is highly input\n stream specific, and therefore not specified.\n\n  If an I/O error occurs reading from the input stream, then it may do\n so after some, but not all, bytes of b have been updated with\n data from the input stream. Consequently the input stream and b\n may be in an inconsistent state. It is strongly recommended that the\n stream be promptly closed if an I/O error occurs."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this input\n stream. The skip method may, for a variety of reasons, end\n up skipping over some smaller number of bytes, possibly 0.\n This may result from any of a number of conditions; reaching end of file\n before n bytes have been skipped is only one possibility.\n The actual number of bytes skipped is returned. If n is\n negative, the skip method for class InputStream always\n returns 0, and no bytes are skipped. Subclasses may handle the negative\n value differently.\n\n  The skip method implementation of this class creates a\n byte array and then repeatedly reads into it until n bytes\n have been read or the end of the stream has been reached. Subclasses are\n encouraged to provide a more efficient implementation of this method.\n For instance, the implementation may depend on the ability to seek."
                }
              ]
            },
            {
              "name": "skipNBytes",
              "overloads": [
                {
                  "signature": "public void skipNBytes(long n) throws IOException",
                  "description": "Skips over and discards exactly n bytes of data from this input\n stream.  If n is zero, then no bytes are skipped.\n If n is negative, then no bytes are skipped.\n Subclasses may handle the negative value differently.\n\n  This method blocks until the requested number of bytes has been\n skipped, end of file is reached, or an exception is thrown.\n\n  If end of stream is reached before the stream is at the desired\n position, then an EOFException is thrown.\n\n  If an I/O error occurs, then the input stream may be\n in an inconsistent state. It is strongly recommended that the\n stream be promptly closed if an I/O error occurs."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or skipped\n over) from this input stream without blocking, which may be 0, or 0 when\n end of stream is detected.  The read might be on the same thread or\n another thread.  A single read or skip of this many bytes will not block,\n but may read or skip fewer bytes.\n\n  Note that while some implementations of InputStream will\n return the total number of bytes in the stream, many will not.  It is\n never correct to use the return value of this method to allocate\n a buffer intended to hold all data in this stream.\n\n  A subclass's implementation of this method may choose to throw an\n IOException if this input stream has been closed by invoking the\n close() method.\n\n  The available method of InputStream always returns\n 0.\n\n  This method should be overridden by subclasses."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources associated\n with the stream.\n\n  The close method of InputStream does\n nothing."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent call to\n the reset method repositions this stream at the last marked\n position so that subsequent reads re-read the same bytes.\n\n  The readlimit arguments tells this input stream to\n allow that many bytes to be read before the mark position gets\n invalidated.\n\n  The general contract of mark is that, if the method\n markSupported returns true, the stream somehow\n remembers all the bytes read after the call to mark and\n stands ready to supply those same bytes again if and whenever the method\n reset is called.  However, the stream is not required to\n remember any data at all if more than readlimit bytes are\n read from the stream before reset is called.\n\n  Marking a closed stream should not have any effect on the stream.\n\n  The mark method of InputStream does\n nothing."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n\n  The general contract of reset is:\n\n \n  If the method markSupported returns\n true, then:\n\n      If the method mark has not been called since\n     the stream was created, or the number of bytes read from the stream\n     since mark was last called is larger than the argument\n     to mark at that last call, then an\n     IOException might be thrown.\n\n      If such an IOException is not thrown, then the\n     stream is reset to a state such that all the bytes read since the\n     most recent call to mark (or since the start of the\n     file, if mark has not been called) will be resupplied\n     to subsequent callers of the read method, followed by\n     any bytes that otherwise would have been the next input data as of\n     the time of the call to reset. \n\n  If the method markSupported returns\n false, then:\n\n      The call to reset may throw an\n     IOException.\n\n      If an IOException is not thrown, then the stream\n     is reset to a fixed state that depends on the particular type of the\n     input stream and how it was created. The bytes that will be supplied\n     to subsequent callers of the read method depend on the\n     particular type of the input stream. \n\n The method reset for class InputStream\n does nothing except throw an IOException."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark and\n reset methods. Whether or not mark and\n reset are supported is an invariant property of a\n particular input stream instance. The markSupported method\n of InputStream returns false."
                }
              ]
            },
            {
              "name": "transferTo",
              "overloads": [
                {
                  "signature": "public long transferTo(OutputStream out) throws IOException",
                  "description": "Reads all bytes from this input stream and writes the bytes to the\n given output stream in the order that they are read. On return, this\n input stream will be at end of stream. This method does not close either\n stream.\n \n This method may block indefinitely reading from the input stream, or\n writing to the output stream. The behavior for the case where the input\n and/or output stream is asynchronously closed, or the thread\n interrupted during the transfer, is highly input and output stream\n specific, and therefore not specified.\n \n If an I/O error occurs reading from the input stream or writing to the\n output stream, then it may do so after some bytes have been read or\n written. Consequently the input stream may not be at end of stream and\n one, or both, streams may be in an inconsistent state. It is strongly\n recommended that both streams be promptly closed if an I/O error occurs."
                }
              ]
            }
          ]
        },
        {
          "name": "InputStreamReader",
          "methods": [
            {
              "name": "InputStreamReader",
              "overloads": [
                {
                  "signature": "public InputStreamReader(InputStream in)",
                  "description": "Creates an InputStreamReader that uses the\n default charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException",
                  "description": "Creates an InputStreamReader that uses the named charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, Charset cs)",
                  "description": "Creates an InputStreamReader that uses the given charset."
                },
                {
                  "signature": "public InputStreamReader(InputStream in, CharsetDecoder dec)",
                  "description": "Creates an InputStreamReader that uses the given charset decoder."
                }
              ]
            },
            {
              "name": "getEncoding",
              "overloads": [
                {
                  "signature": "public String getEncoding()",
                  "description": "Returns the name of the character encoding being used by this stream.\n\n  If the encoding has an historical name then that name is returned;\n otherwise the encoding's canonical name is returned.\n\n  If this instance was created with the InputStreamReader(InputStream, String) constructor then the returned\n name, being unique for the encoding, may differ from the name passed to\n the constructor. This method will return null if the\n stream has been closed."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read.  An InputStreamReader is\n ready if its input buffer is not empty, or if bytes are available to be\n read from the underlying byte stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Reader"
                }
              ]
            }
          ]
        },
        {
          "name": "Interface",
          "methods": []
        },
        {
          "name": "InterruptedIOException",
          "methods": [
            {
              "name": "InterruptedIOException",
              "overloads": [
                {
                  "signature": "public InterruptedIOException()",
                  "description": "Constructs an InterruptedIOException with\n null as its error detail message."
                },
                {
                  "signature": "public InterruptedIOException(String s)",
                  "description": "Constructs an InterruptedIOException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidClassException",
          "methods": [
            {
              "name": "InvalidClassException",
              "overloads": [
                {
                  "signature": "public InvalidClassException(String reason)",
                  "description": "Report an InvalidClassException for the reason specified."
                },
                {
                  "signature": "public InvalidClassException(String cname, String reason)",
                  "description": "Constructs an InvalidClassException object."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Produce the message and include the classname, if present."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidObjectException",
          "methods": [
            {
              "name": "InvalidObjectException",
              "overloads": [
                {
                  "signature": "public InvalidObjectException(String reason)",
                  "description": "Constructs an InvalidObjectException."
                }
              ]
            }
          ]
        },
        {
          "name": "IOError",
          "methods": [
            {
              "name": "IOError",
              "overloads": [
                {
                  "signature": "public IOError(Throwable cause)",
                  "description": "Constructs a new instance of IOError with the specified cause. The\n IOError is created with the detail message of\n (cause==null ? null : cause.toString()) (which typically\n contains the class and detail message of cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "IOException",
          "methods": [
            {
              "name": "IOException",
              "overloads": [
                {
                  "signature": "public IOException()",
                  "description": "Constructs an IOException with null\n as its error detail message."
                },
                {
                  "signature": "public IOException(String message)",
                  "description": "Constructs an IOException with the specified detail message."
                },
                {
                  "signature": "public IOException(String message, Throwable cause)",
                  "description": "Constructs an IOException with the specified detail message\n and cause.\n\n  Note that the detail message associated with cause is\n not automatically incorporated into this exception's detail\n message."
                },
                {
                  "signature": "public IOException(Throwable cause)",
                  "description": "Constructs an IOException with the specified cause and a\n detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of cause).\n This constructor is useful for IO exceptions that are little more\n than wrappers for other throwables."
                }
              ]
            }
          ]
        },
        {
          "name": "LineNumberInputStream",
          "methods": [
            {
              "name": "LineNumberInputStream",
              "overloads": [
                {
                  "signature": "public LineNumberInputStream(InputStream in)",
                  "description": "Constructs a newline number input stream that reads its input\n from the specified input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n \n The read method of\n LineNumberInputStream calls the read\n method of the underlying input stream. It checks for carriage\n returns and newline characters in the input, and modifies the\n current line number as appropriate. A carriage-return character or\n a carriage return followed by a newline character are both\n converted into a single newline character.",
                  "deprecated": true
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes. This method blocks until some input is available.\n \n The read method of\n LineNumberInputStream repeatedly calls the\n read method of zero arguments to fill in the byte array.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly 0. The actual number of bytes skipped is\n returned.  If n is negative, no bytes are skipped.\n \n The skip method of LineNumberInputStream creates\n a byte array and then repeatedly reads into it until\n n bytes have been read or the end of the stream has\n been reached.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setLineNumber",
              "overloads": [
                {
                  "signature": "public void setLineNumber(int lineNumber)",
                  "description": "Sets the line number to the specified argument.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Returns the current line number.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this input\n stream without blocking.\n \n Note that if the underlying input stream is able to supply\n k input characters without blocking, the\n LineNumberInputStream can guarantee only to provide\n k/2 characters without blocking, because the\n k characters from the underlying input stream might\n consist of k/2 pairs of '\\r' and\n '\\n', which are converted to just\n k/2 '\\n' characters.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream. A subsequent\n call to the reset method repositions this stream at\n the last marked position so that subsequent reads re-read the same bytes.\n \n The mark method of\n LineNumberInputStream remembers the current line\n number in a private variable, and then calls the mark\n method of the underlying input stream.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n \n The reset method of\n LineNumberInputStream resets the line number to be\n the line number at the time the mark method was\n called, and then calls the reset method of the\n underlying input stream.\n \n Stream marks are intended to be used in\n situations where you need to read ahead a little to see what's in\n the stream. Often this is most easily done by invoking some\n general parser. If the stream is of the type handled by the\n parser, it just chugs along happily. If the stream is not of\n that type, the parser should toss an exception when it fails,\n which, if it happens within readlimit bytes, allows the outer\n code to reset the stream and try another parser.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "LineNumberReader",
          "methods": [
            {
              "name": "LineNumberReader",
              "overloads": [
                {
                  "signature": "public LineNumberReader(Reader in)",
                  "description": "Create a new line-numbering reader, using the default input-buffer\n size."
                },
                {
                  "signature": "public LineNumberReader(Reader in, int sz)",
                  "description": "Create a new line-numbering reader, reading characters into a buffer of\n the given size."
                }
              ]
            },
            {
              "name": "setLineNumber",
              "overloads": [
                {
                  "signature": "public void setLineNumber(int lineNumber)",
                  "description": "Set the current line number."
                }
              ]
            },
            {
              "name": "getLineNumber",
              "overloads": [
                {
                  "signature": "public int getLineNumber()",
                  "description": "Get the current line number."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Read a single character.  Line terminators are\n compressed into single newline ('\\n') characters.  The current line\n number is incremented whenever a line terminator is read, or when the\n end of the stream is reached and the last character in the stream is\n not a line terminator."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf.\n\n Line terminators are compressed into single newline\n ('\\n') characters.  The current line number is incremented whenever a\n line terminator is read, or when the end of the stream is reached and\n the last character in the stream is not a line terminator."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public String readLine() throws IOException",
                  "description": "Read a line of text.  Line terminators are compressed\n into single newline ('\\n') characters. The current line number is\n incremented whenever a line terminator is read, or when the end of the\n stream is reached and the last character in the stream is not a line\n terminator."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Mark the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point, and will also reset\n the line number appropriately."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Reset the stream to the most recent mark."
                }
              ]
            }
          ]
        },
        {
          "name": "NotActiveException",
          "methods": [
            {
              "name": "NotActiveException",
              "overloads": [
                {
                  "signature": "public NotActiveException(String reason)",
                  "description": "Constructor to create a new NotActiveException with the reason given."
                },
                {
                  "signature": "public NotActiveException()",
                  "description": "Constructor to create a new NotActiveException without a reason."
                }
              ]
            }
          ]
        },
        {
          "name": "NotSerializableException",
          "methods": [
            {
              "name": "NotSerializableException",
              "overloads": [
                {
                  "signature": "public NotSerializableException(String classname)",
                  "description": "Constructs a NotSerializableException object with message string."
                },
                {
                  "signature": "public NotSerializableException()",
                  "description": "Constructs a NotSerializableException object."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInput",
          "methods": [
            {
              "name": "readObject",
              "overloads": [
                {
                  "signature": "Object readObject() throws ClassNotFoundException, IOException",
                  "description": "Read and return an object. The class that implements this interface\n defines where the object is \"read\" from."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "int read() throws IOException",
                  "description": "Reads a byte of data. This method will block if no input is\n available."
                },
                {
                  "signature": "int read(byte[] b) throws IOException",
                  "description": "Reads into an array of bytes.  This method will\n block until some input is available."
                },
                {
                  "signature": "int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads into an array of bytes.  This method will\n block until some input is available."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "long skip(long n) throws IOException",
                  "description": "Skips n bytes of input."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "int available() throws IOException",
                  "description": "Returns the number of bytes that can be read\n without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes the input stream. Must be called\n to release any resources associated with\n the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter",
          "methods": [
            {
              "name": "checkInput",
              "overloads": [
                {
                  "signature": "ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo filterInfo)",
                  "description": "Check the class, array length, number of object references, depth,\n stream size, and other available filtering information.\n Implementations of this method check the contents of the object graph being created\n during deserialization. The filter returns Status.ALLOWED,\n Status.REJECTED, or Status.UNDECIDED.\n\n If filterInfo.serialClass() is non-null, there is a class to be checked.\n If serialClass() is null, there is no class and the info contains\n only metrics related to the depth of the graph being deserialized, the number of\n references, and the size of the stream read."
                }
              ]
            },
            {
              "name": "allowFilter",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter allowFilter(Predicate<Class<?>> predicate, ObjectInputFilter.Status otherStatus)",
                  "description": "Returns a filter that returns Status.ALLOWED if the predicate\n on the class is true.\n The filter returns ALLOWED or the otherStatus based on the predicate\n of the non-null class and UNDECIDED if the class is null.\n\n When the filter's checkInput(info) method is invoked,\n the predicate is applied to the info.serialClass(),\n the return Status is:\n \n     UNDECIDED, if the serialClass is null,\n     ALLOWED, if the predicate on the class returns true,\n     Otherwise, return otherStatus.\n \n \n Example, to create a filter that will allow any class loaded from the platform\n or bootstrap classloaders.\n \n     ObjectInputFilter f\n         = allowFilter(cl -> cl.getClassLoader() == ClassLoader.getPlatformClassLoader() ||\n                       cl.getClassLoader() == null, Status.UNDECIDED);"
                }
              ]
            },
            {
              "name": "rejectFilter",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter rejectFilter(Predicate<Class<?>> predicate, ObjectInputFilter.Status otherStatus)",
                  "description": "Returns a filter that returns Status.REJECTED if the predicate\n on the class is true.\n The filter returns REJECTED or the otherStatus based on the predicate\n of the non-null class and UNDECIDED if the class is null.\n\n When the filter's checkInput(info) method is invoked,\n the predicate is applied to the serialClass(),\n the return Status is:\n \n     UNDECIDED, if the serialClass is null,\n     REJECTED, if the predicate on the class returns true,\n     Otherwise, return otherStatus.\n \n \n Example, to create a filter that will reject any class loaded from the application classloader.\n \n     ObjectInputFilter f = rejectFilter(cl ->\n          cl.getClassLoader() == ClassLoader.ClassLoader.getSystemClassLoader(), Status.UNDECIDED);"
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter merge(ObjectInputFilter filter, ObjectInputFilter anotherFilter)",
                  "description": "Returns a filter that merges the status of a filter and another filter.\n If another filter is null, the filter is returned.\n Otherwise, a filter is returned to merge the pair of non-null filters.\n\n The filter returned implements the checkInput(FilterInfo) method\n as follows:\n \n     Invoke filter on the FilterInfo to get its status;\n     Return REJECTED if the status is REJECTED;\n     Invoke anotherFilter to get the otherStatus;\n     Return REJECTED if the otherStatus is REJECTED;\n     Return ALLOWED, if either status or otherStatus\n          is ALLOWED, \n     Otherwise, return UNDECIDED"
                }
              ]
            },
            {
              "name": "rejectUndecidedClass",
              "overloads": [
                {
                  "signature": "static ObjectInputFilter rejectUndecidedClass(ObjectInputFilter filter)",
                  "description": "Returns a filter that invokes a given filter and maps UNDECIDED to REJECTED\n for classes, with some special cases, and otherwise returns the status.\n If the class is not a primitive class and not an array, the status returned is REJECTED.\n If the class is a primitive class or an array class additional checks are performed;\n see the list below for details.\n\n Object deserialization accepts a class if the filter returns UNDECIDED.\n Adding a filter to reject undecided results for classes that have not been\n either allowed or rejected can prevent classes from slipping through the filter."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter.Config",
          "methods": [
            {
              "name": "getSerialFilter",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter getSerialFilter()",
                  "description": "Returns the static JVM-wide deserialization filter or null if not configured."
                }
              ]
            },
            {
              "name": "setSerialFilter",
              "overloads": [
                {
                  "signature": "public static void setSerialFilter(ObjectInputFilter filter)",
                  "description": "Set the static JVM-wide filter if it has not already been configured or set."
                }
              ]
            },
            {
              "name": "getSerialFilterFactory",
              "overloads": [
                {
                  "signature": "public static BinaryOperator<ObjectInputFilter> getSerialFilterFactory()",
                  "description": "Returns the JVM-wide deserialization filter factory.\n If the filter factory has been set it is returned,\n otherwise, a builtin deserialization filter factory is returned.\n The filter factory provides a filter for every ObjectInputStream when invoked from\n ObjectInputStream constructors\n and when a stream-specific filter is set with\n setObjectInputFilter."
                }
              ]
            },
            {
              "name": "setSerialFilterFactory",
              "overloads": [
                {
                  "signature": "public static void setSerialFilterFactory(BinaryOperator<ObjectInputFilter> filterFactory)",
                  "description": "Set the JVM-wide deserialization filter factory.\n The filter factory can be configured exactly once with one of:\n setting the jdk.serialFilterFactory property on the command line,\n setting the jdk.serialFilterFactory property in the Security\n file, or using this setSerialFilterFactory method.\n The filter factory can be set only before any ObjectInputStream has been\n created to avoid any inconsistency in which filter factory is being used.\n\n The JVM-wide filter factory is invoked when an ObjectInputStream\n is constructed and when the\n stream-specific filter is set.\n The parameters are the current filter and a requested filter and it\n returns the filter to be used for the stream.\n If the current filter is non-null, the filter factory must return a\n non-null filter; this is to prevent unintentional disabling of filtering\n after it has been enabled.\n The factory determines the filter to be used for ObjectInputStream streams based\n on its inputs, any other filters, context, or state that is available.\n The factory may throw runtime exceptions to signal incorrect use or invalid parameters.\n See the filter models for examples of composition and delegation."
                }
              ]
            },
            {
              "name": "createFilter",
              "overloads": [
                {
                  "signature": "public static ObjectInputFilter createFilter(String pattern)",
                  "description": "Returns an ObjectInputFilter from a string of patterns.\n \n Patterns are separated by \";\" (semicolon). Whitespace is significant and\n is considered part of the pattern.\n If a pattern includes an equals assignment, \"=\" it sets a limit.\n If a limit appears more than once the last value is used.\n \n     maxdepth=value - the maximum depth of a graph\n     maxrefs=value  - the maximum number of internal references\n     maxbytes=value - the maximum number of bytes in the input stream\n     maxarray=value - the maximum array length allowed\n \n \n Other patterns match or reject class or package name\n as returned from Class.getName() and\n if an optional module name is present\n class.getModule().getName().\n Note that for arrays the element type is used in the pattern,\n not the array type.\n \n If the pattern starts with \"!\", the class is rejected if the remaining pattern is matched;\n     otherwise the class is allowed if the pattern matches.\n If the pattern contains \"/\", the non-empty prefix up to the \"/\" is the module name;\n     if the module name matches the module name of the class then\n     the remaining pattern is matched with the class name.\n     If there is no \"/\", the module name is not compared.\n If the pattern ends with \".**\" it matches any class in the package and all subpackages.\n If the pattern ends with \".*\" it matches any class in the package.\n If the pattern ends with \"*\", it matches any class with the pattern as a prefix.\n If the pattern is equal to the class name, it matches.\n Otherwise, the pattern is not matched.\n \n \n The resulting filter performs the limit checks and then\n tries to match the class, if any. If any of the limits are exceeded,\n the filter returns Status.REJECTED.\n If the class is an array type, the class to be matched is the element type.\n Arrays of any number of dimensions are treated the same as the element type.\n For example, a pattern of \"!example.Foo\",\n rejects creation of any instance or array of example.Foo.\n The first pattern that matches, working from left to right, determines\n the Status.ALLOWED\n or Status.REJECTED result.\n If the limits are not exceeded and no pattern matches the class,\n the result is Status.UNDECIDED."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputFilter.FilterInfo",
          "methods": [
            {
              "name": "serialClass",
              "overloads": [
                {
                  "signature": "Class<?> serialClass()",
                  "description": "The class of an object being deserialized.\n For arrays, it is the array type.\n For example, the array class name of a 2 dimensional array of strings is\n \"[[Ljava.lang.String;\".\n To check the array's element type, iteratively use\n Class.getComponentType while the result\n is an array and then check the class.\n The serialClass is null in the case where a new object is not being\n created and to give the filter a chance to check the depth, number of\n references to existing objects, and the stream size."
                }
              ]
            },
            {
              "name": "arrayLength",
              "overloads": [
                {
                  "signature": "long arrayLength()",
                  "description": "The number of array elements when deserializing an array of the class."
                }
              ]
            },
            {
              "name": "depth",
              "overloads": [
                {
                  "signature": "long depth()",
                  "description": "The current depth.\n The depth starts at 1 and increases for each nested object and\n decrements when each nested object returns."
                }
              ]
            },
            {
              "name": "references",
              "overloads": [
                {
                  "signature": "long references()",
                  "description": "The current number of object references."
                }
              ]
            },
            {
              "name": "streamBytes",
              "overloads": [
                {
                  "signature": "long streamBytes()",
                  "description": "The current number of bytes consumed."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputStream",
          "methods": [
            {
              "name": "ObjectInputStream",
              "overloads": [
                {
                  "signature": "public ObjectInputStream(InputStream in) throws IOException",
                  "description": "Creates an ObjectInputStream that reads from the specified InputStream.\n A serialization stream header is read from the stream and verified.\n This constructor will block until the corresponding ObjectOutputStream\n has written and flushed the header.\n\n The constructor initializes the deserialization filter to the filter returned\n by invoking the ObjectInputFilter.Config.getSerialFilterFactory() with null for the current filter\n and the static JVM-wide filter for the requested filter.\n\n If a security manager is installed, this constructor will check for\n the \"enableSubclassImplementation\" SerializablePermission when invoked\n directly or indirectly by the constructor of a subclass which overrides\n the ObjectInputStream.readFields or ObjectInputStream.readUnshared\n methods."
                },
                {
                  "signature": "protected ObjectInputStream() throws IOException, SecurityException",
                  "description": "Provide a way for subclasses that are completely reimplementing\n ObjectInputStream to not have to allocate private data just used by this\n implementation of ObjectInputStream.\n\n The constructor initializes the deserialization filter to the filter returned\n by invoking the ObjectInputFilter.Config.getSerialFilterFactory() with null for the current filter\n and the static JVM-wide filter for the requested filter.\n\n If there is a security manager installed, this method first calls the\n security manager's checkPermission method with the\n SerializablePermission(\"enableSubclassImplementation\")\n permission to ensure it's ok to enable subclassing."
                }
              ]
            },
            {
              "name": "readObject",
              "overloads": [
                {
                  "signature": "public final Object readObject() throws IOException, ClassNotFoundException",
                  "description": "Read an object from the ObjectInputStream.  The class of the object, the\n signature of the class, and the values of the non-transient and\n non-static fields of the class and all of its supertypes are read.\n Default deserializing for a class can be overridden using the writeObject\n and readObject methods.  Objects referenced by this object are read\n transitively so that a complete equivalent graph of objects is\n reconstructed by readObject.\n\n The root object is completely restored when all of its fields and the\n objects it references are completely restored.  At this point the object\n validation callbacks are executed in order based on their registered\n priorities. The callbacks are registered by objects (in the readObject\n special methods) as they are individually restored.\n\n The deserialization filter, when not null, is invoked for\n each object (regular or class) read to reconstruct the root object.\n See setObjectInputFilter for details.\n\n Exceptions are thrown for problems with the InputStream and for\n classes that should not be deserialized.  All exceptions are fatal to\n the InputStream and leave it in an indeterminate state; it is up to the\n caller to ignore or recover the stream state."
                }
              ]
            },
            {
              "name": "readObjectOverride",
              "overloads": [
                {
                  "signature": "protected Object readObjectOverride() throws IOException, ClassNotFoundException",
                  "description": "This method is called by trusted subclasses of ObjectInputStream that\n constructed ObjectInputStream using the protected no-arg constructor.\n The subclass is expected to provide an override method with the modifier\n \"final\"."
                }
              ]
            },
            {
              "name": "readUnshared",
              "overloads": [
                {
                  "signature": "public Object readUnshared() throws IOException, ClassNotFoundException",
                  "description": "Reads an \"unshared\" object from the ObjectInputStream.  This method is\n identical to readObject, except that it prevents subsequent calls to\n readObject and readUnshared from returning additional references to the\n deserialized instance obtained via this call.  Specifically:\n \n   If readUnshared is called to deserialize a back-reference (the\n       stream representation of an object which has been written\n       previously to the stream), an ObjectStreamException will be\n       thrown.\n\n   If readUnshared returns successfully, then any subsequent attempts\n       to deserialize back-references to the stream handle deserialized\n       by readUnshared will cause an ObjectStreamException to be thrown.\n \n Deserializing an object via readUnshared invalidates the stream handle\n associated with the returned object.  Note that this in itself does not\n always guarantee that the reference returned by readUnshared is unique;\n the deserialized object may define a readResolve method which returns an\n object visible to other parties, or readUnshared may return a Class\n object or enum constant obtainable elsewhere in the stream or through\n external means. If the deserialized object defines a readResolve method\n and the invocation of that method returns an array, then readUnshared\n returns a shallow clone of that array; this guarantees that the returned\n array object is unique and cannot be obtained a second time from an\n invocation of readObject or readUnshared on the ObjectInputStream,\n even if the underlying data stream has been manipulated.\n\n The deserialization filter, when not null, is invoked for\n each object (regular or class) read to reconstruct the root object.\n See setObjectInputFilter for details.\n\n ObjectInputStream subclasses which override this method can only be\n constructed in security contexts possessing the\n \"enableSubclassImplementation\" SerializablePermission; any attempt to\n instantiate such a subclass without this permission will cause a\n SecurityException to be thrown."
                }
              ]
            },
            {
              "name": "defaultReadObject",
              "overloads": [
                {
                  "signature": "public void defaultReadObject() throws IOException, ClassNotFoundException",
                  "description": "Read the non-static and non-transient fields of the current class from\n this stream.  This may only be called from the readObject method of the\n class being deserialized. It will throw the NotActiveException if it is\n called otherwise."
                }
              ]
            },
            {
              "name": "readFields",
              "overloads": [
                {
                  "signature": "public ObjectInputStream.GetField readFields() throws IOException, ClassNotFoundException",
                  "description": "Reads the persistent fields from the stream and makes them available by\n name."
                }
              ]
            },
            {
              "name": "registerValidation",
              "overloads": [
                {
                  "signature": "public void registerValidation(ObjectInputValidation obj, int prio) throws NotActiveException, InvalidObjectException",
                  "description": "Register an object to be validated before the graph is returned.  While\n similar to resolveObject these validations are called after the entire\n graph has been reconstituted.  Typically, a readObject method will\n register the object with the stream so that when all of the objects are\n restored a final set of validations can be performed."
                }
              ]
            },
            {
              "name": "resolveClass",
              "overloads": [
                {
                  "signature": "protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException",
                  "description": "Load the local class equivalent of the specified stream class\n description.  Subclasses may implement this method to allow classes to\n be fetched from an alternate source.\n\n The corresponding method in ObjectOutputStream is\n annotateClass.  This method will be invoked only once for\n each unique class in the stream.  This method can be implemented by\n subclasses to use an alternate loading mechanism but must return a\n Class object. Once returned, if the class is not an array\n class, its serialVersionUID is compared to the serialVersionUID of the\n serialized class, and if there is a mismatch, the deserialization fails\n and an InvalidClassException is thrown.\n\n The default implementation of this method in\n ObjectInputStream returns the result of calling\n      Class.forName(desc.getName(), false, loader)\n \n where loader is the first class loader on the current\n thread's stack (starting from the currently executing method) that is\n neither the platform\n class loader nor its ancestor; otherwise, loader is the\n platform class loader. If this call results in a\n ClassNotFoundException and the name of the passed\n ObjectStreamClass instance is the Java language keyword\n for a primitive type or void, then the Class object\n representing that primitive type or void will be returned\n (e.g., an ObjectStreamClass with the name\n \"int\" will be resolved to Integer.TYPE).\n Otherwise, the ClassNotFoundException will be thrown to\n the caller of this method."
                }
              ]
            },
            {
              "name": "resolveProxyClass",
              "overloads": [
                {
                  "signature": "protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException",
                  "description": "Returns a proxy class that implements the interfaces named in a proxy\n class descriptor; subclasses may implement this method to read custom\n data from the stream along with the descriptors for dynamic proxy\n classes, allowing them to use an alternate loading mechanism for the\n interfaces and the proxy class.\n\n This method is called exactly once for each unique proxy class\n descriptor in the stream.\n\n The corresponding method in ObjectOutputStream is\n annotateProxyClass.  For a given subclass of\n ObjectInputStream that overrides this method, the\n annotateProxyClass method in the corresponding subclass of\n ObjectOutputStream must write any data or objects read by\n this method.\n\n The default implementation of this method in\n ObjectInputStream returns the result of calling\n Proxy.getProxyClass with the list of Class\n objects for the interfaces that are named in the interfaces\n parameter.  The Class object for each interface name\n i is the value returned by calling\n      Class.forName(i, false, loader)\n \n where loader is the first class loader on the current\n thread's stack (starting from the currently executing method) that is\n neither the platform\n class loader nor its ancestor; otherwise, loader is the\n platform class loader.\n Unless any of the resolved interfaces are non-public, this same value\n of loader is also the class loader passed to\n Proxy.getProxyClass; if non-public interfaces are present,\n their class loader is passed instead (if more than one non-public\n interface class loader is encountered, an\n IllegalAccessError is thrown).\n If Proxy.getProxyClass throws an\n IllegalArgumentException, resolveProxyClass\n will throw a ClassNotFoundException containing the\n IllegalArgumentException."
                }
              ]
            },
            {
              "name": "resolveObject",
              "overloads": [
                {
                  "signature": "protected Object resolveObject(Object obj) throws IOException",
                  "description": "This method will allow trusted subclasses of ObjectInputStream to\n substitute one object for another during deserialization. Replacing\n objects is disabled until enableResolveObject is called. The\n enableResolveObject method checks that the stream requesting to resolve\n object can be trusted. Every reference to serializable objects is passed\n to resolveObject.  To insure that the private state of objects is not\n unintentionally exposed only trusted streams may use resolveObject.\n\n This method is called after an object has been read but before it is\n returned from readObject.  The default resolveObject method just returns\n the same object.\n\n When a subclass is replacing objects it must insure that the\n substituted object is compatible with every field where the reference\n will be stored.  Objects whose type is not a subclass of the type of the\n field or array element abort the deserialization by raising an exception\n and the object is not be stored.\n\n This method is called only once when each object is first\n encountered.  All subsequent references to the object will be redirected\n to the new object."
                }
              ]
            },
            {
              "name": "enableResolveObject",
              "overloads": [
                {
                  "signature": "protected boolean enableResolveObject(boolean enable) throws SecurityException",
                  "description": "Enables the stream to do replacement of objects read from the stream. When\n enabled, the resolveObject(java.lang.Object) method is called for every object being\n deserialized.\n\n If object replacement is currently not enabled, and\n enable is true, and there is a security manager installed,\n this method first calls the security manager's\n checkPermission method with the\n SerializablePermission(\"enableSubstitution\") permission to\n ensure that the caller is permitted to enable the stream to do replacement\n of objects read from the stream."
                }
              ]
            },
            {
              "name": "readStreamHeader",
              "overloads": [
                {
                  "signature": "protected void readStreamHeader() throws IOException, StreamCorruptedException",
                  "description": "The readStreamHeader method is provided to allow subclasses to read and\n verify their own stream headers. It reads and verifies the magic number\n and version number."
                }
              ]
            },
            {
              "name": "readClassDescriptor",
              "overloads": [
                {
                  "signature": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException",
                  "description": "Read a class descriptor from the serialization stream.  This method is\n called when the ObjectInputStream expects a class descriptor as the next\n item in the serialization stream.  Subclasses of ObjectInputStream may\n override this method to read in class descriptors that have been written\n in non-standard formats (by subclasses of ObjectOutputStream which have\n overridden the writeClassDescriptor method).  By default,\n this method reads class descriptors according to the format defined in\n the Object Serialization specification."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data. This method will block if no input is available."
                },
                {
                  "signature": "public int read(byte[] buf, int off, int len) throws IOException",
                  "description": "Reads into an array of bytes.  This method will block until some input\n is available. Consider using java.io.DataInputStream.readFully to read\n exactly 'length' bytes."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the input stream. Must be called to release any resources\n associated with the stream."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public boolean readBoolean() throws IOException",
                  "description": "Reads in a boolean."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public byte readByte() throws IOException",
                  "description": "Reads an 8 bit byte."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public int readUnsignedByte() throws IOException",
                  "description": "Reads an unsigned 8 bit byte."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public char readChar() throws IOException",
                  "description": "Reads a 16 bit char."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public short readShort() throws IOException",
                  "description": "Reads a 16 bit short."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public int readUnsignedShort() throws IOException",
                  "description": "Reads an unsigned 16 bit short."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public int readInt() throws IOException",
                  "description": "Reads a 32 bit int."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public long readLong() throws IOException",
                  "description": "Reads a 64 bit long."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public float readFloat() throws IOException",
                  "description": "Reads a 32 bit float."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public double readDouble() throws IOException",
                  "description": "Reads a 64 bit double."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public void readFully(byte[] buf) throws IOException",
                  "description": "Reads bytes, blocking until all bytes are read."
                },
                {
                  "signature": "public void readFully(byte[] buf, int off, int len) throws IOException",
                  "description": "Reads bytes, blocking until all bytes are read."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public int skipBytes(int len) throws IOException",
                  "description": "Skips bytes."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "@Deprecated public String readLine() throws IOException",
                  "description": "Reads in a line that has been terminated by a \\n, \\r, \\r\\n or EOF.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public String readUTF() throws IOException",
                  "description": "Reads a String in\n modified UTF-8\n format."
                }
              ]
            },
            {
              "name": "getObjectInputFilter",
              "overloads": [
                {
                  "signature": "public final ObjectInputFilter getObjectInputFilter()",
                  "description": "Returns the deserialization filter for this stream.\n The filter is the result of invoking the\n JVM-wide filter factory\n either by the constructor or the most recent invocation of\n setObjectInputFilter."
                }
              ]
            },
            {
              "name": "setObjectInputFilter",
              "overloads": [
                {
                  "signature": "public final void setObjectInputFilter(ObjectInputFilter filter)",
                  "description": "Set the deserialization filter for the stream.\n\n The deserialization filter is set to the filter returned by invoking the\n JVM-wide filter factory\n with the current filter and the filter parameter.\n The current filter was set in the\n ObjectInputStream constructors by invoking the\n JVM-wide filter factory and may be null.\n setObjectInputFilter(ObjectInputFilter) This method} can be called\n once and only once before reading any objects from the stream;\n for example, by calling readObject() or readUnshared().\n\n It is not permitted to replace a non-null filter with a null filter.\n If the current filter is non-null,\n the value returned from the filter factory must be non-null.\n\n The filter's checkInput method is called\n for each class and reference in the stream.\n The filter can check any or all of the class, the array length, the number\n of references, the depth of the graph, and the size of the input stream.\n The depth is the number of nested readObject\n calls starting with the reading of the root of the graph being deserialized\n and the current object being deserialized.\n The number of references is the cumulative number of objects and references\n to objects already read from the stream including the current object being read.\n The filter is invoked only when reading objects from the stream and not for\n primitives.\n \n If the filter returns Status.REJECTED,\n null or throws a RuntimeException,\n the active readObject or readUnshared\n throws InvalidClassException, otherwise deserialization\n continues uninterrupted."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputStream.GetField",
          "methods": [
            {
              "name": "GetField",
              "overloads": [
                {
                  "signature": "public GetField()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getObjectStreamClass",
              "overloads": [
                {
                  "signature": "public abstract ObjectStreamClass getObjectStreamClass()",
                  "description": "Get the ObjectStreamClass that describes the fields in the stream."
                }
              ]
            },
            {
              "name": "defaulted",
              "overloads": [
                {
                  "signature": "public abstract boolean defaulted(String name) throws IOException",
                  "description": "Return true if the named field is defaulted and has no value in this\n stream."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract boolean get(String name, boolean val) throws IOException",
                  "description": "Get the value of the named boolean field from the persistent field."
                },
                {
                  "signature": "public abstract byte get(String name, byte val) throws IOException",
                  "description": "Get the value of the named byte field from the persistent field."
                },
                {
                  "signature": "public abstract char get(String name, char val) throws IOException",
                  "description": "Get the value of the named char field from the persistent field."
                },
                {
                  "signature": "public abstract short get(String name, short val) throws IOException",
                  "description": "Get the value of the named short field from the persistent field."
                },
                {
                  "signature": "public abstract int get(String name, int val) throws IOException",
                  "description": "Get the value of the named int field from the persistent field."
                },
                {
                  "signature": "public abstract long get(String name, long val) throws IOException",
                  "description": "Get the value of the named long field from the persistent field."
                },
                {
                  "signature": "public abstract float get(String name, float val) throws IOException",
                  "description": "Get the value of the named float field from the persistent field."
                },
                {
                  "signature": "public abstract double get(String name, double val) throws IOException",
                  "description": "Get the value of the named double field from the persistent field."
                },
                {
                  "signature": "public abstract Object get(String name, Object val) throws IOException",
                  "description": "Get the value of the named Object field from the persistent field."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectInputValidation",
          "methods": [
            {
              "name": "validateObject",
              "overloads": [
                {
                  "signature": "void validateObject() throws InvalidObjectException",
                  "description": "Validates the object."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutput",
          "methods": [
            {
              "name": "writeObject",
              "overloads": [
                {
                  "signature": "void writeObject(Object obj) throws IOException",
                  "description": "Write an object to the underlying storage or stream.  The\n class that implements this interface defines how the object is\n written."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "void write(int b) throws IOException",
                  "description": "Writes a byte. This method will block until the byte is actually\n written."
                },
                {
                  "signature": "void write(byte[] b) throws IOException",
                  "description": "Writes an array of bytes. This method will block until the bytes\n are actually written."
                },
                {
                  "signature": "void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes a sub array of bytes."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "void flush() throws IOException",
                  "description": "Flushes the stream. This will write any buffered\n output bytes."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "void close() throws IOException",
                  "description": "Closes the stream. This method must be called\n to release any resources associated with the\n stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutputStream",
          "methods": [
            {
              "name": "ObjectOutputStream",
              "overloads": [
                {
                  "signature": "public ObjectOutputStream(OutputStream out) throws IOException",
                  "description": "Creates an ObjectOutputStream that writes to the specified OutputStream.\n This constructor writes the serialization stream header to the\n underlying stream; callers may wish to flush the stream immediately to\n ensure that constructors for receiving ObjectInputStreams will not block\n when reading the header.\n\n If a security manager is installed, this constructor will check for\n the \"enableSubclassImplementation\" SerializablePermission when invoked\n directly or indirectly by the constructor of a subclass which overrides\n the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n methods."
                },
                {
                  "signature": "protected ObjectOutputStream() throws IOException, SecurityException",
                  "description": "Provide a way for subclasses that are completely reimplementing\n ObjectOutputStream to not have to allocate private data just used by\n this implementation of ObjectOutputStream.\n\n If there is a security manager installed, this method first calls the\n security manager's checkPermission method with a\n SerializablePermission(\"enableSubclassImplementation\")\n permission to ensure it's ok to enable subclassing."
                }
              ]
            },
            {
              "name": "useProtocolVersion",
              "overloads": [
                {
                  "signature": "public void useProtocolVersion(int version) throws IOException",
                  "description": "Specify stream protocol version to use when writing the stream.\n\n This routine provides a hook to enable the current version of\n Serialization to write in a format that is backwards compatible to a\n previous version of the stream format.\n\n Every effort will be made to avoid introducing additional\n backwards incompatibilities; however, sometimes there is no\n other alternative."
                }
              ]
            },
            {
              "name": "writeObject",
              "overloads": [
                {
                  "signature": "public final void writeObject(Object obj) throws IOException",
                  "description": "Write the specified object to the ObjectOutputStream.  The class of the\n object, the signature of the class, and the values of the non-transient\n and non-static fields of the class and all of its supertypes are\n written.  Default serialization for a class can be overridden using the\n writeObject and the readObject methods.  Objects referenced by this\n object are written transitively so that a complete equivalent graph of\n objects can be reconstructed by an ObjectInputStream.\n\n Exceptions are thrown for problems with the OutputStream and for\n classes that should not be serialized.  All exceptions are fatal to the\n OutputStream, which is left in an indeterminate state, and it is up to\n the caller to ignore or recover the stream state."
                }
              ]
            },
            {
              "name": "writeObjectOverride",
              "overloads": [
                {
                  "signature": "protected void writeObjectOverride(Object obj) throws IOException",
                  "description": "Method used by subclasses to override the default writeObject method.\n This method is called by trusted subclasses of ObjectOutputStream that\n constructed ObjectOutputStream using the protected no-arg constructor.\n The subclass is expected to provide an override method with the modifier\n \"final\"."
                }
              ]
            },
            {
              "name": "writeUnshared",
              "overloads": [
                {
                  "signature": "public void writeUnshared(Object obj) throws IOException",
                  "description": "Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n identical to writeObject, except that it always writes the given object\n as a new, unique object in the stream (as opposed to a back-reference\n pointing to a previously serialized instance).  Specifically:\n \n   An object written via writeUnshared is always serialized in the\n       same manner as a newly appearing object (an object that has not\n       been written to the stream yet), regardless of whether or not the\n       object has been written previously.\n\n   If writeObject is used to write an object that has been previously\n       written with writeUnshared, the previous writeUnshared operation\n       is treated as if it were a write of a separate object.  In other\n       words, ObjectOutputStream will never generate back-references to\n       object data written by calls to writeUnshared.\n \n While writing an object via writeUnshared does not in itself guarantee a\n unique reference to the object when it is deserialized, it allows a\n single object to be defined multiple times in a stream, so that multiple\n calls to readUnshared by the receiver will not conflict.  Note that the\n rules described above only apply to the base-level object written with\n writeUnshared, and not to any transitively referenced sub-objects in the\n object graph to be serialized.\n\n ObjectOutputStream subclasses which override this method can only be\n constructed in security contexts possessing the\n \"enableSubclassImplementation\" SerializablePermission; any attempt to\n instantiate such a subclass without this permission will cause a\n SecurityException to be thrown."
                }
              ]
            },
            {
              "name": "defaultWriteObject",
              "overloads": [
                {
                  "signature": "public void defaultWriteObject() throws IOException",
                  "description": "Write the non-static and non-transient fields of the current class to\n this stream.  This may only be called from the writeObject method of the\n class being serialized. It will throw the NotActiveException if it is\n called otherwise."
                }
              ]
            },
            {
              "name": "putFields",
              "overloads": [
                {
                  "signature": "public ObjectOutputStream.PutField putFields() throws IOException",
                  "description": "Retrieve the object used to buffer persistent fields to be written to\n the stream.  The fields will be written to the stream when writeFields\n method is called."
                }
              ]
            },
            {
              "name": "writeFields",
              "overloads": [
                {
                  "signature": "public void writeFields() throws IOException",
                  "description": "Write the buffered fields to the stream."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Reset will disregard the state of any objects already written to the\n stream.  The state is reset to be the same as a new ObjectOutputStream.\n The current point in the stream is marked as reset so the corresponding\n ObjectInputStream will be reset at the same point.  Objects previously\n written to the stream will not be referred to as already being in the\n stream.  They will be written to the stream again."
                }
              ]
            },
            {
              "name": "annotateClass",
              "overloads": [
                {
                  "signature": "protected void annotateClass(Class<?> cl) throws IOException",
                  "description": "Subclasses may implement this method to allow class data to be stored in\n the stream. By default this method does nothing.  The corresponding\n method in ObjectInputStream is resolveClass.  This method is called\n exactly once for each unique class in the stream.  The class name and\n signature will have already been written to the stream.  This method may\n make free use of the ObjectOutputStream to save any representation of\n the class it deems suitable (for example, the bytes of the class file).\n The resolveClass method in the corresponding subclass of\n ObjectInputStream must read and use any data or objects written by\n annotateClass."
                }
              ]
            },
            {
              "name": "annotateProxyClass",
              "overloads": [
                {
                  "signature": "protected void annotateProxyClass(Class<?> cl) throws IOException",
                  "description": "Subclasses may implement this method to store custom data in the stream\n along with descriptors for dynamic proxy classes.\n\n This method is called exactly once for each unique proxy class\n descriptor in the stream.  The default implementation of this method in\n ObjectOutputStream does nothing.\n\n The corresponding method in ObjectInputStream is\n resolveProxyClass.  For a given subclass of\n ObjectOutputStream that overrides this method, the\n resolveProxyClass method in the corresponding subclass of\n ObjectInputStream must read any data or objects written by\n annotateProxyClass."
                }
              ]
            },
            {
              "name": "replaceObject",
              "overloads": [
                {
                  "signature": "protected Object replaceObject(Object obj) throws IOException",
                  "description": "This method will allow trusted subclasses of ObjectOutputStream to\n substitute one object for another during serialization. Replacing\n objects is disabled until enableReplaceObject is called. The\n enableReplaceObject method checks that the stream requesting to do\n replacement can be trusted.  The first occurrence of each object written\n into the serialization stream is passed to replaceObject.  Subsequent\n references to the object are replaced by the object returned by the\n original call to replaceObject.  To ensure that the private state of\n objects is not unintentionally exposed, only trusted streams may use\n replaceObject.\n\n The ObjectOutputStream.writeObject method takes a parameter of type\n Object (as opposed to type Serializable) to allow for cases where\n non-serializable objects are replaced by serializable ones.\n\n When a subclass is replacing objects it must insure that either a\n complementary substitution must be made during deserialization or that\n the substituted object is compatible with every field where the\n reference will be stored.  Objects whose type is not a subclass of the\n type of the field or array element abort the serialization by raising an\n exception and the object is not be stored.\n\n This method is called only once when each object is first\n encountered.  All subsequent references to the object will be redirected\n to the new object. This method should return the object to be\n substituted or the original object.\n\n Null can be returned as the object to be substituted, but may cause\n NullReferenceException in classes that contain references to the\n original object since they may be expecting an object instead of\n null."
                }
              ]
            },
            {
              "name": "enableReplaceObject",
              "overloads": [
                {
                  "signature": "protected boolean enableReplaceObject(boolean enable) throws SecurityException",
                  "description": "Enables the stream to do replacement of objects written to the stream.  When\n enabled, the replaceObject(java.lang.Object) method is called for every object being\n serialized.\n\n If object replacement is currently not enabled, and\n enable is true, and there is a security manager installed,\n this method first calls the security manager's\n checkPermission method with the\n SerializablePermission(\"enableSubstitution\") permission to\n ensure that the caller is permitted to enable the stream to do replacement\n of objects written to the stream."
                }
              ]
            },
            {
              "name": "writeStreamHeader",
              "overloads": [
                {
                  "signature": "protected void writeStreamHeader() throws IOException",
                  "description": "The writeStreamHeader method is provided so subclasses can append or\n prepend their own header to the stream.  It writes the magic number and\n version to the stream."
                }
              ]
            },
            {
              "name": "writeClassDescriptor",
              "overloads": [
                {
                  "signature": "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException",
                  "description": "Write the specified class descriptor to the ObjectOutputStream.  Class\n descriptors are used to identify the classes of objects written to the\n stream.  Subclasses of ObjectOutputStream may override this method to\n customize the way in which class descriptors are written to the\n serialization stream.  The corresponding method in ObjectInputStream,\n readClassDescriptor, should then be overridden to\n reconstitute the class descriptor from its custom stream representation.\n By default, this method writes class descriptors according to the format\n defined in the Object Serialization specification.\n\n Note that this method will only be called if the ObjectOutputStream\n is not using the old serialization stream format (set by calling\n ObjectOutputStream's useProtocolVersion method).  If this\n serialization stream is using the old format\n (PROTOCOL_VERSION_1), the class descriptor will be written\n internally in a manner that cannot be overridden or customized."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int val) throws IOException",
                  "description": "Writes a byte. This method will block until the byte is actually\n written."
                },
                {
                  "signature": "public void write(byte[] buf) throws IOException",
                  "description": "Writes an array of bytes. This method will block until the bytes are\n actually written."
                },
                {
                  "signature": "public void write(byte[] buf, int off, int len) throws IOException",
                  "description": "Writes a sub array of bytes."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream. This will write any buffered output bytes and flush\n through to the underlying stream."
                }
              ]
            },
            {
              "name": "drain",
              "overloads": [
                {
                  "signature": "protected void drain() throws IOException",
                  "description": "Drain any buffered data in ObjectOutputStream.  Similar to flush but\n does not propagate the flush to the underlying stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the stream. This method must be called to release any resources\n associated with the stream."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public void writeBoolean(boolean val) throws IOException",
                  "description": "Writes a boolean."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public void writeByte(int val) throws IOException",
                  "description": "Writes an 8 bit byte."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public void writeShort(int val) throws IOException",
                  "description": "Writes a 16 bit short."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public void writeChar(int val) throws IOException",
                  "description": "Writes a 16 bit char."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public void writeInt(int val) throws IOException",
                  "description": "Writes a 32 bit int."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public void writeLong(long val) throws IOException",
                  "description": "Writes a 64 bit long."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public void writeFloat(float val) throws IOException",
                  "description": "Writes a 32 bit float."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public void writeDouble(double val) throws IOException",
                  "description": "Writes a 64 bit double."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(String str) throws IOException",
                  "description": "Writes a String as a sequence of bytes."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public void writeChars(String str) throws IOException",
                  "description": "Writes a String as a sequence of chars."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public void writeUTF(String str) throws IOException",
                  "description": "Primitive data write of this String in\n modified UTF-8\n format.  Note that there is a\n significant difference between writing a String into the stream as\n primitive data or as an Object. A String instance written by writeObject\n is written into the stream as a String initially. Future writeObject()\n calls write references to the string into the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectOutputStream.PutField",
          "methods": [
            {
              "name": "PutField",
              "overloads": [
                {
                  "signature": "public PutField()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract void put(String name, boolean val)",
                  "description": "Put the value of the named boolean field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, byte val)",
                  "description": "Put the value of the named byte field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, char val)",
                  "description": "Put the value of the named char field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, short val)",
                  "description": "Put the value of the named short field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, int val)",
                  "description": "Put the value of the named int field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, long val)",
                  "description": "Put the value of the named long field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, float val)",
                  "description": "Put the value of the named float field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, double val)",
                  "description": "Put the value of the named double field into the persistent field."
                },
                {
                  "signature": "public abstract void put(String name, Object val)",
                  "description": "Put the value of the named Object field into the persistent field."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "@Deprecated public abstract void write(ObjectOutput out) throws IOException",
                  "description": "Write the data and fields to the specified ObjectOutput stream,\n which must be the same stream that produced this\n PutField object.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamClass",
          "methods": [
            {
              "name": "lookup",
              "overloads": [
                {
                  "signature": "public static ObjectStreamClass lookup(Class<?> cl)",
                  "description": "Find the descriptor for a class that can be serialized.  Creates an\n ObjectStreamClass instance if one does not exist yet for class. Null is\n returned if the specified class does not implement java.io.Serializable\n or java.io.Externalizable."
                }
              ]
            },
            {
              "name": "lookupAny",
              "overloads": [
                {
                  "signature": "public static ObjectStreamClass lookupAny(Class<?> cl)",
                  "description": "Returns the descriptor for any class, regardless of whether it\n implements Serializable."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the class described by this descriptor.\n This method returns the name of the class in the format that\n is used by the Class.getName() method."
                }
              ]
            },
            {
              "name": "getSerialVersionUID",
              "overloads": [
                {
                  "signature": "public long getSerialVersionUID()",
                  "description": "Return the serialVersionUID for this class.  The serialVersionUID\n defines a set of classes all with the same name that have evolved from a\n common root class and agree to be serialized and deserialized using a\n common format.  NonSerializable classes have a serialVersionUID of 0L."
                }
              ]
            },
            {
              "name": "forClass",
              "overloads": [
                {
                  "signature": "public Class<?> forClass()",
                  "description": "Return the class in the local VM that this version is mapped to.  Null\n is returned if there is no corresponding local class."
                }
              ]
            },
            {
              "name": "getFields",
              "overloads": [
                {
                  "signature": "public ObjectStreamField[] getFields()",
                  "description": "Return an array of the fields of this serializable class."
                }
              ]
            },
            {
              "name": "getField",
              "overloads": [
                {
                  "signature": "public ObjectStreamField getField(String name)",
                  "description": "Get the field of this class by name."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string describing this ObjectStreamClass."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamConstants",
          "methods": []
        },
        {
          "name": "ObjectStreamException",
          "methods": [
            {
              "name": "ObjectStreamException",
              "overloads": [
                {
                  "signature": "protected ObjectStreamException(String message)",
                  "description": "Create an ObjectStreamException with the specified argument."
                },
                {
                  "signature": "protected ObjectStreamException()",
                  "description": "Create an ObjectStreamException."
                }
              ]
            }
          ]
        },
        {
          "name": "ObjectStreamField",
          "methods": [
            {
              "name": "ObjectStreamField",
              "overloads": [
                {
                  "signature": "public ObjectStreamField(String name, Class<?> type)",
                  "description": "Create a Serializable field with the specified type.  This field should\n be documented with a serialField tag."
                },
                {
                  "signature": "public ObjectStreamField(String name, Class<?> type, boolean unshared)",
                  "description": "Creates an ObjectStreamField representing a serializable field with the\n given name and type.  If unshared is false, values of the represented\n field are serialized and deserialized in the default manner--if the\n field is non-primitive, object values are serialized and deserialized as\n if they had been written and read by calls to writeObject and\n readObject.  If unshared is true, values of the represented field are\n serialized and deserialized as if they had been written and read by\n calls to writeUnshared and readUnshared."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Get the name of this field."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public Class<?> getType()",
                  "description": "Get the type of the field.  If the type is non-primitive and this\n ObjectStreamField was obtained from a deserialized ObjectStreamClass instance, then Object.class is returned.\n Otherwise, the Class object for the type of the field is\n returned."
                }
              ]
            },
            {
              "name": "getTypeCode",
              "overloads": [
                {
                  "signature": "public char getTypeCode()",
                  "description": "Returns character encoding of field type.  The encoding is as follows:\n  B            byte\n C            char\n D            double\n F            float\n I            int\n J            long\n L            class or interface\n S            short\n Z            boolean\n [            array"
                }
              ]
            },
            {
              "name": "getTypeString",
              "overloads": [
                {
                  "signature": "public String getTypeString()",
                  "description": "Return the JVM type signature."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset()",
                  "description": "Offset of field within instance data."
                }
              ]
            },
            {
              "name": "setOffset",
              "overloads": [
                {
                  "signature": "protected void setOffset(int offset)",
                  "description": "Offset within instance data."
                }
              ]
            },
            {
              "name": "isPrimitive",
              "overloads": [
                {
                  "signature": "public boolean isPrimitive()",
                  "description": "Return true if this field has a primitive type."
                }
              ]
            },
            {
              "name": "isUnshared",
              "overloads": [
                {
                  "signature": "public boolean isUnshared()",
                  "description": "Returns boolean value indicating whether or not the serializable field\n represented by this ObjectStreamField instance is unshared."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Object obj)",
                  "description": "Compare this field with another ObjectStreamField.  Return\n -1 if this is smaller, 0 if equal, 1 if greater.  Types that are\n primitives are \"smaller\" than object types.  If equal, the field names\n are compared."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string that describes this field."
                }
              ]
            }
          ]
        },
        {
          "name": "OptionalDataException",
          "methods": []
        },
        {
          "name": "OutputStream",
          "methods": [
            {
              "name": "OutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "nullOutputStream",
              "overloads": [
                {
                  "signature": "public static OutputStream nullOutputStream()",
                  "description": "Returns a new OutputStream which discards all bytes.  The\n returned stream is initially open.  The stream is closed by calling\n the close() method.  Subsequent calls to close() have\n no effect.\n\n  While the stream is open, the write(int), \n write(byte[]), and write(byte[], int, int) methods do nothing.\n After the stream has been closed, these methods all throw \n IOException.\n\n  The flush() method does nothing."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public abstract void write(int b) throws IOException",
                  "description": "Writes the specified byte to this output stream. The general\n contract for write is that one byte is written\n to the output stream. The byte to be written is the eight\n low-order bits of the argument b. The 24\n high-order bits of b are ignored.\n \n Subclasses of OutputStream must provide an\n implementation for this method."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this output stream. The general contract for write(b)\n is that it should have exactly the same effect as the call\n write(b, 0, b.length)."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this output stream.\n The general contract for write(b, off, len) is that\n some of the bytes in the array b are written to the\n output stream in order; element b[off] is the first\n byte written and b[off+len-1] is the last byte written\n by this operation.\n \n The write method of OutputStream calls\n the write method of one argument on each of the bytes to be\n written out. Subclasses are encouraged to override this method and\n provide a more efficient implementation.\n \n If b is null, a\n NullPointerException is thrown.\n \n If off is negative, or len is negative, or\n off+len is greater than the length of the array\n b, then an IndexOutOfBoundsException is thrown."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out. The general contract of flush is\n that calling it is an indication that, if any bytes previously\n written have been buffered by the implementation of the output\n stream, such bytes should immediately be written to their\n intended destination.\n \n If the intended destination of this stream is an abstraction provided by\n the underlying operating system, for example a file, then flushing the\n stream guarantees only that bytes previously written to the stream are\n passed to the operating system for writing; it does not guarantee that\n they are actually written to a physical device such as a disk drive.\n \n The flush method of OutputStream does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this output stream and releases any system resources\n associated with this stream. The general contract of close\n is that it closes the output stream. A closed stream cannot perform\n output operations and cannot be reopened.\n \n The close method of OutputStream does nothing."
                }
              ]
            }
          ]
        },
        {
          "name": "OutputStreamWriter",
          "methods": [
            {
              "name": "OutputStreamWriter",
              "overloads": [
                {
                  "signature": "public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException",
                  "description": "Creates an OutputStreamWriter that uses the named charset."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out)",
                  "description": "Creates an OutputStreamWriter that uses the default character encoding."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out, Charset cs)",
                  "description": "Creates an OutputStreamWriter that uses the given charset."
                },
                {
                  "signature": "public OutputStreamWriter(OutputStream out, CharsetEncoder enc)",
                  "description": "Creates an OutputStreamWriter that uses the given charset encoder."
                }
              ]
            },
            {
              "name": "getEncoding",
              "overloads": [
                {
                  "signature": "public String getEncoding()",
                  "description": "Returns the name of the character encoding being used by this stream.\n\n  If the encoding has an historical name then that name is returned;\n otherwise the encoding's canonical name is returned.\n\n  If this instance was created with the OutputStreamWriter(OutputStream, String) constructor then the returned\n name, being unique for the encoding, may differ from the name passed to\n the constructor.  This method may return null if the stream has\n been closed."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Description copied from class:Writer"
                }
              ]
            }
          ]
        },
        {
          "name": "PipedInputStream",
          "methods": [
            {
              "name": "PipedInputStream",
              "overloads": [
                {
                  "signature": "public PipedInputStream(PipedOutputStream src) throws IOException",
                  "description": "Creates a PipedInputStream so\n that it is connected to the piped output\n stream src. Data bytes written\n to src will then be  available\n as input from this stream."
                },
                {
                  "signature": "public PipedInputStream(PipedOutputStream src, int pipeSize) throws IOException",
                  "description": "Creates a PipedInputStream so that it is\n connected to the piped output stream\n src and uses the specified pipe size for\n the pipe's buffer.\n Data bytes written to src will then\n be available as input from this stream."
                },
                {
                  "signature": "public PipedInputStream()",
                  "description": "Creates a PipedInputStream so\n that it is not yet connected.\n It must be connected to a\n PipedOutputStream before being used."
                },
                {
                  "signature": "public PipedInputStream(int pipeSize)",
                  "description": "Creates a PipedInputStream so that it is not yet\n connected and\n uses the specified pipe size for the pipe's buffer.\n It must be connected to a PipedOutputStream before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedOutputStream src) throws IOException",
                  "description": "Causes this piped input stream to be connected\n to the piped  output stream src.\n If this object is already connected to some\n other piped output  stream, an IOException\n is thrown.\n \n If src is an\n unconnected piped output stream and snk\n is an unconnected piped input stream, they\n may be connected by either the call:\n\n snk.connect(src) \n \n or the call:\n\n src.connect(snk) \n \n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "protected void receive(int b) throws IOException",
                  "description": "Receives a byte of data.  This method will block if no input is\n available."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this piped input stream. The\n value byte is returned as an int in the range\n 0 to 255.\n This method blocks until input data is available, the end of the\n stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this piped input\n stream into an array of bytes. Less than len bytes\n will be read if the end of the data stream is reached or if\n len exceeds the pipe's buffer size.\n If len  is zero, then no bytes are read and 0 is returned;\n otherwise, the method blocks until at least 1 byte of input is\n available, end of the stream has been detected, or an exception is\n thrown."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this input\n stream without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped input stream and releases any system resources\n associated with the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedOutputStream",
          "methods": [
            {
              "name": "PipedOutputStream",
              "overloads": [
                {
                  "signature": "public PipedOutputStream(PipedInputStream snk) throws IOException",
                  "description": "Creates a piped output stream connected to the specified piped\n input stream. Data bytes written to this stream will then be\n available as input from snk."
                },
                {
                  "signature": "public PipedOutputStream()",
                  "description": "Creates a piped output stream that is not yet connected to a\n piped input stream. It must be connected to a piped input stream,\n either by the receiver or the sender, before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedInputStream snk) throws IOException",
                  "description": "Connects this piped output stream to a receiver. If this object\n is already connected to some other piped input stream, an\n IOException is thrown.\n \n If snk is an unconnected piped input stream and\n src is an unconnected piped output stream, they may\n be connected by either the call:\n  src.connect(snk)\n or the call:\n  snk.connect(src)\n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to the piped output stream.\n \n Implements the write method of OutputStream."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this piped output stream.\n This method blocks until all the bytes are written to the output\n stream."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output bytes\n to be written out.\n This will notify any readers that bytes are waiting in the pipe."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped output stream and releases any system resources\n associated with this stream. This stream may no longer be used for\n writing bytes."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedReader",
          "methods": [
            {
              "name": "PipedReader",
              "overloads": [
                {
                  "signature": "public PipedReader(PipedWriter src) throws IOException",
                  "description": "Creates a PipedReader so\n that it is connected to the piped writer\n src. Data written to src\n will then be available as input from this stream."
                },
                {
                  "signature": "public PipedReader(PipedWriter src, int pipeSize) throws IOException",
                  "description": "Creates a PipedReader so that it is connected\n to the piped writer src and uses the specified\n pipe size for the pipe's buffer. Data written to src\n will then be  available as input from this stream."
                },
                {
                  "signature": "public PipedReader()",
                  "description": "Creates a PipedReader so\n that it is not yet connected. It must be connected to a PipedWriter\n before being used."
                },
                {
                  "signature": "public PipedReader(int pipeSize)",
                  "description": "Creates a PipedReader so that it is not yet\n connected and uses\n the specified pipe size for the pipe's buffer.\n It must be  connected to a PipedWriter\n before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedWriter src) throws IOException",
                  "description": "Causes this piped reader to be connected\n to the piped  writer src.\n If this object is already connected to some\n other piped writer, an IOException\n is thrown.\n \n If src is an\n unconnected piped writer and snk\n is an unconnected piped reader, they\n may be connected by either the call:\n\n snk.connect(src) \n \n or the call:\n\n src.connect(snk) \n \n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next character of data from this piped stream.\n If no character is available because the end of the stream\n has been reached, the value -1 is returned.\n This method blocks until input data is available, the end of\n the stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf.\n\n  Fewer than len characters will be read if\n len exceeds the pipe's buffer size."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tell whether this stream is ready to be read.  A piped character\n stream is ready if the circular buffer is not empty."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped stream and releases any system resources\n associated with the stream."
                }
              ]
            }
          ]
        },
        {
          "name": "PipedWriter",
          "methods": [
            {
              "name": "PipedWriter",
              "overloads": [
                {
                  "signature": "public PipedWriter(PipedReader snk) throws IOException",
                  "description": "Creates a piped writer connected to the specified piped\n reader. Data characters written to this stream will then be\n available as input from snk."
                },
                {
                  "signature": "public PipedWriter()",
                  "description": "Creates a piped writer that is not yet connected to a\n piped reader. It must be connected to a piped reader,\n either by the receiver or the sender, before being used."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(PipedReader snk) throws IOException",
                  "description": "Connects this piped writer to a receiver. If this object\n is already connected to some other piped reader, an\n IOException is thrown.\n \n If snk is an unconnected piped reader and\n src is an unconnected piped writer, they may\n be connected by either the call:\n  src.connect(snk)\n or the call:\n  snk.connect(src)\n The two calls have the same effect."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes the specified char to the piped output stream.\n If a thread was reading data characters from the connected piped input\n stream, but the thread is no longer alive, then an\n IOException is thrown.\n \n Implements the write method of Writer."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes len characters from the specified character array\n starting at offset off to this piped output stream.\n This method blocks until all the characters are written to the output\n stream.\n If a thread was reading data characters from the connected piped input\n stream, but the thread is no longer alive, then an\n IOException is thrown."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush() throws IOException",
                  "description": "Flushes this output stream and forces any buffered output characters\n to be written out.\n This will notify any readers that characters are waiting in the pipe."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this piped output stream and releases any system resources\n associated with this stream. This stream may no longer be used for\n writing characters."
                }
              ]
            }
          ]
        },
        {
          "name": "PrintStream",
          "methods": [
            {
              "name": "PrintStream",
              "overloads": [
                {
                  "signature": "public PrintStream(OutputStream out)",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified OutputStream. Characters written to the stream are converted\n to bytes using the platform's default character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush)",
                  "description": "Creates a new print stream, with the specified OutputStream and line\n flushing. Characters written to the stream are converted to bytes using\n the platform's default character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush, String encoding) throws UnsupportedEncodingException",
                  "description": "Creates a new print stream, with the specified OutputStream, line\n flushing, and character encoding."
                },
                {
                  "signature": "public PrintStream(OutputStream out, boolean autoFlush, Charset charset)",
                  "description": "Creates a new print stream, with the specified OutputStream, line\n flushing and charset.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the provided charset."
                },
                {
                  "signature": "public PrintStream(String fileName) throws FileNotFoundException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the\n default charset\n for this instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintStream(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(File file) throws FileNotFoundException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintStream(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintStream(File file, Charset charset) throws IOException",
                  "description": "Creates a new print stream, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the stream.  This is done by writing any buffered output bytes to\n the underlying output stream and then flushing that stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream.  This is done by flushing the stream and then closing\n the underlying output stream."
                }
              ]
            },
            {
              "name": "checkError",
              "overloads": [
                {
                  "signature": "public boolean checkError()",
                  "description": "Flushes the stream and checks its error state. The internal error state\n is set to true when the underlying output stream throws an\n IOException other than InterruptedIOException,\n and when the setError method is invoked.  If an operation\n on the underlying output stream throws an\n InterruptedIOException, then the PrintStream\n converts the exception back into an interrupt by doing:\n \n     Thread.currentThread().interrupt();\n \n or the equivalent."
                }
              ]
            },
            {
              "name": "setError",
              "overloads": [
                {
                  "signature": "protected void setError()",
                  "description": "Sets the error state of the stream to true.\n\n  This method will cause subsequent invocations of checkError() to return true until\n clearError() is invoked."
                }
              ]
            },
            {
              "name": "clearError",
              "overloads": [
                {
                  "signature": "protected void clearError()",
                  "description": "Clears the internal error state of this stream.\n\n  This method will cause subsequent invocations of checkError() to return false until another write\n operation fails and invokes setError()."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b)",
                  "description": "Writes the specified byte to this stream.  If the byte is a newline and\n automatic flushing is enabled then the flush method will be\n invoked on the underlying output stream.\n\n  Note that the byte is written as given; to write a character that\n will be translated according to the platform's default character\n encoding, use the print(char) or println(char)\n methods."
                },
                {
                  "signature": "public void write(byte[] buf, int off, int len)",
                  "description": "Writes len bytes from the specified byte array starting at\n offset off to this stream.  If automatic flushing is\n enabled then the flush method will be invoked on the underlying\n output stream.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char) or println(char)\n methods."
                },
                {
                  "signature": "public void write(byte[] buf) throws IOException",
                  "description": "Writes all bytes from the specified byte array to this stream. If\n automatic flushing is enabled then the flush method will be\n invoked on the underlying output stream.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char[]) or println(char[])\n methods."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public void writeBytes(byte[] buf)",
                  "description": "Writes all bytes from the specified byte array to this stream.\n If automatic flushing is enabled then the flush method\n will be invoked.\n\n  Note that the bytes will be written as given; to write characters\n that will be translated according to the platform's default character\n encoding, use the print(char[]) or println(char[])\n methods."
                }
              ]
            },
            {
              "name": "print",
              "overloads": [
                {
                  "signature": "public void print(boolean b)",
                  "description": "Prints a boolean value.  The string produced by String.valueOf(boolean) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(char c)",
                  "description": "Prints a character.  The character is translated into one or more bytes\n according to the character encoding given to the constructor, or the\n platform's default character encoding if none specified. These bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(int i)",
                  "description": "Prints an integer.  The string produced by String.valueOf(int) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(long l)",
                  "description": "Prints a long integer.  The string produced by String.valueOf(long) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(float f)",
                  "description": "Prints a floating-point number.  The string produced by String.valueOf(float) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(double d)",
                  "description": "Prints a double-precision floating-point number.  The string produced by\n String.valueOf(double) is translated into\n bytes according to the platform's default character encoding, and these\n bytes are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char[] s)",
                  "description": "Prints an array of characters.  The characters are converted into bytes\n according to the character encoding given to the constructor, or the\n platform's default character encoding if none specified. These bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(String s)",
                  "description": "Prints a string.  If the argument is null then the string\n \"null\" is printed.  Otherwise, the string's characters are\n converted into bytes according to the character encoding given to the\n constructor, or the platform's default character encoding if none\n specified. These bytes are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(Object obj)",
                  "description": "Prints an object.  The string produced by the String.valueOf(Object) method is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the\n write(int) method."
                }
              ]
            },
            {
              "name": "println",
              "overloads": [
                {
                  "signature": "public void println()",
                  "description": "Terminates the current line by writing the line separator string.  The\n line separator string is defined by the system property\n line.separator, and is not necessarily a single newline\n character ('\\n')."
                },
                {
                  "signature": "public void println(boolean x)",
                  "description": "Prints a boolean and then terminate the line.  This method behaves as\n though it invokes print(boolean) and then\n println()."
                },
                {
                  "signature": "public void println(char x)",
                  "description": "Prints a character and then terminate the line.  This method behaves as\n though it invokes print(char) and then\n println()."
                },
                {
                  "signature": "public void println(int x)",
                  "description": "Prints an integer and then terminate the line.  This method behaves as\n though it invokes print(int) and then\n println()."
                },
                {
                  "signature": "public void println(long x)",
                  "description": "Prints a long and then terminate the line.  This method behaves as\n though it invokes print(long) and then\n println()."
                },
                {
                  "signature": "public void println(float x)",
                  "description": "Prints a float and then terminate the line.  This method behaves as\n though it invokes print(float) and then\n println()."
                },
                {
                  "signature": "public void println(double x)",
                  "description": "Prints a double and then terminate the line.  This method behaves as\n though it invokes print(double) and then\n println()."
                },
                {
                  "signature": "public void println(char[] x)",
                  "description": "Prints an array of characters and then terminate the line.  This method\n behaves as though it invokes print(char[]) and\n then println()."
                },
                {
                  "signature": "public void println(String x)",
                  "description": "Prints a String and then terminate the line.  This method behaves as\n though it invokes print(String) and then\n println()."
                },
                {
                  "signature": "public void println(Object x)",
                  "description": "Prints an Object and then terminate the line.  This method calls\n at first String.valueOf(x) to get the printed object's string value,\n then behaves as\n though it invokes print(String) and then\n println()."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public PrintStream printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.\n\n  An invocation of this method of the form\n out.printf(format, args) behaves\n in exactly the same way as the invocation\n\n \n     out.format(format, args)"
                },
                {
                  "signature": "public PrintStream printf(Locale l, String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.\n\n  An invocation of this method of the form\n out.printf(l, format, args) behaves\n in exactly the same way as the invocation\n\n \n     out.format(l, format, args)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public PrintStream format(String format, Object... args)",
                  "description": "Writes a formatted string to this output stream using the specified\n format string and arguments.\n\n  The locale always used is the one returned by Locale.getDefault(Locale.Category) with\n FORMAT category specified,\n regardless of any previous invocations of other formatting methods on\n this object."
                },
                {
                  "signature": "public PrintStream format(Locale l, String format, Object... args)",
                  "description": "Writes a formatted string to this output stream using the specified\n format string and arguments."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public PrintStream append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this output stream.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n \n     out.print(csq.toString())\n \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended.  For instance, invoking then toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public PrintStream append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this output\n stream.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when\n csq is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.print(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public PrintStream append(char c)",
                  "description": "Appends the specified character to this output stream.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n \n     out.print(c)"
                }
              ]
            }
          ]
        },
        {
          "name": "PrintWriter",
          "methods": [
            {
              "name": "PrintWriter",
              "overloads": [
                {
                  "signature": "public PrintWriter(Writer out)",
                  "description": "Creates a new PrintWriter, without automatic line flushing."
                },
                {
                  "signature": "public PrintWriter(Writer out, boolean autoFlush)",
                  "description": "Creates a new PrintWriter."
                },
                {
                  "signature": "public PrintWriter(OutputStream out)",
                  "description": "Creates a new PrintWriter, without automatic line flushing, from an\n existing OutputStream.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will convert characters\n into bytes using the default character encoding."
                },
                {
                  "signature": "public PrintWriter(OutputStream out, boolean autoFlush)",
                  "description": "Creates a new PrintWriter from an existing OutputStream.  This\n convenience constructor creates the necessary intermediate\n OutputStreamWriter, which will convert characters into bytes using the\n default character encoding."
                },
                {
                  "signature": "public PrintWriter(OutputStream out, boolean autoFlush, Charset charset)",
                  "description": "Creates a new PrintWriter from an existing OutputStream.  This\n convenience constructor creates the necessary intermediate\n OutputStreamWriter, which will convert characters into bytes using the\n specified charset."
                },
                {
                  "signature": "public PrintWriter(String fileName) throws FileNotFoundException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintWriter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(String fileName, Charset charset) throws IOException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file name and charset.  This convenience constructor creates\n the necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(File file) throws FileNotFoundException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file.  This convenience constructor creates the necessary\n intermediate OutputStreamWriter,\n which will encode characters using the default charset for this\n instance of the Java virtual machine."
                },
                {
                  "signature": "public PrintWriter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                },
                {
                  "signature": "public PrintWriter(File file, Charset charset) throws IOException",
                  "description": "Creates a new PrintWriter, without automatic line flushing, with the\n specified file and charset.  This convenience constructor creates the\n necessary intermediate OutputStreamWriter, which will encode characters using the provided\n charset."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flushes the stream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated\n with it. Closing a previously closed stream has no effect."
                }
              ]
            },
            {
              "name": "checkError",
              "overloads": [
                {
                  "signature": "public boolean checkError()",
                  "description": "Flushes the stream if it's not closed and checks its error state."
                }
              ]
            },
            {
              "name": "setError",
              "overloads": [
                {
                  "signature": "protected void setError()",
                  "description": "Indicates that an error has occurred.\n\n  This method will cause subsequent invocations of checkError() to return true until clearError() is invoked."
                }
              ]
            },
            {
              "name": "clearError",
              "overloads": [
                {
                  "signature": "protected void clearError()",
                  "description": "Clears the error state of this stream.\n\n  This method will cause subsequent invocations of checkError() to return false until another write\n operation fails and invokes setError()."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Writes a single character."
                },
                {
                  "signature": "public void write(char[] buf, int off, int len)",
                  "description": "Writes A Portion of an array of characters."
                },
                {
                  "signature": "public void write(char[] buf)",
                  "description": "Writes an array of characters.  This method cannot be inherited from the\n Writer class because it must suppress I/O exceptions."
                },
                {
                  "signature": "public void write(String s, int off, int len)",
                  "description": "Writes a portion of a string."
                },
                {
                  "signature": "public void write(String s)",
                  "description": "Writes a string.  This method cannot be inherited from the Writer class\n because it must suppress I/O exceptions."
                }
              ]
            },
            {
              "name": "print",
              "overloads": [
                {
                  "signature": "public void print(boolean b)",
                  "description": "Prints a boolean value.  The string produced by String.valueOf(boolean) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char c)",
                  "description": "Prints a character.  The character is translated into one or more bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(int i)",
                  "description": "Prints an integer.  The string produced by String.valueOf(int) is translated into bytes according\n to the platform's default character encoding, and these bytes are\n written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(long l)",
                  "description": "Prints a long integer.  The string produced by String.valueOf(long) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(float f)",
                  "description": "Prints a floating-point number.  The string produced by String.valueOf(float) is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(double d)",
                  "description": "Prints a double-precision floating-point number.  The string produced by\n String.valueOf(double) is translated into\n bytes according to the platform's default character encoding, and these\n bytes are written in exactly the manner of the write(int) method."
                },
                {
                  "signature": "public void print(char[] s)",
                  "description": "Prints an array of characters.  The characters are converted into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                },
                {
                  "signature": "public void print(String s)",
                  "description": "Prints a string.  If the argument is null then the string\n \"null\" is printed.  Otherwise, the string's characters are\n converted into bytes according to the platform's default character\n encoding, and these bytes are written in exactly the manner of the\n write(int) method."
                },
                {
                  "signature": "public void print(Object obj)",
                  "description": "Prints an object.  The string produced by the String.valueOf(Object) method is translated into bytes\n according to the platform's default character encoding, and these bytes\n are written in exactly the manner of the write(int)\n method."
                }
              ]
            },
            {
              "name": "println",
              "overloads": [
                {
                  "signature": "public void println()",
                  "description": "Terminates the current line by writing the line separator string.  The\n line separator is System.lineSeparator() and is not necessarily\n a single newline character ('\\n')."
                },
                {
                  "signature": "public void println(boolean x)",
                  "description": "Prints a boolean value and then terminates the line.  This method behaves\n as though it invokes print(boolean) and then\n println()."
                },
                {
                  "signature": "public void println(char x)",
                  "description": "Prints a character and then terminates the line.  This method behaves as\n though it invokes print(char) and then println()."
                },
                {
                  "signature": "public void println(int x)",
                  "description": "Prints an integer and then terminates the line.  This method behaves as\n though it invokes print(int) and then println()."
                },
                {
                  "signature": "public void println(long x)",
                  "description": "Prints a long integer and then terminates the line.  This method behaves\n as though it invokes print(long) and then\n println()."
                },
                {
                  "signature": "public void println(float x)",
                  "description": "Prints a floating-point number and then terminates the line.  This method\n behaves as though it invokes print(float) and then\n println()."
                },
                {
                  "signature": "public void println(double x)",
                  "description": "Prints a double-precision floating-point number and then terminates the\n line.  This method behaves as though it invokes print(double) and then println()."
                },
                {
                  "signature": "public void println(char[] x)",
                  "description": "Prints an array of characters and then terminates the line.  This method\n behaves as though it invokes print(char[]) and then\n println()."
                },
                {
                  "signature": "public void println(String x)",
                  "description": "Prints a String and then terminates the line.  This method behaves as\n though it invokes print(String) and then\n println()."
                },
                {
                  "signature": "public void println(Object x)",
                  "description": "Prints an Object and then terminates the line.  This method calls\n at first String.valueOf(x) to get the printed object's string value,\n then behaves as\n though it invokes print(String) and then\n println()."
                }
              ]
            },
            {
              "name": "printf",
              "overloads": [
                {
                  "signature": "public PrintWriter printf(String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.  If automatic flushing is\n enabled, calls to this method will flush the output buffer.\n\n  An invocation of this method of the form\n out.printf(format, args)\n behaves in exactly the same way as the invocation\n\n \n     out.format(format, args)"
                },
                {
                  "signature": "public PrintWriter printf(Locale l, String format, Object... args)",
                  "description": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.  If automatic flushing is\n enabled, calls to this method will flush the output buffer.\n\n  An invocation of this method of the form\n out.printf(l, format, args)\n behaves in exactly the same way as the invocation\n\n \n     out.format(l, format, args)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public PrintWriter format(String format, Object... args)",
                  "description": "Writes a formatted string to this writer using the specified format\n string and arguments.  If automatic flushing is enabled, calls to this\n method will flush the output buffer.\n\n  The locale always used is the one returned by Locale.getDefault(), regardless of any\n previous invocations of other formatting methods on this object."
                },
                {
                  "signature": "public PrintWriter format(Locale l, String format, Object... args)",
                  "description": "Writes a formatted string to this writer using the specified format\n string and arguments.  If automatic flushing is enabled, calls to this\n method will flush the output buffer."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public PrintWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n \n     out.write(csq.toString())\n \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public PrintWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end)\n when csq is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public PrintWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n \n     out.write(c)"
                }
              ]
            }
          ]
        },
        {
          "name": "PushbackInputStream",
          "methods": [
            {
              "name": "PushbackInputStream",
              "overloads": [
                {
                  "signature": "public PushbackInputStream(InputStream in, int size)",
                  "description": "Creates a PushbackInputStream\n with a pushback buffer of the specified size,\n and saves its argument, the input stream\n in, for later use. Initially,\n the pushback buffer is empty."
                },
                {
                  "signature": "public PushbackInputStream(InputStream in)",
                  "description": "Creates a PushbackInputStream\n with a 1-byte pushback buffer, and saves its argument, the input stream\n in, for later use. Initially,\n the pushback buffer is empty."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned. This method blocks until input data\n is available, the end of the stream is detected, or an exception\n is thrown.\n\n  This method returns the most recently pushed-back byte, if there is\n one, and otherwise calls the read method of its underlying\n input stream and returns whatever value that method returns."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream into\n an array of bytes.  This method first reads any pushed-back bytes; after\n that, if fewer than len bytes have been read then it\n reads from the underlying input stream. If len is not zero, the method\n blocks until at least 1 byte of input is available; otherwise, no\n bytes are read and 0 is returned."
                }
              ]
            },
            {
              "name": "unread",
              "overloads": [
                {
                  "signature": "public void unread(int b) throws IOException",
                  "description": "Pushes back a byte by copying it to the front of the pushback buffer.\n After this method returns, the next byte to be read will have the value\n (byte)b."
                },
                {
                  "signature": "public void unread(byte[] b, int off, int len) throws IOException",
                  "description": "Pushes back a portion of an array of bytes by copying it to the front\n of the pushback buffer.  After this method returns, the next byte to be\n read will have the value b[off], the byte after that will\n have the value b[off+1], and so forth."
                },
                {
                  "signature": "public void unread(byte[] b) throws IOException",
                  "description": "Pushes back an array of bytes by copying it to the front of the\n pushback buffer.  After this method returns, the next byte to be read\n will have the value b[0], the byte after that will have the\n value b[1], and so forth."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n\n  The method returns the sum of the number of bytes that have been\n pushed back and the value returned by available."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips over and discards n bytes of data from this\n input stream. The skip method may, for a variety of\n reasons, end up skipping over some smaller number of bytes,\n possibly zero.  If n is negative, no bytes are skipped.\n\n  The skip method of PushbackInputStream\n first skips over the bytes in the pushback buffer, if any.  It then\n calls the skip method of the underlying input stream if\n more bytes need to be skipped.  The actual number of bytes skipped\n is returned."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tests if this input stream supports the mark and\n reset methods, which it does not."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readlimit)",
                  "description": "Marks the current position in this input stream.\n\n  The mark method of PushbackInputStream\n does nothing."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.\n\n  The method reset for class\n PushbackInputStream does nothing except throw an\n IOException."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n Once the stream has been closed, further read(), unread(),\n available(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        },
        {
          "name": "PushbackReader",
          "methods": [
            {
              "name": "PushbackReader",
              "overloads": [
                {
                  "signature": "public PushbackReader(Reader in, int size)",
                  "description": "Creates a new pushback reader with a pushback buffer of the given size."
                },
                {
                  "signature": "public PushbackReader(Reader in)",
                  "description": "Creates a new pushback reader with a one-character pushback buffer."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                }
              ]
            },
            {
              "name": "unread",
              "overloads": [
                {
                  "signature": "public void unread(int c) throws IOException",
                  "description": "Pushes back a single character by copying it to the front of the\n pushback buffer. After this method returns, the next character to be read\n will have the value (char)c."
                },
                {
                  "signature": "public void unread(char[] cbuf, int off, int len) throws IOException",
                  "description": "Pushes back a portion of an array of characters by copying it to the\n front of the pushback buffer.  After this method returns, the next\n character to be read will have the value cbuf[off], the\n character after that will have the value cbuf[off+1], and\n so forth."
                },
                {
                  "signature": "public void unread(char[] cbuf) throws IOException",
                  "description": "Pushes back an array of characters by copying it to the front of the\n pushback buffer.  After this method returns, the next character to be\n read will have the value cbuf[0], the character after that\n will have the value cbuf[1], and so forth."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream. The mark\n for class PushbackReader always throws an exception."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream. The reset method of\n PushbackReader always throws an exception."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does\n not."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes the stream and releases any system resources associated with\n it. Once the stream has been closed, further read(),\n unread(), ready(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "RandomAccessFile",
          "methods": [
            {
              "name": "RandomAccessFile",
              "overloads": [
                {
                  "signature": "public RandomAccessFile(String name, String mode) throws FileNotFoundException",
                  "description": "Creates a random access file stream to read from, and optionally\n to write to, a file with the specified name. A new\n FileDescriptor object is created to represent the\n connection to the file.\n\n  The mode argument specifies the access mode with which the\n file is to be opened.  The permitted values and their meanings are as\n specified for the RandomAccessFile(File,String) constructor.\n\n \n If there is a security manager, its checkRead method\n is called with the name argument\n as its argument to see if read access to the file is allowed.\n If the mode allows writing, the security manager's\n checkWrite method\n is also called with the name argument\n as its argument to see if write access to the file is allowed."
                },
                {
                  "signature": "public RandomAccessFile(File file, String mode) throws FileNotFoundException",
                  "description": "Creates a random access file stream to read from, and optionally to\n write to, the file specified by the File argument.  A new FileDescriptor object is created to represent this file connection.\n\n The mode argument specifies the access mode\n in which the file is to be opened.  The permitted values and their\n meanings are:\n\n \n Access mode permitted values and meanings\n \n ValueMeaning\n \n \n \"r\"\n      Open for reading only. Invoking any of the write\n     methods of the resulting object will cause an\n     IOException to be thrown.\n \"rw\"\n      Open for reading and writing.  If the file does not already\n     exist then an attempt will be made to create it.\n \"rws\"\n      Open for reading and writing, as with \"rw\", and also\n     require that every update to the file's content or metadata be\n     written synchronously to the underlying storage device.\n \"rwd\"\n      Open for reading and writing, as with \"rw\", and also\n     require that every update to the file's content be written\n     synchronously to the underlying storage device.\n \n \n\n The \"rws\" and \"rwd\" modes work much like the force(boolean) method of\n the FileChannel class, passing arguments of\n true and false, respectively, except that they always\n apply to every I/O operation and are therefore often more efficient.  If\n the file resides on a local storage device then when an invocation of a\n method of this class returns it is guaranteed that all changes made to\n the file by that invocation will have been written to that device.  This\n is useful for ensuring that critical information is not lost in the\n event of a system crash.  If the file does not reside on a local device\n then no such guarantee is made.\n\n The \"rwd\" mode can be used to reduce the number of I/O\n operations performed.  Using \"rwd\" only requires updates to the\n file's content to be written to storage; using \"rws\" requires\n updates to both the file's content and its metadata to be written, which\n generally requires at least one more low-level I/O operation.\n\n If there is a security manager, its checkRead method is\n called with the pathname of the file argument as its\n argument to see if read access to the file is allowed.  If the mode\n allows writing, the security manager's checkWrite method is\n also called with the path argument to see if write access to the file is\n allowed."
                }
              ]
            },
            {
              "name": "getFD",
              "overloads": [
                {
                  "signature": "public final FileDescriptor getFD() throws IOException",
                  "description": "Returns the opaque file descriptor object associated with this\n stream."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public final FileChannel getChannel()",
                  "description": "Returns the unique FileChannel\n object associated with this file.\n\n  The position of the returned channel will always be equal to\n this object's file-pointer offset as returned by the getFilePointer method.  Changing this object's\n file-pointer offset, whether explicitly or by reading or writing bytes,\n will change the position of the channel, and vice versa.  Changing the\n file's length via this object will change the length seen via the file\n channel, and vice versa."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte of data from this file. The byte is returned as an\n integer in the range 0 to 255 (0x00-0x0ff). This\n method blocks if no input is yet available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the same\n way as the InputStream.read() method of\n InputStream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this file into an\n array of bytes. This method blocks until at least one byte of input\n is available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the\n same way as the InputStream.read(byte[], int, int) method of\n InputStream."
                },
                {
                  "signature": "public int read(byte[] b) throws IOException",
                  "description": "Reads up to b.length bytes of data from this file\n into an array of bytes. This method blocks until at least one byte\n of input is available.\n \n Although RandomAccessFile is not a subclass of\n InputStream, this method behaves in exactly the\n same way as the InputStream.read(byte[]) method of\n InputStream."
                }
              ]
            },
            {
              "name": "readFully",
              "overloads": [
                {
                  "signature": "public final void readFully(byte[] b) throws IOException",
                  "description": "Reads b.length bytes from this file into the byte\n array, starting at the current file pointer. This method reads\n repeatedly from the file until the requested number of bytes are\n read. This method blocks until the requested number of bytes are\n read, the end of the stream is detected, or an exception is thrown."
                },
                {
                  "signature": "public final void readFully(byte[] b, int off, int len) throws IOException",
                  "description": "Reads exactly len bytes from this file into the byte\n array, starting at the current file pointer. This method reads\n repeatedly from the file until the requested number of bytes are\n read. This method blocks until the requested number of bytes are\n read, the end of the stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "skipBytes",
              "overloads": [
                {
                  "signature": "public int skipBytes(int n) throws IOException",
                  "description": "Attempts to skip over n bytes of input discarding the\n skipped bytes.\n \n\n This method may skip over some smaller number of bytes, possibly zero.\n This may result from any of a number of conditions; reaching end of\n file before n bytes have been skipped is only one\n possibility. This method never throws an EOFException.\n The actual number of bytes skipped is returned.  If n\n is negative, no bytes are skipped."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Writes the specified byte to this file. The write starts at\n the current file pointer."
                },
                {
                  "signature": "public void write(byte[] b) throws IOException",
                  "description": "Writes b.length bytes from the specified byte array\n to this file, starting at the current file pointer."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Writes len bytes from the specified byte array\n starting at offset off to this file."
                }
              ]
            },
            {
              "name": "getFilePointer",
              "overloads": [
                {
                  "signature": "public long getFilePointer() throws IOException",
                  "description": "Returns the current offset in this file."
                }
              ]
            },
            {
              "name": "seek",
              "overloads": [
                {
                  "signature": "public void seek(long pos) throws IOException",
                  "description": "Sets the file-pointer offset, measured from the beginning of this\n file, at which the next read or write occurs.  The offset may be\n set beyond the end of the file. Setting the offset beyond the end\n of the file does not change the file length.  The file length will\n change only by writing after the offset has been set beyond the end\n of the file."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public long length() throws IOException",
                  "description": "Returns the length of this file."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(long newLength) throws IOException",
                  "description": "Sets the length of this file.\n\n  If the present length of the file as returned by the\n length method is greater than the newLength\n argument then the file will be truncated.  In this case, if the file\n offset as returned by the getFilePointer method is greater\n than newLength then after this method returns the offset\n will be equal to newLength.\n\n  If the present length of the file as returned by the\n length method is smaller than the newLength\n argument then the file will be extended.  In this case, the contents of\n the extended portion of the file are not defined."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this random access file stream and releases any system\n resources associated with the stream. A closed random access\n file cannot perform input or output operations and cannot be\n reopened.\n\n  If this file has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "readBoolean",
              "overloads": [
                {
                  "signature": "public final boolean readBoolean() throws IOException",
                  "description": "Reads a boolean from this file. This method reads a\n single byte from the file, starting at the current file pointer.\n A value of 0 represents\n false. Any other value represents true.\n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readByte",
              "overloads": [
                {
                  "signature": "public final byte readByte() throws IOException",
                  "description": "Reads a signed eight-bit value from this file. This method reads a\n byte from the file, starting from the current file pointer.\n If the byte read is b, where\n 0 <= b <= 255,\n then the result is:\n      (byte)(b)\n \n \n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUnsignedByte",
              "overloads": [
                {
                  "signature": "public final int readUnsignedByte() throws IOException",
                  "description": "Reads an unsigned eight-bit number from this file. This method reads\n a byte from this file, starting at the current file pointer,\n and returns that byte.\n \n This method blocks until the byte is read, the end of the stream\n is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readShort",
              "overloads": [
                {
                  "signature": "public final short readShort() throws IOException",
                  "description": "Reads a signed 16-bit number from this file. The method reads two\n bytes from this file, starting at the current file pointer.\n If the two bytes read, in order, are\n b1 and b2, where each of the two values is\n between 0 and 255, inclusive, then the\n result is equal to:\n      (short)((b1 << 8) | b2)\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUnsignedShort",
              "overloads": [
                {
                  "signature": "public final int readUnsignedShort() throws IOException",
                  "description": "Reads an unsigned 16-bit number from this file. This method reads\n two bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1 and b2, where\n 0 <= b1, b2 <= 255,\n then the result is equal to:\n      (b1 << 8) | b2\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readChar",
              "overloads": [
                {
                  "signature": "public final char readChar() throws IOException",
                  "description": "Reads a character from this file. This method reads two\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1 and b2, where\n 0 <= b1, b2 <= 255,\n then the result is equal to:\n      (char)((b1 << 8) | b2)\n \n \n This method blocks until the two bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readInt",
              "overloads": [
                {
                  "signature": "public final int readInt() throws IOException",
                  "description": "Reads a signed 32-bit integer from this file. This method reads 4\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are b1,\n b2, b3, and b4, where\n 0 <= b1, b2, b3, b4 <= 255,\n then the result is equal to:\n      (b1 << 24) | (b2 << 16) + (b3 << 8) + b4\n \n \n This method blocks until the four bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readLong",
              "overloads": [
                {
                  "signature": "public final long readLong() throws IOException",
                  "description": "Reads a signed 64-bit integer from this file. This method reads eight\n bytes from the file, starting at the current file pointer.\n If the bytes read, in order, are\n b1, b2, b3,\n b4, b5, b6,\n b7, and b8, where:\n      0 <= b1, b2, b3, b4, b5, b6, b7, b8 <=255,\n \n \n then the result is equal to:\n      ((long)b1 << 56) + ((long)b2 << 48)\n     + ((long)b3 << 40) + ((long)b4 << 32)\n     + ((long)b5 << 24) + ((long)b6 << 16)\n     + ((long)b7 << 8) + b8\n \n \n This method blocks until the eight bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readFloat",
              "overloads": [
                {
                  "signature": "public final float readFloat() throws IOException",
                  "description": "Reads a float from this file. This method reads an\n int value, starting at the current file pointer,\n as if by the readInt method\n and then converts that int to a float\n using the intBitsToFloat method in class\n Float.\n \n This method blocks until the four bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readDouble",
              "overloads": [
                {
                  "signature": "public final double readDouble() throws IOException",
                  "description": "Reads a double from this file. This method reads a\n long value, starting at the current file pointer,\n as if by the readLong method\n and then converts that long to a double\n using the longBitsToDouble method in\n class Double.\n \n This method blocks until the eight bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readLine",
              "overloads": [
                {
                  "signature": "public final String readLine() throws IOException",
                  "description": "Reads the next line of text from this file.  This method successively\n reads bytes from the file, starting at the current file pointer,\n until it reaches a line terminator or the end\n of the file.  Each byte is converted into a character by taking the\n byte's value for the lower eight bits of the character and setting the\n high eight bits of the character to zero.  This method does not,\n therefore, support the full Unicode character set.\n\n  A line of text is terminated by a carriage-return character\n ('\\r'), a newline character ('\\n'), a\n carriage-return character immediately followed by a newline character,\n or the end of the file.  Line-terminating characters are discarded and\n are not included as part of the string returned.\n\n  This method blocks until a newline character is read, a carriage\n return and the byte following it are read (to see if it is a newline),\n the end of the file is reached, or an exception is thrown."
                }
              ]
            },
            {
              "name": "readUTF",
              "overloads": [
                {
                  "signature": "public final String readUTF() throws IOException",
                  "description": "Reads in a string from this file. The string has been encoded\n using a\n modified UTF-8\n format.\n \n The first two bytes are read, starting from the current file\n pointer, as if by\n readUnsignedShort. This value gives the number of\n following bytes that are in the encoded string, not\n the length of the resulting string. The following bytes are then\n interpreted as bytes encoding characters in the modified UTF-8 format\n and are converted into characters.\n \n This method blocks until all the bytes are read, the end of the\n stream is detected, or an exception is thrown."
                }
              ]
            },
            {
              "name": "writeBoolean",
              "overloads": [
                {
                  "signature": "public final void writeBoolean(boolean v) throws IOException",
                  "description": "Writes a boolean to the file as a one-byte value. The\n value true is written out as the value\n (byte)1; the value false is written out\n as the value (byte)0. The write starts at\n the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeByte",
              "overloads": [
                {
                  "signature": "public final void writeByte(int v) throws IOException",
                  "description": "Writes a byte to the file as a one-byte value. The\n write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeShort",
              "overloads": [
                {
                  "signature": "public final void writeShort(int v) throws IOException",
                  "description": "Writes a short to the file as two bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeChar",
              "overloads": [
                {
                  "signature": "public final void writeChar(int v) throws IOException",
                  "description": "Writes a char to the file as a two-byte value, high\n byte first. The write starts at the current position of the\n file pointer."
                }
              ]
            },
            {
              "name": "writeInt",
              "overloads": [
                {
                  "signature": "public final void writeInt(int v) throws IOException",
                  "description": "Writes an int to the file as four bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeLong",
              "overloads": [
                {
                  "signature": "public final void writeLong(long v) throws IOException",
                  "description": "Writes a long to the file as eight bytes, high byte first.\n The write starts at the current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeFloat",
              "overloads": [
                {
                  "signature": "public final void writeFloat(float v) throws IOException",
                  "description": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the file as a\n four-byte quantity, high byte first. The write starts at the\n current position of the file pointer."
                }
              ]
            },
            {
              "name": "writeDouble",
              "overloads": [
                {
                  "signature": "public final void writeDouble(double v) throws IOException",
                  "description": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the file as an\n eight-byte quantity, high byte first. The write starts at the current\n position of the file pointer."
                }
              ]
            },
            {
              "name": "writeBytes",
              "overloads": [
                {
                  "signature": "public final void writeBytes(String s) throws IOException",
                  "description": "Writes the string to the file as a sequence of bytes. Each\n character in the string is written out, in sequence, by discarding\n its high eight bits. The write starts at the current position of\n the file pointer."
                }
              ]
            },
            {
              "name": "writeChars",
              "overloads": [
                {
                  "signature": "public final void writeChars(String s) throws IOException",
                  "description": "Writes a string to the file as a sequence of characters. Each\n character is written to the data output stream as if by the\n writeChar method. The write starts at the current\n position of the file pointer."
                }
              ]
            },
            {
              "name": "writeUTF",
              "overloads": [
                {
                  "signature": "public final void writeUTF(String str) throws IOException",
                  "description": "Writes a string to the file using\n modified UTF-8\n encoding in a machine-independent manner.\n \n First, two bytes are written to the file, starting at the\n current file pointer, as if by the\n writeShort method giving the number of bytes to\n follow. This value is the number of bytes actually written out,\n not the length of the string. Following the length, each character\n of the string is output, in sequence, using the modified UTF-8 encoding\n for each character."
                }
              ]
            }
          ]
        },
        {
          "name": "Reader",
          "methods": [
            {
              "name": "Reader",
              "overloads": [
                {
                  "signature": "protected Reader()",
                  "description": "Creates a new character-stream reader whose critical sections will\n synchronize on the reader itself."
                },
                {
                  "signature": "protected Reader(Object lock)",
                  "description": "Creates a new character-stream reader whose critical sections will\n synchronize on the given object."
                }
              ]
            },
            {
              "name": "nullReader",
              "overloads": [
                {
                  "signature": "public static Reader nullReader()",
                  "description": "Returns a new Reader that reads no characters. The returned\n stream is initially open.  The stream is closed by calling the\n close() method.  Subsequent calls to close() have no\n effect.\n\n  While the stream is open, the read(), read(char[]),\n read(char[], int, int), read(CharBuffer), \n ready(), skip(long), and transferTo() methods all\n behave as if end of stream has been reached. After the stream has been\n closed, these methods all throw IOException.\n\n  The markSupported() method returns false.  The\n mark() and reset() methods throw an IOException.\n\n  The object used to synchronize operations on the\n returned Reader is not specified."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read(CharBuffer target) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                },
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character.  This method will block until a character is\n available, an I/O error occurs, or the end of the stream is reached.\n\n  Subclasses that intend to support efficient single-character input\n should override this method."
                },
                {
                  "signature": "public int read(char[] cbuf) throws IOException",
                  "description": "Reads characters into an array.  This method will block until some input\n is available, an I/O error occurs, or the end of the stream is reached.\n\n  If the length of cbuf is zero, then no characters are read\n and 0 is returned; otherwise, there is an attempt to read at\n least one character.  If no character is available because the stream is\n at its end, the value -1 is returned; otherwise, at least one\n character is read and stored into cbuf."
                },
                {
                  "signature": "public abstract int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters.  This method will block until some characters are\n available, an I/O error occurs, or the end of the stream is reached.\n If the stream is already at its end before this method is invoked,\n then no characters are skipped and zero is returned."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation. The default\n implementation always returns false. Subclasses should override this\n method."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point.  Not all\n character-input streams support the mark() operation."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream.  If the stream has been marked, then attempt to\n reposition it at the mark.  If the stream has not been marked, then\n attempt to reset it in some way appropriate to the particular stream,\n for example by repositioning it to its starting point.  Not all\n character-input streams support the reset() operation, and some support\n reset() without supporting mark()."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public abstract void close() throws IOException",
                  "description": "Closes the stream and releases any system resources associated with\n it.  Once the stream has been closed, further read(), ready(),\n mark(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."
                }
              ]
            },
            {
              "name": "transferTo",
              "overloads": [
                {
                  "signature": "public long transferTo(Writer out) throws IOException",
                  "description": "Reads all characters from this reader and writes the characters to the\n given writer in the order that they are read. On return, this reader\n will be at end of the stream. This method does not close either reader\n or writer.\n \n This method may block indefinitely reading from the reader, or\n writing to the writer. The behavior for the case where the reader\n and/or writer is asynchronously closed, or the thread\n interrupted during the transfer, is highly reader and writer\n specific, and therefore not specified.\n \n If an I/O error occurs reading from the reader or writing to the\n writer, then it may do so after some characters have been read or\n written. Consequently the reader may not be at end of the stream and\n one, or both, streams may be in an inconsistent state. It is strongly\n recommended that both streams be promptly closed if an I/O error occurs."
                }
              ]
            }
          ]
        },
        {
          "name": "SequenceInputStream",
          "methods": [
            {
              "name": "SequenceInputStream",
              "overloads": [
                {
                  "signature": "public SequenceInputStream(Enumeration<? extends InputStream> e)",
                  "description": "Initializes a newly created SequenceInputStream\n by remembering the argument, which must\n be an Enumeration  that produces\n objects whose run-time type is InputStream.\n The input streams that are  produced by\n the enumeration will be read, in order,\n to provide the bytes to be read  from this\n SequenceInputStream. After\n each input stream from the enumeration\n is exhausted, it is closed by calling its\n close method."
                },
                {
                  "signature": "public SequenceInputStream(InputStream s1, InputStream s2)",
                  "description": "Initializes a newly\n created SequenceInputStream\n by remembering the two arguments, which\n will be read in order, first s1\n and then s2, to provide the\n bytes to be read from this SequenceInputStream."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available() throws IOException",
                  "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from the current underlying input stream without\n blocking by the next invocation of a method for the current\n underlying input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method simply calls available of the current underlying\n input stream and returns the result."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads the next byte of data from this input stream. The byte is\n returned as an int in the range 0 to\n 255. If no byte is available because the end of the\n stream has been reached, the value -1 is returned.\n This method blocks until input data is available, the end of the\n stream is detected, or an exception is thrown.\n \n This method\n tries to read one character from the current substream. If it\n reaches the end of the stream, it calls the close\n method of the current substream and begins reading from the next\n substream."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes.  If len is not zero, the method\n blocks until at least 1 byte of input is available; otherwise, no\n bytes are read and 0 is returned.\n \n The read method of SequenceInputStream\n tries to read the data from the current substream. If it fails to\n read any characters because the substream has reached the end of\n the stream, it calls the close method of the current\n substream and begins reading from the next substream."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this input stream and releases any system resources\n associated with the stream.\n A closed SequenceInputStream\n cannot  perform input operations and cannot\n be reopened.\n \n If this stream was created\n from an enumeration, all remaining elements\n are requested from the enumeration and closed\n before the close method returns."
                }
              ]
            }
          ]
        },
        {
          "name": "Serializable",
          "methods": []
        },
        {
          "name": "SerializablePermission",
          "methods": [
            {
              "name": "SerializablePermission",
              "overloads": [
                {
                  "signature": "public SerializablePermission(String name)",
                  "description": "Creates a new SerializablePermission with the specified name.\n The name is the symbolic name of the SerializablePermission, such as\n \"enableSubstitution\", etc."
                },
                {
                  "signature": "public SerializablePermission(String name, String actions)",
                  "description": "Creates a new SerializablePermission object with the specified name.\n The name is the symbolic name of the SerializablePermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "StreamCorruptedException",
          "methods": [
            {
              "name": "StreamCorruptedException",
              "overloads": [
                {
                  "signature": "public StreamCorruptedException(String reason)",
                  "description": "Create a StreamCorruptedException and list a reason why thrown."
                },
                {
                  "signature": "public StreamCorruptedException()",
                  "description": "Create a StreamCorruptedException and list no reason why thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "StreamTokenizer",
          "methods": [
            {
              "name": "StreamTokenizer",
              "overloads": [
                {
                  "signature": "@Deprecated public StreamTokenizer(InputStream is)",
                  "description": "Creates a stream tokenizer that parses the specified input\n stream. The stream tokenizer is initialized to the following\n default state:\n \n All byte values 'A' through 'Z',\n     'a' through 'z', and\n     '\\u00A0' through '\\u00FF' are\n     considered to be alphabetic.\n All byte values '\\u0000' through\n     '\\u0020' are considered to be white space.\n '/' is a comment character.\n Single quote '\\'' and double quote '\"'\n     are string quote characters.\n Numbers are parsed.\n Ends of lines are treated as white space, not as separate tokens.\n C-style and C++-style comments are not recognized.",
                  "deprecated": true
                },
                {
                  "signature": "public StreamTokenizer(Reader r)",
                  "description": "Create a tokenizer that parses the given character stream."
                }
              ]
            },
            {
              "name": "resetSyntax",
              "overloads": [
                {
                  "signature": "public void resetSyntax()",
                  "description": "Resets this tokenizer's syntax table so that all characters are\n \"ordinary.\" See the ordinaryChar method\n for more information on a character being ordinary."
                }
              ]
            },
            {
              "name": "wordChars",
              "overloads": [
                {
                  "signature": "public void wordChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are word constituents. A word token consists of a word constituent\n followed by zero or more word constituents or number constituents."
                }
              ]
            },
            {
              "name": "whitespaceChars",
              "overloads": [
                {
                  "signature": "public void whitespaceChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are white space characters. White space characters serve only to\n separate tokens in the input stream.\n\n Any other attribute settings for the characters in the specified\n range are cleared."
                }
              ]
            },
            {
              "name": "ordinaryChars",
              "overloads": [
                {
                  "signature": "public void ordinaryChars(int low, int hi)",
                  "description": "Specifies that all characters c in the range\n low <= c <= high\n are \"ordinary\" in this tokenizer. See the\n ordinaryChar method for more information on a\n character being ordinary."
                }
              ]
            },
            {
              "name": "ordinaryChar",
              "overloads": [
                {
                  "signature": "public void ordinaryChar(int ch)",
                  "description": "Specifies that the character argument is \"ordinary\"\n in this tokenizer. It removes any special significance the\n character has as a comment character, word component, string\n delimiter, white space, or number character. When such a character\n is encountered by the parser, the parser treats it as a\n single-character token and sets ttype field to the\n character value.\n\n Making a line terminator character \"ordinary\" may interfere\n with the ability of a StreamTokenizer to count\n lines. The lineno method may no longer reflect\n the presence of such terminator characters in its line count."
                }
              ]
            },
            {
              "name": "commentChar",
              "overloads": [
                {
                  "signature": "public void commentChar(int ch)",
                  "description": "Specified that the character argument starts a single-line\n comment. All characters from the comment character to the end of\n the line are ignored by this stream tokenizer.\n\n Any other attribute settings for the specified character are cleared."
                }
              ]
            },
            {
              "name": "quoteChar",
              "overloads": [
                {
                  "signature": "public void quoteChar(int ch)",
                  "description": "Specifies that matching pairs of this character delimit string\n constants in this tokenizer.\n \n When the nextToken method encounters a string\n constant, the ttype field is set to the string\n delimiter and the sval field is set to the body of\n the string.\n \n If a string quote character is encountered, then a string is\n recognized, consisting of all characters after (but not including)\n the string quote character, up to (but not including) the next\n occurrence of that same string quote character, or a line\n terminator, or end of file. The usual escape sequences such as\n \"\\n\" and \"\\t\" are recognized and\n converted to single characters as the string is parsed.\n\n Any other attribute settings for the specified character are cleared."
                }
              ]
            },
            {
              "name": "parseNumbers",
              "overloads": [
                {
                  "signature": "public void parseNumbers()",
                  "description": "Specifies that numbers should be parsed by this tokenizer. The\n syntax table of this tokenizer is modified so that each of the twelve\n characters:\n       0 1 2 3 4 5 6 7 8 9 . -\n \n \n has the \"numeric\" attribute.\n \n When the parser encounters a word token that has the format of a\n double precision floating-point number, it treats the token as a\n number rather than a word, by setting the ttype\n field to the value TT_NUMBER and putting the numeric\n value of the token into the nval field."
                }
              ]
            },
            {
              "name": "eolIsSignificant",
              "overloads": [
                {
                  "signature": "public void eolIsSignificant(boolean flag)",
                  "description": "Determines whether or not ends of line are treated as tokens.\n If the flag argument is true, this tokenizer treats end of lines\n as tokens; the nextToken method returns\n TT_EOL and also sets the ttype field to\n this value when an end of line is read.\n \n A line is a sequence of characters ending with either a\n carriage-return character ('\\r') or a newline\n character ('\\n'). In addition, a carriage-return\n character followed immediately by a newline character is treated\n as a single end-of-line token.\n \n If the flag is false, end-of-line characters are\n treated as white space and serve only to separate tokens."
                }
              ]
            },
            {
              "name": "slashStarComments",
              "overloads": [
                {
                  "signature": "public void slashStarComments(boolean flag)",
                  "description": "Determines whether or not the tokenizer recognizes C-style comments.\n If the flag argument is true, this stream tokenizer\n recognizes C-style comments. All text between successive\n occurrences of /* and */ are discarded.\n \n If the flag argument is false, then C-style comments\n are not treated specially."
                }
              ]
            },
            {
              "name": "slashSlashComments",
              "overloads": [
                {
                  "signature": "public void slashSlashComments(boolean flag)",
                  "description": "Determines whether or not the tokenizer recognizes C++-style comments.\n If the flag argument is true, this stream tokenizer\n recognizes C++-style comments. Any occurrence of two consecutive\n slash characters ('/') is treated as the beginning of\n a comment that extends to the end of the line.\n \n If the flag argument is false, then C++-style\n comments are not treated specially."
                }
              ]
            },
            {
              "name": "lowerCaseMode",
              "overloads": [
                {
                  "signature": "public void lowerCaseMode(boolean fl)",
                  "description": "Determines whether or not word token are automatically lowercased.\n If the flag argument is true, then the value in the\n sval field is lowercased whenever a word token is\n returned (the ttype field has the\n value TT_WORD by the nextToken method\n of this tokenizer.\n \n If the flag argument is false, then the\n sval field is not modified."
                }
              ]
            },
            {
              "name": "nextToken",
              "overloads": [
                {
                  "signature": "public int nextToken() throws IOException",
                  "description": "Parses the next token from the input stream of this tokenizer.\n The type of the next token is returned in the ttype\n field. Additional information about the token may be in the\n nval field or the sval field of this\n tokenizer.\n \n Typical clients of this\n class first set up the syntax tables and then sit in a loop\n calling nextToken to parse successive tokens until TT_EOF\n is returned."
                }
              ]
            },
            {
              "name": "pushBack",
              "overloads": [
                {
                  "signature": "public void pushBack()",
                  "description": "Causes the next call to the nextToken method of this\n tokenizer to return the current value in the ttype\n field, and not to modify the value in the nval or\n sval field."
                }
              ]
            },
            {
              "name": "lineno",
              "overloads": [
                {
                  "signature": "public int lineno()",
                  "description": "Return the current line number."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of the current stream token and\n the line number it occurs on.\n\n The precise string returned is unspecified, although the following\n example can be considered typical:\n\n Token['a'], line 10"
                }
              ]
            }
          ]
        },
        {
          "name": "StringBufferInputStream",
          "methods": [
            {
              "name": "StringBufferInputStream",
              "overloads": [
                {
                  "signature": "public StringBufferInputStream(String s)",
                  "description": "Creates a string input stream to read data from the specified string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read()",
                  "description": "Reads the next byte of data from this input stream. The value\n byte is returned as an int in the range\n 0 to 255. If no byte is available\n because the end of the stream has been reached, the value\n -1 is returned.\n \n The read method of\n StringBufferInputStream cannot block. It returns the\n low eight bits of the next character in this input stream's buffer.",
                  "deprecated": true
                },
                {
                  "signature": "public int read(byte[] b, int off, int len)",
                  "description": "Reads up to len bytes of data from this input stream\n into an array of bytes.\n \n The read method of\n StringBufferInputStream cannot block. It copies the\n low eight bits from the characters in this input stream's buffer into\n the byte array argument.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n)",
                  "description": "Skips n bytes of input from this input stream. Fewer\n bytes might be skipped if the end of the input stream is reached.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "public int available()",
                  "description": "Returns the number of bytes that can be read from the input\n stream without blocking.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the input stream to begin reading from the first character\n of this input stream's underlying buffer.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "StringReader",
          "methods": [
            {
              "name": "StringReader",
              "overloads": [
                {
                  "signature": "public StringReader(String s)",
                  "description": "Creates a new string reader."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a single character."
                },
                {
                  "signature": "public int read(char[] cbuf, int off, int len) throws IOException",
                  "description": "Reads characters into a portion of an array.\n\n  If len is zero, then no characters are read and 0 is\n returned; otherwise, there is an attempt to read at least one character.\n If no character is available because the stream is at its end, the value\n -1 is returned; otherwise, at least one character is read and\n stored into cbuf."
                }
              ]
            },
            {
              "name": "skip",
              "overloads": [
                {
                  "signature": "public long skip(long n) throws IOException",
                  "description": "Skips characters. If the stream is already at its end before this method\n is invoked, then no characters are skipped and zero is returned.\n\n The n parameter may be negative, even though the\n skip method of the Reader superclass throws\n an exception in this case. Negative values of n cause the\n stream to skip backwards. Negative return values indicate a skip\n backwards. It is not possible to skip backwards past the beginning of\n the string.\n\n If the entire string has been read or skipped, then this method has\n no effect and always returns 0."
                }
              ]
            },
            {
              "name": "ready",
              "overloads": [
                {
                  "signature": "public boolean ready() throws IOException",
                  "description": "Tells whether this stream is ready to be read."
                }
              ]
            },
            {
              "name": "markSupported",
              "overloads": [
                {
                  "signature": "public boolean markSupported()",
                  "description": "Tells whether this stream supports the mark() operation, which it does."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public void mark(int readAheadLimit) throws IOException",
                  "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will reposition the stream to this point."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset() throws IOException",
                  "description": "Resets the stream to the most recent mark, or to the beginning of the\n string if it has never been marked."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes the stream and releases any system resources associated with\n it. Once the stream has been closed, further read(),\n ready(), mark(), or reset() invocations will throw an IOException.\n Closing a previously closed stream has no effect. This method will block\n while there is another thread blocking on the reader."
                }
              ]
            }
          ]
        },
        {
          "name": "StringWriter",
          "methods": [
            {
              "name": "StringWriter",
              "overloads": [
                {
                  "signature": "public StringWriter()",
                  "description": "Create a new string writer using the default initial string-buffer\n size."
                },
                {
                  "signature": "public StringWriter(int initialSize)",
                  "description": "Create a new string writer using the specified initial string-buffer\n size."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c)",
                  "description": "Write a single character."
                },
                {
                  "signature": "public void write(char[] cbuf, int off, int len)",
                  "description": "Write a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str)",
                  "description": "Write a string."
                },
                {
                  "signature": "public void write(String str, int off, int len)",
                  "description": "Write a portion of a string."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public StringWriter append(CharSequence csq)",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public StringWriter append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when csq\n is not null, behaves in\n exactly the same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public StringWriter append(char c)",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return the buffer's current value as a string."
                }
              ]
            },
            {
              "name": "getBuffer",
              "overloads": [
                {
                  "signature": "public StringBuffer getBuffer()",
                  "description": "Return the string buffer itself."
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public void flush()",
                  "description": "Flush the stream.\n\n  The flush method of StringWriter does nothing."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closing a StringWriter has no effect. The methods in this\n class can be called after the stream has been closed without generating\n an IOException."
                }
              ]
            }
          ]
        },
        {
          "name": "SyncFailedException",
          "methods": [
            {
              "name": "SyncFailedException",
              "overloads": [
                {
                  "signature": "public SyncFailedException(String desc)",
                  "description": "Constructs an SyncFailedException with a detail message.\n A detail message is a String that describes this particular exception."
                }
              ]
            }
          ]
        },
        {
          "name": "UncheckedIOException",
          "methods": [
            {
              "name": "UncheckedIOException",
              "overloads": [
                {
                  "signature": "public UncheckedIOException(String message, IOException cause)",
                  "description": "Constructs an instance of this class."
                },
                {
                  "signature": "public UncheckedIOException(IOException cause)",
                  "description": "Constructs an instance of this class."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public IOException getCause()",
                  "description": "Returns the cause of this exception."
                }
              ]
            }
          ]
        },
        {
          "name": "UnsupportedEncodingException",
          "methods": [
            {
              "name": "UnsupportedEncodingException",
              "overloads": [
                {
                  "signature": "public UnsupportedEncodingException()",
                  "description": "Constructs an UnsupportedEncodingException without a detail message."
                },
                {
                  "signature": "public UnsupportedEncodingException(String s)",
                  "description": "Constructs an UnsupportedEncodingException with a detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "UTFDataFormatException",
          "methods": [
            {
              "name": "UTFDataFormatException",
              "overloads": [
                {
                  "signature": "public UTFDataFormatException()",
                  "description": "Constructs a UTFDataFormatException with\n null as its error detail message."
                },
                {
                  "signature": "public UTFDataFormatException(String s)",
                  "description": "Constructs a UTFDataFormatException with the\n specified detail message. The string s can be\n retrieved later by the\n Throwable.getMessage()\n method of class java.lang.Throwable."
                }
              ]
            }
          ]
        },
        {
          "name": "WriteAbortedException",
          "methods": [
            {
              "name": "WriteAbortedException",
              "overloads": [
                {
                  "signature": "public WriteAbortedException(String s, Exception ex)",
                  "description": "Constructs a WriteAbortedException with a string describing\n the exception and the exception causing the abort."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Produce the message and include the message from the nested\n exception, if there is one."
                }
              ]
            },
            {
              "name": "getCause",
              "overloads": [
                {
                  "signature": "public Throwable getCause()",
                  "description": "Returns the exception that terminated the operation (the cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Writer",
          "methods": [
            {
              "name": "Writer",
              "overloads": [
                {
                  "signature": "protected Writer()",
                  "description": "Creates a new character-stream writer whose critical sections will\n synchronize on the writer itself."
                },
                {
                  "signature": "protected Writer(Object lock)",
                  "description": "Creates a new character-stream writer whose critical sections will\n synchronize on the given object."
                }
              ]
            },
            {
              "name": "nullWriter",
              "overloads": [
                {
                  "signature": "public static Writer nullWriter()",
                  "description": "Returns a new Writer which discards all characters.  The\n returned stream is initially open.  The stream is closed by calling\n the close() method.  Subsequent calls to close() have\n no effect.\n\n  While the stream is open, the append(char), \n append(CharSequence), append(CharSequence, int, int),\n flush(), write(int), write(char[]), and\n write(char[], int, int) methods do nothing. After the stream\n has been closed, these methods all throw IOException.\n\n  The object used to synchronize operations on the\n returned Writer is not specified."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int c) throws IOException",
                  "description": "Writes a single character.  The character to be written is contained in\n the 16 low-order bits of the given integer value; the 16 high-order bits\n are ignored.\n\n  Subclasses that intend to support efficient single-character output\n should override this method."
                },
                {
                  "signature": "public void write(char[] cbuf) throws IOException",
                  "description": "Writes an array of characters."
                },
                {
                  "signature": "public abstract void write(char[] cbuf, int off, int len) throws IOException",
                  "description": "Writes a portion of an array of characters."
                },
                {
                  "signature": "public void write(String str) throws IOException",
                  "description": "Writes a string."
                },
                {
                  "signature": "public void write(String str, int off, int len) throws IOException",
                  "description": "Writes a portion of a string."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public Writer append(CharSequence csq) throws IOException",
                  "description": "Appends the specified character sequence to this writer.\n\n  An invocation of this method of the form out.append(csq)\n behaves in exactly the same way as the invocation\n\n      out.write(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended. For instance, invoking the toString method of a\n character buffer will return a subsequence whose content depends upon\n the buffer's position and limit."
                },
                {
                  "signature": "public Writer append(CharSequence csq, int start, int end) throws IOException",
                  "description": "Appends a subsequence of the specified character sequence to this writer.\n Appendable.\n\n  An invocation of this method of the form\n out.append(csq, start, end) when csq\n is not null behaves in exactly the\n same way as the invocation\n\n \n     out.write(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public Writer append(char c) throws IOException",
                  "description": "Appends the specified character to this writer.\n\n  An invocation of this method of the form out.append(c)\n behaves in exactly the same way as the invocation\n\n      out.write(c)"
                }
              ]
            },
            {
              "name": "flush",
              "overloads": [
                {
                  "signature": "public abstract void flush() throws IOException",
                  "description": "Flushes the stream.  If the stream has saved any characters from the\n various write() methods in a buffer, write them immediately to their\n intended destination.  Then, if that destination is another character or\n byte stream, flush it.  Thus one flush() invocation will flush all the\n buffers in a chain of Writers and OutputStreams.\n\n  If the intended destination of this stream is an abstraction provided\n by the underlying operating system, for example a file, then flushing the\n stream guarantees only that bytes previously written to the stream are\n passed to the operating system for writing; it does not guarantee that\n they are actually written to a physical device such as a disk drive."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public abstract void close() throws IOException",
                  "description": "Closes the stream, flushing it first. Once the stream has been closed,\n further write() or flush() invocations will cause an IOException to be\n thrown. Closing a previously closed stream has no effect."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.math",
      "description": "Mathematical operations",
      "classes": [
        {
          "name": "BigDecimal",
          "methods": [
            {
              "name": "BigDecimal",
              "overloads": [
                {
                  "signature": "public BigDecimal(char[] in, int offset, int len)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor, while allowing a sub-array to be specified."
                },
                {
                  "signature": "public BigDecimal(char[] in, int offset, int len, MathContext mc)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor, while allowing a sub-array to be specified and\n with rounding according to the context settings."
                },
                {
                  "signature": "public BigDecimal(char[] in)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor."
                },
                {
                  "signature": "public BigDecimal(char[] in, MathContext mc)",
                  "description": "Translates a character array representation of a\n BigDecimal into a BigDecimal, accepting the\n same sequence of characters as the BigDecimal(String)\n constructor and with rounding according to the context\n settings."
                },
                {
                  "signature": "public BigDecimal(String val)",
                  "description": "Translates the string representation of a BigDecimal\n into a BigDecimal.  The string representation consists\n of an optional sign, '+' ( '\\u002B') or\n '-' ('\\u002D'), followed by a sequence of\n zero or more decimal digits (\"the integer\"), optionally\n followed by a fraction, optionally followed by an exponent.\n\n The fraction consists of a decimal point followed by zero\n or more decimal digits.  The string must contain at least one\n digit in either the integer or the fraction.  The number formed\n by the sign, the integer and the fraction is referred to as the\n significand.\n\n The exponent consists of the character 'e'\n ('\\u0065') or 'E' ('\\u0045')\n followed by one or more decimal digits.  The value of the\n exponent must lie between -Integer.MAX_VALUE (Integer.MIN_VALUE+1) and Integer.MAX_VALUE, inclusive.\n\n More formally, the strings this constructor accepts are\n described by the following grammar:\n \n \n BigDecimalString:\n Signopt Significand Exponentopt\n Sign:\n +\n -\n Significand:\n IntegerPart . FractionPartopt\n . FractionPart\n IntegerPart\n IntegerPart:\n Digits\n FractionPart:\n Digits\n Exponent:\n ExponentIndicator SignedInteger\n ExponentIndicator:\n e\n E\n SignedInteger:\n Signopt Digits\n Digits:\n Digit\n Digits Digit\n Digit:\n any character for which Character.isDigit(char)\n returns true, including 0, 1, 2 ...\n \n \n\n The scale of the returned BigDecimal will be the\n number of digits in the fraction, or zero if the string\n contains no decimal point, subject to adjustment for any\n exponent; if the string contains an exponent, the exponent is\n subtracted from the scale.  The value of the resulting scale\n must lie between Integer.MIN_VALUE and\n Integer.MAX_VALUE, inclusive.\n\n The character-to-digit mapping is provided by Character.digit(char, int) set to convert to radix 10.  The\n String may not contain any extraneous characters (whitespace,\n for example).\n\n Examples:\n The value of the returned BigDecimal is equal to\n significand  10exponent.\n For each string on the left, the resulting representation\n [BigInteger, scale] is shown on the right.\n  \"0\"            [0,0]\n \"0.00\"         [0,2]\n \"123\"          [123,0]\n \"-123\"         [-123,0]\n \"1.23E3\"       [123,-1]\n \"1.23E+3\"      [123,-1]\n \"12.3E+7\"      [123,-6]\n \"12.0\"         [120,1]\n \"12.3\"         [123,1]\n \"0.00123\"      [123,5]\n \"-1.23E-12\"    [-123,14]\n \"1234.5E-4\"    [12345,5]\n \"0E+7\"         [0,-7]\n \"-0\"           [0,0]"
                },
                {
                  "signature": "public BigDecimal(String val, MathContext mc)",
                  "description": "Translates the string representation of a BigDecimal\n into a BigDecimal, accepting the same strings as the\n BigDecimal(String) constructor, with rounding\n according to the context settings."
                },
                {
                  "signature": "public BigDecimal(double val)",
                  "description": "Translates a double into a BigDecimal which\n is the exact decimal representation of the double's\n binary floating-point value.  The scale of the returned\n BigDecimal is the smallest value such that\n (10scale  val) is an integer.\n \n Notes:\n \n \n The results of this constructor can be somewhat unpredictable.\n One might assume that writing new BigDecimal(0.1) in\n Java creates a BigDecimal which is exactly equal to\n 0.1 (an unscaled value of 1, with a scale of 1), but it is\n actually equal to\n 0.1000000000000000055511151231257827021181583404541015625.\n This is because 0.1 cannot be represented exactly as a\n double (or, for that matter, as a binary fraction of\n any finite length).  Thus, the value that is being passed\n in to the constructor is not exactly equal to 0.1,\n appearances notwithstanding.\n\n \n The String constructor, on the other hand, is\n perfectly predictable: writing new BigDecimal(\"0.1\")\n creates a BigDecimal which is exactly equal to\n 0.1, as one would expect.  Therefore, it is generally\n recommended that the String constructor be used in preference to this one.\n\n \n When a double must be used as a source for a\n BigDecimal, note that this constructor provides an\n exact conversion; it does not give the same result as\n converting the double to a String using the\n Double.toString(double) method and then using the\n BigDecimal(String) constructor.  To get that result,\n use the static valueOf(double) method."
                },
                {
                  "signature": "public BigDecimal(double val, MathContext mc)",
                  "description": "Translates a double into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal is the smallest value such that\n (10scale  val) is an integer.\n\n The results of this constructor can be somewhat unpredictable\n and its use is generally not recommended; see the notes under\n the BigDecimal(double) constructor."
                },
                {
                  "signature": "public BigDecimal(BigInteger val)",
                  "description": "Translates a BigInteger into a BigDecimal.\n The scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(BigInteger val, MathContext mc)",
                  "description": "Translates a BigInteger into a BigDecimal\n rounding according to the context settings.  The scale of the\n BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(BigInteger unscaledVal, int scale)",
                  "description": "Translates a BigInteger unscaled value and an\n int scale into a BigDecimal.  The value of\n the BigDecimal is\n (unscaledVal  10-scale)."
                },
                {
                  "signature": "public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc)",
                  "description": "Translates a BigInteger unscaled value and an\n int scale into a BigDecimal, with rounding\n according to the context settings.  The value of the\n BigDecimal is (unscaledVal \n 10-scale), rounded according to the\n precision and rounding mode settings."
                },
                {
                  "signature": "public BigDecimal(int val)",
                  "description": "Translates an int into a BigDecimal.  The\n scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(int val, MathContext mc)",
                  "description": "Translates an int into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal, before any rounding, is zero."
                },
                {
                  "signature": "public BigDecimal(long val)",
                  "description": "Translates a long into a BigDecimal.  The\n scale of the BigDecimal is zero."
                },
                {
                  "signature": "public BigDecimal(long val, MathContext mc)",
                  "description": "Translates a long into a BigDecimal, with\n rounding according to the context settings.  The scale of the\n BigDecimal, before any rounding, is zero."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static BigDecimal valueOf(long unscaledVal, int scale)",
                  "description": "Translates a long unscaled value and an\n int scale into a BigDecimal."
                },
                {
                  "signature": "public static BigDecimal valueOf(long val)",
                  "description": "Translates a long value into a BigDecimal\n with a scale of zero."
                },
                {
                  "signature": "public static BigDecimal valueOf(double val)",
                  "description": "Translates a double into a BigDecimal, using\n the double's canonical string representation provided\n by the Double.toString(double) method."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public BigDecimal add(BigDecimal augend)",
                  "description": "Returns a BigDecimal whose value is (this +\n augend), and whose scale is max(this.scale(),\n augend.scale())."
                },
                {
                  "signature": "public BigDecimal add(BigDecimal augend, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this + augend),\n with rounding according to the context settings.\n\n If either number is zero and the precision setting is nonzero then\n the other number, rounded if necessary, is used as the result."
                }
              ]
            },
            {
              "name": "subtract",
              "overloads": [
                {
                  "signature": "public BigDecimal subtract(BigDecimal subtrahend)",
                  "description": "Returns a BigDecimal whose value is (this -\n subtrahend), and whose scale is max(this.scale(),\n subtrahend.scale())."
                },
                {
                  "signature": "public BigDecimal subtract(BigDecimal subtrahend, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this - subtrahend),\n with rounding according to the context settings.\n\n If subtrahend is zero then this, rounded if necessary, is used as the\n result.  If this is zero then the result is subtrahend.negate(mc)."
                }
              ]
            },
            {
              "name": "multiply",
              "overloads": [
                {
                  "signature": "public BigDecimal multiply(BigDecimal multiplicand)",
                  "description": "Returns a BigDecimal whose value is (this \n multiplicand), and whose scale is (this.scale() +\n multiplicand.scale())."
                },
                {
                  "signature": "public BigDecimal multiply(BigDecimal multiplicand, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this \n multiplicand), with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "divide",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied."
                },
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal divide(BigDecimal divisor, int roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied."
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose preferred scale is (this.scale() -\n divisor.scale()); if the exact quotient cannot be\n represented (because it has a non-terminating decimal\n expansion) an ArithmeticException is thrown."
                },
                {
                  "signature": "public BigDecimal divide(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this /\n divisor), with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "divideToIntegralValue",
              "overloads": [
                {
                  "signature": "public BigDecimal divideToIntegralValue(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is the integer part\n of the quotient (this / divisor) rounded down.  The\n preferred scale of the result is (this.scale() -\n divisor.scale())."
                },
                {
                  "signature": "public BigDecimal divideToIntegralValue(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is the integer part\n of (this / divisor).  Since the integer part of the\n exact quotient does not depend on the rounding mode, the\n rounding mode does not affect the values returned by this\n method.  The preferred scale of the result is\n (this.scale() - divisor.scale()).  An\n ArithmeticException is thrown if the integer part of\n the exact quotient needs more than mc.precision\n digits."
                }
              ]
            },
            {
              "name": "remainder",
              "overloads": [
                {
                  "signature": "public BigDecimal remainder(BigDecimal divisor)",
                  "description": "Returns a BigDecimal whose value is (this % divisor).\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor).multiply(divisor)).\n Note that this is not the modulo operation (the result can be\n negative)."
                },
                {
                  "signature": "public BigDecimal remainder(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (this %\n divisor), with rounding according to the context settings.\n The MathContext settings affect the implicit divide\n used to compute the remainder.  The remainder computation\n itself is by definition exact.  Therefore, the remainder may\n contain more than mc.getPrecision() digits.\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor,\n mc).multiply(divisor)).  Note that this is not the modulo\n operation (the result can be negative)."
                }
              ]
            },
            {
              "name": "divideAndRemainder",
              "overloads": [
                {
                  "signature": "public BigDecimal[] divideAndRemainder(BigDecimal divisor)",
                  "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."
                },
                {
                  "signature": "public BigDecimal[] divideAndRemainder(BigDecimal divisor, MathContext mc)",
                  "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands calculated with rounding\n according to the context settings.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public BigDecimal sqrt(MathContext mc)",
                  "description": "Returns an approximation to the square root of this\n with rounding according to the context settings.\n\n The preferred scale of the returned result is equal to\n this.scale()/2. The value of the returned result is\n always within one ulp of the exact decimal value for the\n precision in question.  If the rounding mode is HALF_UP, HALF_DOWN, or HALF_EVEN, the\n result is within one half an ulp of the exact decimal value.\n\n Special case:\n \n  The square root of a number numerically equal to \n ZERO is numerically equal to ZERO with a preferred\n scale according to the general rule above. In particular, for\n ZERO, ZERO.sqrt(mc).equals(ZERO) is true with\n any MathContext as an argument."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public BigDecimal pow(int n)",
                  "description": "Returns a BigDecimal whose value is\n (thisn), The power is computed exactly, to\n unlimited precision.\n\n The parameter n must be in the range 0 through\n 999999999, inclusive.  ZERO.pow(0) returns ONE.\n\n Note that future releases may expand the allowable exponent\n range of this method."
                },
                {
                  "signature": "public BigDecimal pow(int n, MathContext mc)",
                  "description": "Returns a BigDecimal whose value is\n (thisn).  The current implementation uses\n the core algorithm defined in ANSI standard X3.274-1996 with\n rounding according to the context settings.  In general, the\n returned numerical value is within two ulps of the exact\n numerical value for the chosen precision.  Note that future\n releases may use a different algorithm with a decreased\n allowable error bound and increased allowable exponent range.\n\n The X3.274-1996 algorithm is:\n\n \n  An ArithmeticException exception is thrown if\n  \n    abs(n) > 999999999\n    mc.precision == 0 and n < 0\n    mc.precision > 0 and n has more than\n    mc.precision decimal digits\n  \n\n  if n is zero, ONE is returned even if\n this is zero, otherwise\n \n    if n is positive, the result is calculated via\n   the repeated squaring technique into a single accumulator.\n   The individual multiplications with the accumulator use the\n   same math context settings as in mc except for a\n   precision increased to mc.precision + elength + 1\n   where elength is the number of decimal digits in\n   n.\n\n    if n is negative, the result is calculated as if\n   n were positive; this value is then divided into one\n   using the working precision specified above.\n\n    The final value from either the positive or negative case\n   is then rounded to the destination precision."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public BigDecimal abs()",
                  "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, and whose scale is\n this.scale()."
                },
                {
                  "signature": "public BigDecimal abs(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, with rounding according to the\n context settings."
                }
              ]
            },
            {
              "name": "negate",
              "overloads": [
                {
                  "signature": "public BigDecimal negate()",
                  "description": "Returns a BigDecimal whose value is (-this),\n and whose scale is this.scale()."
                },
                {
                  "signature": "public BigDecimal negate(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (-this),\n with rounding according to the context settings."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public BigDecimal plus()",
                  "description": "Returns a BigDecimal whose value is (+this), and whose\n scale is this.scale().\n\n This method, which simply returns this BigDecimal\n is included for symmetry with the unary minus method negate()."
                },
                {
                  "signature": "public BigDecimal plus(MathContext mc)",
                  "description": "Returns a BigDecimal whose value is (+this),\n with rounding according to the context settings.\n\n The effect of this method is identical to that of the round(MathContext) method."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public int signum()",
                  "description": "Returns the signum function of this BigDecimal."
                }
              ]
            },
            {
              "name": "scale",
              "overloads": [
                {
                  "signature": "public int scale()",
                  "description": "Returns the scale of this BigDecimal.  If zero\n or positive, the scale is the number of digits to the right of\n the decimal point.  If negative, the unscaled value of the\n number is multiplied by ten to the power of the negation of the\n scale.  For example, a scale of -3 means the unscaled\n value is multiplied by 1000."
                }
              ]
            },
            {
              "name": "precision",
              "overloads": [
                {
                  "signature": "public int precision()",
                  "description": "Returns the precision of this BigDecimal.  (The\n precision is the number of digits in the unscaled value.)\n\n The precision of a zero value is 1."
                }
              ]
            },
            {
              "name": "unscaledValue",
              "overloads": [
                {
                  "signature": "public BigInteger unscaledValue()",
                  "description": "Returns a BigInteger whose value is the unscaled\n value of this BigDecimal.  (Computes (this *\n 10this.scale()).)"
                }
              ]
            },
            {
              "name": "round",
              "overloads": [
                {
                  "signature": "public BigDecimal round(MathContext mc)",
                  "description": "Returns a BigDecimal rounded according to the\n MathContext settings.  If the precision setting is 0 then\n no rounding takes place.\n\n The effect of this method is identical to that of the\n plus(MathContext) method."
                }
              ]
            },
            {
              "name": "setScale",
              "overloads": [
                {
                  "signature": "public BigDecimal setScale(int newScale, RoundingMode roundingMode)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division."
                },
                {
                  "signature": "@Deprecated(since=\"9\") public BigDecimal setScale(int newScale, int roundingMode)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division.",
                  "deprecated": true
                },
                {
                  "signature": "public BigDecimal setScale(int newScale)",
                  "description": "Returns a BigDecimal whose scale is the specified\n value, and whose value is numerically equal to this\n BigDecimal's.  Throws an ArithmeticException\n if this is not possible.\n\n This call is typically used to increase the scale, in which\n case it is guaranteed that there exists a BigDecimal\n of the specified scale and the correct value.  The call can\n also be used to reduce the scale if the caller knows that the\n BigDecimal has sufficiently many zeros at the end of\n its fractional part (i.e., factors of ten in its integer value)\n to allow for the rescaling without changing its value.\n\n This method returns the same result as the two-argument\n versions of setScale, but saves the caller the trouble\n of specifying a rounding mode in cases where it is irrelevant."
                }
              ]
            },
            {
              "name": "movePointLeft",
              "overloads": [
                {
                  "signature": "public BigDecimal movePointLeft(int n)",
                  "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the left.  If\n n is non-negative, the call merely adds n to\n the scale.  If n is negative, the call is equivalent\n to movePointRight(-n).  The BigDecimal\n returned by this call has value (this \n 10-n) and scale max(this.scale()+n,\n 0)."
                }
              ]
            },
            {
              "name": "movePointRight",
              "overloads": [
                {
                  "signature": "public BigDecimal movePointRight(int n)",
                  "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the right.\n If n is non-negative, the call merely subtracts\n n from the scale.  If n is negative, the call\n is equivalent to movePointLeft(-n).  The\n BigDecimal returned by this call has value (this\n  10n) and scale max(this.scale()-n,\n 0)."
                }
              ]
            },
            {
              "name": "scaleByPowerOfTen",
              "overloads": [
                {
                  "signature": "public BigDecimal scaleByPowerOfTen(int n)",
                  "description": "Returns a BigDecimal whose numerical value is equal to\n (this * 10n).  The scale of\n the result is (this.scale() - n)."
                }
              ]
            },
            {
              "name": "stripTrailingZeros",
              "overloads": [
                {
                  "signature": "public BigDecimal stripTrailingZeros()",
                  "description": "Returns a BigDecimal which is numerically equal to\n this one but with any trailing zeros removed from the\n representation.  For example, stripping the trailing zeros from\n the BigDecimal value 600.0, which has\n [BigInteger, scale] components equal to\n [6000, 1], yields 6E2 with [BigInteger,\n scale] components equal to [6, -2].  If\n this BigDecimal is numerically equal to zero, then\n BigDecimal.ZERO is returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(BigDecimal val)",
                  "description": "Compares this BigDecimal numerically with the specified\n BigDecimal.  Two BigDecimal objects that are\n equal in value but have a different scale (like 2.0 and 2.00)\n are considered equal by this method. Such values are in the\n same cohort.\n\n This method is provided in preference to individual methods for\n each of the six boolean comparison operators (<, ==,\n >, >=, !=, <=).  The suggested\n idiom for performing these comparisons is: \n (x.compareTo(y) <op> 0), where\n <op> is one of the six comparison operators."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this BigDecimal with the specified \n Object for equality.  Unlike compareTo, this method considers two BigDecimal\n objects equal only if they are equal in value and\n scale. Therefore 2.0 is not equal to 2.00 when compared by this\n method since the former has [BigInteger, scale]\n components equal to [20, 1] while the latter has components\n equal to [200, 2]."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public BigDecimal min(BigDecimal val)",
                  "description": "Returns the minimum of this BigDecimal and\n val."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public BigDecimal max(BigDecimal val)",
                  "description": "Returns the maximum of this BigDecimal and val."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this BigDecimal.\n The hash code is computed as a function of the unscaled value and the scale of this BigDecimal."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this BigDecimal,\n using scientific notation if an exponent is needed.\n\n A standard canonical string form of the BigDecimal\n is created as though by the following steps: first, the\n absolute value of the unscaled value of the BigDecimal\n is converted to a string in base ten using the characters\n '0' through '9' with no leading zeros (except\n if its value is zero, in which case a single '0'\n character is used).\n\n Next, an adjusted exponent is calculated; this is the\n negated scale, plus the number of characters in the converted\n unscaled value, less one.  That is,\n -scale+(ulength-1), where ulength is the\n length of the absolute value of the unscaled value in decimal\n digits (its precision).\n\n If the scale is greater than or equal to zero and the\n adjusted exponent is greater than or equal to -6, the\n number will be converted to a character form without using\n exponential notation.  In this case, if the scale is zero then\n no decimal point is added and if the scale is positive a\n decimal point will be inserted with the scale specifying the\n number of characters to the right of the decimal point.\n '0' characters are added to the left of the converted\n unscaled value as necessary.  If no character precedes the\n decimal point after this insertion then a conventional\n '0' character is prefixed.\n\n Otherwise (that is, if the scale is negative, or the\n adjusted exponent is less than -6), the number will be\n converted to a character form using exponential notation.  In\n this case, if the converted BigInteger has more than\n one digit a decimal point is inserted after the first digit.\n An exponent in character form is then suffixed to the converted\n unscaled value (perhaps with inserted decimal point); this\n comprises the letter 'E' followed immediately by the\n adjusted exponent converted to a character form.  The latter is\n in base ten, using the characters '0' through\n '9' with no leading zeros, and is always prefixed by a\n sign character '-' ('\\u002D') if the\n adjusted exponent is negative, '+'\n ('\\u002B') otherwise).\n\n Finally, the entire string is prefixed by a minus sign\n character '-' ('\\u002D') if the unscaled\n value is less than zero.  No sign character is prefixed if the\n unscaled value is zero or positive.\n\n Examples:\n For each representation [unscaled value, scale]\n on the left, the resulting string is shown on the right.\n  [123,0]      \"123\"\n [-123,0]     \"-123\"\n [123,-1]     \"1.23E+3\"\n [123,-3]     \"1.23E+5\"\n [123,1]      \"12.3\"\n [123,5]      \"0.00123\"\n [123,10]     \"1.23E-8\"\n [-123,12]    \"-1.23E-10\"\n \n\n Notes:\n \n\n There is a one-to-one mapping between the distinguishable\n BigDecimal values and the result of this conversion.\n That is, every distinguishable BigDecimal value\n (unscaled value and scale) has a unique string representation\n as a result of using toString.  If that string\n representation is converted back to a BigDecimal using\n the BigDecimal(String) constructor, then the original\n value will be recovered.\n\n The string produced for a given number is always the same;\n it is not affected by locale.  This means that it can be used\n as a canonical string representation for exchanging decimal\n data, or as a key for a Hashtable, etc.  Locale-sensitive\n number formatting and parsing is handled by the NumberFormat class and its subclasses.\n\n The toEngineeringString() method may be used for\n presenting numbers with exponents in engineering notation, and the\n setScale method may be used for\n rounding a BigDecimal so it has a known number of digits after\n the decimal point.\n\n The digit-to-character mapping provided by\n Character.forDigit is used."
                }
              ]
            },
            {
              "name": "toEngineeringString",
              "overloads": [
                {
                  "signature": "public String toEngineeringString()",
                  "description": "Returns a string representation of this BigDecimal,\n using engineering notation if an exponent is needed.\n\n Returns a string that represents the BigDecimal as\n described in the toString() method, except that if\n exponential notation is used, the power of ten is adjusted to\n be a multiple of three (engineering notation) such that the\n integer part of nonzero values will be in the range 1 through\n 999.  If exponential notation is used for zero values, a\n decimal point and one or two fractional zero digits are used so\n that the scale of the zero value is preserved.  Note that\n unlike the output of toString(), the output of this\n method is not guaranteed to recover the same [integer,\n scale] pair of this BigDecimal if the output string is\n converting back to a BigDecimal using the string constructor.  The result of this method meets\n the weaker constraint of always producing a numerically equal\n result from applying the string constructor to the method's output."
                }
              ]
            },
            {
              "name": "toPlainString",
              "overloads": [
                {
                  "signature": "public String toPlainString()",
                  "description": "Returns a string representation of this BigDecimal\n without an exponent field.  For values with a positive scale,\n the number of digits to the right of the decimal point is used\n to indicate scale.  For values with a zero or negative scale,\n the resulting string is generated as if the value were\n converted to a numerically equal value with zero scale and as\n if all the trailing zeros of the zero scale value were present\n in the result.\n\n The entire string is prefixed by a minus sign character '-'\n ('\\u002D') if the unscaled value is less than\n zero. No sign character is prefixed if the unscaled value is\n zero or positive.\n\n Note that if the result of this method is passed to the\n string constructor, only the\n numerical value of this BigDecimal will necessarily be\n recovered; the representation of the new BigDecimal\n may have a different scale.  In particular, if this\n BigDecimal has a negative scale, the string resulting\n from this method will have a scale of zero when processed by\n the string constructor.\n\n (This method behaves analogously to the toString\n method in 1.4 and earlier releases.)"
                }
              ]
            },
            {
              "name": "toBigInteger",
              "overloads": [
                {
                  "signature": "public BigInteger toBigInteger()",
                  "description": "Converts this BigDecimal to a BigInteger.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n long as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded.  Note that this\n conversion can lose information about the precision of the\n BigDecimal value.\n \n To have an exception thrown if the conversion is inexact (in\n other words if a nonzero fractional part is discarded), use the\n toBigIntegerExact() method."
                }
              ]
            },
            {
              "name": "toBigIntegerExact",
              "overloads": [
                {
                  "signature": "public BigInteger toBigIntegerExact()",
                  "description": "Converts this BigDecimal to a BigInteger,\n checking for lost information.  An exception is thrown if this\n BigDecimal has a nonzero fractional part."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Converts this BigDecimal to a long.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in a\n long, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal value as well\n as return a result with the opposite sign."
                }
              ]
            },
            {
              "name": "longValueExact",
              "overloads": [
                {
                  "signature": "public long longValueExact()",
                  "description": "Converts this BigDecimal to a long, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n long result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Converts this BigDecimal to an int.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in an\n int, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal\n value as well as return a result with the opposite sign."
                }
              ]
            },
            {
              "name": "intValueExact",
              "overloads": [
                {
                  "signature": "public int intValueExact()",
                  "description": "Converts this BigDecimal to an int, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for an\n int result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "shortValueExact",
              "overloads": [
                {
                  "signature": "public short shortValueExact()",
                  "description": "Converts this BigDecimal to a short, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n short result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "byteValueExact",
              "overloads": [
                {
                  "signature": "public byte byteValueExact()",
                  "description": "Converts this BigDecimal to a byte, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n byte result then an ArithmeticException is\n thrown."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Converts this BigDecimal to a float.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigDecimal has too great a\n magnitude to represent as a float, it will be\n converted to Float.NEGATIVE_INFINITY or Float.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Converts this BigDecimal to a double.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigDecimal has too great a\n magnitude represent as a double, it will be\n converted to Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."
                }
              ]
            },
            {
              "name": "ulp",
              "overloads": [
                {
                  "signature": "public BigDecimal ulp()",
                  "description": "Returns the size of an ulp, a unit in the last place, of this\n BigDecimal.  An ulp of a nonzero BigDecimal\n value is the positive distance between this value and the\n BigDecimal value next larger in magnitude with the\n same number of digits.  An ulp of a zero value is numerically\n equal to 1 with the scale of this.  The result is\n stored with the same scale as this so the result\n for zero and nonzero values is equal to [1,\n this.scale()]."
                }
              ]
            }
          ]
        },
        {
          "name": "BigInteger",
          "methods": [
            {
              "name": "BigInteger",
              "overloads": [
                {
                  "signature": "public BigInteger(byte[] val, int off, int len)",
                  "description": "Translates a byte sub-array containing the two's-complement binary\n representation of a BigInteger into a BigInteger.  The sub-array is\n specified via an offset into the array and a length.  The sub-array is\n assumed to be in big-endian byte-order: the most significant\n byte is the element at index off.  The val array is\n assumed to be unchanged for the duration of the constructor call.\n\n An IndexOutOfBoundsException is thrown if the length of the array\n val is non-zero and either off is negative, len\n is negative, or off+len is greater than the length of\n val."
                },
                {
                  "signature": "public BigInteger(byte[] val)",
                  "description": "Translates a byte array containing the two's-complement binary\n representation of a BigInteger into a BigInteger.  The input array is\n assumed to be in big-endian byte-order: the most significant\n byte is in the zeroth element.  The val array is assumed to be\n unchanged for the duration of the constructor call."
                },
                {
                  "signature": "public BigInteger(int signum, byte[] magnitude, int off, int len)",
                  "description": "Translates the sign-magnitude representation of a BigInteger into a\n BigInteger.  The sign is represented as an integer signum value: -1 for\n negative, 0 for zero, or 1 for positive.  The magnitude is a sub-array of\n a byte array in big-endian byte-order: the most significant byte\n is the element at index off.  A zero value of the length\n len is permissible, and will result in a BigInteger value of 0,\n whether signum is -1, 0 or 1.  The magnitude array is assumed to\n be unchanged for the duration of the constructor call.\n\n An IndexOutOfBoundsException is thrown if the length of the array\n magnitude is non-zero and either off is negative,\n len is negative, or off+len is greater than the length of\n magnitude."
                },
                {
                  "signature": "public BigInteger(int signum, byte[] magnitude)",
                  "description": "Translates the sign-magnitude representation of a BigInteger into a\n BigInteger.  The sign is represented as an integer signum value: -1 for\n negative, 0 for zero, or 1 for positive.  The magnitude is a byte array\n in big-endian byte-order: the most significant byte is the\n zeroth element.  A zero-length magnitude array is permissible, and will\n result in a BigInteger value of 0, whether signum is -1, 0 or 1.  The\n magnitude array is assumed to be unchanged for the duration of\n the constructor call."
                },
                {
                  "signature": "public BigInteger(String val, int radix)",
                  "description": "Translates the String representation of a BigInteger in the\n specified radix into a BigInteger.  The String representation\n consists of an optional minus or plus sign followed by a\n sequence of one or more digits in the specified radix.  The\n character-to-digit mapping is provided by Character.digit.  The String may\n not contain any extraneous characters (whitespace, for\n example)."
                },
                {
                  "signature": "public BigInteger(String val)",
                  "description": "Translates the decimal String representation of a BigInteger\n into a BigInteger.  The String representation consists of an\n optional minus or plus sign followed by a sequence of one or\n more decimal digits.  The character-to-digit mapping is\n provided by Character.digit.  The String may not contain any extraneous\n characters (whitespace, for example)."
                },
                {
                  "signature": "public BigInteger(int numBits, Random rnd)",
                  "description": "Constructs a randomly generated BigInteger, uniformly distributed over\n the range 0 to (2numBits - 1), inclusive.\n The uniformity of the distribution assumes that a fair source of random\n bits is provided in rnd.  Note that this constructor always\n constructs a non-negative BigInteger."
                },
                {
                  "signature": "public BigInteger(int bitLength, int certainty, Random rnd)",
                  "description": "Constructs a randomly generated positive BigInteger that is probably\n prime, with the specified bitLength."
                }
              ]
            },
            {
              "name": "probablePrime",
              "overloads": [
                {
                  "signature": "public static BigInteger probablePrime(int bitLength, Random rnd)",
                  "description": "Returns a positive BigInteger that is probably prime, with the\n specified bitLength. The probability that a BigInteger returned\n by this method is composite does not exceed 2-100."
                }
              ]
            },
            {
              "name": "nextProbablePrime",
              "overloads": [
                {
                  "signature": "public BigInteger nextProbablePrime()",
                  "description": "Returns the first integer greater than this BigInteger that\n is probably prime.  The probability that the number returned by this\n method is composite does not exceed 2-100. This method will\n never skip over a prime when searching: if it returns p, there\n is no prime q such that this < q < p."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static BigInteger valueOf(long val)",
                  "description": "Returns a BigInteger whose value is equal to that of the\n specified long."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public BigInteger add(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this + val)."
                }
              ]
            },
            {
              "name": "subtract",
              "overloads": [
                {
                  "signature": "public BigInteger subtract(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this - val)."
                }
              ]
            },
            {
              "name": "multiply",
              "overloads": [
                {
                  "signature": "public BigInteger multiply(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this * val)."
                }
              ]
            },
            {
              "name": "divide",
              "overloads": [
                {
                  "signature": "public BigInteger divide(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this / val)."
                }
              ]
            },
            {
              "name": "divideAndRemainder",
              "overloads": [
                {
                  "signature": "public BigInteger[] divideAndRemainder(BigInteger val)",
                  "description": "Returns an array of two BigIntegers containing (this / val)\n followed by (this % val)."
                }
              ]
            },
            {
              "name": "remainder",
              "overloads": [
                {
                  "signature": "public BigInteger remainder(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this % val)."
                }
              ]
            },
            {
              "name": "pow",
              "overloads": [
                {
                  "signature": "public BigInteger pow(int exponent)",
                  "description": "Returns a BigInteger whose value is (thisexponent).\n Note that exponent is an integer rather than a BigInteger."
                }
              ]
            },
            {
              "name": "sqrt",
              "overloads": [
                {
                  "signature": "public BigInteger sqrt()",
                  "description": "Returns the integer square root of this BigInteger.  The integer square\n root of the corresponding mathematical integer n is the largest\n mathematical integer s such that s*s <= n.  It is equal\n to the value of floor(sqrt(n)), where sqrt(n) denotes the\n real square root of n treated as a real.  Note that the integer\n square root will be less than the real square root if the latter is not\n representable as an integral value."
                }
              ]
            },
            {
              "name": "sqrtAndRemainder",
              "overloads": [
                {
                  "signature": "public BigInteger[] sqrtAndRemainder()",
                  "description": "Returns an array of two BigIntegers containing the integer square root\n s of this and its remainder this - s*s,\n respectively."
                }
              ]
            },
            {
              "name": "gcd",
              "overloads": [
                {
                  "signature": "public BigInteger gcd(BigInteger val)",
                  "description": "Returns a BigInteger whose value is the greatest common divisor of\n abs(this) and abs(val).  Returns 0 if\n this == 0 && val == 0."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public BigInteger abs()",
                  "description": "Returns a BigInteger whose value is the absolute value of this\n BigInteger."
                }
              ]
            },
            {
              "name": "negate",
              "overloads": [
                {
                  "signature": "public BigInteger negate()",
                  "description": "Returns a BigInteger whose value is (-this)."
                }
              ]
            },
            {
              "name": "signum",
              "overloads": [
                {
                  "signature": "public int signum()",
                  "description": "Returns the signum function of this BigInteger."
                }
              ]
            },
            {
              "name": "mod",
              "overloads": [
                {
                  "signature": "public BigInteger mod(BigInteger m)",
                  "description": "Returns a BigInteger whose value is (this mod m).  This method\n differs from remainder in that it always returns a\n non-negative BigInteger."
                }
              ]
            },
            {
              "name": "modPow",
              "overloads": [
                {
                  "signature": "public BigInteger modPow(BigInteger exponent, BigInteger m)",
                  "description": "Returns a BigInteger whose value is\n (thisexponent mod m).  (Unlike pow, this\n method permits negative exponents.)"
                }
              ]
            },
            {
              "name": "modInverse",
              "overloads": [
                {
                  "signature": "public BigInteger modInverse(BigInteger m)",
                  "description": "Returns a BigInteger whose value is (this-1 mod m)."
                }
              ]
            },
            {
              "name": "shiftLeft",
              "overloads": [
                {
                  "signature": "public BigInteger shiftLeft(int n)",
                  "description": "Returns a BigInteger whose value is (this << n).\n The shift distance, n, may be negative, in which case\n this method performs a right shift.\n (Computes floor(this * 2n).)"
                }
              ]
            },
            {
              "name": "shiftRight",
              "overloads": [
                {
                  "signature": "public BigInteger shiftRight(int n)",
                  "description": "Returns a BigInteger whose value is (this >> n).  Sign\n extension is performed.  The shift distance, n, may be\n negative, in which case this method performs a left shift.\n (Computes floor(this / 2n).)"
                }
              ]
            },
            {
              "name": "and",
              "overloads": [
                {
                  "signature": "public BigInteger and(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this & val).  (This\n method returns a negative BigInteger if and only if this and val are\n both negative.)"
                }
              ]
            },
            {
              "name": "or",
              "overloads": [
                {
                  "signature": "public BigInteger or(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this | val).  (This method\n returns a negative BigInteger if and only if either this or val is\n negative.)"
                }
              ]
            },
            {
              "name": "xor",
              "overloads": [
                {
                  "signature": "public BigInteger xor(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this ^ val).  (This method\n returns a negative BigInteger if and only if exactly one of this and\n val are negative.)"
                }
              ]
            },
            {
              "name": "not",
              "overloads": [
                {
                  "signature": "public BigInteger not()",
                  "description": "Returns a BigInteger whose value is (~this).  (This method\n returns a negative value if and only if this BigInteger is\n non-negative.)"
                }
              ]
            },
            {
              "name": "andNot",
              "overloads": [
                {
                  "signature": "public BigInteger andNot(BigInteger val)",
                  "description": "Returns a BigInteger whose value is (this & ~val).  This\n method, which is equivalent to and(val.not()), is provided as\n a convenience for masking operations.  (This method returns a negative\n BigInteger if and only if this is negative and val is\n positive.)"
                }
              ]
            },
            {
              "name": "testBit",
              "overloads": [
                {
                  "signature": "public boolean testBit(int n)",
                  "description": "Returns true if and only if the designated bit is set.\n (Computes ((this & (1<<n)) != 0).)"
                }
              ]
            },
            {
              "name": "setBit",
              "overloads": [
                {
                  "signature": "public BigInteger setBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit set.  (Computes (this | (1<<n)).)"
                }
              ]
            },
            {
              "name": "clearBit",
              "overloads": [
                {
                  "signature": "public BigInteger clearBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit cleared.\n (Computes (this & ~(1<<n)).)"
                }
              ]
            },
            {
              "name": "flipBit",
              "overloads": [
                {
                  "signature": "public BigInteger flipBit(int n)",
                  "description": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit flipped.\n (Computes (this ^ (1<<n)).)"
                }
              ]
            },
            {
              "name": "getLowestSetBit",
              "overloads": [
                {
                  "signature": "public int getLowestSetBit()",
                  "description": "Returns the index of the rightmost (lowest-order) one bit in this\n BigInteger (the number of zero bits to the right of the rightmost\n one bit).  Returns -1 if this BigInteger contains no one bits.\n (Computes (this == 0? -1 : log2(this & -this)).)"
                }
              ]
            },
            {
              "name": "bitLength",
              "overloads": [
                {
                  "signature": "public int bitLength()",
                  "description": "Returns the number of bits in the minimal two's-complement\n representation of this BigInteger, excluding a sign bit.\n For positive BigIntegers, this is equivalent to the number of bits in\n the ordinary binary representation.  For zero this method returns\n 0.  (Computes (ceil(log2(this < 0 ? -this : this+1))).)"
                }
              ]
            },
            {
              "name": "bitCount",
              "overloads": [
                {
                  "signature": "public int bitCount()",
                  "description": "Returns the number of bits in the two's complement representation\n of this BigInteger that differ from its sign bit.  This method is\n useful when implementing bit-vector style sets atop BigIntegers."
                }
              ]
            },
            {
              "name": "isProbablePrime",
              "overloads": [
                {
                  "signature": "public boolean isProbablePrime(int certainty)",
                  "description": "Returns true if this BigInteger is probably prime,\n false if it's definitely composite.  If\n certainty is  0, true is\n returned."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(BigInteger val)",
                  "description": "Compares this BigInteger with the specified BigInteger.  This\n method is provided in preference to individual methods for each\n of the six boolean comparison operators (<, ==,\n >, >=, !=, <=).  The suggested\n idiom for performing these comparisons is: \n (x.compareTo(y) <op> 0), where\n <op> is one of the six comparison operators."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this BigInteger with the specified Object for equality."
                }
              ]
            },
            {
              "name": "min",
              "overloads": [
                {
                  "signature": "public BigInteger min(BigInteger val)",
                  "description": "Returns the minimum of this BigInteger and val."
                }
              ]
            },
            {
              "name": "max",
              "overloads": [
                {
                  "signature": "public BigInteger max(BigInteger val)",
                  "description": "Returns the maximum of this BigInteger and val."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this BigInteger."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString(int radix)",
                  "description": "Returns the String representation of this BigInteger in the\n given radix.  If the radix is outside the range from Character.MIN_RADIX to Character.MAX_RADIX inclusive,\n it will default to 10 (as is the case for\n Integer.toString).  The digit-to-character mapping\n provided by Character.forDigit is used, and a minus\n sign is prepended if appropriate.  (This representation is\n compatible with the (String,\n int) constructor.)"
                },
                {
                  "signature": "public String toString()",
                  "description": "Returns the decimal String representation of this BigInteger.\n The digit-to-character mapping provided by\n Character.forDigit is used, and a minus sign is\n prepended if appropriate.  (This representation is compatible\n with the (String) constructor, and\n allows for String concatenation with Java's + operator.)"
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public byte[] toByteArray()",
                  "description": "Returns a byte array containing the two's-complement\n representation of this BigInteger.  The byte array will be in\n big-endian byte-order: the most significant byte is in\n the zeroth element.  The array will contain the minimum number\n of bytes required to represent this BigInteger, including at\n least one sign bit, which is (ceil((this.bitLength() +\n 1)/8)).  (This representation is compatible with the\n (byte[]) constructor.)"
                }
              ]
            },
            {
              "name": "intValue",
              "overloads": [
                {
                  "signature": "public int intValue()",
                  "description": "Converts this BigInteger to an int.  This\n conversion is analogous to a\n narrowing primitive conversion from long to\n int as defined in\n The Java Language Specification:\n if this BigInteger is too big to fit in an\n int, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude of the BigInteger value as well as return a\n result with the opposite sign."
                }
              ]
            },
            {
              "name": "longValue",
              "overloads": [
                {
                  "signature": "public long longValue()",
                  "description": "Converts this BigInteger to a long.  This\n conversion is analogous to a\n narrowing primitive conversion from long to\n int as defined in\n The Java Language Specification:\n if this BigInteger is too big to fit in a\n long, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude of the BigInteger value as well as return a\n result with the opposite sign."
                }
              ]
            },
            {
              "name": "floatValue",
              "overloads": [
                {
                  "signature": "public float floatValue()",
                  "description": "Converts this BigInteger to a float.  This\n conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigInteger has too great a magnitude\n to represent as a float, it will be converted to\n Float.NEGATIVE_INFINITY or Float.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigInteger value."
                }
              ]
            },
            {
              "name": "doubleValue",
              "overloads": [
                {
                  "signature": "public double doubleValue()",
                  "description": "Converts this BigInteger to a double.  This\n conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java Language Specification:\n if this BigInteger has too great a magnitude\n to represent as a double, it will be converted to\n Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigInteger value."
                }
              ]
            },
            {
              "name": "longValueExact",
              "overloads": [
                {
                  "signature": "public long longValueExact()",
                  "description": "Converts this BigInteger to a long, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the long type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "intValueExact",
              "overloads": [
                {
                  "signature": "public int intValueExact()",
                  "description": "Converts this BigInteger to an int, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the int type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "shortValueExact",
              "overloads": [
                {
                  "signature": "public short shortValueExact()",
                  "description": "Converts this BigInteger to a short, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the short type, then an\n ArithmeticException is thrown."
                }
              ]
            },
            {
              "name": "byteValueExact",
              "overloads": [
                {
                  "signature": "public byte byteValueExact()",
                  "description": "Converts this BigInteger to a byte, checking\n for lost information.  If the value of this BigInteger\n is out of the range of the byte type, then an\n ArithmeticException is thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static RoundingMode[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static RoundingMode valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                },
                {
                  "signature": "public static RoundingMode valueOf(int rm)",
                  "description": "Returns the RoundingMode object corresponding to a\n legacy integer rounding mode constant in BigDecimal."
                }
              ]
            }
          ]
        },
        {
          "name": "MathContext",
          "methods": [
            {
              "name": "MathContext",
              "overloads": [
                {
                  "signature": "public MathContext(int setPrecision)",
                  "description": "Constructs a new MathContext with the specified\n precision and the HALF_UP rounding\n mode."
                },
                {
                  "signature": "public MathContext(int setPrecision, RoundingMode setRoundingMode)",
                  "description": "Constructs a new MathContext with a specified\n precision and rounding mode."
                },
                {
                  "signature": "public MathContext(String val)",
                  "description": "Constructs a new MathContext from a string.\n\n The string must be in the same format as that produced by the\n toString() method.\n\n An IllegalArgumentException is thrown if the precision\n section of the string is out of range (< 0) or the string is\n not in the format created by the toString() method."
                }
              ]
            },
            {
              "name": "getPrecision",
              "overloads": [
                {
                  "signature": "public int getPrecision()",
                  "description": "Returns the precision setting.\n This value is always non-negative."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Returns the roundingMode setting.\n This will be one of\n RoundingMode.CEILING,\n RoundingMode.DOWN,\n RoundingMode.FLOOR,\n RoundingMode.HALF_DOWN,\n RoundingMode.HALF_EVEN,\n RoundingMode.HALF_UP,\n RoundingMode.UNNECESSARY, or\n RoundingMode.UP."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object x)",
                  "description": "Compares this MathContext with the specified\n Object for equality."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this MathContext."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the string representation of this MathContext.\n The String returned represents the settings of the\n MathContext object as two space-delimited words\n (separated by a single space character, '\\u0020',\n and with no leading or trailing white space), as follows:\n \n \n The string \"precision=\", immediately followed\n by the value of the precision setting as a numeric string as if\n generated by the Integer.toString\n method.\n\n \n The string \"roundingMode=\", immediately\n followed by the value of the roundingMode setting as a\n word.  This word will be the same as the name of the\n corresponding public constant in the RoundingMode\n enum.\n \n \n For example:\n  precision=9 roundingMode=HALF_UP\n \n\n Additional words may be appended to the result of\n toString in the future if more properties are added to\n this class."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.net",
      "description": "Networking classes",
      "classes": [
        {
          "name": "Authenticator",
          "methods": [
            {
              "name": "Authenticator",
              "overloads": [
                {
                  "signature": "public Authenticator()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(Authenticator a)",
                  "description": "Sets the authenticator that will be used by the networking code\n when a proxy or an HTTP server asks for authentication.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"setDefaultAuthenticator\") permission.\n This may result in a java.lang.SecurityException."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static Authenticator getDefault()",
                  "description": "Gets the default authenticator.\n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException.\n Then the default authenticator, if set, is returned.\n Otherwise, null is returned."
                }
              ]
            },
            {
              "name": "requestPasswordAuthentication",
              "overloads": [
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(InetAddress addr, int port, String protocol, String prompt, String scheme)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(String host, InetAddress addr, int port, String protocol, String prompt, String scheme)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password. This is the preferred method for requesting a password\n because the hostname can be provided in cases where the InetAddress\n is not available.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask the authenticator that has been registered with the system\n for a password.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                },
                {
                  "signature": "public static PasswordAuthentication requestPasswordAuthentication(Authenticator authenticator, String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask the given authenticator for a password. If the given\n authenticator is null, the authenticator, if any, that has been\n registered with the system using setDefault is used.\n \n First, if there is a security manager, its checkPermission\n method is called with a\n NetPermission(\"requestPasswordAuthentication\") permission.\n This may result in a java.lang.SecurityException."
                }
              ]
            },
            {
              "name": "requestPasswordAuthenticationInstance",
              "overloads": [
                {
                  "signature": "public PasswordAuthentication requestPasswordAuthenticationInstance(String host, InetAddress addr, int port, String protocol, String prompt, String scheme, URL url, Authenticator.RequestorType reqType)",
                  "description": "Ask this authenticator for a password."
                }
              ]
            },
            {
              "name": "getRequestingHost",
              "overloads": [
                {
                  "signature": "protected final String getRequestingHost()",
                  "description": "Gets the hostname of the\n site or proxy requesting authentication, or null\n if not available."
                }
              ]
            },
            {
              "name": "getRequestingSite",
              "overloads": [
                {
                  "signature": "protected final InetAddress getRequestingSite()",
                  "description": "Gets the InetAddress of the\n site requesting authorization, or null\n if not available."
                }
              ]
            },
            {
              "name": "getRequestingPort",
              "overloads": [
                {
                  "signature": "protected final int getRequestingPort()",
                  "description": "Gets the port number for the requested connection."
                }
              ]
            },
            {
              "name": "getRequestingProtocol",
              "overloads": [
                {
                  "signature": "protected final String getRequestingProtocol()",
                  "description": "Give the protocol that's requesting the connection.  Often this\n will be based on a URL, but in a future JDK it could be, for\n example, \"SOCKS\" for a password-protected SOCKS5 firewall."
                }
              ]
            },
            {
              "name": "getRequestingPrompt",
              "overloads": [
                {
                  "signature": "protected final String getRequestingPrompt()",
                  "description": "Gets the prompt string given by the requestor."
                }
              ]
            },
            {
              "name": "getRequestingScheme",
              "overloads": [
                {
                  "signature": "protected final String getRequestingScheme()",
                  "description": "Gets the scheme of the requestor (the HTTP scheme\n for an HTTP firewall, for example)."
                }
              ]
            },
            {
              "name": "getPasswordAuthentication",
              "overloads": [
                {
                  "signature": "protected PasswordAuthentication getPasswordAuthentication()",
                  "description": "Called when password authorization is needed.  Subclasses should\n override the default implementation, which returns null."
                }
              ]
            },
            {
              "name": "getRequestingURL",
              "overloads": [
                {
                  "signature": "protected URL getRequestingURL()",
                  "description": "Returns the URL that resulted in this\n request for authentication."
                }
              ]
            },
            {
              "name": "getRequestorType",
              "overloads": [
                {
                  "signature": "protected Authenticator.RequestorType getRequestorType()",
                  "description": "Returns whether the requestor is a Proxy or a Server."
                }
              ]
            }
          ]
        },
        {
          "name": "BindException",
          "methods": [
            {
              "name": "BindException",
              "overloads": [
                {
                  "signature": "public BindException(String msg)",
                  "description": "Constructs a new BindException with the specified detail\n message as to why the bind error occurred.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public BindException()",
                  "description": "Construct a new BindException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "CacheRequest",
          "methods": [
            {
              "name": "CacheRequest",
              "overloads": [
                {
                  "signature": "public CacheRequest()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getBody",
              "overloads": [
                {
                  "signature": "public abstract OutputStream getBody() throws IOException",
                  "description": "Returns an OutputStream to which the response body can be\n written."
                }
              ]
            },
            {
              "name": "abort",
              "overloads": [
                {
                  "signature": "public abstract void abort()",
                  "description": "Aborts the attempt to cache the response. If an IOException is\n encountered while reading the response or writing to the cache,\n the current cache store operation will be abandoned."
                }
              ]
            }
          ]
        },
        {
          "name": "CacheResponse",
          "methods": [
            {
              "name": "CacheResponse",
              "overloads": [
                {
                  "signature": "public CacheResponse()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getHeaders",
              "overloads": [
                {
                  "signature": "public abstract Map<String,List<String>> getHeaders() throws IOException",
                  "description": "Returns the response headers as a Map."
                }
              ]
            },
            {
              "name": "getBody",
              "overloads": [
                {
                  "signature": "public abstract InputStream getBody() throws IOException",
                  "description": "Returns the response body as an InputStream."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Authenticator.RequestorType[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Authenticator.RequestorType valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static StandardProtocolFamily[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static StandardProtocolFamily valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Proxy.Type[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Proxy.Type valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "ConnectException",
          "methods": [
            {
              "name": "ConnectException",
              "overloads": [
                {
                  "signature": "public ConnectException(String msg)",
                  "description": "Constructs a new ConnectException with the specified detail\n message as to why the connect error occurred.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public ConnectException()",
                  "description": "Construct a new ConnectException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "ContentHandler",
          "methods": [
            {
              "name": "ContentHandler",
              "overloads": [
                {
                  "signature": "public ContentHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public abstract Object getContent(URLConnection urlc) throws IOException",
                  "description": "Given a URL connect stream positioned at the beginning of the\n representation of an object, this method reads that stream and\n creates an object from it."
                },
                {
                  "signature": "public Object getContent(URLConnection urlc, Class[] classes) throws IOException",
                  "description": "Given a URL connect stream positioned at the beginning of the\n representation of an object, this method reads that stream and\n creates an object that matches one of the types specified.\n\n The default implementation of this method should call\n getContent(URLConnection)\n and screen the return type for a match of the suggested types."
                }
              ]
            }
          ]
        },
        {
          "name": "ContentHandlerFactory",
          "methods": [
            {
              "name": "createContentHandler",
              "overloads": [
                {
                  "signature": "ContentHandler createContentHandler(String mimetype)",
                  "description": "Creates a new ContentHandler to read an object from\n a URLStreamHandler."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieHandler",
          "methods": [
            {
              "name": "CookieHandler",
              "overloads": [
                {
                  "signature": "public CookieHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static CookieHandler getDefault()",
                  "description": "Gets the system-wide cookie handler."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(CookieHandler cHandler)",
                  "description": "Sets (or unsets) the system-wide cookie handler.\n\n Note: non-standard http protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract Map<String,List<String>> get(URI uri, Map<String,List<String>> requestHeaders) throws IOException",
                  "description": "Gets all the applicable cookies from a cookie cache for the\n specified uri in the request header.\n\n The URI passed as an argument specifies the intended use for\n the cookies. In particular the scheme should reflect whether the cookies\n will be sent over http, https or used in another context like javascript.\n The host part should reflect either the destination of the cookies or\n their origin in the case of javascript.\n It is up to the implementation to take into account the URI and\n the cookies attributes and security settings to determine which ones\n should be returned.\n\n HTTP protocol implementers should make sure that this method is\n called after all request headers related to choosing cookies\n are added, and before the request is sent."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract void put(URI uri, Map<String,List<String>> responseHeaders) throws IOException",
                  "description": "Sets all the applicable cookies, examples are response header\n fields that are named Set-Cookie2, present in the response\n headers into a cookie cache."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieManager",
          "methods": [
            {
              "name": "CookieManager",
              "overloads": [
                {
                  "signature": "public CookieManager()",
                  "description": "Create a new cookie manager.\n\n This constructor will create new cookie manager with default\n cookie store and accept policy. The effect is same as\n CookieManager(null, null)."
                },
                {
                  "signature": "public CookieManager(CookieStore store, CookiePolicy cookiePolicy)",
                  "description": "Create a new cookie manager with specified cookie store and cookie policy."
                }
              ]
            },
            {
              "name": "setCookiePolicy",
              "overloads": [
                {
                  "signature": "public void setCookiePolicy(CookiePolicy cookiePolicy)",
                  "description": "To set the cookie policy of this cookie manager.\n\n  A instance of CookieManager will have\n cookie policy ACCEPT_ORIGINAL_SERVER by default. Users always\n can call this method to set another cookie policy."
                }
              ]
            },
            {
              "name": "getCookieStore",
              "overloads": [
                {
                  "signature": "public CookieStore getCookieStore()",
                  "description": "To retrieve current cookie store."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> get(URI uri, Map<String,List<String>> requestHeaders) throws IOException",
                  "description": "Description copied from class:CookieHandler"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public void put(URI uri, Map<String,List<String>> responseHeaders) throws IOException",
                  "description": "Description copied from class:CookieHandler"
                }
              ]
            }
          ]
        },
        {
          "name": "CookiePolicy",
          "methods": [
            {
              "name": "shouldAccept",
              "overloads": [
                {
                  "signature": "boolean shouldAccept(URI uri, HttpCookie cookie)",
                  "description": "Will be called to see whether or not this cookie should be accepted."
                }
              ]
            }
          ]
        },
        {
          "name": "CookieStore",
          "methods": [
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "void add(URI uri, HttpCookie cookie)",
                  "description": "Adds one HTTP cookie to the store. This is called for every\n incoming HTTP response.\n\n A cookie to store may or may not be associated with an URI. If it\n is not associated with an URI, the cookie's domain and path attribute\n will indicate where it comes from. If it is associated with an URI and\n its domain and path attribute are not specified, given URI will indicate\n where this cookie comes from.\n\n If a cookie corresponding to the given URI already exists,\n then it is replaced with the new one."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "List<HttpCookie> get(URI uri)",
                  "description": "Retrieve cookies associated with given URI, or whose domain matches the\n given URI. Only cookies that have not expired are returned.\n This is called for every outgoing HTTP request."
                }
              ]
            },
            {
              "name": "getCookies",
              "overloads": [
                {
                  "signature": "List<HttpCookie> getCookies()",
                  "description": "Get all not-expired cookies in cookie store."
                }
              ]
            },
            {
              "name": "getURIs",
              "overloads": [
                {
                  "signature": "List<URI> getURIs()",
                  "description": "Get all URIs which identify the cookies in this cookie store."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "boolean remove(URI uri, HttpCookie cookie)",
                  "description": "Remove a cookie from store."
                }
              ]
            },
            {
              "name": "removeAll",
              "overloads": [
                {
                  "signature": "boolean removeAll()",
                  "description": "Remove all cookies in this cookie store."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramPacket",
          "methods": [
            {
              "name": "DatagramPacket",
              "overloads": [
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length)",
                  "description": "Constructs a DatagramPacket for receiving packets of\n length length, specifying an offset into the buffer.\n \n The length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length)",
                  "description": "Constructs a DatagramPacket for receiving packets of\n length length.\n \n The length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)",
                  "description": "Constructs a datagram packet for sending packets of length\n length with offset offset to the\n specified port number on the specified host. The\n length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)",
                  "description": "Constructs a datagram packet for sending packets of length\n length with offset offset to the\n specified port number on the specified host. The\n length argument must be less than or equal to\n buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length, InetAddress address, int port)",
                  "description": "Constructs a datagram packet for sending packets of length\n length to the specified port number on the specified\n host. The length argument must be less than or equal\n to buf.length."
                },
                {
                  "signature": "public DatagramPacket(byte[] buf, int length, SocketAddress address)",
                  "description": "Constructs a datagram packet for sending packets of length\n length to the specified port number on the specified\n host. The length argument must be less than or equal\n to buf.length."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getAddress()",
                  "description": "Returns the IP address of the machine to which this datagram is being\n sent or from which the datagram was received, or null if not\n set."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number on the remote host to which this datagram is\n being sent or from which the datagram was received, or 0 if not set."
                }
              ]
            },
            {
              "name": "getData",
              "overloads": [
                {
                  "signature": "public byte[] getData()",
                  "description": "Returns the data buffer. The data received or the data to be sent\n starts from the offset in the buffer,\n and runs for length long."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset()",
                  "description": "Returns the offset of the data to be sent or the offset of the\n data received."
                }
              ]
            },
            {
              "name": "getLength",
              "overloads": [
                {
                  "signature": "public int getLength()",
                  "description": "Returns the length of the data to be sent or the length of the\n data received."
                }
              ]
            },
            {
              "name": "setData",
              "overloads": [
                {
                  "signature": "public void setData(byte[] buf, int offset, int length)",
                  "description": "Set the data buffer for this packet. This sets the\n data, length and offset of the packet."
                },
                {
                  "signature": "public void setData(byte[] buf)",
                  "description": "Set the data buffer for this packet. With the offset of\n this DatagramPacket set to 0, and the length set to\n the length of buf."
                }
              ]
            },
            {
              "name": "setAddress",
              "overloads": [
                {
                  "signature": "public void setAddress(InetAddress iaddr)",
                  "description": "Sets the IP address of the machine to which this datagram\n is being sent."
                }
              ]
            },
            {
              "name": "setPort",
              "overloads": [
                {
                  "signature": "public void setPort(int iport)",
                  "description": "Sets the port number on the remote host to which this datagram\n is being sent."
                }
              ]
            },
            {
              "name": "setSocketAddress",
              "overloads": [
                {
                  "signature": "public void setSocketAddress(SocketAddress address)",
                  "description": "Sets the SocketAddress (usually IP address + port number) of the remote\n host to which this datagram is being sent."
                }
              ]
            },
            {
              "name": "getSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getSocketAddress()",
                  "description": "Returns the SocketAddress (usually IP address +\n port number) of the remote host that this packet\n is being sent to or is coming from."
                }
              ]
            },
            {
              "name": "setLength",
              "overloads": [
                {
                  "signature": "public void setLength(int length)",
                  "description": "Set the length for this packet. The length of the packet is\n the number of bytes from the packet's data buffer that will be\n sent, or the number of bytes of the packet's data buffer that\n will be used for receiving data. The length must be lesser or\n equal to the offset plus the length of the packet's buffer."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocket",
          "methods": [
            {
              "name": "DatagramSocket",
              "overloads": [
                {
                  "signature": "public DatagramSocket() throws SocketException",
                  "description": "Constructs a datagram socket and binds it to any available port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with 0 as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "protected DatagramSocket(DatagramSocketImpl impl)",
                  "description": "Creates an unbound datagram socket with the specified\n DatagramSocketImpl."
                },
                {
                  "signature": "public DatagramSocket(SocketAddress bindaddr) throws SocketException",
                  "description": "Creates a datagram socket, bound to the specified local\n socket address.\n \n If the address is null an unbound socket will be created.\n\n If there is a security manager,\n its checkListen method is first called\n with the port from the socket address\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public DatagramSocket(int port) throws SocketException",
                  "description": "Constructs a datagram socket and binds it to the specified port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public DatagramSocket(int port, InetAddress laddr) throws SocketException",
                  "description": "Creates a datagram socket, bound to the specified local\n address.\n The local port must be between 0 and\n 65535 inclusive. A port number of zero will let the system pick\n up an ephemeral port in a bind operation.\n \n If the IP address is a wildcard\n address, or is null, the socket will be bound to the wildcard\n address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress addr) throws SocketException",
                  "description": "Binds this DatagramSocket to a specific address and port.\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(InetAddress address, int port)",
                  "description": "Connects the socket to a remote address for this socket. When a\n socket is connected to a remote address, packets may only be\n sent to or received from that address. By default a datagram\n socket is not connected. If the socket is already closed,\n then this method has no effect.\n\n  If this socket is not bound then this method will first cause the\n socket to be bound to an address that is assigned automatically,\n as if invoking the bind method with a parameter of\n null. If the remote destination to which the socket is connected\n does not exist, or is otherwise unreachable, and if an ICMP destination\n unreachable packet has been received for that address, then a subsequent\n call to send or receive may throw a PortUnreachableException. Note,\n there is no guarantee that the exception will be thrown.\n\n  If a security manager has been installed then it is invoked to check\n access to the remote address. Specifically, if the given address\n is a multicast address,\n the security manager's checkMulticast method is invoked with the given address.\n Otherwise, the security manager's checkConnect\n and checkAccept methods\n are invoked, with the given address and port, to\n verify that datagrams are permitted to be sent and received\n respectively.\n\n  Care should be taken to ensure that a connected datagram socket\n is not shared with untrusted code. When a socket is connected,\n receive and send will not perform\n any security checks on incoming and outgoing packets, other than\n matching the packet's and the socket's address and port. On a send\n operation, if the packet's address is set and the packet's address\n and the socket's address do not match, an IllegalArgumentException\n will be thrown. A socket connected to a multicast address may only\n be used to send packets. Datagrams in the socket's socket receive buffer, which\n have not been received before invoking\n this method, may be discarded."
                },
                {
                  "signature": "public void connect(SocketAddress addr) throws SocketException",
                  "description": "Connects this socket to a remote socket address (IP address + port number).\n\n  If given an InetSocketAddress, this method\n behaves as if invoking connect(InetAddress,int)\n with the given socket addresses IP address and port number, except that the\n SocketException that may be raised is not wrapped in an\n UncheckedIOException. Datagrams in the socket's socket receive buffer, which\n have not been received before invoking\n this method, may be discarded."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "public void disconnect()",
                  "description": "Disconnects the socket. If the socket is closed or not connected,\n then this method has no effect."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the socket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "isConnected",
              "overloads": [
                {
                  "signature": "public boolean isConnected()",
                  "description": "Returns the connection state of the socket.\n \n If the socket was connected prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the address to which this socket is connected. Returns\n null if the socket is not connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number to which this socket is connected.\n Returns -1 if the socket is not connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getRemoteSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getRemoteSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to."
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "public void send(DatagramPacket p) throws IOException",
                  "description": "Sends a datagram packet from this socket. The\n DatagramPacket includes information indicating the\n data to be sent, its length, the IP address of the remote host,\n and the port number on the remote host.\n\n If there is a security manager, and the socket is not currently\n connected to a remote address, this method first performs some\n security checks. First, if p.getAddress().isMulticastAddress()\n is true, this method calls the\n security manager's checkMulticast method\n with p.getAddress() as its argument.\n If the evaluation of that expression is false,\n this method instead calls the security manager's\n checkConnect method with arguments\n p.getAddress().getHostAddress() and\n p.getPort(). Each call to a security manager method\n could result in a SecurityException if the operation is not allowed."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "public void receive(DatagramPacket p) throws IOException",
                  "description": "Receives a datagram packet from this socket. When this method\n returns, the DatagramPacket's buffer is filled with\n the data received. The datagram packet also contains the sender's\n IP address, and the port number on the sender's machine.\n \n This method blocks until a datagram is received. The\n length field of the datagram packet object contains\n the length of the received message. If the message is longer than\n the packet's length, the message is truncated.\n \n If there is a security manager, and the socket is not currently\n connected to a remote address, a packet cannot be received if the\n security manager's checkAccept method does not allow it.\n Datagrams that are not permitted by the security manager are silently\n discarded."
                }
              ]
            },
            {
              "name": "getLocalAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getLocalAddress()",
                  "description": "Gets the local address to which the socket is bound.\n\n If there is a security manager, its\n checkConnect method is first called\n with the host address and -1\n as its arguments to see if the operation is allowed."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the port number on the local host to which this socket\n is bound."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT with the specified timeout, in\n milliseconds. With this option set to a positive timeout value,\n a call to receive() for this DatagramSocket\n will block for only this amount of time.  If the timeout expires,\n a java.net.SocketTimeoutException is raised, though the\n DatagramSocket is still valid. A timeout of zero is interpreted\n as an infinite timeout.\n The option must be enabled prior to entering the blocking\n operation to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws SocketException",
                  "description": "Retrieve setting for SO_TIMEOUT.  0 returns implies that the\n option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setSendBufferSize",
              "overloads": [
                {
                  "signature": "public void setSendBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_SNDBUF option to the specified value for this\n DatagramSocket. The SO_SNDBUF option is used by the\n network implementation as a hint to size the underlying\n network I/O buffers. The SO_SNDBUF setting may also be used\n by the network implementation to determine the maximum size\n of the packet that can be sent on this socket.\n \n As SO_SNDBUF is a hint, applications that want to verify\n what size the buffer is should call getSendBufferSize().\n \n Increasing the buffer size may allow multiple outgoing packets\n to be queued by the network implementation when the send rate\n is high.\n \n Note: If send(DatagramPacket) is used to send a\n DatagramPacket that is larger than the setting\n of SO_SNDBUF then it is implementation specific if the\n packet is sent or discarded."
                }
              ]
            },
            {
              "name": "getSendBufferSize",
              "overloads": [
                {
                  "signature": "public int getSendBufferSize() throws SocketException",
                  "description": "Get value of the SO_SNDBUF option for this DatagramSocket, that is the\n buffer size, in bytes, used by the platform for output on this DatagramSocket."
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_RCVBUF option to the specified value for this\n DatagramSocket. The SO_RCVBUF option is used by\n the network implementation as a hint to size the underlying\n network I/O buffers. The SO_RCVBUF setting may also be used\n by the network implementation to determine the maximum size\n of the packet that can be received on this socket.\n \n Because SO_RCVBUF is a hint, applications that want to\n verify what size the buffers were set to should call\n getReceiveBufferSize().\n \n Increasing SO_RCVBUF may allow the network implementation\n to buffer multiple packets when packets arrive faster than\n are being received using receive(DatagramPacket).\n \n Note: It is implementation specific if a packet larger\n than SO_RCVBUF can be received."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Get value of the SO_RCVBUF option for this DatagramSocket, that is the\n buffer size, in bytes, used by the platform for input on this DatagramSocket."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR socket option.\n \n For UDP sockets it may be necessary to bind more than one\n socket to the same socket address. This is typically for the\n purpose of receiving multicast packets\n (See MulticastSocket). The\n SO_REUSEADDR socket option allows multiple\n sockets to be bound to the same socket address if the\n SO_REUSEADDR socket option is enabled prior\n to binding the socket using bind(SocketAddress).\n \n Note: This functionality is not supported by all existing platforms,\n so it is implementation specific whether this option will be ignored\n or not. However, if it is not supported then\n getReuseAddress() will always return false.\n \n When a DatagramSocket is created the initial setting\n of SO_REUSEADDR is disabled.\n \n The behaviour when SO_REUSEADDR is enabled or\n disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "setBroadcast",
              "overloads": [
                {
                  "signature": "public void setBroadcast(boolean on) throws SocketException",
                  "description": "Enable/disable SO_BROADCAST.\n\n  Some operating systems may require that the Java virtual machine be\n started with implementation specific privileges to enable this option or\n send broadcast datagrams."
                }
              ]
            },
            {
              "name": "getBroadcast",
              "overloads": [
                {
                  "signature": "public boolean getBroadcast() throws SocketException",
                  "description": "Tests if SO_BROADCAST is enabled."
                }
              ]
            },
            {
              "name": "setTrafficClass",
              "overloads": [
                {
                  "signature": "public void setTrafficClass(int tc) throws SocketException",
                  "description": "Sets traffic class or type-of-service octet in the IP\n datagram header for datagrams sent from this DatagramSocket.\n As the underlying network implementation may ignore this\n value applications should consider it a hint.\n\n  The tc must be in the range 0 <= tc <=\n 255 or an IllegalArgumentException will be thrown.\n Notes:\n For Internet Protocol v4 the value consists of an\n integer, the least significant 8 bits of which\n represent the value of the TOS octet in IP packets sent by\n the socket.\n RFC 1349 defines the TOS values as follows:\n\n \n IPTOS_LOWCOST (0x02)\n IPTOS_RELIABILITY (0x04)\n IPTOS_THROUGHPUT (0x08)\n IPTOS_LOWDELAY (0x10)\n \n The last low order bit is always ignored as this\n corresponds to the MBZ (must be zero) bit.\n \n Setting bits in the precedence field may result in a\n SocketException indicating that the operation is not\n permitted.\n \n for Internet Protocol v6 tc is the value that\n would be placed into the sin6_flowinfo field of the IP header."
                }
              ]
            },
            {
              "name": "getTrafficClass",
              "overloads": [
                {
                  "signature": "public int getTrafficClass() throws SocketException",
                  "description": "Gets traffic class or type-of-service in the IP datagram\n header for packets sent from this DatagramSocket.\n \n As the underlying network implementation may ignore the\n traffic class or type-of-service set using setTrafficClass(int)\n this method may return a different value than was previously\n set using the setTrafficClass(int) method on this\n DatagramSocket."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close()",
                  "description": "Closes this datagram socket.\n \n Any thread currently blocked in receive(java.net.DatagramPacket) upon this socket\n will throw a SocketException.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns whether the socket is closed or not."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public DatagramChannel getChannel()",
                  "description": "Returns the unique DatagramChannel object\n associated with this datagram socket, if any.\n\n  A datagram socket will have a channel if, and only if, the channel\n itself was created via the DatagramChannel.open method."
                }
              ]
            },
            {
              "name": "setDatagramSocketImplFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac) throws IOException",
                  "description": "Sets the datagram socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new datagram socket, the socket\n implementation factory's createDatagramSocketImpl method is\n called to create the actual datagram socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n\n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> DatagramSocket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Joins a multicast group.\n\n  In order to join a multicast group, the caller should specify\n the IP address of the multicast group to join, and the local\n network interface to receive multicast\n packets from.\n \n   The mcastaddr argument indicates the IP address\n   of the multicast group to join. For historical reasons this is\n   specified as a SocketAddress.\n   The default implementation only supports InetSocketAddress and\n   the port information is ignored.\n  \n   The netIf argument specifies the local interface to receive\n       multicast datagram packets, or null to defer to the interface\n       set for outgoing multicast datagrams.\n       If null, and no interface has been set, the behaviour is\n       unspecified: any interface may be selected or the operation may fail\n       with a SocketException.\n  \n \n\n  It is possible to call this method several times to join\n several different multicast groups, or join the same group\n in several different networks. However, if the socket is already a\n member of the group, an IOException will be thrown.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the mcastaddr\n argument as its argument."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave a multicast group on a specified local interface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument."
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocketImpl",
          "methods": [
            {
              "name": "DatagramSocketImpl",
              "overloads": [
                {
                  "signature": "public DatagramSocketImpl()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "protected abstract void create() throws SocketException",
                  "description": "Creates a datagram socket."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "protected abstract void bind(int lport, InetAddress laddr) throws SocketException",
                  "description": "Binds a datagram socket to a local port and address."
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "protected abstract void send(DatagramPacket p) throws IOException",
                  "description": "Sends a datagram packet. The packet contains the data and the\n destination address to send the packet to."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "protected void connect(InetAddress address, int port) throws SocketException",
                  "description": "Connects a datagram socket to a remote destination. This associates the remote\n address with the local socket so that datagrams may only be sent to this destination\n and received from this destination. This may be overridden to call a native\n system connect.\n\n If the remote destination to which the socket is connected does not\n exist, or is otherwise unreachable, and if an ICMP destination unreachable\n packet has been received for that address, then a subsequent call to\n send or receive may throw a PortUnreachableException.\n Note, there is no guarantee that the exception will be thrown."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "protected void disconnect()",
                  "description": "Disconnects a datagram socket from its remote destination."
                }
              ]
            },
            {
              "name": "peek",
              "overloads": [
                {
                  "signature": "protected abstract int peek(InetAddress i) throws IOException",
                  "description": "Peek at the packet to see who it is from. Updates the specified InetAddress\n to the address which the packet came from."
                }
              ]
            },
            {
              "name": "peekData",
              "overloads": [
                {
                  "signature": "protected abstract int peekData(DatagramPacket p) throws IOException",
                  "description": "Peek at the packet to see who it is from. The data is copied into the specified\n DatagramPacket. The data is returned,\n but not consumed, so that a subsequent peekData/receive operation\n will see the same data."
                }
              ]
            },
            {
              "name": "receive",
              "overloads": [
                {
                  "signature": "protected abstract void receive(DatagramPacket p) throws IOException",
                  "description": "Receive the datagram packet."
                }
              ]
            },
            {
              "name": "setTTL",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract void setTTL(byte ttl) throws IOException",
                  "description": "Set the TTL (time-to-live) option.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTTL",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract byte getTTL() throws IOException",
                  "description": "Retrieve the TTL (time-to-live) option.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setTimeToLive",
              "overloads": [
                {
                  "signature": "protected abstract void setTimeToLive(int ttl) throws IOException",
                  "description": "Set the TTL (time-to-live) option."
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "protected abstract int getTimeToLive() throws IOException",
                  "description": "Retrieve the TTL (time-to-live) option."
                }
              ]
            },
            {
              "name": "join",
              "overloads": [
                {
                  "signature": "protected abstract void join(InetAddress inetaddr) throws IOException",
                  "description": "Join the multicast group."
                }
              ]
            },
            {
              "name": "leave",
              "overloads": [
                {
                  "signature": "protected abstract void leave(InetAddress inetaddr) throws IOException",
                  "description": "Leave the multicast group."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "protected abstract void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Join the multicast group."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "protected abstract void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave the multicast group."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "protected abstract void close()",
                  "description": "Close the socket."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "protected int getLocalPort()",
                  "description": "Gets the local port."
                }
              ]
            },
            {
              "name": "getFileDescriptor",
              "overloads": [
                {
                  "signature": "protected FileDescriptor getFileDescriptor()",
                  "description": "Gets the datagram socket file descriptor."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "protected <T> void setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Called to set a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "protected <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Called to get a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "protected Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of SocketOptions supported by this impl\n and by this impl's socket (DatagramSocket or MulticastSocket)"
                }
              ]
            }
          ]
        },
        {
          "name": "DatagramSocketImplFactory",
          "methods": [
            {
              "name": "createDatagramSocketImpl",
              "overloads": [
                {
                  "signature": "DatagramSocketImpl createDatagramSocketImpl()",
                  "description": "Creates a new DatagramSocketImpl instance."
                }
              ]
            }
          ]
        },
        {
          "name": "FileNameMap",
          "methods": [
            {
              "name": "getContentTypeFor",
              "overloads": [
                {
                  "signature": "String getContentTypeFor(String fileName)",
                  "description": "Gets the MIME type for the specified file name."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpCookie",
          "methods": [
            {
              "name": "HttpCookie",
              "overloads": [
                {
                  "signature": "public HttpCookie(String name, String value)",
                  "description": "Constructs a cookie with a specified name and value.\n\n  The name must conform to RFC 2965. That means it can contain\n only ASCII alphanumeric characters and cannot contain commas,\n semicolons, or white space or begin with a $ character. The cookie's\n name cannot be changed after creation.\n\n  The value can be anything the server chooses to send. Its\n value is probably of interest only to the server. The cookie's\n value can be changed after creation with the\n setValue method.\n\n  By default, cookies are created according to the RFC 2965\n cookie specification. The version can be changed with the\n setVersion method."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static List<HttpCookie> parse(String header)",
                  "description": "Constructs cookies from set-cookie or set-cookie2 header string.\n RFC 2965 section 3.2.2 set-cookie2 syntax indicates that one header line\n may contain more than one cookie definitions, so this is a static\n utility method instead of another constructor."
                }
              ]
            },
            {
              "name": "hasExpired",
              "overloads": [
                {
                  "signature": "public boolean hasExpired()",
                  "description": "Reports whether this HTTP cookie has expired or not."
                }
              ]
            },
            {
              "name": "setComment",
              "overloads": [
                {
                  "signature": "public void setComment(String purpose)",
                  "description": "Specifies a comment that describes a cookie's purpose.\n The comment is useful if the browser presents the cookie\n to the user. Comments are not supported by Netscape Version 0 cookies."
                }
              ]
            },
            {
              "name": "getComment",
              "overloads": [
                {
                  "signature": "public String getComment()",
                  "description": "Returns the comment describing the purpose of this cookie, or\n null if the cookie has no comment."
                }
              ]
            },
            {
              "name": "setCommentURL",
              "overloads": [
                {
                  "signature": "public void setCommentURL(String purpose)",
                  "description": "Specifies a comment URL that describes a cookie's purpose.\n The comment URL is useful if the browser presents the cookie\n to the user. Comment URL is RFC 2965 only."
                }
              ]
            },
            {
              "name": "getCommentURL",
              "overloads": [
                {
                  "signature": "public String getCommentURL()",
                  "description": "Returns the comment URL describing the purpose of this cookie, or\n null if the cookie has no comment URL."
                }
              ]
            },
            {
              "name": "setDiscard",
              "overloads": [
                {
                  "signature": "public void setDiscard(boolean discard)",
                  "description": "Specify whether user agent should discard the cookie unconditionally.\n This is RFC 2965 only attribute."
                }
              ]
            },
            {
              "name": "getDiscard",
              "overloads": [
                {
                  "signature": "public boolean getDiscard()",
                  "description": "Returns the discard attribute of the cookie"
                }
              ]
            },
            {
              "name": "setPortlist",
              "overloads": [
                {
                  "signature": "public void setPortlist(String ports)",
                  "description": "Specify the portlist of the cookie, which restricts the port(s)\n to which a cookie may be sent back in a Cookie header."
                }
              ]
            },
            {
              "name": "getPortlist",
              "overloads": [
                {
                  "signature": "public String getPortlist()",
                  "description": "Returns the port list attribute of the cookie"
                }
              ]
            },
            {
              "name": "setDomain",
              "overloads": [
                {
                  "signature": "public void setDomain(String pattern)",
                  "description": "Specifies the domain within which this cookie should be presented.\n\n  The form of the domain name is specified by RFC 2965. A domain\n name begins with a dot (.foo.com) and means that\n the cookie is visible to servers in a specified Domain Name System\n (DNS) zone (for example, www.foo.com, but not\n a.b.foo.com). By default, cookies are only returned\n to the server that sent them."
                }
              ]
            },
            {
              "name": "getDomain",
              "overloads": [
                {
                  "signature": "public String getDomain()",
                  "description": "Returns the domain name set for this cookie. The form of the domain name\n is set by RFC 2965."
                }
              ]
            },
            {
              "name": "setMaxAge",
              "overloads": [
                {
                  "signature": "public void setMaxAge(long expiry)",
                  "description": "Sets the maximum age of the cookie in seconds.\n\n  A positive value indicates that the cookie will expire\n after that many seconds have passed. Note that the value is\n the maximum age when the cookie will expire, not the cookie's\n current age.\n\n  A negative value means that the cookie is not stored persistently\n and will be deleted when the Web browser exits. A zero value causes the\n cookie to be deleted."
                }
              ]
            },
            {
              "name": "getMaxAge",
              "overloads": [
                {
                  "signature": "public long getMaxAge()",
                  "description": "Returns the maximum age of the cookie, specified in seconds. By default,\n -1 indicating the cookie will persist until browser shutdown."
                }
              ]
            },
            {
              "name": "setPath",
              "overloads": [
                {
                  "signature": "public void setPath(String uri)",
                  "description": "Specifies a path for the cookie to which the client should return\n the cookie.\n\n  The cookie is visible to all the pages in the directory\n you specify, and all the pages in that directory's subdirectories.\n A cookie's path must include the servlet that set the cookie,\n for example, /catalog, which makes the cookie\n visible to all directories on the server under /catalog.\n\n  Consult RFC 2965 (available on the Internet) for more\n information on setting path names for cookies."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Returns the path on the server to which the browser returns this cookie.\n The cookie is visible to all subpaths on the server."
                }
              ]
            },
            {
              "name": "setSecure",
              "overloads": [
                {
                  "signature": "public void setSecure(boolean flag)",
                  "description": "Indicates whether the cookie should only be sent using a secure protocol,\n such as HTTPS or SSL.\n\n  The default value is false."
                }
              ]
            },
            {
              "name": "getSecure",
              "overloads": [
                {
                  "signature": "public boolean getSecure()",
                  "description": "Returns true if sending this cookie should be restricted to a\n secure protocol, or false if the it can be sent using any\n protocol."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of the cookie. The name cannot be changed after\n creation."
                }
              ]
            },
            {
              "name": "setValue",
              "overloads": [
                {
                  "signature": "public void setValue(String newValue)",
                  "description": "Assigns a new value to a cookie after the cookie is created.\n If you use a binary value, you may want to use BASE64 encoding.\n\n  With Version 0 cookies, values should not contain white space,\n brackets, parentheses, equals signs, commas, double quotes, slashes,\n question marks, at signs, colons, and semicolons. Empty values may not\n behave the same way on all browsers."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public String getValue()",
                  "description": "Returns the value of the cookie."
                }
              ]
            },
            {
              "name": "getVersion",
              "overloads": [
                {
                  "signature": "public int getVersion()",
                  "description": "Returns the version of the protocol this cookie complies with. Version 1\n complies with RFC 2965/2109, and version 0 complies with the original\n cookie specification drafted by Netscape. Cookies provided by a browser\n use and identify the browser's cookie version."
                }
              ]
            },
            {
              "name": "setVersion",
              "overloads": [
                {
                  "signature": "public void setVersion(int v)",
                  "description": "Sets the version of the cookie protocol this cookie complies\n with. Version 0 complies with the original Netscape cookie\n specification. Version 1 complies with RFC 2965/2109."
                }
              ]
            },
            {
              "name": "isHttpOnly",
              "overloads": [
                {
                  "signature": "public boolean isHttpOnly()",
                  "description": "Returns true if this cookie contains the HttpOnly\n attribute. This means that the cookie should not be accessible to\n scripting engines, like javascript."
                }
              ]
            },
            {
              "name": "setHttpOnly",
              "overloads": [
                {
                  "signature": "public void setHttpOnly(boolean httpOnly)",
                  "description": "Indicates whether the cookie should be considered HTTP Only. If set to\n true it means the cookie should not be accessible to scripting\n engines like javascript."
                }
              ]
            },
            {
              "name": "domainMatches",
              "overloads": [
                {
                  "signature": "public static boolean domainMatches(String domain, String host)",
                  "description": "The utility method to check whether a host name is in a domain or not.\n\n  This concept is described in the cookie specification.\n To understand the concept, some terminologies need to be defined first:\n \n effective host name = hostname if host name contains dot\n \n or = hostname.local if not\n \n Host A's name domain-matches host B's if:\n \n   their host name strings string-compare equal; or\n   A is a HDN string and has the form NB, where N is a non-empty\n   name string, B has the form .B', and B' is a HDN string.  (So,\n   x.y.com domain-matches .Y.com but not Y.com.)\n \n\n A host isn't in a domain (RFC 2965 sec. 3.3.2) if:\n \n   The value for the Domain attribute contains no embedded dots,\n   and the value is not .local.\n   The effective host name that derives from the request-host does\n   not domain-match the Domain attribute.\n   The request-host is a HDN (not IP address) and has the form HD,\n   where D is the value of the Domain attribute, and H is a string\n   that contains one or more dots.\n \n\n Examples:\n \n   A Set-Cookie2 from request-host y.x.foo.com for Domain=.foo.com\n   would be rejected, because H is y.x and contains a dot.\n   A Set-Cookie2 from request-host x.foo.com for Domain=.foo.com\n   would be accepted.\n   A Set-Cookie2 with Domain=.com or Domain=.com., will always be\n   rejected, because there is no embedded dot.\n   A Set-Cookie2 from request-host example for Domain=.local will\n   be accepted, because the effective host name for the request-\n   host is example.local, and example.local domain-matches .local."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a cookie header string representation of this cookie,\n which is in the format defined by corresponding cookie specification,\n but without the leading \"Cookie:\" token."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Test the equality of two HTTP cookies.\n\n  The result is true only if two cookies come from same domain\n (case-insensitive), have same name (case-insensitive), and have same path\n (case-sensitive)."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this HTTP cookie. The result is the sum of\n hash code value of three significant components of this cookie: name,\n domain, and path. That is, the hash code is the value of the expression:\n \n getName().toLowerCase().hashCode()\n + getDomain().toLowerCase().hashCode()\n + getPath().hashCode()"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Create and return a copy of this object."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpRetryException",
          "methods": [
            {
              "name": "HttpRetryException",
              "overloads": [
                {
                  "signature": "public HttpRetryException(String detail, int code)",
                  "description": "Constructs a new HttpRetryException from the\n specified response code and exception detail message"
                },
                {
                  "signature": "public HttpRetryException(String detail, int code, String location)",
                  "description": "Constructs a new HttpRetryException with detail message\n responseCode and the contents of the Location response header field."
                }
              ]
            },
            {
              "name": "responseCode",
              "overloads": [
                {
                  "signature": "public int responseCode()",
                  "description": "Returns the http response code"
                }
              ]
            },
            {
              "name": "getReason",
              "overloads": [
                {
                  "signature": "public String getReason()",
                  "description": "Returns a string explaining why the http request could\n not be retried."
                }
              ]
            },
            {
              "name": "getLocation",
              "overloads": [
                {
                  "signature": "public String getLocation()",
                  "description": "Returns the value of the Location header field if the\n error resulted from redirection."
                }
              ]
            }
          ]
        },
        {
          "name": "HttpURLConnection",
          "methods": [
            {
              "name": "HttpURLConnection",
              "overloads": [
                {
                  "signature": "protected HttpURLConnection(URL u)",
                  "description": "Constructor for the HttpURLConnection."
                }
              ]
            },
            {
              "name": "setAuthenticator",
              "overloads": [
                {
                  "signature": "public void setAuthenticator(Authenticator auth)",
                  "description": "Supplies an Authenticator to be used\n when authentication is requested through the HTTP protocol for\n this HttpURLConnection.\n If no authenticator is supplied, the\n default\n authenticator will be used."
                }
              ]
            },
            {
              "name": "getHeaderFieldKey",
              "overloads": [
                {
                  "signature": "public String getHeaderFieldKey(int n)",
                  "description": "Returns the key for the nth header field.\n Some implementations may treat the 0th\n header field as special, i.e. as the status line returned by the HTTP\n server. In this case, getHeaderField(0) returns the status\n line, but getHeaderFieldKey(0) returns null."
                }
              ]
            },
            {
              "name": "setFixedLengthStreamingMode",
              "overloads": [
                {
                  "signature": "public void setFixedLengthStreamingMode(int contentLength)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is known in\n advance.\n \n An exception will be thrown if the application\n attempts to write more data than the indicated\n content-length, or if the application closes the OutputStream\n before writing the indicated amount.\n \n When output streaming is enabled, authentication\n and redirection cannot be handled automatically.\n A HttpRetryException will be thrown when reading\n the response if authentication or redirection are required.\n This exception can be queried for the details of the error.\n \n This method must be called before the URLConnection is connected.\n \n NOTE: setFixedLengthStreamingMode(long) is recommended\n instead of this method as it allows larger content lengths to be set."
                },
                {
                  "signature": "public void setFixedLengthStreamingMode(long contentLength)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is known in\n advance.\n\n  An exception will be thrown if the application attempts to write\n more data than the indicated content-length, or if the application\n closes the OutputStream before writing the indicated amount.\n\n  When output streaming is enabled, authentication and redirection\n cannot be handled automatically. A HttpRetryException will\n be thrown when reading the response if authentication or redirection\n are required. This exception can be queried for the details of the\n error.\n\n  This method must be called before the URLConnection is connected.\n\n  The content length set by invoking this method takes precedence\n over any value set by setFixedLengthStreamingMode(int)."
                }
              ]
            },
            {
              "name": "setChunkedStreamingMode",
              "overloads": [
                {
                  "signature": "public void setChunkedStreamingMode(int chunklen)",
                  "description": "This method is used to enable streaming of a HTTP request body\n without internal buffering, when the content length is not\n known in advance. In this mode, chunked transfer encoding\n is used to send the request body. Note, not all HTTP servers\n support this mode.\n \n When output streaming is enabled, authentication\n and redirection cannot be handled automatically.\n A HttpRetryException will be thrown when reading\n the response if authentication or redirection are required.\n This exception can be queried for the details of the error.\n \n This method must be called before the URLConnection is connected."
                }
              ]
            },
            {
              "name": "getHeaderField",
              "overloads": [
                {
                  "signature": "public String getHeaderField(int n)",
                  "description": "Returns the value for the nth header field.\n Some implementations may treat the 0th\n header field as special, i.e. as the status line returned by the HTTP\n server.\n \n This method can be used in conjunction with the\n getHeaderFieldKey method to iterate through all\n the headers in the message."
                }
              ]
            },
            {
              "name": "setFollowRedirects",
              "overloads": [
                {
                  "signature": "public static void setFollowRedirects(boolean set)",
                  "description": "Sets whether HTTP redirects  (requests with response code 3xx) should\n be automatically followed by this class.  True by default.  Applets\n cannot change this variable.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "getFollowRedirects",
              "overloads": [
                {
                  "signature": "public static boolean getFollowRedirects()",
                  "description": "Returns a boolean indicating\n whether or not HTTP redirects (3xx) should\n be automatically followed."
                }
              ]
            },
            {
              "name": "setInstanceFollowRedirects",
              "overloads": [
                {
                  "signature": "public void setInstanceFollowRedirects(boolean followRedirects)",
                  "description": "Sets whether HTTP redirects (requests with response code 3xx) should\n be automatically followed by this HttpURLConnection\n instance.\n \n The default value comes from followRedirects, which defaults to\n true."
                }
              ]
            },
            {
              "name": "getInstanceFollowRedirects",
              "overloads": [
                {
                  "signature": "public boolean getInstanceFollowRedirects()",
                  "description": "Returns the value of this HttpURLConnection's\n instanceFollowRedirects field."
                }
              ]
            },
            {
              "name": "setRequestMethod",
              "overloads": [
                {
                  "signature": "public void setRequestMethod(String method) throws ProtocolException",
                  "description": "Set the method for the URL request, one of:\n \n  GET\n  POST\n  HEAD\n  OPTIONS\n  PUT\n  DELETE\n  TRACE\n  are legal, subject to protocol restrictions.  The default\n method is GET."
                }
              ]
            },
            {
              "name": "getRequestMethod",
              "overloads": [
                {
                  "signature": "public String getRequestMethod()",
                  "description": "Get the request method."
                }
              ]
            },
            {
              "name": "getResponseCode",
              "overloads": [
                {
                  "signature": "public int getResponseCode() throws IOException",
                  "description": "Gets the status code from an HTTP response message.\n For example, in the case of the following status lines:\n  HTTP/1.0 200 OK\n HTTP/1.0 401 Unauthorized\n \n It will return 200 and 401 respectively.\n Returns -1 if no code can be discerned\n from the response (i.e., the response is not valid HTTP)."
                }
              ]
            },
            {
              "name": "getResponseMessage",
              "overloads": [
                {
                  "signature": "public String getResponseMessage() throws IOException",
                  "description": "Gets the HTTP response message, if any, returned along with the\n response code from a server.  From responses like:\n  HTTP/1.0 200 OK\n HTTP/1.0 404 Not Found\n \n Extracts the Strings \"OK\" and \"Not Found\" respectively.\n Returns null if none could be discerned from the responses\n (the result was not valid HTTP)."
                }
              ]
            },
            {
              "name": "disconnect",
              "overloads": [
                {
                  "signature": "public abstract void disconnect()",
                  "description": "Indicates that other requests to the server\n are unlikely in the near future. Calling disconnect()\n should not imply that this HttpURLConnection\n instance can be reused for other requests."
                }
              ]
            },
            {
              "name": "usingProxy",
              "overloads": [
                {
                  "signature": "public abstract boolean usingProxy()",
                  "description": "Indicates if the connection is going through a proxy.\n\n This method returns true if the connection is known\n to be going or has gone through proxies, and returns false\n if the connection will never go through a proxy or if\n the use of a proxy cannot be determined."
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission() throws IOException",
                  "description": "Returns a SocketPermission object representing the\n permission necessary to connect to the destination host and port."
                }
              ]
            },
            {
              "name": "getErrorStream",
              "overloads": [
                {
                  "signature": "public InputStream getErrorStream()",
                  "description": "Returns the error stream if the connection failed\n but the server sent useful data nonetheless. The\n typical example is when an HTTP server responds\n with a 404, which will cause a FileNotFoundException\n to be thrown in connect, but the server sent an HTML\n help page with suggestions as to what to do.\n\n This method will not cause a connection to be initiated.  If\n the connection was not connected, or if the server did not have\n an error while connecting or if the server had an error but\n no error data was sent, this method will return null. This is\n the default."
                }
              ]
            }
          ]
        },
        {
          "name": "IDN",
          "methods": [
            {
              "name": "toASCII",
              "overloads": [
                {
                  "signature": "public static String toASCII(String input, int flag)",
                  "description": "Translates a string from Unicode to ASCII Compatible Encoding (ACE),\n as defined by the ToASCII operation of RFC 3490.\n\n ToASCII operation can fail. ToASCII fails if any step of it fails.\n If ToASCII operation fails, an IllegalArgumentException will be thrown.\n In this case, the input string should not be used in an internationalized domain name.\n\n  A label is an individual part of a domain name. The original ToASCII operation,\n as defined in RFC 3490, only operates on a single label. This method can handle\n both label and entire domain name, by assuming that labels in a domain name are\n always separated by dots. The following characters are recognized as dots:\n \\u002E (full stop), \\u3002 (ideographic full stop), \\uFF0E (fullwidth full stop),\n and \\uFF61 (halfwidth ideographic full stop). if dots are\n used as label separators, this method also changes all of them to \\u002E (full stop)\n in output translated string."
                },
                {
                  "signature": "public static String toASCII(String input)",
                  "description": "Translates a string from Unicode to ASCII Compatible Encoding (ACE),\n as defined by the ToASCII operation of RFC 3490.\n\n  This convenience method works as if by invoking the\n two-argument counterpart as follows:\n \n toASCII(input,0);"
                }
              ]
            },
            {
              "name": "toUnicode",
              "overloads": [
                {
                  "signature": "public static String toUnicode(String input, int flag)",
                  "description": "Translates a string from ASCII Compatible Encoding (ACE) to Unicode,\n as defined by the ToUnicode operation of RFC 3490.\n\n ToUnicode never fails. In case of any error, the input string is returned unmodified.\n\n  A label is an individual part of a domain name. The original ToUnicode operation,\n as defined in RFC 3490, only operates on a single label. This method can handle\n both label and entire domain name, by assuming that labels in a domain name are\n always separated by dots. The following characters are recognized as dots:\n \\u002E (full stop), \\u3002 (ideographic full stop), \\uFF0E (fullwidth full stop),\n and \\uFF61 (halfwidth ideographic full stop)."
                },
                {
                  "signature": "public static String toUnicode(String input)",
                  "description": "Translates a string from ASCII Compatible Encoding (ACE) to Unicode,\n as defined by the ToUnicode operation of RFC 3490.\n\n  This convenience method works as if by invoking the\n two-argument counterpart as follows:\n \n toUnicode(input,0);"
                }
              ]
            }
          ]
        },
        {
          "name": "Inet4Address",
          "methods": [
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IP multicast address. IP multicast address is a Class D\n address i.e first four bits of the address are 1110."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress\n object. The result is in network byte order: the highest order\n byte of the address is in getAddress()[0]."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation form."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same IP address as\n this object.\n \n Two instances of InetAddress represent the same IP\n address if the length of the byte arrays returned by\n getAddress is the same for both, and each of the\n array components is the same for the byte arrays."
                }
              ]
            }
          ]
        },
        {
          "name": "Inet6Address",
          "methods": [
            {
              "name": "getByAddress",
              "overloads": [
                {
                  "signature": "public static Inet6Address getByAddress(String host, byte[] addr, NetworkInterface nif) throws UnknownHostException",
                  "description": "Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is\n set to the value corresponding to the given interface for the address\n type specified in addr. The call will fail with an\n UnknownHostException if the given interface does not have a numeric\n scope_id assigned for the given address type (e.g. link-local or site-local).\n See here for a description of IPv6\n scoped addresses."
                },
                {
                  "signature": "public static Inet6Address getByAddress(String host, byte[] addr, int scope_id) throws UnknownHostException",
                  "description": "Create an Inet6Address in the exact manner of InetAddress.getByAddress(String,byte[]) except that the IPv6 scope_id is\n set to the given numeric value. The scope_id is not checked to determine\n if it corresponds to any interface on the system.\n See here for a description of IPv6\n scoped addresses."
                }
              ]
            },
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an IP multicast\n address. 11111111 at the start of the address identifies the\n address as being a multicast address."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress object. The result\n is in network byte order: the highest order byte of the address is in\n getAddress()[0]."
                }
              ]
            },
            {
              "name": "getScopeId",
              "overloads": [
                {
                  "signature": "public int getScopeId()",
                  "description": "Returns the numeric scopeId, if this instance is associated with\n an interface. If no scoped_id is set, the returned value is zero."
                }
              ]
            },
            {
              "name": "getScopedInterface",
              "overloads": [
                {
                  "signature": "public NetworkInterface getScopedInterface()",
                  "description": "Returns the scoped interface, if this instance was created with\n a scoped interface."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation. If the instance\n was created specifying a scope identifier then the scope id is appended\n to the IP address preceded by a \"%\" (per-cent) character. This can be\n either a numeric value or a string, depending on which was used to create\n the instance."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object. The result is \n true if and only if the argument is not null and it represents\n the same IP address as this object.\n\n  Two instances of InetAddress represent the same IP address\n if the length of the byte arrays returned by getAddress is the\n same for both, and each of the array components is the same for the byte\n arrays."
                }
              ]
            },
            {
              "name": "isIPv4CompatibleAddress",
              "overloads": [
                {
                  "signature": "public boolean isIPv4CompatibleAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IPv4 compatible IPv6 address."
                }
              ]
            }
          ]
        },
        {
          "name": "InetAddress",
          "methods": [
            {
              "name": "isMulticastAddress",
              "overloads": [
                {
                  "signature": "public boolean isMulticastAddress()",
                  "description": "Utility routine to check if the InetAddress is an\n IP multicast address."
                }
              ]
            },
            {
              "name": "isAnyLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isAnyLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a wildcard address."
                }
              ]
            },
            {
              "name": "isLoopbackAddress",
              "overloads": [
                {
                  "signature": "public boolean isLoopbackAddress()",
                  "description": "Utility routine to check if the InetAddress is a loopback address."
                }
              ]
            },
            {
              "name": "isLinkLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isLinkLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is an link local address."
                }
              ]
            },
            {
              "name": "isSiteLocalAddress",
              "overloads": [
                {
                  "signature": "public boolean isSiteLocalAddress()",
                  "description": "Utility routine to check if the InetAddress is a site local address."
                }
              ]
            },
            {
              "name": "isMCGlobal",
              "overloads": [
                {
                  "signature": "public boolean isMCGlobal()",
                  "description": "Utility routine to check if the multicast address has global scope."
                }
              ]
            },
            {
              "name": "isMCNodeLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCNodeLocal()",
                  "description": "Utility routine to check if the multicast address has node scope."
                }
              ]
            },
            {
              "name": "isMCLinkLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCLinkLocal()",
                  "description": "Utility routine to check if the multicast address has link scope."
                }
              ]
            },
            {
              "name": "isMCSiteLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCSiteLocal()",
                  "description": "Utility routine to check if the multicast address has site scope."
                }
              ]
            },
            {
              "name": "isMCOrgLocal",
              "overloads": [
                {
                  "signature": "public boolean isMCOrgLocal()",
                  "description": "Utility routine to check if the multicast address has organization scope."
                }
              ]
            },
            {
              "name": "isReachable",
              "overloads": [
                {
                  "signature": "public boolean isReachable(int timeout) throws IOException",
                  "description": "Test whether that address is reachable. Best effort is made by the\n implementation to try to reach the host, but firewalls and server\n configuration may block requests resulting in a unreachable status\n while some specific ports may be accessible.\n A typical implementation will use ICMP ECHO REQUESTs if the\n privilege can be obtained, otherwise it will try to establish\n a TCP connection on port 7 (Echo) of the destination host.\n \n The timeout value, in milliseconds, indicates the maximum amount of time\n the try should take. If the operation times out before getting an\n answer, the host is deemed unreachable. A negative value will result\n in an IllegalArgumentException being thrown."
                },
                {
                  "signature": "public boolean isReachable(NetworkInterface netif, int ttl, int timeout) throws IOException",
                  "description": "Test whether that address is reachable. Best effort is made by the\n implementation to try to reach the host, but firewalls and server\n configuration may block requests resulting in a unreachable status\n while some specific ports may be accessible.\n A typical implementation will use ICMP ECHO REQUESTs if the\n privilege can be obtained, otherwise it will try to establish\n a TCP connection on port 7 (Echo) of the destination host.\n \n The network interface and ttl parameters\n let the caller specify which network interface the test will go through\n and the maximum number of hops the packets should go through.\n A negative value for the ttl will result in an\n IllegalArgumentException being thrown.\n \n The timeout value, in milliseconds, indicates the maximum amount of time\n the try should take. If the operation times out before getting an\n answer, the host is deemed unreachable. A negative value will result\n in an IllegalArgumentException being thrown."
                }
              ]
            },
            {
              "name": "getHostName",
              "overloads": [
                {
                  "signature": "public String getHostName()",
                  "description": "Gets the host name for this IP address.\n\n If this InetAddress was created with a host name,\n this host name will be remembered and returned;\n otherwise, a reverse name lookup will be performed\n and the result will be returned based on the system\n configured name lookup service. If a lookup of the name service\n is required, call\n getCanonicalHostName.\n\n If there is a security manager, its\n checkConnect method is first called\n with the hostname and -1\n as its arguments to see if the operation is allowed.\n If the operation is not allowed, it will return\n the textual representation of the IP address."
                }
              ]
            },
            {
              "name": "getCanonicalHostName",
              "overloads": [
                {
                  "signature": "public String getCanonicalHostName()",
                  "description": "Gets the fully qualified domain name for this IP address.\n Best effort method, meaning we may not be able to return\n the FQDN depending on the underlying system configuration.\n\n If there is a security manager, this method first\n calls its checkConnect method\n with the hostname and -1\n as its arguments to see if the calling code is allowed to know\n the hostname for this IP address, i.e., to connect to the host.\n If the operation is not allowed, it will return\n the textual representation of the IP address."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public byte[] getAddress()",
                  "description": "Returns the raw IP address of this InetAddress\n object. The result is in network byte order: the highest order\n byte of the address is in getAddress()[0]."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "public String getHostAddress()",
                  "description": "Returns the IP address string in textual presentation."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this IP address."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same IP address as\n this object.\n \n Two instances of InetAddress represent the same IP\n address if the length of the byte arrays returned by\n getAddress is the same for both, and each of the\n array components is the same for the byte arrays."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this IP address to a String. The\n string returned is of the form: hostname / literal IP\n address.\n\n If the host name is unresolved, no reverse name service lookup\n is performed. The hostname part will be represented by an empty string."
                }
              ]
            },
            {
              "name": "getByAddress",
              "overloads": [
                {
                  "signature": "public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException",
                  "description": "Creates an InetAddress based on the provided host name and IP address.\n No name service is checked for the validity of the address.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its IP\n address.\n  No validity checking is done on the host name either.\n\n  If addr specifies an IPv4 address an instance of Inet4Address\n will be returned; otherwise, an instance of Inet6Address\n will be returned.\n\n  IPv4 address byte array must be 4 bytes long and IPv6 byte array\n must be 16 bytes long"
                },
                {
                  "signature": "public static InetAddress getByAddress(byte[] addr) throws UnknownHostException",
                  "description": "Returns an InetAddress object given the raw IP address .\n The argument is in network byte order: the highest order\n byte of the address is in getAddress()[0].\n\n  This method doesn't block, i.e. no reverse name service lookup\n is performed.\n\n  IPv4 address byte array must be 4 bytes long and IPv6 byte array\n must be 16 bytes long"
                }
              ]
            },
            {
              "name": "getByName",
              "overloads": [
                {
                  "signature": "public static InetAddress getByName(String host) throws UnknownHostException",
                  "description": "Determines the IP address of a host, given the host's name.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its\n IP address. If a literal IP address is supplied, only the\n validity of the address format is checked.\n\n  For host specified in literal IPv6 address,\n either the form defined in RFC 2732 or the literal IPv6 address\n format defined in RFC 2373 is accepted. IPv6 scoped addresses are also\n supported. See here for a description of IPv6\n scoped addresses.\n\n  If the host is null or host.length() is equal\n to zero, then an InetAddress representing an address of the\n loopback interface is returned.\n See RFC3330\n section2 and RFC2373\n section2.5.3.\n\n  If there is a security manager, and host is not null\n or host.length()  is not equal to zero, the security manager's\n checkConnect method is called with the hostname and -1\n as its arguments to determine if the operation is allowed."
                }
              ]
            },
            {
              "name": "getAllByName",
              "overloads": [
                {
                  "signature": "public static InetAddress[] getAllByName(String host) throws UnknownHostException",
                  "description": "Given the name of a host, returns an array of its IP addresses,\n based on the configured name service on the system.\n\n  The host name can either be a machine name, such as\n \"www.example.com\", or a textual representation of its IP\n address. If a literal IP address is supplied, only the\n validity of the address format is checked.\n\n  For host specified in literal IPv6 address,\n either the form defined in RFC 2732 or the literal IPv6 address\n format defined in RFC 2373 is accepted. A literal IPv6 address may\n also be qualified by appending a scoped zone identifier or scope_id.\n The syntax and usage of scope_ids is described\n here.\n\n  If the host is null or host.length() is equal\n to zero, then an InetAddress representing an address of the\n loopback interface is returned.\n See RFC3330\n section2 and RFC2373\n section2.5.3. \n\n  If there is a security manager, and host is not null\n or host.length()  is not equal to zero, the security manager's\n checkConnect method is called with the hostname and -1\n as its arguments to determine if the operation is allowed."
                }
              ]
            },
            {
              "name": "getLoopbackAddress",
              "overloads": [
                {
                  "signature": "public static InetAddress getLoopbackAddress()",
                  "description": "Returns the loopback address.\n \n The InetAddress returned will represent the IPv4\n loopback address, 127.0.0.1, or the IPv6 loopback\n address, ::1. The IPv4 loopback address returned\n is only one of many in the form 127.*.*.*"
                }
              ]
            },
            {
              "name": "getLocalHost",
              "overloads": [
                {
                  "signature": "public static InetAddress getLocalHost() throws UnknownHostException",
                  "description": "Returns the address of the local host. This is achieved by retrieving\n the name of the host from the system, then resolving that name into\n an InetAddress.\n\n Note: The resolved address may be cached for a short period of time.\n \n\n If there is a security manager, its\n checkConnect method is called\n with the local host name and -1\n as its arguments to see if the operation is allowed.\n If the operation is not allowed, an InetAddress representing\n the loopback address is returned."
                }
              ]
            }
          ]
        },
        {
          "name": "InetSocketAddress",
          "methods": [
            {
              "name": "InetSocketAddress",
              "overloads": [
                {
                  "signature": "public InetSocketAddress(int port)",
                  "description": "Creates a socket address where the IP address is the wildcard address\n and the port number a specified value.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                },
                {
                  "signature": "public InetSocketAddress(InetAddress addr, int port)",
                  "description": "Creates a socket address from an IP address and a port number.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation.\n \n A null address will assign the wildcard address."
                },
                {
                  "signature": "public InetSocketAddress(String hostname, int port)",
                  "description": "Creates a socket address from a hostname and a port number.\n \n An attempt will be made to resolve the hostname into an InetAddress.\n If that attempt fails, the address will be flagged as unresolved.\n \n If there is a security manager, its checkConnect method\n is called with the host name as its argument to check the permission\n to resolve it. This could result in a SecurityException.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                }
              ]
            },
            {
              "name": "createUnresolved",
              "overloads": [
                {
                  "signature": "public static InetSocketAddress createUnresolved(String host, int port)",
                  "description": "Creates an unresolved socket address from a hostname and a port number.\n \n No attempt will be made to resolve the hostname into an InetAddress.\n The address will be flagged as unresolved.\n \n A valid port value is between 0 and 65535.\n A port number of zero will let the system pick up an\n ephemeral port in a bind operation."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public final int getPort()",
                  "description": "Gets the port number."
                }
              ]
            },
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public final InetAddress getAddress()",
                  "description": "Gets the InetAddress."
                }
              ]
            },
            {
              "name": "getHostName",
              "overloads": [
                {
                  "signature": "public final String getHostName()",
                  "description": "Gets the hostname.\n Note: This method may trigger a name service reverse lookup if the\n address was created with a literal IP address."
                }
              ]
            },
            {
              "name": "getHostString",
              "overloads": [
                {
                  "signature": "public final String getHostString()",
                  "description": "Returns the hostname, or the String form of the address if it\n doesn't have a hostname (it was created using a literal).\n This has the benefit of not attempting a reverse lookup."
                }
              ]
            },
            {
              "name": "isUnresolved",
              "overloads": [
                {
                  "signature": "public final boolean isUnresolved()",
                  "description": "Checks whether the address has been resolved or not."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this InetSocketAddress.\n This string is constructed by calling InetAddress.toString()\n on the InetAddress and concatenating the port number (with a colon).\n \n If the address is an IPv6 address, the IPv6 literal is enclosed in\n square brackets, for example: \"localhost/[0:0:0:0:0:0:0:1]:80\".\n If the address is unresolved,\n <unresolved> is displayed in place of the address literal, for\n example \"foo/<unresolved>:80\".\n \n To retrieve a string representation of the hostname or the address, use\n getHostString(), rather than parsing the string returned by this\n toString() method."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same address as\n this object.\n \n Two instances of InetSocketAddress represent the same\n address if both the InetAddresses (or hostnames if it is unresolved) and port\n numbers are equal.\n If both addresses are unresolved, then the hostname and the port number\n are compared.\n\n Note: Hostnames are case insensitive. e.g. \"FooBar\" and \"foobar\" are\n considered equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hashcode for this socket address."
                }
              ]
            }
          ]
        },
        {
          "name": "InterfaceAddress",
          "methods": [
            {
              "name": "getAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getAddress()",
                  "description": "Returns an InetAddress for this address."
                }
              ]
            },
            {
              "name": "getBroadcast",
              "overloads": [
                {
                  "signature": "public InetAddress getBroadcast()",
                  "description": "Returns an InetAddress for the broadcast address\n for this InterfaceAddress.\n \n Only IPv4 networks have broadcast address therefore, in the case\n of an IPv6 network, null will be returned."
                }
              ]
            },
            {
              "name": "getNetworkPrefixLength",
              "overloads": [
                {
                  "signature": "public short getNetworkPrefixLength()",
                  "description": "Returns the network prefix length for this address. This is also known\n as the subnet mask in the context of IPv4 addresses.\n Typical IPv4 values would be 8 (255.0.0.0), 16 (255.255.0.0)\n or 24 (255.255.255.0). \n Typical IPv6 values would be 128 (::1/128) or 10 (fe80::203:baff:fe27:1243/10)"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same interface address as\n this object.\n \n Two instances of InterfaceAddress represent the same\n address if the InetAddress, the prefix length and the broadcast are\n the same for both."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this Interface address."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this Interface address to a String. The\n string returned is of the form: InetAddress / prefix length [ broadcast address ]."
                }
              ]
            }
          ]
        },
        {
          "name": "JarURLConnection",
          "methods": [
            {
              "name": "JarURLConnection",
              "overloads": [
                {
                  "signature": "protected JarURLConnection(URL url) throws MalformedURLException",
                  "description": "Creates the new JarURLConnection to the specified URL."
                }
              ]
            },
            {
              "name": "getJarFileURL",
              "overloads": [
                {
                  "signature": "public URL getJarFileURL()",
                  "description": "Returns the URL for the Jar file for this connection."
                }
              ]
            },
            {
              "name": "getEntryName",
              "overloads": [
                {
                  "signature": "public String getEntryName()",
                  "description": "Return the entry name for this connection. This method\n returns null if the JAR file URL corresponding to this\n connection points to a JAR file and not a JAR file entry."
                }
              ]
            },
            {
              "name": "getJarFile",
              "overloads": [
                {
                  "signature": "public abstract JarFile getJarFile() throws IOException",
                  "description": "Return the JAR file for this connection."
                }
              ]
            },
            {
              "name": "getManifest",
              "overloads": [
                {
                  "signature": "public Manifest getManifest() throws IOException",
                  "description": "Returns the Manifest for this connection, or null if none."
                }
              ]
            },
            {
              "name": "getJarEntry",
              "overloads": [
                {
                  "signature": "public JarEntry getJarEntry() throws IOException",
                  "description": "Return the JAR entry object for this connection, if any. This\n method returns null if the JAR file URL corresponding to this\n connection points to a JAR file and not a JAR file entry."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "public Attributes getAttributes() throws IOException",
                  "description": "Return the Attributes object for this connection if the URL\n for it points to a JAR file entry, null otherwise."
                }
              ]
            },
            {
              "name": "getMainAttributes",
              "overloads": [
                {
                  "signature": "public Attributes getMainAttributes() throws IOException",
                  "description": "Returns the main Attributes for the JAR file for this\n connection."
                }
              ]
            },
            {
              "name": "getCertificates",
              "overloads": [
                {
                  "signature": "public Certificate[] getCertificates() throws IOException",
                  "description": "Returns the Certificate objects for this connection if the URL\n for it points to a JAR file entry, null otherwise. This method\n can only be called once\n the connection has been completely verified by reading\n from the input stream until the end of the stream has been\n reached. Otherwise, this method will return null"
                }
              ]
            }
          ]
        },
        {
          "name": "MalformedURLException",
          "methods": [
            {
              "name": "MalformedURLException",
              "overloads": [
                {
                  "signature": "public MalformedURLException()",
                  "description": "Constructs a MalformedURLException with no detail message."
                },
                {
                  "signature": "public MalformedURLException(String msg)",
                  "description": "Constructs a MalformedURLException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "MulticastSocket",
          "methods": [
            {
              "name": "MulticastSocket",
              "overloads": [
                {
                  "signature": "public MulticastSocket() throws IOException",
                  "description": "Constructs a multicast socket and binds it to any available port\n on the local host machine.  The socket will be bound to the\n wildcard address.\n\n \n If there is a security manager, its checkListen method is first\n called with 0 as its argument to ensure the operation is allowed. This\n could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is called to\n enable the SO_REUSEADDR socket option."
                },
                {
                  "signature": "public MulticastSocket(int port) throws IOException",
                  "description": "Constructs a multicast socket and binds it to the specified port\n on the local host machine. The socket will be bound to the\n wildcard address.\n\n If there is a security manager,\n its checkListen method is first called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is\n called to enable the SO_REUSEADDR socket option."
                },
                {
                  "signature": "public MulticastSocket(SocketAddress bindaddr) throws IOException",
                  "description": "Creates a multicast socket, bound to the specified local\n socket address.\n \n If the address is null an unbound socket will be created.\n\n If there is a security manager,\n its checkListen method is first called\n with the SocketAddress port as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n \n When the socket is created the\n DatagramSocket.setReuseAddress(boolean) method is\n called to enable the SO_REUSEADDR socket option."
                }
              ]
            },
            {
              "name": "setTTL",
              "overloads": [
                {
                  "signature": "@Deprecated public void setTTL(byte ttl) throws IOException",
                  "description": "Set the default time-to-live for multicast packets sent out\n on this MulticastSocket in order to control the\n scope of the multicasts.\n\n The ttl is an unsigned 8-bit quantity, and so must be\n in the range 0 <= ttl <= 0xFF .",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setTimeToLive",
              "overloads": [
                {
                  "signature": "public void setTimeToLive(int ttl) throws IOException",
                  "description": "Set the default time-to-live for multicast packets sent out\n on this MulticastSocket in order to control the\n scope of the multicasts.\n\n  The ttl must be in the range  0 <= ttl <=\n 255 or an IllegalArgumentException will be thrown.\n Multicast packets sent with a TTL of 0 are not transmitted\n on the network but may be delivered locally."
                }
              ]
            },
            {
              "name": "getTTL",
              "overloads": [
                {
                  "signature": "@Deprecated public byte getTTL() throws IOException",
                  "description": "Get the default time-to-live for multicast packets sent out on\n the socket.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getTimeToLive",
              "overloads": [
                {
                  "signature": "public int getTimeToLive() throws IOException",
                  "description": "Get the default time-to-live for multicast packets sent out on\n the socket."
                }
              ]
            },
            {
              "name": "joinGroup",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void joinGroup(InetAddress mcastaddr) throws IOException",
                  "description": "Joins a multicast group. Its behavior may be affected by\n setInterface or setNetworkInterface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument.",
                  "deprecated": true
                },
                {
                  "signature": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Joins a multicast group.\n\n  In order to join a multicast group, the caller should specify\n the IP address of the multicast group to join, and the local\n network interface to receive multicast\n packets from.\n \n   The mcastaddr argument indicates the IP address\n   of the multicast group to join. For historical reasons this is\n   specified as a SocketAddress.\n   The default implementation only supports InetSocketAddress and\n   the port information is ignored.\n  \n   The netIf argument specifies the local interface to receive\n       multicast datagram packets, or null to defer to the interface\n       set for outgoing multicast datagrams.\n       If null, and no interface has been set, the behaviour is\n       unspecified: any interface may be selected or the operation may fail\n       with a SocketException.\n  \n \n\n  It is possible to call this method several times to join\n several different multicast groups, or join the same group\n in several different networks. However, if the socket is already a\n member of the group, an IOException will be thrown.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the mcastaddr\n argument as its argument."
                }
              ]
            },
            {
              "name": "leaveGroup",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void leaveGroup(InetAddress mcastaddr) throws IOException",
                  "description": "Leave a multicast group. Its behavior may be affected by\n setInterface or setNetworkInterface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument.",
                  "deprecated": true
                },
                {
                  "signature": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException",
                  "description": "Leave a multicast group on a specified local interface.\n\n If there is a security manager, this method first\n calls its checkMulticast method with the\n mcastaddr argument as its argument."
                }
              ]
            },
            {
              "name": "setInterface",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void setInterface(InetAddress inf) throws SocketException",
                  "description": "Set the multicast network interface used by methods\n whose behavior would be affected by the value of the\n network interface. Useful for multihomed hosts.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getInterface",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public InetAddress getInterface() throws SocketException",
                  "description": "Retrieve the address of the network interface used for\n multicast packets.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setNetworkInterface",
              "overloads": [
                {
                  "signature": "public void setNetworkInterface(NetworkInterface netIf) throws SocketException",
                  "description": "Specify the network interface for outgoing multicast datagrams\n sent on this socket."
                }
              ]
            },
            {
              "name": "getNetworkInterface",
              "overloads": [
                {
                  "signature": "public NetworkInterface getNetworkInterface() throws SocketException",
                  "description": "Get the multicast network interface set for outgoing multicast\n datagrams sent from this socket."
                }
              ]
            },
            {
              "name": "setLoopbackMode",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public void setLoopbackMode(boolean disable) throws SocketException",
                  "description": "Disable/Enable local loopback of multicast datagrams.\n The option is used by the platform's networking code as a hint\n for setting whether multicast data will be looped back to\n the local socket.\n\n Because this option is a hint, applications that want to\n verify what loopback mode is set to should call\n getLoopbackMode()",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getLoopbackMode",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"14\") public boolean getLoopbackMode() throws SocketException",
                  "description": "Get the setting for local loopback of multicast datagrams.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "send",
              "overloads": [
                {
                  "signature": "@Deprecated public void send(DatagramPacket p, byte ttl) throws IOException",
                  "description": "Sends a datagram packet to the destination, with a TTL (time-to-live)\n other than the default for the socket.  This method\n need only be used in instances where a particular TTL is desired;\n otherwise it is preferable to set a TTL once on the socket, and\n use that default TTL for all packets.  This method does not\n  alter the default TTL for the socket. Its behavior may be\n affected by setInterface.\n\n If there is a security manager, this method first performs some\n security checks. First, if p.getAddress().isMulticastAddress()\n is true, this method calls the\n security manager's checkMulticast method\n with p.getAddress() and ttl as its arguments.\n If the evaluation of that expression is false,\n this method instead calls the security manager's\n checkConnect method with arguments\n p.getAddress().getHostAddress() and\n p.getPort(). Each call to a security manager method\n could result in a SecurityException if the operation is not allowed.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "NetPermission",
          "methods": [
            {
              "name": "NetPermission",
              "overloads": [
                {
                  "signature": "public NetPermission(String name)",
                  "description": "Creates a new NetPermission with the specified name.\n The name is the symbolic name of the NetPermission, such as\n \"setDefaultAuthenticator\", etc. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match."
                },
                {
                  "signature": "public NetPermission(String name, String actions)",
                  "description": "Creates a new NetPermission object with the specified name.\n The name is the symbolic name of the NetPermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "NetworkInterface",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Get the name of this network interface."
                }
              ]
            },
            {
              "name": "getInetAddresses",
              "overloads": [
                {
                  "signature": "public Enumeration<InetAddress> getInetAddresses()",
                  "description": "Get an Enumeration with all or a subset of the InetAddresses bound to\n this network interface.\n \n If there is a security manager, its checkConnect\n method is called for each InetAddress. Only InetAddresses where\n the checkConnect doesn't throw a SecurityException\n will be returned in the Enumeration. However, if the caller has the\n NetPermission(\"getNetworkInformation\") permission, then all\n InetAddresses are returned."
                }
              ]
            },
            {
              "name": "inetAddresses",
              "overloads": [
                {
                  "signature": "public Stream<InetAddress> inetAddresses()",
                  "description": "Get a Stream of all or a subset of the InetAddresses bound to this\n network interface.\n \n If there is a security manager, its checkConnect\n method is called for each InetAddress. Only InetAddresses where\n the checkConnect doesn't throw a SecurityException will be\n returned in the Stream. However, if the caller has the\n NetPermission(\"getNetworkInformation\") permission, then all\n InetAddresses are returned."
                }
              ]
            },
            {
              "name": "getInterfaceAddresses",
              "overloads": [
                {
                  "signature": "public List<InterfaceAddress> getInterfaceAddresses()",
                  "description": "Get a List of all or a subset of the InterfaceAddresses\n of this network interface.\n \n If there is a security manager, its checkConnect\n method is called with the InetAddress for each InterfaceAddress.\n Only InterfaceAddresses where the checkConnect doesn't throw\n a SecurityException will be returned in the List."
                }
              ]
            },
            {
              "name": "getSubInterfaces",
              "overloads": [
                {
                  "signature": "public Enumeration<NetworkInterface> getSubInterfaces()",
                  "description": "Get an Enumeration with all the subinterfaces (also known as virtual\n interfaces) attached to this network interface.\n \n For instance eth0:1 will be a subinterface to eth0."
                }
              ]
            },
            {
              "name": "subInterfaces",
              "overloads": [
                {
                  "signature": "public Stream<NetworkInterface> subInterfaces()",
                  "description": "Get a Stream of all subinterfaces (also known as virtual\n interfaces) attached to this network interface."
                }
              ]
            },
            {
              "name": "getParent",
              "overloads": [
                {
                  "signature": "public NetworkInterface getParent()",
                  "description": "Returns the parent NetworkInterface of this interface if this is\n a subinterface, or null if it is a physical\n (non virtual) interface or has no parent."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Returns the index of this network interface. The index is an integer greater\n or equal to zero, or -1 for unknown. This is a system specific value\n and interfaces with the same name can have different indexes on different\n machines."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName()",
                  "description": "Get the display name of this network interface.\n A display name is a human readable String describing the network\n device."
                }
              ]
            },
            {
              "name": "getByName",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByName(String name) throws SocketException",
                  "description": "Searches for the network interface with the specified name."
                }
              ]
            },
            {
              "name": "getByIndex",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByIndex(int index) throws SocketException",
                  "description": "Get a network interface given its index."
                }
              ]
            },
            {
              "name": "getByInetAddress",
              "overloads": [
                {
                  "signature": "public static NetworkInterface getByInetAddress(InetAddress addr) throws SocketException",
                  "description": "Convenience method to search for a network interface that\n has the specified Internet Protocol (IP) address bound to\n it.\n \n If the specified IP address is bound to multiple network\n interfaces it is not defined which network interface is\n returned."
                }
              ]
            },
            {
              "name": "getNetworkInterfaces",
              "overloads": [
                {
                  "signature": "public static Enumeration<NetworkInterface> getNetworkInterfaces() throws SocketException",
                  "description": "Returns an Enumeration of all the interfaces on this machine. The\n Enumeration contains at least one element, possibly representing\n a loopback interface that only supports communication between entities on\n this machine."
                }
              ]
            },
            {
              "name": "networkInterfaces",
              "overloads": [
                {
                  "signature": "public static Stream<NetworkInterface> networkInterfaces() throws SocketException",
                  "description": "Returns a Stream of all the interfaces on this machine.  The\n Stream contains at least one interface, possibly representing a\n loopback interface that only supports communication between entities on\n this machine."
                }
              ]
            },
            {
              "name": "isUp",
              "overloads": [
                {
                  "signature": "public boolean isUp() throws SocketException",
                  "description": "Returns whether a network interface is up and running."
                }
              ]
            },
            {
              "name": "isLoopback",
              "overloads": [
                {
                  "signature": "public boolean isLoopback() throws SocketException",
                  "description": "Returns whether a network interface is a loopback interface."
                }
              ]
            },
            {
              "name": "isPointToPoint",
              "overloads": [
                {
                  "signature": "public boolean isPointToPoint() throws SocketException",
                  "description": "Returns whether a network interface is a point to point interface.\n A typical point to point interface would be a PPP connection through\n a modem."
                }
              ]
            },
            {
              "name": "supportsMulticast",
              "overloads": [
                {
                  "signature": "public boolean supportsMulticast() throws SocketException",
                  "description": "Returns whether a network interface supports multicasting or not."
                }
              ]
            },
            {
              "name": "getHardwareAddress",
              "overloads": [
                {
                  "signature": "public byte[] getHardwareAddress() throws SocketException",
                  "description": "Returns the hardware address (usually MAC) of the interface if it\n has one and if it can be accessed given the current privileges.\n If a security manager is set, then the caller must have\n the permission NetPermission(\"getNetworkInformation\")."
                }
              ]
            },
            {
              "name": "getMTU",
              "overloads": [
                {
                  "signature": "public int getMTU() throws SocketException",
                  "description": "Returns the Maximum Transmission Unit (MTU) of this interface."
                }
              ]
            },
            {
              "name": "isVirtual",
              "overloads": [
                {
                  "signature": "public boolean isVirtual()",
                  "description": "Returns whether this interface is a virtual interface (also called\n subinterface).\n Virtual interfaces are, on some systems, interfaces created as a child\n of a physical interface and given different settings (like address or\n MTU). Usually the name of the interface will the name of the parent\n followed by a colon (:) and a number identifying the child since there\n can be several virtual interfaces attached to a single physical\n interface."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same NetworkInterface\n as this object.\n \n Two instances of NetworkInterface represent the same\n NetworkInterface if both the name and the set of InetAddresses\n bound to the interfaces are equal."
                }
              ]
            }
          ]
        },
        {
          "name": "NoRouteToHostException",
          "methods": [
            {
              "name": "NoRouteToHostException",
              "overloads": [
                {
                  "signature": "public NoRouteToHostException(String msg)",
                  "description": "Constructs a new NoRouteToHostException with the specified detail\n message as to why the remote host cannot be reached.\n A detail message is a String that gives a specific\n description of this error."
                },
                {
                  "signature": "public NoRouteToHostException()",
                  "description": "Construct a new NoRouteToHostException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "PasswordAuthentication",
          "methods": [
            {
              "name": "PasswordAuthentication",
              "overloads": [
                {
                  "signature": "public PasswordAuthentication(String userName, char[] password)",
                  "description": "Creates a new PasswordAuthentication object from the given\n user name and password.\n\n  Note that the given user password is cloned before it is stored in\n the new PasswordAuthentication object."
                }
              ]
            },
            {
              "name": "getUserName",
              "overloads": [
                {
                  "signature": "public String getUserName()",
                  "description": "Returns the user name."
                }
              ]
            },
            {
              "name": "getPassword",
              "overloads": [
                {
                  "signature": "public char[] getPassword()",
                  "description": "Returns the user password.\n\n  Note that this method returns a reference to the password. It is\n the caller's responsibility to zero out the password information after\n it is no longer needed."
                }
              ]
            }
          ]
        },
        {
          "name": "PortUnreachableException",
          "methods": [
            {
              "name": "PortUnreachableException",
              "overloads": [
                {
                  "signature": "public PortUnreachableException(String msg)",
                  "description": "Constructs a new PortUnreachableException with a\n detail message."
                },
                {
                  "signature": "public PortUnreachableException()",
                  "description": "Construct a new PortUnreachableException with no\n detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "ProtocolException",
          "methods": [
            {
              "name": "ProtocolException",
              "overloads": [
                {
                  "signature": "public ProtocolException(String message)",
                  "description": "Constructs a new ProtocolException with the\n specified detail message."
                },
                {
                  "signature": "public ProtocolException()",
                  "description": "Constructs a new ProtocolException with no detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "ProtocolFamily",
          "methods": [
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "String name()",
                  "description": "Returns the name of the protocol family."
                }
              ]
            }
          ]
        },
        {
          "name": "Proxy",
          "methods": [
            {
              "name": "Proxy",
              "overloads": [
                {
                  "signature": "public Proxy(Proxy.Type type, SocketAddress sa)",
                  "description": "Creates an entry representing a PROXY connection.\n Certain combinations are illegal. For instance, for types Http, and\n Socks, a SocketAddress must be provided.\n \n Use the Proxy.NO_PROXY constant\n for representing a direct connection."
                }
              ]
            },
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "public Proxy.Type type()",
                  "description": "Returns the proxy type."
                }
              ]
            },
            {
              "name": "address",
              "overloads": [
                {
                  "signature": "public SocketAddress address()",
                  "description": "Returns the socket address of the proxy, or\n null if its a direct connection."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this Proxy.\n This String is constructed by calling toString() on its type\n and concatenating \" @ \" and the toString() result from its address\n if its type is not DIRECT."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares this object against the specified object.\n The result is true if and only if the argument is\n not null and it represents the same proxy as\n this object.\n \n Two instances of Proxy represent the same\n address if both the SocketAddresses and type are equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hashcode for this Proxy."
                }
              ]
            }
          ]
        },
        {
          "name": "ProxySelector",
          "methods": [
            {
              "name": "ProxySelector",
              "overloads": [
                {
                  "signature": "public ProxySelector()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static ProxySelector getDefault()",
                  "description": "Gets the system-wide proxy selector."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(ProxySelector ps)",
                  "description": "Sets (or unsets) the system-wide proxy selector.\n\n Note: non-standard protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "select",
              "overloads": [
                {
                  "signature": "public abstract List<Proxy> select(URI uri)",
                  "description": "Selects all the applicable proxies based on the protocol to\n access the resource with and a destination address to access\n the resource at.\n The format of the URI is defined as follow:\n \n http URI for http connections\n https URI for https connections\n socket://host:port\n     for tcp client sockets connections"
                }
              ]
            },
            {
              "name": "connectFailed",
              "overloads": [
                {
                  "signature": "public abstract void connectFailed(URI uri, SocketAddress sa, IOException ioe)",
                  "description": "Called to indicate that a connection could not be established\n to a proxy/socks server. An implementation of this method can\n temporarily remove the proxies or reorder the sequence of\n proxies returned by select(URI), using the address\n and the IOException caught when trying to connect."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static ProxySelector of(InetSocketAddress proxyAddress)",
                  "description": "Returns a ProxySelector which uses the given proxy address for all HTTP\n and HTTPS requests. If proxy is null then proxying is disabled."
                }
              ]
            }
          ]
        },
        {
          "name": "ResponseCache",
          "methods": [
            {
              "name": "ResponseCache",
              "overloads": [
                {
                  "signature": "public ResponseCache()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getDefault",
              "overloads": [
                {
                  "signature": "public static ResponseCache getDefault()",
                  "description": "Gets the system-wide response cache."
                }
              ]
            },
            {
              "name": "setDefault",
              "overloads": [
                {
                  "signature": "public static void setDefault(ResponseCache responseCache)",
                  "description": "Sets (or unsets) the system-wide cache.\n\n Note: non-standard protocol handlers may ignore this setting."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract CacheResponse get(URI uri, String rqstMethod, Map<String,List<String>> rqstHeaders) throws IOException",
                  "description": "Retrieve the cached response based on the requesting uri,\n request method and request headers. Typically this method is\n called by the protocol handler before it sends out the request\n to get the network resource. If a cached response is returned,\n that resource is used instead."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract CacheRequest put(URI uri, URLConnection conn) throws IOException",
                  "description": "The protocol handler calls this method after a resource has\n been retrieved, and the ResponseCache must decide whether or\n not to store the resource in its cache. If the resource is to\n be cached, then put() must return a CacheRequest object which\n contains an OutputStream that the protocol handler will\n use to write the resource into the cache. If the resource is\n not to be cached, then put must return null."
                }
              ]
            }
          ]
        },
        {
          "name": "SecureCacheResponse",
          "methods": [
            {
              "name": "SecureCacheResponse",
              "overloads": [
                {
                  "signature": "public SecureCacheResponse()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "getCipherSuite",
              "overloads": [
                {
                  "signature": "public abstract String getCipherSuite()",
                  "description": "Returns the cipher suite in use on the original connection that\n retrieved the network resource."
                }
              ]
            },
            {
              "name": "getLocalCertificateChain",
              "overloads": [
                {
                  "signature": "public abstract List<Certificate> getLocalCertificateChain()",
                  "description": "Returns the certificate chain that were sent to the server during\n handshaking of the original connection that retrieved the\n network resource.  Note: This method is useful only\n when using certificate-based cipher suites."
                }
              ]
            },
            {
              "name": "getServerCertificateChain",
              "overloads": [
                {
                  "signature": "public abstract List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException",
                  "description": "Returns the server's certificate chain, which was established as\n part of defining the session in the original connection that\n retrieved the network resource, from cache.  Note: This method\n can be used only when using certificate-based cipher suites;\n using it with non-certificate-based cipher suites, such as\n Kerberos, will throw an SSLPeerUnverifiedException."
                }
              ]
            },
            {
              "name": "getPeerPrincipal",
              "overloads": [
                {
                  "signature": "public abstract Principal getPeerPrincipal() throws SSLPeerUnverifiedException",
                  "description": "Returns the server's principal which was established as part of\n defining the session during the original connection that\n retrieved the network resource."
                }
              ]
            },
            {
              "name": "getLocalPrincipal",
              "overloads": [
                {
                  "signature": "public abstract Principal getLocalPrincipal()",
                  "description": "Returns the principal that was sent to the server during\n handshaking in the original connection that retrieved the\n network resource."
                }
              ]
            },
            {
              "name": "getSSLSession",
              "overloads": [
                {
                  "signature": "public Optional<SSLSession> getSSLSession()",
                  "description": "Returns an Optional containing the SSLSession in\n use on the original connection that retrieved the network resource.\n Returns an empty Optional if the underlying implementation\n does not support this method."
                }
              ]
            }
          ]
        },
        {
          "name": "ServerSocket",
          "methods": [
            {
              "name": "ServerSocket",
              "overloads": [
                {
                  "signature": "protected ServerSocket(SocketImpl impl)",
                  "description": "Creates a server socket with a user-specified SocketImpl."
                },
                {
                  "signature": "public ServerSocket() throws IOException",
                  "description": "Creates an unbound server socket."
                },
                {
                  "signature": "public ServerSocket(int port) throws IOException",
                  "description": "Creates a server socket, bound to the specified port. A port number\n of 0 means that the port number is automatically\n allocated, typically from an ephemeral port range. This port\n number can then be retrieved by calling getLocalPort.\n \n The maximum queue length for incoming connection indications (a\n request to connect) is set to 50. If a connection\n indication arrives when the queue is full, the connection is refused.\n \n If the application has specified a server socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager,\n its checkListen method is called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException."
                },
                {
                  "signature": "public ServerSocket(int port, int backlog) throws IOException",
                  "description": "Creates a server socket and binds it to the specified local port\n number, with the specified backlog.\n A port number of 0 means that the port number is\n automatically allocated, typically from an ephemeral port range.\n This port number can then be retrieved by calling\n getLocalPort.\n \n The maximum queue length for incoming connection indications (a\n request to connect) is set to the backlog parameter. If\n a connection indication arrives when the queue is full, the\n connection is refused.\n \n If the application has specified a server socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager,\n its checkListen method is called\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n\n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                },
                {
                  "signature": "public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException",
                  "description": "Create a server with the specified port, listen backlog, and\n local IP address to bind to.  The bindAddr argument\n can be used on a multi-homed host for a ServerSocket that\n will only accept connect requests to one of its addresses.\n If bindAddr is null, it will default accepting\n connections on any/all local addresses.\n The port must be between 0 and 65535, inclusive.\n A port number of 0 means that the port number is\n automatically allocated, typically from an ephemeral port range.\n This port number can then be retrieved by calling\n getLocalPort.\n\n If there is a security manager, this method\n calls its checkListen method\n with the port argument\n as its argument to ensure the operation is allowed.\n This could result in a SecurityException.\n\n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress endpoint) throws IOException",
                  "description": "Binds the ServerSocket to a specific address\n (IP address and port number).\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                },
                {
                  "signature": "public void bind(SocketAddress endpoint, int backlog) throws IOException",
                  "description": "Binds the ServerSocket to a specific address\n (IP address and port number).\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket.\n \n The backlog argument is the requested maximum number of\n pending connections on the socket. Its exact semantics are implementation\n specific. In particular, an implementation may impose a maximum length\n or may choose to ignore the parameter altogether. The value provided\n should be greater than 0. If it is less than or equal to\n 0, then an implementation specific default will be used."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the local address of this server socket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the local address\n after the socket is closed.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n the loopback address is returned."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the port number on which this socket is listening.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the address of the endpoint\n after the socket is closed.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a SocketAddress representing the\n loopback address and the local\n port to which the socket is bound is returned."
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "public Socket accept() throws IOException",
                  "description": "Listens for a connection to be made to this socket and accepts\n it. The method blocks until a connection is made.\n\n A new Socket s is created and, if there\n is a security manager,\n the security manager's checkAccept method is called\n with s.getInetAddress().getHostAddress() and\n s.getPort()\n as its arguments to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "implAccept",
              "overloads": [
                {
                  "signature": "protected final void implAccept(Socket s) throws IOException",
                  "description": "Subclasses of ServerSocket use this method to override accept()\n to return their own subclass of socket.  So a FooServerSocket\n will typically hand this method a newly created, unbound, FooSocket.\n On return from implAccept the FooSocket will be connected to a client.\n\n  The behavior of this method is unspecified when invoked with a\n socket that is not newly created and unbound. Any socket options set\n on the given socket prior to invoking this method may or may not be\n preserved when the connection is accepted. It may not be possible to\n accept a connection when this socket has a SocketImpl of one\n type and the given socket has a SocketImpl of a completely\n different type."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this socket.\n\n Any thread currently blocked in accept() will throw\n a SocketException.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public ServerSocketChannel getChannel()",
                  "description": "Returns the unique ServerSocketChannel object\n associated with this socket, if any.\n\n  A server socket will have a channel if, and only if, the channel\n itself was created via the ServerSocketChannel.open\n method."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the ServerSocket.\n \n If the socket was bound prior to being closed,\n then this method will continue to return true\n after the socket is closed."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns the closed state of the ServerSocket."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT with the\n specified timeout, in milliseconds.  With this option set to a positive\n timeout value, a call to accept() for this ServerSocket\n will block for only this amount of time.  If the timeout expires,\n a java.net.SocketTimeoutException is raised, though the\n ServerSocket is still valid. A timeout of zero is interpreted as an\n infinite timeout.\n The option must be enabled prior to entering the blocking\n operation to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws IOException",
                  "description": "Retrieve setting for SO_TIMEOUT.\n 0 returns implies that the option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR\n socket option.\n \n When a TCP connection is closed the connection may remain\n in a timeout state for a period of time after the connection\n is closed (typically known as the TIME_WAIT state\n or 2MSL wait state).\n For applications using a well known socket address or port\n it may not be possible to bind a socket to the required\n SocketAddress if there is a connection in the\n timeout state involving the socket address or port.\n \n Enabling SO_REUSEADDR prior to\n binding the socket using bind(SocketAddress) allows the socket\n to be bound even though a previous connection is in a timeout state.\n \n When a ServerSocket is created the initial setting\n of SO_REUSEADDR is not defined.\n Applications can use getReuseAddress() to determine the initial\n setting of SO_REUSEADDR.\n \n The behaviour when SO_REUSEADDR is\n enabled or disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the implementation address and implementation port of\n this socket as a String.\n \n If there is a security manager set, and this socket is\n bound, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n an InetAddress representing the\n loopback address is returned as\n the implementation address."
                }
              ]
            },
            {
              "name": "setSocketFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setSocketFactory(SocketImplFactory fac) throws IOException",
                  "description": "Sets the server socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new server socket, the socket\n implementation factory's createSocketImpl method is\n called to create the actual socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets a default proposed value for the\n SO_RCVBUF option for sockets\n accepted from this ServerSocket. The value actually set\n in the accepted socket must be determined by calling\n Socket.getReceiveBufferSize() after the socket\n is returned by accept().\n \n The value of SO_RCVBUF is used both to\n set the size of the internal socket receive buffer, and to set the size\n of the TCP receive window that is advertised to the remote peer.\n \n It is possible to change the value subsequently, by calling\n Socket.setReceiveBufferSize(int). However, if the application\n wishes to allow a receive window larger than 64K bytes, as defined by RFC1323\n then the proposed value must be set in the ServerSocket before\n it is bound to a local address. This implies, that the ServerSocket must be\n created with the no-argument constructor, then setReceiveBufferSize() must\n be called and lastly the ServerSocket is bound to an address by calling bind().\n \n Failure to do this will not cause an error, and the buffer size may be set to the\n requested value but the TCP receive window in sockets accepted from\n this ServerSocket will be no larger than 64K bytes."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Gets the value of the SO_RCVBUF option\n for this ServerSocket, that is the proposed buffer size that\n will be used for Sockets accepted from this ServerSocket.\n\n Note, the value actually set in the accepted socket is determined by\n calling Socket.getReceiveBufferSize()."
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this ServerSocket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences.  If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n  Invoking this method after this socket has been bound\n will have no effect. This implies that in order to use this capability\n requires the socket to be created with the no-argument constructor."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> ServerSocket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this server socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            }
          ]
        },
        {
          "name": "Socket",
          "methods": [
            {
              "name": "Socket",
              "overloads": [
                {
                  "signature": "public Socket()",
                  "description": "Creates an unconnected Socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created."
                },
                {
                  "signature": "public Socket(Proxy proxy)",
                  "description": "Creates an unconnected socket, specifying the type of proxy, if any,\n that should be used regardless of any other settings.\n \n If there is a security manager, its checkConnect method\n is called with the proxy host address and port number\n as its arguments. This could result in a SecurityException.\n \n Examples:\n  Socket s = new Socket(Proxy.NO_PROXY); will create\n a plain socket ignoring any other proxy configuration.\n Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(\"socks.mydom.com\", 1080)));\n will create a socket connecting through the specified SOCKS proxy\n server."
                },
                {
                  "signature": "protected Socket(SocketImpl impl) throws SocketException",
                  "description": "Creates an unconnected Socket with a user-specified\n SocketImpl."
                },
                {
                  "signature": "public Socket(String host, int port) throws UnknownHostException, IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number on the named host.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(InetAddress address, int port) throws IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number at the specified IP address.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException",
                  "description": "Creates a socket and connects it to the specified remote host on\n the specified remote port. The Socket will also bind() to the local\n address and port supplied.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n A local port number of zero will let the system pick up a\n free port in the bind operation.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException",
                  "description": "Creates a socket and connects it to the specified remote address on\n the specified remote port. The Socket will also bind() to the local\n address and port supplied.\n \n If the specified local address is null it is the equivalent of\n specifying the address as the AnyLocal address\n (see InetAddress.isAnyLocalAddress()).\n \n A local port number of zero will let the system pick up a\n free port in the bind operation.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException."
                },
                {
                  "signature": "@Deprecated public Socket(String host, int port, boolean stream) throws IOException",
                  "description": "Creates a stream socket and connects it to the specified port\n number on the named host.\n \n If the specified host is null it is the equivalent of\n specifying the address as\n InetAddress.getByName(null).\n In other words, it is equivalent to specifying an address of the\n loopback interface. \n \n If the stream argument is true, this creates a\n stream socket. If the stream argument is false, it\n creates a datagram socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n \n If there is a security manager, its\n checkConnect method is called\n with the host address and port\n as its arguments. This could result in a SecurityException.\n \n If a UDP socket is used, TCP/IP related socket options will not apply.",
                  "deprecated": true
                },
                {
                  "signature": "@Deprecated public Socket(InetAddress host, int port, boolean stream) throws IOException",
                  "description": "Creates a socket and connects it to the specified port number at\n the specified IP address.\n \n If the stream argument is true, this creates a\n stream socket. If the stream argument is false, it\n creates a datagram socket.\n \n If the application has specified a client socket implementation\n factory, that factory's createSocketImpl method is called to\n create the actual socket implementation. Otherwise a system-default\n socket implementation is created.\n\n If there is a security manager, its\n checkConnect method is called\n with host.getHostAddress() and port\n as its arguments. This could result in a SecurityException.\n \n If UDP socket is used, TCP/IP related socket options will not apply.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public void connect(SocketAddress endpoint) throws IOException",
                  "description": "Connects this socket to the server."
                },
                {
                  "signature": "public void connect(SocketAddress endpoint, int timeout) throws IOException",
                  "description": "Connects this socket to the server with a specified timeout value.\n A timeout of zero is interpreted as an infinite timeout. The connection\n will then block until established or an error occurs."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "public void bind(SocketAddress bindpoint) throws IOException",
                  "description": "Binds the socket to a local address.\n \n If the address is null, then the system will pick up\n an ephemeral port and a valid local address to bind the socket."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getInetAddress()",
                  "description": "Returns the address to which the socket is connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalAddress",
              "overloads": [
                {
                  "signature": "public InetAddress getLocalAddress()",
                  "description": "Gets the local address to which the socket is bound.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n the loopback address is returned."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the remote port number to which this socket is connected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "public int getLocalPort()",
                  "description": "Returns the local port number to which this socket is bound.\n \n If the socket was bound prior to being closed,\n then this method will continue to return the local port number\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getRemoteSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getRemoteSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.\n \n If the socket was connected prior to being closed,\n then this method will continue to return the connected address\n after the socket is closed."
                }
              ]
            },
            {
              "name": "getLocalSocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress getLocalSocketAddress()",
                  "description": "Returns the address of the endpoint this socket is bound to.\n \n If a socket bound to an endpoint represented by an\n InetSocketAddress  is closed,\n then this method will continue to return an InetSocketAddress\n after the socket is closed. In that case the returned\n InetSocketAddress's address is the\n wildcard address\n and its port is the local port that it was bound to.\n \n If there is a security manager set, its checkConnect method is\n called with the local address and -1 as its arguments to see\n if the operation is allowed. If the operation is not allowed,\n a SocketAddress representing the\n loopback address and the local\n port to which this socket is bound is returned."
                }
              ]
            },
            {
              "name": "getChannel",
              "overloads": [
                {
                  "signature": "public SocketChannel getChannel()",
                  "description": "Returns the unique SocketChannel\n object associated with this socket, if any.\n\n  A socket will have a channel if, and only if, the channel itself was\n created via the SocketChannel.open or ServerSocketChannel.accept\n methods."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream for this socket.\n\n  If this socket has an associated channel then the resulting input\n stream delegates all of its operations to the channel.  If the channel\n is in non-blocking mode then the input stream's read operations\n will throw an IllegalBlockingModeException.\n\n Under abnormal conditions the underlying connection may be\n broken by the remote host or the network software (for example\n a connection reset in the case of TCP connections). When a\n broken connection is detected by the network software the\n following applies to the returned input stream :-\n\n \n\n   The network software may discard bytes that are buffered\n   by the socket. Bytes that aren't discarded by the network\n   software can be read using read.\n\n   If there are no bytes buffered on the socket, or all\n   buffered bytes have been consumed by\n   read, then all subsequent\n   calls to read will throw an\n   IOException.\n\n   If there are no bytes buffered on the socket, and the\n   socket has not been closed using close, then\n   available will\n   return 0.\n\n \n\n  Closing the returned InputStream\n will close the associated socket."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream for this socket.\n\n  If this socket has an associated channel then the resulting output\n stream delegates all of its operations to the channel.  If the channel\n is in non-blocking mode then the output stream's write\n operations will throw an IllegalBlockingModeException.\n\n  Closing the returned OutputStream\n will close the associated socket."
                }
              ]
            },
            {
              "name": "setTcpNoDelay",
              "overloads": [
                {
                  "signature": "public void setTcpNoDelay(boolean on) throws SocketException",
                  "description": "Enable/disable TCP_NODELAY\n (disable/enable Nagle's algorithm)."
                }
              ]
            },
            {
              "name": "getTcpNoDelay",
              "overloads": [
                {
                  "signature": "public boolean getTcpNoDelay() throws SocketException",
                  "description": "Tests if TCP_NODELAY is enabled."
                }
              ]
            },
            {
              "name": "setSoLinger",
              "overloads": [
                {
                  "signature": "public void setSoLinger(boolean on, int linger) throws SocketException",
                  "description": "Enable/disable SO_LINGER with the\n specified linger time in seconds. The maximum timeout value is platform\n specific.\n\n The setting only affects socket close."
                }
              ]
            },
            {
              "name": "getSoLinger",
              "overloads": [
                {
                  "signature": "public int getSoLinger() throws SocketException",
                  "description": "Returns setting for SO_LINGER.\n -1 returns implies that the\n option is disabled.\n\n The setting only affects socket close."
                }
              ]
            },
            {
              "name": "sendUrgentData",
              "overloads": [
                {
                  "signature": "public void sendUrgentData(int data) throws IOException",
                  "description": "Send one byte of urgent data on the socket. The byte to be sent is the lowest eight\n bits of the data parameter. The urgent byte is\n sent after any preceding writes to the socket OutputStream\n and before any future writes to the OutputStream."
                }
              ]
            },
            {
              "name": "setOOBInline",
              "overloads": [
                {
                  "signature": "public void setOOBInline(boolean on) throws SocketException",
                  "description": "Enable/disable SO_OOBINLINE\n (receipt of TCP urgent data)\n\n By default, this option is disabled and TCP urgent data received on a\n socket is silently discarded. If the user wishes to receive urgent data, then\n this option must be enabled. When enabled, urgent data is received\n inline with normal data.\n \n Note, only limited support is provided for handling incoming urgent\n data. In particular, no notification of incoming urgent data is provided\n and there is no capability to distinguish between normal data and urgent\n data unless provided by a higher level protocol."
                }
              ]
            },
            {
              "name": "getOOBInline",
              "overloads": [
                {
                  "signature": "public boolean getOOBInline() throws SocketException",
                  "description": "Tests if SO_OOBINLINE is enabled."
                }
              ]
            },
            {
              "name": "setSoTimeout",
              "overloads": [
                {
                  "signature": "public void setSoTimeout(int timeout) throws SocketException",
                  "description": "Enable/disable SO_TIMEOUT\n  with the specified timeout, in milliseconds. With this option set\n  to a positive timeout value, a read() call on the InputStream associated with\n  this Socket will block for only this amount of time.  If the timeout\n  expires, a java.net.SocketTimeoutException is raised, though the\n  Socket is still valid. A timeout of zero is interpreted as an infinite timeout.\n  The option must be enabled prior to entering the blocking operation\n  to have effect."
                }
              ]
            },
            {
              "name": "getSoTimeout",
              "overloads": [
                {
                  "signature": "public int getSoTimeout() throws SocketException",
                  "description": "Returns setting for SO_TIMEOUT.\n 0 returns implies that the option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setSendBufferSize",
              "overloads": [
                {
                  "signature": "public void setSendBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_SNDBUF option to the\n specified value for this Socket.\n The SO_SNDBUF option is used by the\n platform's networking code as a hint for the size to set the underlying\n network I/O buffers.\n\n Because SO_SNDBUF is a hint,\n applications that want to verify what size the buffers were set to\n should call getSendBufferSize()."
                }
              ]
            },
            {
              "name": "getSendBufferSize",
              "overloads": [
                {
                  "signature": "public int getSendBufferSize() throws SocketException",
                  "description": "Get value of the SO_SNDBUF option\n for this Socket, that is the buffer size used by the platform\n for output on this Socket."
                }
              ]
            },
            {
              "name": "setReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public void setReceiveBufferSize(int size) throws SocketException",
                  "description": "Sets the SO_RCVBUF option to the\n specified value for this Socket. The\n SO_RCVBUF option is\n used by the platform's networking code as a hint for the size to set\n the underlying network I/O buffers.\n\n Increasing the receive buffer size can increase the performance of\n network I/O for high-volume connection, while decreasing it can\n help reduce the backlog of incoming data.\n\n Because SO_RCVBUF is a hint,\n applications that want to verify what size the buffers were set to\n should call getReceiveBufferSize().\n\n The value of SO_RCVBUF is also used\n to set the TCP receive window that is advertised to the remote peer.\n Generally, the window size can be modified at any time when a socket is\n connected. However, if a receive window larger than 64K is required then\n this must be requested before the socket is connected to the\n remote peer. There are two cases to be aware of:\n \n For sockets accepted from a ServerSocket, this must be done by calling\n ServerSocket.setReceiveBufferSize(int) before the ServerSocket\n is bound to a local address.\n For client sockets, setReceiveBufferSize() must be called before\n connecting the socket to its remote peer."
                }
              ]
            },
            {
              "name": "getReceiveBufferSize",
              "overloads": [
                {
                  "signature": "public int getReceiveBufferSize() throws SocketException",
                  "description": "Gets the value of the SO_RCVBUF option\n for this Socket, that is the buffer size used by the platform\n for input on this Socket."
                }
              ]
            },
            {
              "name": "setKeepAlive",
              "overloads": [
                {
                  "signature": "public void setKeepAlive(boolean on) throws SocketException",
                  "description": "Enable/disable SO_KEEPALIVE."
                }
              ]
            },
            {
              "name": "getKeepAlive",
              "overloads": [
                {
                  "signature": "public boolean getKeepAlive() throws SocketException",
                  "description": "Tests if SO_KEEPALIVE is enabled."
                }
              ]
            },
            {
              "name": "setTrafficClass",
              "overloads": [
                {
                  "signature": "public void setTrafficClass(int tc) throws SocketException",
                  "description": "Sets traffic class or type-of-service octet in the IP\n header for packets sent from this Socket.\n As the underlying network implementation may ignore this\n value applications should consider it a hint.\n\n  The tc must be in the range 0 <= tc <=\n 255 or an IllegalArgumentException will be thrown.\n Notes:\n For Internet Protocol v4 the value consists of an\n integer, the least significant 8 bits of which\n represent the value of the TOS octet in IP packets sent by\n the socket.\n RFC 1349 defines the TOS values as follows:\n\n \n IPTOS_LOWCOST (0x02)\n IPTOS_RELIABILITY (0x04)\n IPTOS_THROUGHPUT (0x08)\n IPTOS_LOWDELAY (0x10)\n \n The last low order bit is always ignored as this\n corresponds to the MBZ (must be zero) bit.\n \n Setting bits in the precedence field may result in a\n SocketException indicating that the operation is not\n permitted.\n \n As RFC 1122 section 4.2.4.2 indicates, a compliant TCP\n implementation should, but is not required to, let application\n change the TOS field during the lifetime of a connection.\n So whether the type-of-service field can be changed after the\n TCP connection has been established depends on the implementation\n in the underlying platform. Applications should not assume that\n they can change the TOS field after the connection.\n \n For Internet Protocol v6 tc is the value that\n would be placed into the sin6_flowinfo field of the IP header."
                }
              ]
            },
            {
              "name": "getTrafficClass",
              "overloads": [
                {
                  "signature": "public int getTrafficClass() throws SocketException",
                  "description": "Gets traffic class or type-of-service in the IP header\n for packets sent from this Socket\n \n As the underlying network implementation may ignore the\n traffic class or type-of-service set using setTrafficClass(int)\n this method may return a different value than was previously\n set using the setTrafficClass(int) method on this Socket."
                }
              ]
            },
            {
              "name": "setReuseAddress",
              "overloads": [
                {
                  "signature": "public void setReuseAddress(boolean on) throws SocketException",
                  "description": "Enable/disable the SO_REUSEADDR\n socket option.\n \n When a TCP connection is closed the connection may remain\n in a timeout state for a period of time after the connection\n is closed (typically known as the TIME_WAIT state\n or 2MSL wait state).\n For applications using a well known socket address or port\n it may not be possible to bind a socket to the required\n SocketAddress if there is a connection in the\n timeout state involving the socket address or port.\n \n Enabling SO_REUSEADDR\n prior to binding the socket using bind(SocketAddress) allows\n the socket to be bound even though a previous connection is in a timeout\n state.\n \n When a Socket is created the initial setting\n of SO_REUSEADDR is disabled.\n \n The behaviour when SO_REUSEADDR is\n enabled or disabled after a socket is bound (See isBound())\n is not defined."
                }
              ]
            },
            {
              "name": "getReuseAddress",
              "overloads": [
                {
                  "signature": "public boolean getReuseAddress() throws SocketException",
                  "description": "Tests if SO_REUSEADDR is enabled."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this socket.\n \n Any thread currently blocked in an I/O operation upon this socket\n will throw a SocketException.\n \n Once a socket has been closed, it is not available for further networking\n use (i.e. can't be reconnected or rebound). A new socket needs to be\n created.\n\n  Closing this socket will also close the socket's\n InputStream and\n OutputStream.\n\n  If this socket has an associated channel then the channel is closed\n as well."
                }
              ]
            },
            {
              "name": "shutdownInput",
              "overloads": [
                {
                  "signature": "public void shutdownInput() throws IOException",
                  "description": "Places the input stream for this socket at \"end of stream\".\n Any data sent to the input stream side of the socket is acknowledged\n and then silently discarded.\n \n If you read from a socket input stream after invoking this method on the\n socket, the stream's available method will return 0, and its\n read methods will return -1 (end of stream)."
                }
              ]
            },
            {
              "name": "shutdownOutput",
              "overloads": [
                {
                  "signature": "public void shutdownOutput() throws IOException",
                  "description": "Disables the output stream for this socket.\n For a TCP socket, any previously written data will be sent\n followed by TCP's normal connection termination sequence.\n\n If you write to a socket output stream after invoking\n shutdownOutput() on the socket, the stream will throw\n an IOException."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Converts this socket to a String."
                }
              ]
            },
            {
              "name": "isConnected",
              "overloads": [
                {
                  "signature": "public boolean isConnected()",
                  "description": "Returns the connection state of the socket.\n \n Note: Closing a socket doesn't clear its connection state, which means\n this method will return true for a closed socket\n (see isClosed()) if it was successfully connected prior\n to being closed."
                }
              ]
            },
            {
              "name": "isBound",
              "overloads": [
                {
                  "signature": "public boolean isBound()",
                  "description": "Returns the binding state of the socket.\n \n Note: Closing a socket doesn't clear its binding state, which means\n this method will return true for a closed socket\n (see isClosed()) if it was successfully bound prior\n to being closed."
                }
              ]
            },
            {
              "name": "isClosed",
              "overloads": [
                {
                  "signature": "public boolean isClosed()",
                  "description": "Returns the closed state of the socket."
                }
              ]
            },
            {
              "name": "isInputShutdown",
              "overloads": [
                {
                  "signature": "public boolean isInputShutdown()",
                  "description": "Returns whether the read-half of the socket connection is closed."
                }
              ]
            },
            {
              "name": "isOutputShutdown",
              "overloads": [
                {
                  "signature": "public boolean isOutputShutdown()",
                  "description": "Returns whether the write-half of the socket connection is closed."
                }
              ]
            },
            {
              "name": "setSocketImplFactory",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"17\") public static void setSocketImplFactory(SocketImplFactory fac) throws IOException",
                  "description": "Sets the client socket implementation factory for the\n application. The factory can be specified only once.\n \n When an application creates a new client socket, the socket\n implementation factory's createSocketImpl method is\n called to create the actual socket implementation.\n \n Passing null to the method is a no-op unless the factory\n was already set.\n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this socket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences. Negative\n values represent a lower priority than positive values. If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n  Invoking this method after this socket has been connected\n will have no effect."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "public <T> Socket setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Sets the value of a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "public <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Returns the value of a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "public Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of the socket options supported by this socket.\n\n This method will continue to return the set of options even after\n the socket has been closed."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketAddress",
          "methods": [
            {
              "name": "SocketAddress",
              "overloads": [
                {
                  "signature": "public SocketAddress()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketException",
          "methods": [
            {
              "name": "SocketException",
              "overloads": [
                {
                  "signature": "public SocketException(String msg)",
                  "description": "Constructs a new SocketException with the\n specified detail message."
                },
                {
                  "signature": "public SocketException()",
                  "description": "Constructs a new SocketException with no detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketImpl",
          "methods": [
            {
              "name": "SocketImpl",
              "overloads": [
                {
                  "signature": "public SocketImpl()",
                  "description": "Initialize a new instance of this class"
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "protected abstract void create(boolean stream) throws IOException",
                  "description": "Creates either a stream or a datagram socket."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "protected abstract void connect(String host, int port) throws IOException",
                  "description": "Connects this socket to the specified port on the named host."
                },
                {
                  "signature": "protected abstract void connect(InetAddress address, int port) throws IOException",
                  "description": "Connects this socket to the specified port number on the specified host."
                },
                {
                  "signature": "protected abstract void connect(SocketAddress address, int timeout) throws IOException",
                  "description": "Connects this socket to the specified port number on the specified host.\n A timeout of zero is interpreted as an infinite timeout. The connection\n will then block until established or an error occurs."
                }
              ]
            },
            {
              "name": "bind",
              "overloads": [
                {
                  "signature": "protected abstract void bind(InetAddress host, int port) throws IOException",
                  "description": "Binds this socket to the specified local IP address and port number."
                }
              ]
            },
            {
              "name": "listen",
              "overloads": [
                {
                  "signature": "protected abstract void listen(int backlog) throws IOException",
                  "description": "Sets the maximum queue length for incoming connection indications\n (a request to connect) to the count argument. If a\n connection indication arrives when the queue is full, the\n connection is refused."
                }
              ]
            },
            {
              "name": "accept",
              "overloads": [
                {
                  "signature": "protected abstract void accept(SocketImpl s) throws IOException",
                  "description": "Accepts a connection."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "protected abstract InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream for this socket."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "protected abstract OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream for this socket."
                }
              ]
            },
            {
              "name": "available",
              "overloads": [
                {
                  "signature": "protected abstract int available() throws IOException",
                  "description": "Returns the number of bytes that can be read from this socket\n without blocking."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "protected abstract void close() throws IOException",
                  "description": "Closes this socket."
                }
              ]
            },
            {
              "name": "shutdownInput",
              "overloads": [
                {
                  "signature": "protected void shutdownInput() throws IOException",
                  "description": "Places the input stream for this socket at \"end of stream\".\n Any data sent to this socket is acknowledged and then\n silently discarded.\n\n If you read from a socket input stream after invoking this method on the\n socket, the stream's available method will return 0, and its\n read methods will return -1 (end of stream)."
                }
              ]
            },
            {
              "name": "shutdownOutput",
              "overloads": [
                {
                  "signature": "protected void shutdownOutput() throws IOException",
                  "description": "Disables the output stream for this socket.\n For a TCP socket, any previously written data will be sent\n followed by TCP's normal connection termination sequence.\n\n If you write to a socket output stream after invoking\n shutdownOutput() on the socket, the stream will throw\n an IOException."
                }
              ]
            },
            {
              "name": "getFileDescriptor",
              "overloads": [
                {
                  "signature": "protected FileDescriptor getFileDescriptor()",
                  "description": "Returns the value of this socket's fd field."
                }
              ]
            },
            {
              "name": "getInetAddress",
              "overloads": [
                {
                  "signature": "protected InetAddress getInetAddress()",
                  "description": "Returns the value of this socket's address field."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "protected int getPort()",
                  "description": "Returns the value of this socket's port field."
                }
              ]
            },
            {
              "name": "supportsUrgentData",
              "overloads": [
                {
                  "signature": "protected boolean supportsUrgentData()",
                  "description": "Returns whether or not this SocketImpl supports sending\n urgent data. By default, false is returned\n unless the method is overridden in a sub-class"
                }
              ]
            },
            {
              "name": "sendUrgentData",
              "overloads": [
                {
                  "signature": "protected abstract void sendUrgentData(int data) throws IOException",
                  "description": "Send one byte of urgent data on the socket.\n The byte to be sent is the low eight bits of the parameter"
                }
              ]
            },
            {
              "name": "getLocalPort",
              "overloads": [
                {
                  "signature": "protected int getLocalPort()",
                  "description": "Returns the value of this socket's localport field."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the address and port of this socket as a String."
                }
              ]
            },
            {
              "name": "setPerformancePreferences",
              "overloads": [
                {
                  "signature": "protected void setPerformancePreferences(int connectionTime, int latency, int bandwidth)",
                  "description": "Sets performance preferences for this socket.\n\n  Sockets use the TCP/IP protocol by default.  Some implementations\n may offer alternative protocols which have different performance\n characteristics than TCP/IP.  This method allows the application to\n express its own preferences as to how these tradeoffs should be made\n when the implementation chooses from the available protocols.\n\n  Performance preferences are described by three integers\n whose values indicate the relative importance of short connection time,\n low latency, and high bandwidth.  The absolute values of the integers\n are irrelevant; in order to choose a protocol the values are simply\n compared, with larger values indicating stronger preferences. Negative\n values represent a lower priority than positive values. If the\n application prefers short connection time over both low latency and high\n bandwidth, for example, then it could invoke this method with the values\n (1, 0, 0).  If the application prefers high bandwidth above low\n latency, and low latency above short connection time, then it could\n invoke this method with the values (0, 1, 2).\n\n By default, this method does nothing, unless it is overridden in\n a sub-class."
                }
              ]
            },
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "protected <T> void setOption(SocketOption<T> name, T value) throws IOException",
                  "description": "Called to set a socket option."
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "protected <T> T getOption(SocketOption<T> name) throws IOException",
                  "description": "Called to get a socket option."
                }
              ]
            },
            {
              "name": "supportedOptions",
              "overloads": [
                {
                  "signature": "protected Set<SocketOption<?>> supportedOptions()",
                  "description": "Returns a set of SocketOptions supported by this impl\n and by this impl's socket (Socket or ServerSocket)"
                }
              ]
            }
          ]
        },
        {
          "name": "SocketImplFactory",
          "methods": [
            {
              "name": "createSocketImpl",
              "overloads": [
                {
                  "signature": "SocketImpl createSocketImpl()",
                  "description": "Creates a new SocketImpl instance."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketOption<T>",
          "methods": [
            {
              "name": "name",
              "overloads": [
                {
                  "signature": "String name()",
                  "description": "Returns the name of the socket option."
                }
              ]
            },
            {
              "name": "type",
              "overloads": [
                {
                  "signature": "Class<T> type()",
                  "description": "Returns the type of the socket option value."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketOptions",
          "methods": [
            {
              "name": "setOption",
              "overloads": [
                {
                  "signature": "void setOption(int optID, Object value) throws SocketException",
                  "description": "Enable/disable the option specified by optID.  If the option\n is to be enabled, and it takes an option-specific \"value\",  this is\n passed in value.  The actual type of value is option-specific,\n and it is an error to pass something that isn't of the expected type:\n  SocketImpl s;\n ...\n s.setOption(SO_LINGER, new Integer(10));\n    // OK - set SO_LINGER w/ timeout of 10 sec.\n s.setOption(SO_LINGER, new Double(10));\n    // ERROR - expects java.lang.Integer\n\n If the requested option is binary, it can be set using this method by\n a java.lang.Boolean:\n  s.setOption(TCP_NODELAY, Boolean.TRUE);\n    // OK - enables TCP_NODELAY, a binary option\n \n \n Any option can be disabled using this method with a Boolean.FALSE:\n  s.setOption(TCP_NODELAY, Boolean.FALSE);\n    // OK - disables TCP_NODELAY\n s.setOption(SO_LINGER, Boolean.FALSE);\n    // OK - disables SO_LINGER\n \n \n For an option that has a notion of on and off, and requires\n a non-boolean parameter, setting its value to anything other than\n Boolean.FALSE implicitly enables it.\n \n Throws SocketException if the option is unrecognized,\n the socket is closed, or some low-level error occurred"
                }
              ]
            },
            {
              "name": "getOption",
              "overloads": [
                {
                  "signature": "Object getOption(int optID) throws SocketException",
                  "description": "Fetch the value of an option.\n Binary options will return java.lang.Boolean.TRUE\n if enabled, java.lang.Boolean.FALSE if disabled, e.g.:\n  SocketImpl s;\n ...\n Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY));\n if (noDelay.booleanValue()) {\n     // true if TCP_NODELAY is enabled...\n ...\n }\n \n \n For options that take a particular type as a parameter,\n getOption(int) will return the parameter's value, else\n it will return java.lang.Boolean.FALSE:\n  Object o = s.getOption(SO_LINGER);\n if (o instanceof Integer) {\n     System.out.print(\"Linger time is \" + ((Integer)o).intValue());\n } else {\n   // the true type of o is java.lang.Boolean.FALSE;\n }"
                }
              ]
            }
          ]
        },
        {
          "name": "SocketPermission",
          "methods": [
            {
              "name": "SocketPermission",
              "overloads": [
                {
                  "signature": "public SocketPermission(String host, String action)",
                  "description": "Creates a new SocketPermission object with the specified actions.\n The host is expressed as a DNS name, or as a numerical IP address.\n Optionally, a port or a portrange may be supplied (separated\n from the DNS name or IP address by a colon).\n \n To specify the local machine, use \"localhost\" as the host.\n Also note: An empty host String (\"\") is equivalent to \"localhost\".\n \n The actions parameter contains a comma-separated list of the\n actions granted for the specified host (and port(s)). Possible actions are\n \"connect\", \"listen\", \"accept\", \"resolve\", or\n any combination of those. \"resolve\" is automatically added\n when any of the other three are specified.\n \n Examples of SocketPermission instantiation are the following:\n     nr = new SocketPermission(\"www.example.com\", \"connect\");\n    nr = new SocketPermission(\"www.example.com:80\", \"connect\");\n    nr = new SocketPermission(\"*.example.com\", \"connect\");\n    nr = new SocketPermission(\"*.edu\", \"resolve\");\n    nr = new SocketPermission(\"204.160.241.0\", \"connect\");\n    nr = new SocketPermission(\"localhost:1024-65535\", \"listen\");\n    nr = new SocketPermission(\"204.160.241.0:1024-65535\", \"connect\");"
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this socket permission object \"implies\" the\n specified permission.\n \n More specifically, this method first ensures that all of the following\n are true (and returns false if any of them are not):\n \n  p is an instanceof SocketPermission,\n  p's actions are a proper subset of this\n object's actions, and\n  p's port range is included in this port range. Note:\n port range is ignored when p only contains the action, 'resolve'.\n \n\n Then implies checks each of the following, in order,\n and for each returns true if the stated condition is true:\n \n  If this object was initialized with a single IP address and one of p's\n IP addresses is equal to this object's IP address.\n If this object is a wildcard domain (such as *.example.com), and\n p's canonical name (the name without any preceding *)\n ends with this object's canonical host name. For example, *.example.com\n implies *.foo.example.com.\n If this object was not initialized with a single IP address, and one of this\n object's IP addresses equals one of p's IP addresses.\n If this canonical name equals p's canonical name.\n \n\n If none of the above are true, implies returns false."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two SocketPermission objects for equality."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions.\n Always returns present actions in the following order:\n connect, listen, accept, resolve."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing SocketPermission\n objects.\n \n SocketPermission objects must be stored in a manner that allows them\n to be inserted into the collection in any order, but that also enables the\n PermissionCollection implies\n method to be implemented in an efficient (and consistent) manner."
                }
              ]
            }
          ]
        },
        {
          "name": "SocketTimeoutException",
          "methods": [
            {
              "name": "SocketTimeoutException",
              "overloads": [
                {
                  "signature": "public SocketTimeoutException(String msg)",
                  "description": "Constructs a new SocketTimeoutException with a detail\n message."
                },
                {
                  "signature": "public SocketTimeoutException()",
                  "description": "Construct a new SocketTimeoutException with no detailed message."
                }
              ]
            }
          ]
        },
        {
          "name": "StandardSocketOptions",
          "methods": []
        },
        {
          "name": "UnixDomainSocketAddress",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static UnixDomainSocketAddress of(String pathname)",
                  "description": "Creates a UnixDomainSocketAddress from the given path string."
                },
                {
                  "signature": "public static UnixDomainSocketAddress of(Path path)",
                  "description": "Creates a UnixDomainSocketAddress for the given path."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public Path getPath()",
                  "description": "Returns this address's path."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code of this UnixDomainSocketAddress"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object o)",
                  "description": "Compares this address with another object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this UnixDomainSocketAddress."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownHostException",
          "methods": [
            {
              "name": "UnknownHostException",
              "overloads": [
                {
                  "signature": "public UnknownHostException(String message)",
                  "description": "Constructs a new UnknownHostException with the\n specified detail message."
                },
                {
                  "signature": "public UnknownHostException()",
                  "description": "Constructs a new UnknownHostException with no detail\n message."
                }
              ]
            }
          ]
        },
        {
          "name": "UnknownServiceException",
          "methods": [
            {
              "name": "UnknownServiceException",
              "overloads": [
                {
                  "signature": "public UnknownServiceException()",
                  "description": "Constructs a new UnknownServiceException with no\n detail message."
                },
                {
                  "signature": "public UnknownServiceException(String msg)",
                  "description": "Constructs a new UnknownServiceException with the\n specified detail message."
                }
              ]
            }
          ]
        },
        {
          "name": "URI",
          "methods": [
            {
              "name": "URI",
              "overloads": [
                {
                  "signature": "public URI(String str) throws URISyntaxException",
                  "description": "Constructs a URI by parsing the given string.\n\n  This constructor parses the given string exactly as specified by the\n grammar in RFC2396,\n AppendixA, except for the following deviations: \n\n \n\n    An empty authority component is permitted as long as it is\n   followed by a non-empty path, a query component, or a fragment\n   component.  This allows the parsing of URIs such as\n   \"file:///foo/bar\", which seems to be the intent of\n   RFC2396 although the grammar does not permit it.  If the\n   authority component is empty then the user-information, host, and port\n   components are undefined. \n\n    Empty relative paths are permitted; this seems to be the\n   intent of RFC2396 although the grammar does not permit it.  The\n   primary consequence of this deviation is that a standalone fragment\n   such as \"#foo\" parses as a relative URI with an empty path\n   and the given fragment, and can be usefully resolved against a base URI.\n\n    IPv4 addresses in host components are parsed rigorously, as\n   specified by RFC2732: Each\n   element of a dotted-quad address must contain no more than three\n   decimal digits.  Each element is further constrained to have a value\n   no greater than 255. \n\n     Hostnames in host components that comprise only a single\n   domain label are permitted to start with an alphanum\n   character. This seems to be the intent of RFC2396\n   section3.2.2 although the grammar does not permit it. The\n   consequence of this deviation is that the authority component of a\n   hierarchical URI such as s://123, will parse as a server-based\n   authority. \n\n    IPv6 addresses are permitted for the host component.  An IPv6\n   address must be enclosed in square brackets ('[' and\n   ']') as specified by RFC2732.  The\n   IPv6 address itself must parse according to RFC2373.  IPv6\n   addresses are further constrained to describe no more than sixteen\n   bytes of address information, a constraint implicit in RFC2373\n   but not expressible in the grammar. \n\n    Characters in the other category are permitted wherever\n   RFC2396 permits escaped octets, that is, in the\n   user-information, path, query, and fragment components, as well as in\n   the authority component if the authority is registry-based.  This\n   allows URIs to contain Unicode characters beyond those in the US-ASCII\n   character set."
                },
                {
                  "signature": "public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  If a scheme is given then the path, if also given, must either be\n empty or begin with a slash character ('/').  Otherwise a\n component of the new URI may be left undefined by passing null\n for the corresponding parameter or, in the case of the port\n parameter, by passing -1.\n\n  This constructor first builds a URI string from the given components\n according to the rules specified in RFC2396,\n section5.2, step7: \n\n \n\n    Initially, the result string is empty. \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If user information, a host, or a port are given then the\n   string \"//\" is appended.  \n\n    If user information is given then it is appended, followed by\n   a commercial-at character ('@').  Any character not in the\n   unreserved, punct, escaped, or other\n   categories is quoted.  \n\n    If a host is given then it is appended.  If the host is a\n   literal IPv6 address but is not enclosed in square brackets\n   ('[' and ']') then the square brackets are added.\n   \n\n    If a port number is given then a colon character\n   (':') is appended, followed by the port number in decimal.\n   \n\n    If a path is given then it is appended.  Any character not in\n   the unreserved, punct, escaped, or other\n   categories, and not equal to the slash character ('/') or the\n   commercial-at character ('@'), is quoted.  \n\n    If a query is given then a question-mark character\n   ('?') is appended, followed by the query.  Any character that\n   is not a legal URI character is quoted.\n   \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended, followed by the fragment.  Any character\n   that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
                },
                {
                  "signature": "public URI(String scheme, String authority, String path, String query, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  If a scheme is given then the path, if also given, must either be\n empty or begin with a slash character ('/').  Otherwise a\n component of the new URI may be left undefined by passing null\n for the corresponding parameter.\n\n  This constructor first builds a URI string from the given components\n according to the rules specified in RFC2396,\n section5.2, step7: \n\n \n\n    Initially, the result string is empty.  \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If an authority is given then the string \"//\" is\n   appended, followed by the authority.  If the authority contains a\n   literal IPv6 address then the address must be enclosed in square\n   brackets ('[' and ']').  Any character not in the\n   unreserved, punct, escaped, or other\n   categories, and not equal to the commercial-at character\n   ('@'), is quoted.  \n\n    If a path is given then it is appended.  Any character not in\n   the unreserved, punct, escaped, or other\n   categories, and not equal to the slash character ('/') or the\n   commercial-at character ('@'), is quoted.  \n\n    If a query is given then a question-mark character\n   ('?') is appended, followed by the query.  Any character that\n   is not a legal URI character is quoted.\n   \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended, followed by the fragment.  Any character\n   that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed as if by invoking the URI(String) constructor and then invoking the parseServerAuthority() method upon the result; this may cause a URISyntaxException to be thrown."
                },
                {
                  "signature": "public URI(String scheme, String host, String path, String fragment) throws URISyntaxException",
                  "description": "Constructs a hierarchical URI from the given components.\n\n  A component may be left undefined by passing null.\n\n  This convenience constructor works as if by invoking the\n seven-argument constructor as follows:\n\n \n new URI(scheme, null, host, -1, path, null, fragment);"
                },
                {
                  "signature": "public URI(String scheme, String ssp, String fragment) throws URISyntaxException",
                  "description": "Constructs a URI from the given components.\n\n  A component may be left undefined by passing null.\n\n  This constructor first builds a URI in string form using the given\n components as follows:  \n\n \n\n    Initially, the result string is empty.  \n\n    If a scheme is given then it is appended to the result,\n   followed by a colon character (':').  \n\n    If a scheme-specific part is given then it is appended.  Any\n   character that is not a legal URI character\n   is quoted.  \n\n    Finally, if a fragment is given then a hash character\n   ('#') is appended to the string, followed by the fragment.\n   Any character that is not a legal URI character is quoted.  \n\n \n\n  The resulting URI string is then parsed in order to create the new\n URI instance as if by invoking the URI(String) constructor;\n this may cause a URISyntaxException to be thrown."
                }
              ]
            },
            {
              "name": "create",
              "overloads": [
                {
                  "signature": "public static URI create(String str)",
                  "description": "Creates a URI by parsing the given string.\n\n  This convenience factory method works as if by invoking the URI(String) constructor; any URISyntaxException thrown by the\n constructor is caught and wrapped in a new IllegalArgumentException object, which is then thrown.\n\n  This method is provided for use in situations where it is known that\n the given string is a legal URI, for example for URI constants declared\n within a program, and so it would be considered a programming error\n for the string not to parse as such.  The constructors, which throw\n URISyntaxException directly, should be used in situations where a\n URI is being constructed from user input or from some other source that\n may be prone to errors."
                }
              ]
            },
            {
              "name": "parseServerAuthority",
              "overloads": [
                {
                  "signature": "public URI parseServerAuthority() throws URISyntaxException",
                  "description": "Attempts to parse this URI's authority component, if defined, into\n user-information, host, and port components.\n\n  If this URI's authority component has already been recognized as\n being server-based then it will already have been parsed into\n user-information, host, and port components.  In this case, or if this\n URI has no authority component, this method simply returns this URI.\n\n  Otherwise this method attempts once more to parse the authority\n component into user-information, host, and port components, and throws\n an exception describing why the authority component could not be parsed\n in that way.\n\n  This method is provided because the generic URI syntax specified in\n RFC2396\n cannot always distinguish a malformed server-based authority from a\n legitimate registry-based authority.  It must therefore treat some\n instances of the former as instances of the latter.  The authority\n component in the URI string \"//foo:bar\", for example, is not a\n legal server-based authority but it is legal as a registry-based\n authority.\n\n  In many common situations, for example when working URIs that are\n known to be either URNs or URLs, the hierarchical URIs being used will\n always be server-based.  They therefore must either be parsed as such or\n treated as an error.  In these cases a statement such as\n\n \n URI u = new URI(str).parseServerAuthority();\n \n\n  can be used to ensure that u always refers to a URI that, if\n it has an authority component, has a server-based authority with proper\n user-information, host, and port components.  Invoking this method also\n ensures that if the authority could not be parsed in that way then an\n appropriate diagnostic message can be issued based upon the exception\n that is thrown."
                }
              ]
            },
            {
              "name": "normalize",
              "overloads": [
                {
                  "signature": "public URI normalize()",
                  "description": "Normalizes this URI's path.\n\n  If this URI is opaque, or if its path is already in normal form,\n then this URI is returned.  Otherwise a new URI is constructed that is\n identical to this URI except that its path is computed by normalizing\n this URI's path in a manner consistent with RFC2396,\n section5.2, step6, sub-stepsc throughf; that is:\n \n\n \n\n    All \".\" segments are removed. \n\n    If a \"..\" segment is preceded by a non-\"..\"\n   segment then both of these segments are removed.  This step is\n   repeated until it is no longer applicable. \n\n    If the path is relative, and if its first segment contains a\n   colon character (':'), then a \".\" segment is\n   prepended.  This prevents a relative URI with a path such as\n   \"a:b/c/d\" from later being re-parsed as an opaque URI with a\n   scheme of \"a\" and a scheme-specific part of \"b/c/d\".\n   (Deviation from RFC2396) \n\n \n\n  A normalized path will begin with one or more \"..\" segments\n if there were insufficient non-\"..\" segments preceding them to\n allow their removal.  A normalized path will begin with a \".\"\n segment if one was inserted by step 3 above.  Otherwise, a normalized\n path will not contain any \".\" or \"..\" segments."
                }
              ]
            },
            {
              "name": "resolve",
              "overloads": [
                {
                  "signature": "public URI resolve(URI uri)",
                  "description": "Resolves the given URI against this URI.\n\n  If the given URI is already absolute, or if this URI is opaque, then\n the given URI is returned.\n\n  If the given URI's fragment component is\n defined, its path component is empty, and its scheme, authority, and\n query components are undefined, then a URI with the given fragment but\n with all other components equal to those of this URI is returned.  This\n allows a URI representing a standalone fragment reference, such as\n \"#foo\", to be usefully resolved against a base URI.\n\n  Otherwise this method constructs a new hierarchical URI in a manner\n consistent with RFC2396,\n section5.2; that is: \n\n \n\n    A new URI is constructed with this URI's scheme and the given\n   URI's query and fragment components. \n\n    If the given URI has an authority component then the new URI's\n   authority and path are taken from the given URI. \n\n    Otherwise the new URI's authority component is copied from\n   this URI, and its path is computed as follows: \n\n   \n\n      If the given URI's path is absolute then the new URI's path\n     is taken from the given URI. \n\n      Otherwise the given URI's path is relative, and so the new\n     URI's path is computed by resolving the path of the given URI\n     against the path of this URI.  This is done by concatenating all but\n     the last segment of this URI's path, if any, with the given URI's\n     path and then normalizing the result as if by invoking the normalize method. \n\n   \n\n \n\n  The result of this method is absolute if, and only if, either this\n URI is absolute or the given URI is absolute."
                },
                {
                  "signature": "public URI resolve(String str)",
                  "description": "Constructs a new URI by parsing the given string and then resolving it\n against this URI.\n\n  This convenience method works as if invoking it were equivalent to\n evaluating the expression resolve(URI.create(str))."
                }
              ]
            },
            {
              "name": "relativize",
              "overloads": [
                {
                  "signature": "public URI relativize(URI uri)",
                  "description": "Relativizes the given URI against this URI.\n\n  The relativization of the given URI against this URI is computed as\n follows: \n\n \n\n    If either this URI or the given URI are opaque, or if the\n   scheme and authority components of the two URIs are not identical, or\n   if the path of this URI is not a prefix of the path of the given URI,\n   then the given URI is returned. \n\n    Otherwise a new relative hierarchical URI is constructed with\n   query and fragment components taken from the given URI and with a path\n   component computed by removing this URI's path from the beginning of\n   the given URI's path."
                }
              ]
            },
            {
              "name": "toURL",
              "overloads": [
                {
                  "signature": "public URL toURL() throws MalformedURLException",
                  "description": "Constructs a URL from this URI.\n\n  This convenience method works as if invoking it were equivalent to\n evaluating the expression new URL(this.toString()) after\n first checking that this URI is absolute."
                }
              ]
            },
            {
              "name": "getScheme",
              "overloads": [
                {
                  "signature": "public String getScheme()",
                  "description": "Returns the scheme component of this URI.\n\n  The scheme component of a URI, if defined, only contains characters\n in the alphanum category and in the string \"-.+\".  A\n scheme always starts with an alpha character. \n\n The scheme component of a URI cannot contain escaped octets, hence this\n method does not perform any decoding."
                }
              ]
            },
            {
              "name": "isAbsolute",
              "overloads": [
                {
                  "signature": "public boolean isAbsolute()",
                  "description": "Tells whether or not this URI is absolute.\n\n  A URI is absolute if, and only if, it has a scheme component."
                }
              ]
            },
            {
              "name": "isOpaque",
              "overloads": [
                {
                  "signature": "public boolean isOpaque()",
                  "description": "Tells whether or not this URI is opaque.\n\n  A URI is opaque if, and only if, it is absolute and its\n scheme-specific part does not begin with a slash character ('/').\n An opaque URI has a scheme, a scheme-specific part, and possibly\n a fragment; all other components are undefined."
                }
              ]
            },
            {
              "name": "getRawSchemeSpecificPart",
              "overloads": [
                {
                  "signature": "public String getRawSchemeSpecificPart()",
                  "description": "Returns the raw scheme-specific part of this URI.  The scheme-specific\n part is never undefined, though it may be empty.\n\n  The scheme-specific part of a URI only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getSchemeSpecificPart",
              "overloads": [
                {
                  "signature": "public String getSchemeSpecificPart()",
                  "description": "Returns the decoded scheme-specific part of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawSchemeSpecificPart method\n except that all sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawAuthority",
              "overloads": [
                {
                  "signature": "public String getRawAuthority()",
                  "description": "Returns the raw authority component of this URI.\n\n  The authority component of a URI, if defined, only contains the\n commercial-at character ('@') and characters in the\n unreserved, punct, escaped, and other\n categories.  If the authority is server-based then it is further\n constrained to have valid user-information, host, and port\n components."
                }
              ]
            },
            {
              "name": "getAuthority",
              "overloads": [
                {
                  "signature": "public String getAuthority()",
                  "description": "Returns the decoded authority component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawAuthority method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawUserInfo",
              "overloads": [
                {
                  "signature": "public String getRawUserInfo()",
                  "description": "Returns the raw user-information component of this URI.\n\n  The user-information component of a URI, if defined, only contains\n characters in the unreserved, punct, escaped, and\n other categories."
                }
              ]
            },
            {
              "name": "getUserInfo",
              "overloads": [
                {
                  "signature": "public String getUserInfo()",
                  "description": "Returns the decoded user-information component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawUserInfo method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getHost",
              "overloads": [
                {
                  "signature": "public String getHost()",
                  "description": "Returns the host component of this URI.\n\n  The host component of a URI, if defined, will have one of the\n following forms: \n\n \n\n    A domain name consisting of one or more labels\n   separated by period characters ('.'), optionally followed by\n   a period character.  Each label consists of alphanum characters\n   as well as hyphen characters ('-'), though hyphens never\n   occur as the first or last characters in a label. The rightmost\n   label of a domain name consisting of two or more labels, begins\n   with an alpha character. \n\n    A dotted-quad IPv4 address of the form\n   digit+.digit+.digit+.digit+,\n   where no digit sequence is longer than three characters and no\n   sequence has a value larger than 255. \n\n    An IPv6 address enclosed in square brackets ('[' and\n   ']') and consisting of hexadecimal digits, colon characters\n   (':'), and possibly an embedded IPv4 address.  The full\n   syntax of IPv6 addresses is specified in RFC2373: IPv6\n   Addressing Architecture.  \n\n \n\n The host component of a URI cannot contain escaped octets, hence this\n method does not perform any decoding."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Returns the port number of this URI.\n\n  The port component of a URI, if defined, is a non-negative\n integer."
                }
              ]
            },
            {
              "name": "getRawPath",
              "overloads": [
                {
                  "signature": "public String getRawPath()",
                  "description": "Returns the raw path component of this URI.\n\n  The path component of a URI, if defined, only contains the slash\n character ('/'), the commercial-at character ('@'),\n and characters in the unreserved, punct, escaped,\n and other categories."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Returns the decoded path component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawPath method except that all sequences of\n escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawQuery",
              "overloads": [
                {
                  "signature": "public String getRawQuery()",
                  "description": "Returns the raw query component of this URI.\n\n  The query component of a URI, if defined, only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getQuery",
              "overloads": [
                {
                  "signature": "public String getQuery()",
                  "description": "Returns the decoded query component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawQuery method except that all sequences of\n escaped octets are decoded."
                }
              ]
            },
            {
              "name": "getRawFragment",
              "overloads": [
                {
                  "signature": "public String getRawFragment()",
                  "description": "Returns the raw fragment component of this URI.\n\n  The fragment component of a URI, if defined, only contains legal URI\n characters."
                }
              ]
            },
            {
              "name": "getFragment",
              "overloads": [
                {
                  "signature": "public String getFragment()",
                  "description": "Returns the decoded fragment component of this URI.\n\n  The string returned by this method is equal to that returned by the\n getRawFragment method except that all\n sequences of escaped octets are decoded."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tests this URI for equality with another object.\n\n  If the given object is not a URI then this method immediately\n returns false.\n\n  For two URIs to be considered equal requires that either both are\n opaque or both are hierarchical.  Their schemes must either both be\n undefined or else be equal without regard to case. Their fragments\n must either both be undefined or else be equal.\n\n  For two opaque URIs to be considered equal, their scheme-specific\n parts must be equal.\n\n  For two hierarchical URIs to be considered equal, their paths must\n be equal and their queries must either both be undefined or else be\n equal.  Their authorities must either both be undefined, or both be\n registry-based, or both be server-based.  If their authorities are\n defined and are registry-based, then they must be equal.  If their\n authorities are defined and are server-based, then their hosts must be\n equal without regard to case, their port numbers must be equal, and\n their user-information components must be equal.\n\n  When testing the user-information, path, query, fragment, authority,\n or scheme-specific parts of two URIs for equality, the raw forms rather\n than the encoded forms of these components are compared and the\n hexadecimal digits of escaped octets are compared without regard to\n case.\n\n  This method satisfies the general contract of the Object.equals method."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash-code value for this URI.  The hash code is based upon all\n of the URI's components, and satisfies the general contract of the\n Object.hashCode method."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(URI that)",
                  "description": "Compares this URI to another object, which must be a URI.\n\n  When comparing corresponding components of two URIs, if one\n component is undefined but the other is defined then the first is\n considered to be less than the second.  Unless otherwise noted, string\n components are ordered according to their natural, case-sensitive\n ordering as defined by the String.compareTo method.  String components that are subject to\n encoding are compared by comparing their raw forms rather than their\n encoded forms and the hexadecimal digits of escaped octets are compared\n without regard to case.\n\n  The ordering of URIs is defined as follows: \n\n \n\n    Two URIs with different schemes are ordered according the\n   ordering of their schemes, without regard to case. \n\n    A hierarchical URI is considered to be less than an opaque URI\n   with an identical scheme. \n\n    Two opaque URIs with identical schemes are ordered according\n   to the ordering of their scheme-specific parts. \n\n    Two opaque URIs with identical schemes and scheme-specific\n   parts are ordered according to the ordering of their\n   fragments. \n\n    Two hierarchical URIs with identical schemes are ordered\n   according to the ordering of their authority components: \n\n   \n\n      If both authority components are server-based then the URIs\n     are ordered according to their user-information components; if these\n     components are identical then the URIs are ordered according to the\n     ordering of their hosts, without regard to case; if the hosts are\n     identical then the URIs are ordered according to the ordering of\n     their ports. \n\n      If one or both authority components are registry-based then\n     the URIs are ordered according to the ordering of their authority\n     components. \n\n   \n\n    Finally, two hierarchical URIs with identical schemes and\n   authority components are ordered according to the ordering of their\n   paths; if their paths are identical then they are ordered according to\n   the ordering of their queries; if the queries are identical then they\n   are ordered according to the order of their fragments. \n\n \n\n  This method satisfies the general contract of the Comparable.compareTo\n method."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the content of this URI as a string.\n\n  If this URI was created by invoking one of the constructors in this\n class then a string equivalent to the original input string, or to the\n string computed from the originally-given components, as appropriate, is\n returned.  Otherwise this URI was created by normalization, resolution,\n or relativization, and so a string is constructed from this URI's\n components according to the rules specified in RFC2396,\n section5.2, step7."
                }
              ]
            },
            {
              "name": "toASCIIString",
              "overloads": [
                {
                  "signature": "public String toASCIIString()",
                  "description": "Returns the content of this URI as a US-ASCII string.\n\n  If this URI does not contain any characters in the other\n category then an invocation of this method will return the same value as\n an invocation of the toString method.  Otherwise\n this method works as if by invoking that method and then encoding the result."
                }
              ]
            }
          ]
        },
        {
          "name": "URISyntaxException",
          "methods": [
            {
              "name": "URISyntaxException",
              "overloads": [
                {
                  "signature": "public URISyntaxException(String input, String reason, int index)",
                  "description": "Constructs an instance from the given input string, reason, and error\n index."
                },
                {
                  "signature": "public URISyntaxException(String input, String reason)",
                  "description": "Constructs an instance from the given input string and reason.  The\n resulting object will have an error index of -1."
                }
              ]
            },
            {
              "name": "getInput",
              "overloads": [
                {
                  "signature": "public String getInput()",
                  "description": "Returns the input string."
                }
              ]
            },
            {
              "name": "getReason",
              "overloads": [
                {
                  "signature": "public String getReason()",
                  "description": "Returns a string explaining why the input string could not be parsed."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Returns an index into the input string of the position at which the\n parse error occurred, or -1 if this position is not known."
                }
              ]
            },
            {
              "name": "getMessage",
              "overloads": [
                {
                  "signature": "public String getMessage()",
                  "description": "Returns a string describing the parse error.  The resulting string\n consists of the reason string followed by a colon character\n (':'), a space, and the input string.  If the error index is\n defined then the string \" at index \" followed by the index, in\n decimal, is inserted after the reason string and before the colon\n character."
                }
              ]
            }
          ]
        },
        {
          "name": "URL",
          "methods": [
            {
              "name": "URL",
              "overloads": [
                {
                  "signature": "public URL(String protocol, String host, int port, String file) throws MalformedURLException",
                  "description": "Creates a URL object from the specified\n protocol, host, port\n number, and file.\n\n host can be expressed as a host name or a literal\n IP address. If IPv6 literal address is used, it should be\n enclosed in square brackets ('[' and ']'), as\n specified by RFC2732;\n However, the literal IPv6 address format defined in RFC2373: IP\n Version 6 Addressing Architecture is also accepted.\n\n Specifying a port number of -1\n indicates that the URL should use the default port for the\n protocol.\n\n If this is the first URL object being created with the specified\n protocol, a stream protocol handler object, an instance of\n class URLStreamHandler, is created for that protocol:\n \n If the application has previously set up an instance of\n     URLStreamHandlerFactory as the stream handler factory,\n     then the createURLStreamHandler method of that instance\n     is called with the protocol string as an argument to create the\n     stream protocol handler.\n If no URLStreamHandlerFactory has yet been set up,\n     or if the factory's createURLStreamHandler method\n     returns null, then the ServiceLoader mechanism is used to locate URLStreamHandlerProvider\n     implementations using the system class\n     loader. The order that providers are located is implementation\n     specific, and an implementation is free to cache the located\n     providers. A ServiceConfigurationError, Error or RuntimeException\n     thrown from the createURLStreamHandler, if encountered, will\n     be propagated to the calling thread. The \n     createURLStreamHandler method of each provider, if instantiated, is\n     invoked, with the protocol string, until a provider returns non-null,\n     or all providers have been exhausted.\n If the previous step fails to find a protocol handler, the\n     constructor reads the value of the system property:\n     java.protocol.handler.pkgs\n     If the value of that system property is not null,\n     it is interpreted as a list of packages separated by a vertical\n     slash character '|'. The constructor tries to load\n     the class named:\n     \n         <package>.<protocol>.Handler\n     \n     where <package> is replaced by the name of the package\n     and <protocol> is replaced by the name of the protocol.\n     If this class does not exist, or if the class exists but it is not\n     a subclass of URLStreamHandler, then the next package\n     in the list is tried.\n If the previous step fails to find a protocol handler, then the\n     constructor tries to load a built-in protocol handler.\n     If this class does not exist, or if the class exists but it is not a\n     subclass of URLStreamHandler, then a\n     MalformedURLException is thrown.\n \n\n Protocol handlers for the following protocols are guaranteed\n to exist on the search path:\n \n http\n https\n file\n jar\n \n Protocol handlers for additional protocols may also be  available.\n Some protocol handlers, for example those used for loading platform\n classes or classes on the class path, may not be overridden. The details\n of such restrictions, and when those restrictions apply (during\n initialization of the runtime for example), are implementation specific\n and therefore not specified\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String protocol, String host, String file) throws MalformedURLException",
                  "description": "Creates a URL from the specified protocol\n name, host name, and file name. The\n default port for the specified protocol is used.\n \n This constructor is equivalent to the four-argument\n constructor with the only difference of using the\n default port for the specified protocol.\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String protocol, String host, int port, String file, URLStreamHandler handler) throws MalformedURLException",
                  "description": "Creates a URL object from the specified\n protocol, host, port\n number, file, and handler. Specifying\n a port number of -1 indicates that\n the URL should use the default port for the protocol. Specifying\n a handler of null indicates that the URL\n should use a default stream handler for the protocol, as outlined\n for:\n     URL(java.lang.String, java.lang.String, int, java.lang.String)\n\n If the handler is not null and there is a security manager,\n the security manager's checkPermission\n method is called with a\n NetPermission(\"specifyStreamHandler\") permission.\n This may result in a SecurityException.\n\n No validation of the inputs is performed by this constructor."
                },
                {
                  "signature": "public URL(String spec) throws MalformedURLException",
                  "description": "Creates a URL object from the String\n representation.\n \n This constructor is equivalent to a call to the two-argument\n constructor with a null first argument."
                },
                {
                  "signature": "public URL(URL context, String spec) throws MalformedURLException",
                  "description": "Creates a URL by parsing the given spec within a specified context.\n\n The new URL is created from the given context URL and the spec\n argument as described in\n RFC2396 \"Uniform Resource Identifiers : Generic * Syntax\" :\n           <scheme>://<authority><path>?<query>#<fragment>\n \n The reference is parsed into the scheme, authority, path, query and\n fragment parts. If the path component is empty and the scheme,\n authority, and query components are undefined, then the new URL is a\n reference to the current document. Otherwise, the fragment and query\n parts present in the spec are used in the new URL.\n \n If the scheme component is defined in the given spec and does not match\n the scheme of the context, then the new URL is created as an absolute\n URL based on the spec alone. Otherwise the scheme component is inherited\n from the context URL.\n \n If the authority component is present in the spec then the spec is\n treated as absolute and the spec authority and path will replace the\n context authority and path. If the authority component is absent in the\n spec then the authority of the new URL will be inherited from the\n context.\n \n If the spec's path component begins with a slash character\n \"/\" then the\n path is treated as absolute and the spec path replaces the context path.\n \n Otherwise, the path is treated as a relative path and is appended to the\n context path, as described in RFC2396. Also, in this case,\n the path is canonicalized through the removal of directory\n changes made by occurrences of \"..\" and \".\".\n \n For a more detailed description of URL parsing, refer to RFC2396."
                },
                {
                  "signature": "public URL(URL context, String spec, URLStreamHandler handler) throws MalformedURLException",
                  "description": "Creates a URL by parsing the given spec with the specified handler\n within a specified context. If the handler is null, the parsing\n occurs as with the two argument constructor."
                }
              ]
            },
            {
              "name": "getQuery",
              "overloads": [
                {
                  "signature": "public String getQuery()",
                  "description": "Gets the query part of this URL."
                }
              ]
            },
            {
              "name": "getPath",
              "overloads": [
                {
                  "signature": "public String getPath()",
                  "description": "Gets the path part of this URL."
                }
              ]
            },
            {
              "name": "getUserInfo",
              "overloads": [
                {
                  "signature": "public String getUserInfo()",
                  "description": "Gets the userInfo part of this URL."
                }
              ]
            },
            {
              "name": "getAuthority",
              "overloads": [
                {
                  "signature": "public String getAuthority()",
                  "description": "Gets the authority part of this URL."
                }
              ]
            },
            {
              "name": "getPort",
              "overloads": [
                {
                  "signature": "public int getPort()",
                  "description": "Gets the port number of this URL."
                }
              ]
            },
            {
              "name": "getDefaultPort",
              "overloads": [
                {
                  "signature": "public int getDefaultPort()",
                  "description": "Gets the default port number of the protocol associated\n with this URL. If the URL scheme or the URLStreamHandler\n for the URL do not define a default port number,\n then -1 is returned."
                }
              ]
            },
            {
              "name": "getProtocol",
              "overloads": [
                {
                  "signature": "public String getProtocol()",
                  "description": "Gets the protocol name of this URL."
                }
              ]
            },
            {
              "name": "getHost",
              "overloads": [
                {
                  "signature": "public String getHost()",
                  "description": "Gets the host name of this URL, if applicable.\n The format of the host conforms to RFC 2732, i.e. for a\n literal IPv6 address, this method will return the IPv6 address\n enclosed in square brackets ('[' and ']')."
                }
              ]
            },
            {
              "name": "getFile",
              "overloads": [
                {
                  "signature": "public String getFile()",
                  "description": "Gets the file name of this URL.\n The returned file portion will be\n the same as getPath(), plus the concatenation of\n the value of getQuery(), if any. If there is\n no query portion, this method and getPath() will\n return identical results."
                }
              ]
            },
            {
              "name": "getRef",
              "overloads": [
                {
                  "signature": "public String getRef()",
                  "description": "Gets the anchor (also known as the \"reference\") of this\n URL."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this URL for equality with another object.\n\n If the given object is not a URL then this method immediately returns\n false.\n\n Two URL objects are equal if they have the same protocol, reference\n equivalent hosts, have the same port number on the host, and the same\n file and fragment of the file.\n\n Two hosts are considered equivalent if both host names can be resolved\n into the same IP addresses; else if either host name can't be\n resolved, the host names must be equal without regard to case; or both\n host names equal to null.\n\n Since hosts comparison requires name resolution, this operation is a\n blocking operation. \n\n Note: The defined behavior for equals is known to\n be inconsistent with virtual hosting in HTTP."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Creates an integer suitable for hash table indexing.\n\n The hash code is based upon all the URL components relevant for URL\n comparison. As such, this operation is a blocking operation."
                }
              ]
            },
            {
              "name": "sameFile",
              "overloads": [
                {
                  "signature": "public boolean sameFile(URL other)",
                  "description": "Compares two URLs, excluding the fragment component.\n\n Returns true if this URL and the\n other argument are equal without taking the\n fragment component into consideration."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string representation of this URL. The\n string is created by calling the toExternalForm\n method of the stream protocol handler for this object."
                }
              ]
            },
            {
              "name": "toExternalForm",
              "overloads": [
                {
                  "signature": "public String toExternalForm()",
                  "description": "Constructs a string representation of this URL. The\n string is created by calling the toExternalForm\n method of the stream protocol handler for this object."
                }
              ]
            },
            {
              "name": "toURI",
              "overloads": [
                {
                  "signature": "public URI toURI() throws URISyntaxException",
                  "description": "Returns a URI equivalent to this URL.\n This method functions in the same way as new URI (this.toString()).\n Note, any URL instance that complies with RFC 2396 can be converted\n to a URI. However, some URLs that are not strictly in compliance\n can not be converted to a URI."
                }
              ]
            },
            {
              "name": "openConnection",
              "overloads": [
                {
                  "signature": "public URLConnection openConnection() throws IOException",
                  "description": "Returns a URLConnection instance that\n represents a connection to the remote object referred to by the\n URL.\n\n A new instance of URLConnection is\n created every time when invoking the\n URLStreamHandler.openConnection(URL) method of the protocol handler for\n this URL.\n\n It should be noted that a URLConnection instance does not establish\n the actual network connection on creation. This will happen only when\n calling URLConnection.connect().\n\n If for the URL's protocol (such as HTTP or JAR), there\n exists a public, specialized URLConnection subclass belonging\n to one of the following packages or one of their subpackages:\n java.lang, java.io, java.util, java.net, the connection\n returned will be of that subclass. For example, for HTTP an\n HttpURLConnection will be returned, and for JAR a\n JarURLConnection will be returned."
                },
                {
                  "signature": "public URLConnection openConnection(Proxy proxy) throws IOException",
                  "description": "Same as openConnection(), except that the connection will be\n made through the specified proxy; Protocol handlers that do not\n support proxying will ignore the proxy parameter and make a\n normal connection.\n\n Invoking this method preempts the system's default\n ProxySelector settings."
                }
              ]
            },
            {
              "name": "openStream",
              "overloads": [
                {
                  "signature": "public final InputStream openStream() throws IOException",
                  "description": "Opens a connection to this URL and returns an\n InputStream for reading from that connection. This\n method is a shorthand for:\n      openConnection().getInputStream()"
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public final Object getContent() throws IOException",
                  "description": "Gets the contents of this URL. This method is a shorthand for:\n      openConnection().getContent()"
                },
                {
                  "signature": "public final Object getContent(Class<?>[] classes) throws IOException",
                  "description": "Gets the contents of this URL. This method is a shorthand for:\n      openConnection().getContent(classes)"
                }
              ]
            },
            {
              "name": "setURLStreamHandlerFactory",
              "overloads": [
                {
                  "signature": "public static void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)",
                  "description": "Sets an application's URLStreamHandlerFactory.\n This method can be called at most once in a given Java Virtual\n Machine.\n\n The URLStreamHandlerFactory instance is used to\nconstruct a stream protocol handler from a protocol name.\n\n  If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            }
          ]
        },
        {
          "name": "URLClassLoader",
          "methods": [
            {
              "name": "URLClassLoader",
              "overloads": [
                {
                  "signature": "public URLClassLoader(URL[] urls, ClassLoader parent)",
                  "description": "Constructs a new URLClassLoader for the given URLs. The URLs will be\n searched in the order specified for classes and resources after first\n searching in the specified parent class loader.  Any jar:\n scheme URL is assumed to refer to a JAR file.  Any file: scheme\n URL that ends with a '/' is assumed to refer to a directory.  Otherwise,\n the URL is assumed to refer to a JAR file which will be downloaded and\n opened as needed.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(URL[] urls)",
                  "description": "Constructs a new URLClassLoader for the specified URLs using the\n default delegation parent ClassLoader. The URLs will\n be searched in the order specified for classes and resources after\n first searching in the parent class loader. Any URL that ends with\n a '/' is assumed to refer to a directory. Otherwise, the URL is\n assumed to refer to a JAR file which will be downloaded and opened\n as needed.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)",
                  "description": "Constructs a new URLClassLoader for the specified URLs, parent\n class loader, and URLStreamHandlerFactory. The parent argument\n will be used as the parent class loader for delegation. The\n factory argument will be used as the stream handler factory to\n obtain protocol handlers when creating new jar URLs.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader method\n to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "public URLClassLoader(String name, URL[] urls, ClassLoader parent)",
                  "description": "Constructs a new named URLClassLoader for the specified URLs.\n The URLs will be searched in the order specified for classes\n and resources after first searching in the specified parent class loader.\n Any URL that ends with a '/' is assumed to refer to a directory.\n Otherwise, the URL is assumed to refer to a JAR file which will be\n downloaded and opened as needed."
                },
                {
                  "signature": "public URLClassLoader(String name, URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)",
                  "description": "Constructs a new named URLClassLoader for the specified URLs,\n parent class loader, and URLStreamHandlerFactory.\n The parent argument will be used as the parent class loader for delegation.\n The factory argument will be used as the stream handler factory to\n obtain protocol handlers when creating new jar URLs."
                }
              ]
            },
            {
              "name": "getResourceAsStream",
              "overloads": [
                {
                  "signature": "public InputStream getResourceAsStream(String name)",
                  "description": "Returns an input stream for reading the specified resource.\n If this loader is closed, then any resources opened by this method\n will be closed.\n\n  The search order is described in the documentation for ClassLoader.getResource(String)."
                }
              ]
            },
            {
              "name": "close",
              "overloads": [
                {
                  "signature": "public void close() throws IOException",
                  "description": "Closes this URLClassLoader, so that it can no longer be used to load\n new classes or resources that are defined by this loader.\n Classes and resources defined by any of this loader's parents in the\n delegation hierarchy are still accessible. Also, any classes or resources\n that are already loaded, are still accessible.\n \n In the case of jar: and file: URLs, it also closes any files\n that were opened by it. If another thread is loading a\n class when the close method is invoked, then the result of\n that load is undefined.\n \n The method makes a best effort attempt to close all opened files,\n by catching IOExceptions internally. Unchecked exceptions\n and errors are not caught. Calling close on an already closed\n loader has no effect."
                }
              ]
            },
            {
              "name": "addURL",
              "overloads": [
                {
                  "signature": "protected void addURL(URL url)",
                  "description": "Appends the specified URL to the list of URLs to search for\n classes and resources.\n \n If the URL specified is null or is already in the\n list of URLs, or if this loader is closed, then invoking this\n method has no effect."
                }
              ]
            },
            {
              "name": "getURLs",
              "overloads": [
                {
                  "signature": "public URL[] getURLs()",
                  "description": "Returns the search path of URLs for loading classes and resources.\n This includes the original list of URLs specified to the constructor,\n along with any URLs subsequently appended by the addURL() method."
                }
              ]
            },
            {
              "name": "findClass",
              "overloads": [
                {
                  "signature": "protected Class<?> findClass(String name) throws ClassNotFoundException",
                  "description": "Finds and loads the class with the specified name from the URL search\n path. Any URLs referring to JAR files are loaded and opened as needed\n until the class is found."
                }
              ]
            },
            {
              "name": "definePackage",
              "overloads": [
                {
                  "signature": "protected Package definePackage(String name, Manifest man, URL url)",
                  "description": "Defines a new package by name in this URLClassLoader.\n The attributes contained in the specified Manifest\n will be used to obtain package version and sealing information.\n For sealed packages, the additional URL specifies the code source URL\n from which the package was loaded."
                }
              ]
            },
            {
              "name": "findResource",
              "overloads": [
                {
                  "signature": "public URL findResource(String name)",
                  "description": "Finds the resource with the specified name on the URL search path."
                }
              ]
            },
            {
              "name": "findResources",
              "overloads": [
                {
                  "signature": "public Enumeration<URL> findResources(String name) throws IOException",
                  "description": "Returns an Enumeration of URLs representing all of the resources\n on the URL search path having the specified name."
                }
              ]
            },
            {
              "name": "getPermissions",
              "overloads": [
                {
                  "signature": "protected PermissionCollection getPermissions(CodeSource codesource)",
                  "description": "Returns the permissions for the given codesource object.\n The implementation of this method first calls super.getPermissions\n and then adds permissions based on the URL of the codesource.\n \n If the protocol of this URL is \"jar\", then the permission granted\n is based on the permission that is required by the URL of the Jar\n file.\n \n If the protocol is \"file\" and there is an authority component, then\n permission to connect to and accept connections from that authority\n may be granted. If the protocol is \"file\"\n and the path specifies a file, then permission to read that\n file is granted. If protocol is \"file\" and the path is\n a directory, permission is granted to read all files\n and (recursively) all files and subdirectories contained in\n that directory.\n \n If the protocol is not \"file\", then permission\n to connect to and accept connections from the URL's host is granted."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "public static URLClassLoader newInstance(URL[] urls, ClassLoader parent)",
                  "description": "Creates a new instance of URLClassLoader for the specified\n URLs and parent class loader. If a security manager is\n installed, the loadClass method of the URLClassLoader\n returned by this method will invoke the\n SecurityManager.checkPackageAccess method before\n loading the class."
                },
                {
                  "signature": "public static URLClassLoader newInstance(URL[] urls)",
                  "description": "Creates a new instance of URLClassLoader for the specified\n URLs and default parent class loader. If a security manager is\n installed, the loadClass method of the URLClassLoader\n returned by this method will invoke the\n SecurityManager.checkPackageAccess before\n loading the class."
                }
              ]
            }
          ]
        },
        {
          "name": "URLConnection",
          "methods": [
            {
              "name": "URLConnection",
              "overloads": [
                {
                  "signature": "protected URLConnection(URL url)",
                  "description": "Constructs a URL connection to the specified URL. A connection to\n the object referenced by the URL is not created."
                }
              ]
            },
            {
              "name": "getFileNameMap",
              "overloads": [
                {
                  "signature": "public static FileNameMap getFileNameMap()",
                  "description": "Loads filename map (a mimetable) from a data file. It will\n first try to load the user-specific table, defined\n by \"content.types.user.table\" property. If that fails,\n it tries to load the default built-in table."
                }
              ]
            },
            {
              "name": "setFileNameMap",
              "overloads": [
                {
                  "signature": "public static void setFileNameMap(FileNameMap map)",
                  "description": "Sets the FileNameMap.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "connect",
              "overloads": [
                {
                  "signature": "public abstract void connect() throws IOException",
                  "description": "Opens a communications link to the resource referenced by this\n URL, if such a connection has not already been established.\n \n If the connect method is called when the connection\n has already been opened (indicated by the connected\n field having the value true), the call is ignored.\n \n URLConnection objects go through two phases: first they are\n created, then they are connected.  After being created, and\n before being connected, various options can be specified\n (e.g., doInput and UseCaches).  After connecting, it is an\n error to try to set them.  Operations that depend on being\n connected, like getContentLength, will implicitly perform the\n connection, if necessary."
                }
              ]
            },
            {
              "name": "setConnectTimeout",
              "overloads": [
                {
                  "signature": "public void setConnectTimeout(int timeout)",
                  "description": "Sets a specified timeout value, in milliseconds, to be used\n when opening a communications link to the resource referenced\n by this URLConnection.  If the timeout expires before the\n connection can be established, a\n java.net.SocketTimeoutException is raised. A timeout of zero is\n interpreted as an infinite timeout.\n\n  Some non-standard implementation of this method may ignore\n the specified timeout. To see the connect timeout set, please\n call getConnectTimeout()."
                }
              ]
            },
            {
              "name": "getConnectTimeout",
              "overloads": [
                {
                  "signature": "public int getConnectTimeout()",
                  "description": "Returns setting for connect timeout.\n \n 0 return implies that the option is disabled\n (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "setReadTimeout",
              "overloads": [
                {
                  "signature": "public void setReadTimeout(int timeout)",
                  "description": "Sets the read timeout to a specified timeout, in\n milliseconds. A non-zero value specifies the timeout when\n reading from Input stream when a connection is established to a\n resource. If the timeout expires before there is data available\n for read, a java.net.SocketTimeoutException is raised. A\n timeout of zero is interpreted as an infinite timeout.\n\n  Some non-standard implementation of this method ignores the\n specified timeout. To see the read timeout set, please call\n getReadTimeout()."
                }
              ]
            },
            {
              "name": "getReadTimeout",
              "overloads": [
                {
                  "signature": "public int getReadTimeout()",
                  "description": "Returns setting for read timeout. 0 return implies that the\n option is disabled (i.e., timeout of infinity)."
                }
              ]
            },
            {
              "name": "getURL",
              "overloads": [
                {
                  "signature": "public URL getURL()",
                  "description": "Returns the value of this URLConnection's URL\n field."
                }
              ]
            },
            {
              "name": "getContentLength",
              "overloads": [
                {
                  "signature": "public int getContentLength()",
                  "description": "Returns the value of the content-length header field.\n \n Note: getContentLengthLong()\n should be preferred over this method, since it returns a long\n instead and is therefore more portable."
                }
              ]
            },
            {
              "name": "getContentLengthLong",
              "overloads": [
                {
                  "signature": "public long getContentLengthLong()",
                  "description": "Returns the value of the content-length header field as a\n long."
                }
              ]
            },
            {
              "name": "getContentType",
              "overloads": [
                {
                  "signature": "public String getContentType()",
                  "description": "Returns the value of the content-type header field."
                }
              ]
            },
            {
              "name": "getContentEncoding",
              "overloads": [
                {
                  "signature": "public String getContentEncoding()",
                  "description": "Returns the value of the content-encoding header field."
                }
              ]
            },
            {
              "name": "getExpiration",
              "overloads": [
                {
                  "signature": "public long getExpiration()",
                  "description": "Returns the value of the expires header field."
                }
              ]
            },
            {
              "name": "getDate",
              "overloads": [
                {
                  "signature": "public long getDate()",
                  "description": "Returns the value of the date header field."
                }
              ]
            },
            {
              "name": "getLastModified",
              "overloads": [
                {
                  "signature": "public long getLastModified()",
                  "description": "Returns the value of the last-modified header field.\n The result is the number of milliseconds since January 1, 1970 GMT."
                }
              ]
            },
            {
              "name": "getHeaderField",
              "overloads": [
                {
                  "signature": "public String getHeaderField(String name)",
                  "description": "Returns the value of the named header field.\n \n If called on a connection that sets the same header multiple times\n with possibly different values, only the last value is returned."
                },
                {
                  "signature": "public String getHeaderField(int n)",
                  "description": "Returns the value for the nth header field.\n It returns null if there are fewer than\n n+1 fields.\n \n This method can be used in conjunction with the\n getHeaderFieldKey method to iterate through all\n the headers in the message."
                }
              ]
            },
            {
              "name": "getHeaderFields",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> getHeaderFields()",
                  "description": "Returns an unmodifiable Map of the header fields.\n The Map keys are Strings that represent the\n response-header field names. Each Map value is an\n unmodifiable List of Strings that represents\n the corresponding field values."
                }
              ]
            },
            {
              "name": "getHeaderFieldInt",
              "overloads": [
                {
                  "signature": "public int getHeaderFieldInt(String name, int Default)",
                  "description": "Returns the value of the named field parsed as a number.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldLong",
              "overloads": [
                {
                  "signature": "public long getHeaderFieldLong(String name, long Default)",
                  "description": "Returns the value of the named field parsed as a number.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldDate",
              "overloads": [
                {
                  "signature": "public long getHeaderFieldDate(String name, long Default)",
                  "description": "Returns the value of the named field parsed as date.\n The result is the number of milliseconds since January 1, 1970 GMT\n represented by the named field.\n \n This form of getHeaderField exists because some\n connection types (e.g., http-ng) have pre-parsed\n headers. Classes for that connection type can override this method\n and short-circuit the parsing."
                }
              ]
            },
            {
              "name": "getHeaderFieldKey",
              "overloads": [
                {
                  "signature": "public String getHeaderFieldKey(int n)",
                  "description": "Returns the key for the nth header field.\n Some implementations may treat the 0th\n header field as special, in which case, getHeaderField(0)\n may return some value, but getHeaderFieldKey(0) returns null.\n For n > 0  it returns null if there are fewer than n+1 fields."
                }
              ]
            },
            {
              "name": "getContent",
              "overloads": [
                {
                  "signature": "public Object getContent() throws IOException",
                  "description": "Retrieves the contents of this URL connection.\n \n This method first determines the content type of the object by\n calling the getContentType method. If this is\n the first time that the application has seen that specific content\n type, a content handler for that content type is created.\n  This is done as follows:\n \n If the application has set up a content handler factory instance\n     using the setContentHandlerFactory method, the\n     createContentHandler method of that instance is called\n     with the content type as an argument; the result is a content\n     handler for that content type.\n If no ContentHandlerFactory has yet been set up,\n     or if the factory's createContentHandler method\n     returns null, then the ServiceLoader mechanism is used to locate ContentHandlerFactory\n     implementations using the system class\n     loader. The order that factories are located is implementation\n     specific, and an implementation is free to cache the located\n     factories. A ServiceConfigurationError, Error or RuntimeException\n     thrown from the createContentHandler, if encountered, will\n     be propagated to the calling thread. The \n     createContentHandler method of each factory, if instantiated, is\n     invoked, with the content type, until a factory returns non-null,\n     or all factories have been exhausted.\n Failing that, this method tries to load a content handler\n     class as defined by ContentHandler.\n     If the class does not exist, or is not a subclass of \n     ContentHandler, then an UnknownServiceException is thrown."
                },
                {
                  "signature": "public Object getContent(Class<?>[] classes) throws IOException",
                  "description": "Retrieves the contents of this URL connection."
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission() throws IOException",
                  "description": "Returns a permission object representing the permission\n necessary to make the connection represented by this\n object. This method returns null if no permission is\n required to make the connection. By default, this method\n returns java.security.AllPermission. Subclasses\n should override this method and return the permission\n that best represents the permission required to make\n a connection to the URL. For example, a URLConnection\n representing a file: URL would return a\n java.io.FilePermission object.\n\n The permission returned may dependent upon the state of the\n connection. For example, the permission before connecting may be\n different from that after connecting. For example, an HTTP\n sever, say foo.com, may redirect the connection to a different\n host, say bar.com. Before connecting the permission returned by\n the connection will represent the permission needed to connect\n to foo.com, while the permission returned after connecting will\n be to bar.com.\n\n Permissions are generally used for two purposes: to protect\n caches of objects obtained through URLConnections, and to check\n the right of a recipient to learn about a particular URL. In\n the first case, the permission should be obtained\n after the object has been obtained. For example, in an\n HTTP connection, this will represent the permission to connect\n to the host from which the data was ultimately fetched. In the\n second case, the permission should be obtained and tested\n before connecting."
                }
              ]
            },
            {
              "name": "getInputStream",
              "overloads": [
                {
                  "signature": "public InputStream getInputStream() throws IOException",
                  "description": "Returns an input stream that reads from this open connection.\n\n A SocketTimeoutException can be thrown when reading from the\n returned input stream if the read timeout expires before data\n is available for read."
                }
              ]
            },
            {
              "name": "getOutputStream",
              "overloads": [
                {
                  "signature": "public OutputStream getOutputStream() throws IOException",
                  "description": "Returns an output stream that writes to this connection."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a String representation of this URL connection."
                }
              ]
            },
            {
              "name": "setDoInput",
              "overloads": [
                {
                  "signature": "public void setDoInput(boolean doinput)",
                  "description": "Sets the value of the doInput field for this\n URLConnection to the specified value.\n \n A URL connection can be used for input and/or output.  Set the doInput\n flag to true if you intend to use the URL connection for input,\n false if not.  The default is true."
                }
              ]
            },
            {
              "name": "getDoInput",
              "overloads": [
                {
                  "signature": "public boolean getDoInput()",
                  "description": "Returns the value of this URLConnection's\n doInput flag."
                }
              ]
            },
            {
              "name": "setDoOutput",
              "overloads": [
                {
                  "signature": "public void setDoOutput(boolean dooutput)",
                  "description": "Sets the value of the doOutput field for this\n URLConnection to the specified value.\n \n A URL connection can be used for input and/or output.  Set the doOutput\n flag to true if you intend to use the URL connection for output,\n false if not.  The default is false."
                }
              ]
            },
            {
              "name": "getDoOutput",
              "overloads": [
                {
                  "signature": "public boolean getDoOutput()",
                  "description": "Returns the value of this URLConnection's\n doOutput flag."
                }
              ]
            },
            {
              "name": "setAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public void setAllowUserInteraction(boolean allowuserinteraction)",
                  "description": "Set the value of the allowUserInteraction field of\n this URLConnection."
                }
              ]
            },
            {
              "name": "getAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public boolean getAllowUserInteraction()",
                  "description": "Returns the value of the allowUserInteraction field for\n this object."
                }
              ]
            },
            {
              "name": "setDefaultAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public static void setDefaultAllowUserInteraction(boolean defaultallowuserinteraction)",
                  "description": "Sets the default value of the\n allowUserInteraction field for all future\n URLConnection objects to the specified value."
                }
              ]
            },
            {
              "name": "getDefaultAllowUserInteraction",
              "overloads": [
                {
                  "signature": "public static boolean getDefaultAllowUserInteraction()",
                  "description": "Returns the default value of the allowUserInteraction\n field.\n \n This default is \"sticky\", being a part of the static state of all\n URLConnections.  This flag applies to the next, and all following\n URLConnections that are created."
                }
              ]
            },
            {
              "name": "setUseCaches",
              "overloads": [
                {
                  "signature": "public void setUseCaches(boolean usecaches)",
                  "description": "Sets the value of the useCaches field of this\n URLConnection to the specified value.\n \n Some protocols do caching of documents.  Occasionally, it is important\n to be able to \"tunnel through\" and ignore the caches (e.g., the\n \"reload\" button in a browser).  If the UseCaches flag on a connection\n is true, the connection is allowed to use whatever caches it can.\n  If false, caches are to be ignored.\n  The default value comes from defaultUseCaches, which defaults to\n true. A default value can also be set per-protocol using\n setDefaultUseCaches(String,boolean)."
                }
              ]
            },
            {
              "name": "getUseCaches",
              "overloads": [
                {
                  "signature": "public boolean getUseCaches()",
                  "description": "Returns the value of this URLConnection's\n useCaches field."
                }
              ]
            },
            {
              "name": "setIfModifiedSince",
              "overloads": [
                {
                  "signature": "public void setIfModifiedSince(long ifmodifiedsince)",
                  "description": "Sets the value of the ifModifiedSince field of\n this URLConnection to the specified value."
                }
              ]
            },
            {
              "name": "getIfModifiedSince",
              "overloads": [
                {
                  "signature": "public long getIfModifiedSince()",
                  "description": "Returns the value of this object's ifModifiedSince field."
                }
              ]
            },
            {
              "name": "getDefaultUseCaches",
              "overloads": [
                {
                  "signature": "public boolean getDefaultUseCaches()",
                  "description": "Returns the default value of a URLConnection's\n useCaches flag.\n \n This default is \"sticky\", being a part of the static state of all\n URLConnections.  This flag applies to the next, and all following\n URLConnections that are created. This default value can be over-ridden\n per protocol using setDefaultUseCaches(String,boolean)"
                },
                {
                  "signature": "public static boolean getDefaultUseCaches(String protocol)",
                  "description": "Returns the default value of the useCaches flag for the given protocol. If\n setDefaultUseCaches(String,boolean) was called for the given protocol,\n then that value is returned. Otherwise, if setDefaultUseCaches(boolean)\n was called, then that value is returned. If neither method was called,\n the return value is true. The protocol name is case insensitive."
                }
              ]
            },
            {
              "name": "setDefaultUseCaches",
              "overloads": [
                {
                  "signature": "public void setDefaultUseCaches(boolean defaultusecaches)",
                  "description": "Sets the default value of the useCaches field to the\n specified value. This default value can be over-ridden\n per protocol using setDefaultUseCaches(String,boolean)"
                },
                {
                  "signature": "public static void setDefaultUseCaches(String protocol, boolean defaultVal)",
                  "description": "Sets the default value of the useCaches field for the named\n protocol to the given value. This value overrides any default setting\n set by setDefaultUseCaches(boolean) for the given protocol.\n Successive calls to this method change the setting and affect the\n default value for all future connections of that protocol. The protocol\n name is case insensitive."
                }
              ]
            },
            {
              "name": "setRequestProperty",
              "overloads": [
                {
                  "signature": "public void setRequestProperty(String key, String value)",
                  "description": "Sets the general request property. If a property with the key already\n exists, overwrite its value with the new value.\n\n  NOTE: HTTP requires all request properties which can\n legally have multiple instances with the same key\n to use a comma-separated list syntax which enables multiple\n properties to be appended into a single property."
                }
              ]
            },
            {
              "name": "addRequestProperty",
              "overloads": [
                {
                  "signature": "public void addRequestProperty(String key, String value)",
                  "description": "Adds a general request property specified by a\n key-value pair.  This method will not overwrite\n existing values associated with the same key."
                }
              ]
            },
            {
              "name": "getRequestProperty",
              "overloads": [
                {
                  "signature": "public String getRequestProperty(String key)",
                  "description": "Returns the value of the named general request property for this\n connection."
                }
              ]
            },
            {
              "name": "getRequestProperties",
              "overloads": [
                {
                  "signature": "public Map<String,List<String>> getRequestProperties()",
                  "description": "Returns an unmodifiable Map of general request\n properties for this connection. The Map keys\n are Strings that represent the request-header\n field names. Each Map value is a unmodifiable List\n of Strings that represents the corresponding\n field values."
                }
              ]
            },
            {
              "name": "setDefaultRequestProperty",
              "overloads": [
                {
                  "signature": "@Deprecated public static void setDefaultRequestProperty(String key, String value)",
                  "description": "Sets the default value of a general request property. When a\n URLConnection is created, it is initialized with\n these properties.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDefaultRequestProperty",
              "overloads": [
                {
                  "signature": "@Deprecated public static String getDefaultRequestProperty(String key)",
                  "description": "Returns the value of the default request property. Default request\n properties are set for every connection.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setContentHandlerFactory",
              "overloads": [
                {
                  "signature": "public static void setContentHandlerFactory(ContentHandlerFactory fac)",
                  "description": "Sets the ContentHandlerFactory of an\n application. It can be called at most once by an application.\n \n The ContentHandlerFactory instance is used to\n construct a content handler from a content type.\n \n If there is a security manager, this method first calls\n the security manager's checkSetFactory method\n to ensure the operation is allowed.\n This could result in a SecurityException."
                }
              ]
            },
            {
              "name": "guessContentTypeFromName",
              "overloads": [
                {
                  "signature": "public static String guessContentTypeFromName(String fname)",
                  "description": "Tries to determine the content type of an object, based\n on the specified \"file\" component of a URL.\n This is a convenience method that can be used by\n subclasses that override the getContentType method."
                }
              ]
            },
            {
              "name": "guessContentTypeFromStream",
              "overloads": [
                {
                  "signature": "public static String guessContentTypeFromStream(InputStream is) throws IOException",
                  "description": "Tries to determine the type of an input stream based on the\n characters at the beginning of the input stream. This method can\n be used by subclasses that override the\n getContentType method.\n \n Ideally, this routine would not be needed. But many\n http servers return the incorrect content type; in\n addition, there are many nonstandard extensions. Direct inspection\n of the bytes to determine the content type is often more accurate\n than believing the content type claimed by the http server."
                }
              ]
            }
          ]
        },
        {
          "name": "URLDecoder",
          "methods": [
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "@Deprecated public static String decode(String s)",
                  "description": "Decodes a x-www-form-urlencoded string.\n The platform's default encoding is used to determine what characters\n are represented by any consecutive sequences of the form\n \"%xy\".",
                  "deprecated": true
                },
                {
                  "signature": "public static String decode(String s, String enc) throws UnsupportedEncodingException",
                  "description": "Decodes an application/x-www-form-urlencoded string using\n a specific encoding scheme.\n\n \n This method behaves the same as decode(java.lang.String,java.nio.charset.Charset)\n except that it will look up the charset\n using the given encoding name."
                },
                {
                  "signature": "public static String decode(String s, Charset charset)",
                  "description": "Decodes an application/x-www-form-urlencoded string using\n a specific Charset.\n The supplied charset is used to determine\n what characters are represented by any consecutive sequences of the\n form \"%xy\".\n \n Note: The \n World Wide Web Consortium Recommendation states that\n UTF-8 should be used. Not doing so may introduce\n incompatibilities."
                }
              ]
            }
          ]
        },
        {
          "name": "URLEncoder",
          "methods": [
            {
              "name": "encode",
              "overloads": [
                {
                  "signature": "@Deprecated public static String encode(String s)",
                  "description": "Translates a string into x-www-form-urlencoded\n format. This method uses the platform's default encoding\n as the encoding scheme to obtain the bytes for unsafe characters.",
                  "deprecated": true
                },
                {
                  "signature": "public static String encode(String s, String enc) throws UnsupportedEncodingException",
                  "description": "Translates a string into application/x-www-form-urlencoded\n format using a specific encoding scheme.\n \n This method behaves the same as encode(String s, Charset charset)\n except that it will look up the charset\n using the given encoding name."
                },
                {
                  "signature": "public static String encode(String s, Charset charset)",
                  "description": "Translates a string into application/x-www-form-urlencoded\n format using a specific Charset.\n This method uses the supplied charset to obtain the bytes for unsafe\n characters.\n \n Note: The \n World Wide Web Consortium Recommendation states that\n UTF-8 should be used. Not doing so may introduce incompatibilities."
                }
              ]
            }
          ]
        },
        {
          "name": "URLPermission",
          "methods": [
            {
              "name": "URLPermission",
              "overloads": [
                {
                  "signature": "public URLPermission(String url, String actions)",
                  "description": "Creates a new URLPermission from a url string and which permits the given\n request methods and user-settable request headers.\n The name of the permission is the url string it was created with. Only the scheme,\n authority and path components of the url are used internally. Any fragment or query\n components are ignored. The permissions action string is as specified above."
                },
                {
                  "signature": "public URLPermission(String url)",
                  "description": "Creates a URLPermission with the given url string and unrestricted\n methods and request headers by invoking the two argument\n constructor as follows: URLPermission(url, \"*:*\")"
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the normalized method list and request\n header list, in the form:\n       \"method-names : header-names\"\n \n \n where method-names is the list of methods separated by commas\n and header-names is the list of permitted headers separated by commas.\n There is no white space in the returned String. If header-names is empty\n then the colon separator may not be present."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if this URLPermission implies the given permission.\n Specifically, the following checks are done as if in the\n following sequence:\n \n if 'p' is not an instance of URLPermission return false\n if any of p's methods are not in this's method list, and if\n     this's method list is not equal to \"*\", then return false.\n if any of p's headers are not in this's request header list, and if\n     this's request header list is not equal to \"*\", then return false.\n if this's url scheme is not equal to p's url scheme return false\n if the scheme specific part of this's url is '*' return true\n if the set of hosts defined by p's url hostrange is not a subset of\n     this's url hostrange then return false. For example, \"*.foo.example.com\"\n     is a subset of \"*.example.com\". \"foo.bar.example.com\" is not\n     a subset of \"*.foo.example.com\"\n if the portrange defined by p's url is not a subset of the\n     portrange defined by this's url then return false.\n if the path or paths specified by p's url are contained in the\n     set of paths specified by this's url, then return true\n otherwise, return false\n \n Some examples of how paths are matched are shown below:\n \n Examples of Path Matching\n \n this's pathp's pathmatch\n \n \n /a/b/a/byes\n /a/b/*/a/b/cyes\n   /a/b/c/dno\n   /a/b/c/-no\n /a/b/-/a/b/c/dyes\n   /a/b/c/d/eyes\n   /a/b/c/*yes"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object p)",
                  "description": "Returns true if, this.getActions().equals(p.getActions())\n and p's url equals this's url.  Returns false otherwise."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode calculated from the hashcode of the\n actions String and the url string."
                }
              ]
            }
          ]
        },
        {
          "name": "URLStreamHandler",
          "methods": [
            {
              "name": "URLStreamHandler",
              "overloads": [
                {
                  "signature": "public URLStreamHandler()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "openConnection",
              "overloads": [
                {
                  "signature": "protected abstract URLConnection openConnection(URL u) throws IOException",
                  "description": "Opens a connection to the object referenced by the\n URL argument.\n This method should be overridden by a subclass.\n\n If for the handler's protocol (such as HTTP or JAR), there\n exists a public, specialized URLConnection subclass belonging\n to one of the following packages or one of their subpackages:\n java.lang, java.io, java.util, java.net, the connection\n returned will be of that subclass. For example, for HTTP an\n HttpURLConnection will be returned, and for JAR a\n JarURLConnection will be returned."
                },
                {
                  "signature": "protected URLConnection openConnection(URL u, Proxy p) throws IOException",
                  "description": "Same as openConnection(URL), except that the connection will be\n made through the specified proxy; Protocol handlers that do not\n support proxying will ignore the proxy parameter and make a\n normal connection.\n\n  Calling this method preempts the system's default\n ProxySelector settings."
                }
              ]
            },
            {
              "name": "parseURL",
              "overloads": [
                {
                  "signature": "protected void parseURL(URL u, String spec, int start, int limit)",
                  "description": "Parses the string representation of a URL into a\n URL object.\n \n If there is any inherited context, then it has already been\n copied into the URL argument.\n \n The parseURL method of URLStreamHandler\n parses the string representation as if it were an\n http specification. Most URL protocol families have a\n similar parsing. A stream protocol handler for a protocol that has\n a different syntax must override this routine."
                }
              ]
            },
            {
              "name": "getDefaultPort",
              "overloads": [
                {
                  "signature": "protected int getDefaultPort()",
                  "description": "Returns the default port for a URL parsed by this handler. This method\n is meant to be overridden by handlers with default port numbers."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "protected boolean equals(URL u1, URL u2)",
                  "description": "Provides the default equals calculation. May be overridden by handlers\n for other protocols that have different requirements for equals().\n This method requires that none of its arguments is null. This is\n guaranteed by the fact that it is only called by java.net.URL class."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "protected int hashCode(URL u)",
                  "description": "Provides the default hash calculation. May be overridden by handlers for\n other protocols that have different requirements for hashCode\n calculation."
                }
              ]
            },
            {
              "name": "sameFile",
              "overloads": [
                {
                  "signature": "protected boolean sameFile(URL u1, URL u2)",
                  "description": "Compare two urls to see whether they refer to the same file,\n i.e., having the same protocol, host, port, and path.\n This method requires that none of its arguments is null. This is\n guaranteed by the fact that it is only called indirectly\n by java.net.URL class."
                }
              ]
            },
            {
              "name": "getHostAddress",
              "overloads": [
                {
                  "signature": "protected InetAddress getHostAddress(URL u)",
                  "description": "Get the IP address of our host. An empty host field or a DNS failure\n will result in a null return."
                }
              ]
            },
            {
              "name": "hostsEqual",
              "overloads": [
                {
                  "signature": "protected boolean hostsEqual(URL u1, URL u2)",
                  "description": "Compares the host components of two URLs."
                }
              ]
            },
            {
              "name": "toExternalForm",
              "overloads": [
                {
                  "signature": "protected String toExternalForm(URL u)",
                  "description": "Converts a URL of a specific protocol to a\n String."
                }
              ]
            },
            {
              "name": "setURL",
              "overloads": [
                {
                  "signature": "protected void setURL(URL u, String protocol, String host, int port, String authority, String userInfo, String path, String query, String ref)",
                  "description": "Sets the fields of the URL argument to the indicated values.\n Only classes derived from URLStreamHandler are able\n to use this method to set the values of the URL fields."
                },
                {
                  "signature": "@Deprecated protected void setURL(URL u, String protocol, String host, int port, String file, String ref)",
                  "description": "Sets the fields of the URL argument to the indicated values.\n Only classes derived from URLStreamHandler are able\n to use this method to set the values of the URL fields.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "URLStreamHandlerFactory",
          "methods": [
            {
              "name": "createURLStreamHandler",
              "overloads": [
                {
                  "signature": "URLStreamHandler createURLStreamHandler(String protocol)",
                  "description": "Creates a new URLStreamHandler instance with the specified\n protocol."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.nio",
      "description": "New I/O (NIO) classes",
      "classes": [
        {
          "name": "Buffer",
          "methods": [
            {
              "name": "capacity",
              "overloads": [
                {
                  "signature": "public final int capacity()",
                  "description": "Returns this buffer's capacity."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final int position()",
                  "description": "Returns this buffer's position."
                },
                {
                  "signature": "public Buffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final int limit()",
                  "description": "Returns this buffer's limit."
                },
                {
                  "signature": "public Buffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public Buffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public Buffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public Buffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public Buffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public Buffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "remaining",
              "overloads": [
                {
                  "signature": "public final int remaining()",
                  "description": "Returns the number of elements between the current position and the\n limit."
                }
              ]
            },
            {
              "name": "hasRemaining",
              "overloads": [
                {
                  "signature": "public final boolean hasRemaining()",
                  "description": "Tells whether there are any elements between the current position and\n the limit."
                }
              ]
            },
            {
              "name": "isReadOnly",
              "overloads": [
                {
                  "signature": "public abstract boolean isReadOnly()",
                  "description": "Tells whether or not this buffer is read-only."
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public abstract boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public abstract Object array()",
                  "description": "Returns the array that backs this\n buffer(optional operation).\n\n  This method is intended to allow array-backed buffers to be\n passed to native code more efficiently. Concrete subclasses\n provide more strongly-typed return values for this method.\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public abstract int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this buffer is\n direct."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract Buffer slice()",
                  "description": "Creates a new buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of elements remaining in this buffer, its mark will be\n undefined. The new buffer will be direct if, and only if, this buffer is\n direct, and it will be read-only if, and only if, this buffer is\n read-only."
                },
                {
                  "signature": "public abstract Buffer slice(int index, int length)",
                  "description": "Creates a new buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined. The new buffer will\n be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract Buffer duplicate()",
                  "description": "Creates a new buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position and mark values will be\n identical to those of this buffer. The new buffer will be direct if, and\n only if, this buffer is direct, and it will be read-only if, and only if,\n this buffer is read-only."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferOverflowException",
          "methods": [
            {
              "name": "BufferOverflowException",
              "overloads": [
                {
                  "signature": "public BufferOverflowException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "BufferUnderflowException",
          "methods": [
            {
              "name": "BufferUnderflowException",
              "overloads": [
                {
                  "signature": "public BufferUnderflowException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteBuffer",
          "methods": [
            {
              "name": "allocateDirect",
              "overloads": [
                {
                  "signature": "public static ByteBuffer allocateDirect(int capacity)",
                  "description": "Allocates a new direct byte buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n BIG_ENDIAN.  Whether or not it has a\n backing array is unspecified."
                }
              ]
            },
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static ByteBuffer allocate(int capacity)",
                  "description": "Allocates a new byte buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static ByteBuffer wrap(byte[] array, int offset, int length)",
                  "description": "Wraps a byte array into a buffer.\n\n  The new buffer will be backed by the given byte array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static ByteBuffer wrap(byte[] array)",
                  "description": "Wraps a byte array into a buffer.\n\n  The new buffer will be backed by the given byte array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer slice()",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract ByteBuffer slice(int index, int length)",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer duplicate()",
                  "description": "Creates a new byte buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only byte buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract byte get()",
                  "description": "Relative get method.  Reads the byte at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract byte get(int index)",
                  "description": "Absolute get method.  Reads the byte at the given\n index."
                },
                {
                  "signature": "public ByteBuffer get(byte[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  If there are fewer bytes remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n bytes are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length bytes from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient bytes in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public ByteBuffer get(byte[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public ByteBuffer get(int index, byte[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length bytes from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public ByteBuffer get(int index, byte[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers bytes from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer put(byte b)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given byte into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract ByteBuffer put(int index, byte b)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given byte into this buffer at the given\n index."
                },
                {
                  "signature": "public ByteBuffer put(ByteBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the bytes remaining in the given source\n buffer into this buffer.  If there are more bytes remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no bytes are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() bytes from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length bytes into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ByteBuffer put(byte[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers bytes into this buffer from the given\n source array.  If there are more bytes to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n bytes are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length bytes from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final ByteBuffer put(byte[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n byte array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public ByteBuffer put(int index, byte[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length bytes from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public ByteBuffer put(int index, byte[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies bytes into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible byte\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final byte[] array()",
                  "description": "Returns the byte array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public ByteBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public ByteBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public ByteBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public ByteBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public ByteBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public ByteBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public ByteBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The bytes between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n byte at index p=position() is copied\n to index zero, the byte at index p+1 is copied\n to index one, and so forth until the byte at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of bytes copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method. \n\n\n\n  Invoke this method after writing data from a buffer in case the\n write was incomplete.  The following loop, for example, copies bytes\n from one channel to another via the buffer buf:\n\n \n   buf.clear();          // Prepare buffer for use\n   while (in.read(buf) >= 0 || buf.position != 0) {\n       buf.flip();\n       out.write(buf);\n       buf.compact();    // In case of partial write\n   }"
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this byte buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a byte buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two byte buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A byte buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ByteBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two byte buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of byte elements are compared as if by invoking\n Byte.compare(byte,byte).\n\n\n  A byte buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(ByteBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public final ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order is used when reading or writing multibyte values, and\n when creating buffers that are views of this byte buffer.  The order of\n a newly-created byte buffer is always BIG_ENDIAN."
                },
                {
                  "signature": "public final ByteBuffer order(ByteOrder bo)",
                  "description": "Modifies this buffer's byte order."
                }
              ]
            },
            {
              "name": "alignmentOffset",
              "overloads": [
                {
                  "signature": "public final int alignmentOffset(int index, int unitSize)",
                  "description": "Returns the memory address, pointing to the byte at the given index,\n modulo the given unit size.\n\n  The return value is non-negative in the range of 0\n (inclusive) up to unitSize (exclusive), with zero indicating\n that the address of the byte at the index is aligned for the unit size,\n and a positive value that the address is misaligned for the unit size.\n If the address of the byte at the index is misaligned, the return value\n represents how much the index should be adjusted to locate a byte at an\n aligned address.  Specifically, the index should either be decremented by\n the return value if the latter is not greater than index, or be\n incremented by the unit size minus the return value.  Therefore given\n  int value = alignmentOffset(index, unitSize)\n then the identities\n  alignmentOffset(index - value, unitSize) == 0, value  index\n and\n  alignmentOffset(index + (unitSize - value), unitSize) == 0\n must hold."
                }
              ]
            },
            {
              "name": "alignedSlice",
              "overloads": [
                {
                  "signature": "public final ByteBuffer alignedSlice(int unitSize)",
                  "description": "Creates a new byte buffer whose content is a shared and aligned\n subsequence of this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position rounded up to the index of the nearest aligned byte for the\n given unit size, and end at this buffer's limit rounded down to the index\n of the nearest aligned byte for the given unit size.\n If rounding results in out-of-bound values then the new buffer's capacity\n and limit will be zero.  If rounding is within bounds the following\n expressions will be true for a new buffer nb and unit size\n unitSize:\n \n nb.alignmentOffset(0, unitSize) == 0\n nb.alignmentOffset(nb.limit(), unitSize) == 0\n \n\n  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer or fewer subject to\n alignment, its mark will be undefined, and its byte order will be\n BIG_ENDIAN.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getChar",
              "overloads": [
                {
                  "signature": "public abstract char getChar()",
                  "description": "Relative get method for reading a char value.\n\n  Reads the next two bytes at this buffer's current position,\n composing them into a char value according to the current byte order,\n and then increments the position by two."
                },
                {
                  "signature": "public abstract char getChar(int index)",
                  "description": "Absolute get method for reading a char value.\n\n  Reads two bytes at the given index, composing them into a\n char value according to the current byte order."
                }
              ]
            },
            {
              "name": "putChar",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putChar(char value)",
                  "description": "Relative put method for writing a char\n value(optional operation).\n\n  Writes two bytes containing the given char value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by two."
                },
                {
                  "signature": "public abstract ByteBuffer putChar(int index, char value)",
                  "description": "Absolute put method for writing a char\n value(optional operation).\n\n  Writes two bytes containing the given char value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asCharBuffer",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer asCharBuffer()",
                  "description": "Creates a view of this byte buffer as a char buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n two, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getShort",
              "overloads": [
                {
                  "signature": "public abstract short getShort()",
                  "description": "Relative get method for reading a short value.\n\n  Reads the next two bytes at this buffer's current position,\n composing them into a short value according to the current byte order,\n and then increments the position by two."
                },
                {
                  "signature": "public abstract short getShort(int index)",
                  "description": "Absolute get method for reading a short value.\n\n  Reads two bytes at the given index, composing them into a\n short value according to the current byte order."
                }
              ]
            },
            {
              "name": "putShort",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putShort(short value)",
                  "description": "Relative put method for writing a short\n value(optional operation).\n\n  Writes two bytes containing the given short value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by two."
                },
                {
                  "signature": "public abstract ByteBuffer putShort(int index, short value)",
                  "description": "Absolute put method for writing a short\n value(optional operation).\n\n  Writes two bytes containing the given short value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asShortBuffer",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer asShortBuffer()",
                  "description": "Creates a view of this byte buffer as a short buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n two, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getInt",
              "overloads": [
                {
                  "signature": "public abstract int getInt()",
                  "description": "Relative get method for reading an int value.\n\n  Reads the next four bytes at this buffer's current position,\n composing them into an int value according to the current byte order,\n and then increments the position by four."
                },
                {
                  "signature": "public abstract int getInt(int index)",
                  "description": "Absolute get method for reading an int value.\n\n  Reads four bytes at the given index, composing them into a\n int value according to the current byte order."
                }
              ]
            },
            {
              "name": "putInt",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putInt(int value)",
                  "description": "Relative put method for writing an int\n value(optional operation).\n\n  Writes four bytes containing the given int value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by four."
                },
                {
                  "signature": "public abstract ByteBuffer putInt(int index, int value)",
                  "description": "Absolute put method for writing an int\n value(optional operation).\n\n  Writes four bytes containing the given int value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asIntBuffer",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer asIntBuffer()",
                  "description": "Creates a view of this byte buffer as an int buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n four, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public abstract long getLong()",
                  "description": "Relative get method for reading a long value.\n\n  Reads the next eight bytes at this buffer's current position,\n composing them into a long value according to the current byte order,\n and then increments the position by eight."
                },
                {
                  "signature": "public abstract long getLong(int index)",
                  "description": "Absolute get method for reading a long value.\n\n  Reads eight bytes at the given index, composing them into a\n long value according to the current byte order."
                }
              ]
            },
            {
              "name": "putLong",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putLong(long value)",
                  "description": "Relative put method for writing a long\n value(optional operation).\n\n  Writes eight bytes containing the given long value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by eight."
                },
                {
                  "signature": "public abstract ByteBuffer putLong(int index, long value)",
                  "description": "Absolute put method for writing a long\n value(optional operation).\n\n  Writes eight bytes containing the given long value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asLongBuffer",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer asLongBuffer()",
                  "description": "Creates a view of this byte buffer as a long buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n eight, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getFloat",
              "overloads": [
                {
                  "signature": "public abstract float getFloat()",
                  "description": "Relative get method for reading a float value.\n\n  Reads the next four bytes at this buffer's current position,\n composing them into a float value according to the current byte order,\n and then increments the position by four."
                },
                {
                  "signature": "public abstract float getFloat(int index)",
                  "description": "Absolute get method for reading a float value.\n\n  Reads four bytes at the given index, composing them into a\n float value according to the current byte order."
                }
              ]
            },
            {
              "name": "putFloat",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putFloat(float value)",
                  "description": "Relative put method for writing a float\n value(optional operation).\n\n  Writes four bytes containing the given float value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by four."
                },
                {
                  "signature": "public abstract ByteBuffer putFloat(int index, float value)",
                  "description": "Absolute put method for writing a float\n value(optional operation).\n\n  Writes four bytes containing the given float value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asFloatBuffer",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer asFloatBuffer()",
                  "description": "Creates a view of this byte buffer as a float buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n four, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "getDouble",
              "overloads": [
                {
                  "signature": "public abstract double getDouble()",
                  "description": "Relative get method for reading a double value.\n\n  Reads the next eight bytes at this buffer's current position,\n composing them into a double value according to the current byte order,\n and then increments the position by eight."
                },
                {
                  "signature": "public abstract double getDouble(int index)",
                  "description": "Absolute get method for reading a double value.\n\n  Reads eight bytes at the given index, composing them into a\n double value according to the current byte order."
                }
              ]
            },
            {
              "name": "putDouble",
              "overloads": [
                {
                  "signature": "public abstract ByteBuffer putDouble(double value)",
                  "description": "Relative put method for writing a double\n value(optional operation).\n\n  Writes eight bytes containing the given double value, in the\n current byte order, into this buffer at the current position, and then\n increments the position by eight."
                },
                {
                  "signature": "public abstract ByteBuffer putDouble(int index, double value)",
                  "description": "Absolute put method for writing a double\n value(optional operation).\n\n  Writes eight bytes containing the given double value, in the\n current byte order, into this buffer at the given index."
                }
              ]
            },
            {
              "name": "asDoubleBuffer",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer asDoubleBuffer()",
                  "description": "Creates a view of this byte buffer as a double buffer.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer divided by\n eight, its mark will be undefined, and its byte order will be that\n of the byte buffer at the moment the view is created.  The new buffer\n will be direct if, and only if, this buffer is direct, and it will be\n read-only if, and only if, this buffer is read-only."
                }
              ]
            }
          ]
        },
        {
          "name": "ByteOrder",
          "methods": [
            {
              "name": "nativeOrder",
              "overloads": [
                {
                  "signature": "public static ByteOrder nativeOrder()",
                  "description": "Retrieves the native byte order of the underlying platform.\n\n  This method is defined so that performance-sensitive Java code can\n allocate direct buffers with the same byte order as the hardware.\n Native code libraries are often more efficient when such buffers are\n used."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Constructs a string describing this object.\n\n  This method returns the string\n \"BIG_ENDIAN\" for BIG_ENDIAN and\n \"LITTLE_ENDIAN\" for LITTLE_ENDIAN."
                }
              ]
            }
          ]
        },
        {
          "name": "CharBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static CharBuffer allocate(int capacity)",
                  "description": "Allocates a new char buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static CharBuffer wrap(char[] array, int offset, int length)",
                  "description": "Wraps a char array into a buffer.\n\n  The new buffer will be backed by the given char array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static CharBuffer wrap(char[] array)",
                  "description": "Wraps a char array into a buffer.\n\n  The new buffer will be backed by the given char array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                },
                {
                  "signature": "public static CharBuffer wrap(CharSequence csq, int start, int end)",
                  "description": "Wraps a character sequence into a buffer.\n\n  The content of the new, read-only buffer will be the content of the\n given character sequence.  The buffer's capacity will be\n csq.length(), its position will be start, its limit\n will be end, and its mark will be undefined."
                },
                {
                  "signature": "public static CharBuffer wrap(CharSequence csq)",
                  "description": "Wraps a character sequence into a buffer.\n\n  The content of the new, read-only buffer will be the content of the\n given character sequence.  The new buffer's capacity and limit will be\n csq.length(), its position will be zero, and its mark will be\n undefined."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read(CharBuffer target) throws IOException",
                  "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer slice()",
                  "description": "Creates a new char buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of chars remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract CharBuffer slice(int index, int length)",
                  "description": "Creates a new char buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer duplicate()",
                  "description": "Creates a new char buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only char buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract char get()",
                  "description": "Relative get method.  Reads the char at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract char get(int index)",
                  "description": "Absolute get method.  Reads the char at the given\n index."
                },
                {
                  "signature": "public CharBuffer get(char[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  If there are fewer chars remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n chars are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length chars from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient chars in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public CharBuffer get(char[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public CharBuffer get(int index, char[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length chars from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public CharBuffer get(int index, char[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers chars from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer put(char c)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given char into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract CharBuffer put(int index, char c)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given char into this buffer at the given\n index."
                },
                {
                  "signature": "public CharBuffer put(CharBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the chars remaining in the given source\n buffer into this buffer.  If there are more chars remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no chars are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() chars from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public CharBuffer put(int index, CharBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length chars into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public CharBuffer put(char[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers chars into this buffer from the given\n source array.  If there are more chars to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n chars are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length chars from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final CharBuffer put(char[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n char array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public CharBuffer put(int index, char[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length chars from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public CharBuffer put(int index, char[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies chars into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                },
                {
                  "signature": "public CharBuffer put(String src, int start, int end)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers chars from the given string into this\n buffer.  If there are more chars to be copied from the string than\n remain in this buffer, that is, if\n end-start>remaining(),\n then no chars are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=end-start chars\n from the given string into this buffer, starting at the given\n start index and at the current position of this buffer.  The\n position of this buffer is then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src,start,end) has exactly the same effect\n as the loop\n\n \n     for (int i = start; i < end; i++)\n         dst.put(src.charAt(i));\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final CharBuffer put(String src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source string\n into this buffer.  An invocation of this method of the form\n dst.put(s) behaves in exactly the same way as the invocation\n\n      dst.put(s, 0, s.length())"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible char\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final char[] array()",
                  "description": "Returns the char array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final CharBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final CharBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final CharBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final CharBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final CharBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final CharBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final CharBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The chars between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n char at index p=position() is copied\n to index zero, the char at index p+1 is copied\n to index one, and so forth until the char at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of chars copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this char buffer is direct."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a char buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two char buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A char buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(CharBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two char buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of char elements are compared as if by invoking\n Character.compare(char,char).\n\n\n  A char buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(CharBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string containing the characters in this buffer.\n\n  The first character of the resulting string will be the character at\n this buffer's position, while the last character will be the character\n at index limit()-1.  Invoking this method does not\n change the buffer's position."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public final int length()",
                  "description": "Returns the length of this character buffer.\n\n  When viewed as a character sequence, the length of a character\n buffer is simply the number of characters between the position\n (inclusive) and the limit (exclusive); that is, it is equivalent to\n remaining()."
                }
              ]
            },
            {
              "name": "isEmpty",
              "overloads": [
                {
                  "signature": "public final boolean isEmpty()",
                  "description": "Returns true if this character buffer is empty."
                }
              ]
            },
            {
              "name": "charAt",
              "overloads": [
                {
                  "signature": "public final char charAt(int index)",
                  "description": "Reads the character at the given index relative to the current\n position."
                }
              ]
            },
            {
              "name": "subSequence",
              "overloads": [
                {
                  "signature": "public abstract CharBuffer subSequence(int start, int end)",
                  "description": "Creates a new character buffer that represents the specified subsequence\n of this buffer, relative to the current position.\n\n  The new buffer will share this buffer's content; that is, if the\n content of this buffer is mutable then modifications to one buffer will\n cause the other to be modified.  The new buffer's capacity will be that\n of this buffer, its position will be\n position()+start, its limit will be\n position()+end, and its byte order\n will be identical to that of this buffer. The new buffer will be direct\n if, and only if, this buffer is direct, and it will be read-only\n if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "append",
              "overloads": [
                {
                  "signature": "public CharBuffer append(CharSequence csq)",
                  "description": "Appends the specified character sequence  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(csq)\n behaves in exactly the same way as the invocation\n\n      dst.put(csq.toString()) \n\n  Depending on the specification of toString for the\n character sequence csq, the entire sequence may not be\n appended.  For instance, invoking the toString method of a character buffer will return a subsequence whose\n content depends upon the buffer's position and limit."
                },
                {
                  "signature": "public CharBuffer append(CharSequence csq, int start, int end)",
                  "description": "Appends a subsequence of the  specified character sequence  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(csq, start,\n end) when csq is not null, behaves in exactly the\n same way as the invocation\n\n      dst.put(csq.subSequence(start, end).toString())"
                },
                {
                  "signature": "public CharBuffer append(char c)",
                  "description": "Appends the specified char  to this\n buffer(optional operation).\n\n  An invocation of this method of the form dst.append(c)\n behaves in exactly the same way as the invocation\n\n      dst.put(c)"
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a char buffer created by allocation or by\n wrapping an existing char array is the native order of the underlying\n hardware.  The byte order of a char buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "DoubleBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static DoubleBuffer allocate(int capacity)",
                  "description": "Allocates a new double buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static DoubleBuffer wrap(double[] array, int offset, int length)",
                  "description": "Wraps a double array into a buffer.\n\n  The new buffer will be backed by the given double array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static DoubleBuffer wrap(double[] array)",
                  "description": "Wraps a double array into a buffer.\n\n  The new buffer will be backed by the given double array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer slice()",
                  "description": "Creates a new double buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of doubles remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract DoubleBuffer slice(int index, int length)",
                  "description": "Creates a new double buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer duplicate()",
                  "description": "Creates a new double buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only double buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract double get()",
                  "description": "Relative get method.  Reads the double at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract double get(int index)",
                  "description": "Absolute get method.  Reads the double at the given\n index."
                },
                {
                  "signature": "public DoubleBuffer get(double[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  If there are fewer doubles remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n doubles are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length doubles from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient doubles in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public DoubleBuffer get(double[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public DoubleBuffer get(int index, double[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length doubles from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public DoubleBuffer get(int index, double[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers doubles from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer put(double d)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given double into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract DoubleBuffer put(int index, double d)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given double into this buffer at the given\n index."
                },
                {
                  "signature": "public DoubleBuffer put(DoubleBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the doubles remaining in the given source\n buffer into this buffer.  If there are more doubles remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no doubles are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() doubles from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public DoubleBuffer put(int index, DoubleBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length doubles into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public DoubleBuffer put(double[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers doubles into this buffer from the given\n source array.  If there are more doubles to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n doubles are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length doubles from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final DoubleBuffer put(double[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n double array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public DoubleBuffer put(int index, double[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length doubles from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public DoubleBuffer put(int index, double[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies doubles into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible double\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final double[] array()",
                  "description": "Returns the double array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final DoubleBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract DoubleBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The doubles between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n double at index p=position() is copied\n to index zero, the double at index p+1 is copied\n to index one, and so forth until the double at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of doubles copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this double buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a double buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two double buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n   This method considers two double elements a and b\n   to be equal if\n   (a == b) || (Double.isNaN(a) && Double.isNaN(b)).\n   The values -0.0 and +0.0 are considered to be\n   equal, unlike Double.equals(Object).\n\n   \n\n \n\n  A double buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(DoubleBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two double buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n Pairs of double elements are compared as if by invoking\n Double.compare(double,double), except that\n -0.0 and 0.0 are considered to be equal.\n Double.NaN is considered by this method to be equal\n to itself and greater than all other double values\n (including Double.POSITIVE_INFINITY).\n\n\n\n\n\n  A double buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(DoubleBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a double buffer created by allocation or by\n wrapping an existing double array is the native order of the underlying\n hardware.  The byte order of a double buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "FloatBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static FloatBuffer allocate(int capacity)",
                  "description": "Allocates a new float buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static FloatBuffer wrap(float[] array, int offset, int length)",
                  "description": "Wraps a float array into a buffer.\n\n  The new buffer will be backed by the given float array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static FloatBuffer wrap(float[] array)",
                  "description": "Wraps a float array into a buffer.\n\n  The new buffer will be backed by the given float array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer slice()",
                  "description": "Creates a new float buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of floats remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract FloatBuffer slice(int index, int length)",
                  "description": "Creates a new float buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer duplicate()",
                  "description": "Creates a new float buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only float buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract float get()",
                  "description": "Relative get method.  Reads the float at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract float get(int index)",
                  "description": "Absolute get method.  Reads the float at the given\n index."
                },
                {
                  "signature": "public FloatBuffer get(float[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  If there are fewer floats remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n floats are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length floats from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient floats in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public FloatBuffer get(float[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public FloatBuffer get(int index, float[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length floats from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public FloatBuffer get(int index, float[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers floats from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer put(float f)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given float into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract FloatBuffer put(int index, float f)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given float into this buffer at the given\n index."
                },
                {
                  "signature": "public FloatBuffer put(FloatBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the floats remaining in the given source\n buffer into this buffer.  If there are more floats remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no floats are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() floats from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public FloatBuffer put(int index, FloatBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length floats into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public FloatBuffer put(float[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers floats into this buffer from the given\n source array.  If there are more floats to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n floats are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length floats from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final FloatBuffer put(float[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n float array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public FloatBuffer put(int index, float[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length floats from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public FloatBuffer put(int index, float[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies floats into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible float\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final float[] array()",
                  "description": "Returns the float array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final FloatBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final FloatBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final FloatBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final FloatBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final FloatBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final FloatBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final FloatBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract FloatBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The floats between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n float at index p=position() is copied\n to index zero, the float at index p+1 is copied\n to index one, and so forth until the float at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of floats copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this float buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a float buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two float buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n   This method considers two float elements a and b\n   to be equal if\n   (a == b) || (Float.isNaN(a) && Float.isNaN(b)).\n   The values -0.0 and +0.0 are considered to be\n   equal, unlike Float.equals(Object).\n\n   \n\n \n\n  A float buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(FloatBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two float buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n Pairs of float elements are compared as if by invoking\n Float.compare(float,float), except that\n -0.0 and 0.0 are considered to be equal.\n Float.NaN is considered by this method to be equal\n to itself and greater than all other float values\n (including Float.POSITIVE_INFINITY).\n\n\n\n\n\n  A float buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(FloatBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a float buffer created by allocation or by\n wrapping an existing float array is the native order of the underlying\n hardware.  The byte order of a float buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "IntBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static IntBuffer allocate(int capacity)",
                  "description": "Allocates a new int buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static IntBuffer wrap(int[] array, int offset, int length)",
                  "description": "Wraps an int array into a buffer.\n\n  The new buffer will be backed by the given int array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static IntBuffer wrap(int[] array)",
                  "description": "Wraps an int array into a buffer.\n\n  The new buffer will be backed by the given int array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer slice()",
                  "description": "Creates a new int buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of ints remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract IntBuffer slice(int index, int length)",
                  "description": "Creates a new int buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer duplicate()",
                  "description": "Creates a new int buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only int buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract int get()",
                  "description": "Relative get method.  Reads the int at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract int get(int index)",
                  "description": "Absolute get method.  Reads the int at the given\n index."
                },
                {
                  "signature": "public IntBuffer get(int[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  If there are fewer ints remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n ints are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length ints from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient ints in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public IntBuffer get(int[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public IntBuffer get(int index, int[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length ints from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public IntBuffer get(int index, int[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers ints from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer put(int i)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given int into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract IntBuffer put(int index, int i)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given int into this buffer at the given\n index."
                },
                {
                  "signature": "public IntBuffer put(IntBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the ints remaining in the given source\n buffer into this buffer.  If there are more ints remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no ints are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() ints from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public IntBuffer put(int index, IntBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length ints into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public IntBuffer put(int[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers ints into this buffer from the given\n source array.  If there are more ints to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n ints are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length ints from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final IntBuffer put(int[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n int array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public IntBuffer put(int index, int[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length ints from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public IntBuffer put(int index, int[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies ints into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible int\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final int[] array()",
                  "description": "Returns the int array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final IntBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final IntBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final IntBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final IntBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final IntBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final IntBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final IntBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract IntBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The ints between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n int at index p=position() is copied\n to index zero, the int at index p+1 is copied\n to index one, and so forth until the int at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of ints copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this int buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a int buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two int buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A int buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(IntBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two int buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of int elements are compared as if by invoking\n Integer.compare(int,int).\n\n\n  A int buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(IntBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of an int buffer created by allocation or by\n wrapping an existing int array is the native order of the underlying\n hardware.  The byte order of an int buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidMarkException",
          "methods": [
            {
              "name": "InvalidMarkException",
              "overloads": [
                {
                  "signature": "public InvalidMarkException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "LongBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static LongBuffer allocate(int capacity)",
                  "description": "Allocates a new long buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static LongBuffer wrap(long[] array, int offset, int length)",
                  "description": "Wraps a long array into a buffer.\n\n  The new buffer will be backed by the given long array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static LongBuffer wrap(long[] array)",
                  "description": "Wraps a long array into a buffer.\n\n  The new buffer will be backed by the given long array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer slice()",
                  "description": "Creates a new long buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of longs remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract LongBuffer slice(int index, int length)",
                  "description": "Creates a new long buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer duplicate()",
                  "description": "Creates a new long buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only long buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract long get()",
                  "description": "Relative get method.  Reads the long at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract long get(int index)",
                  "description": "Absolute get method.  Reads the long at the given\n index."
                },
                {
                  "signature": "public LongBuffer get(long[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  If there are fewer longs remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n longs are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length longs from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient longs in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public LongBuffer get(long[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public LongBuffer get(int index, long[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length longs from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public LongBuffer get(int index, long[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers longs from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer put(long l)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given long into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract LongBuffer put(int index, long l)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given long into this buffer at the given\n index."
                },
                {
                  "signature": "public LongBuffer put(LongBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the longs remaining in the given source\n buffer into this buffer.  If there are more longs remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no longs are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() longs from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public LongBuffer put(int index, LongBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length longs into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public LongBuffer put(long[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers longs into this buffer from the given\n source array.  If there are more longs to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n longs are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length longs from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final LongBuffer put(long[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n long array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public LongBuffer put(int index, long[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length longs from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public LongBuffer put(int index, long[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies longs into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible long\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final long[] array()",
                  "description": "Returns the long array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final LongBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final LongBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final LongBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final LongBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final LongBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final LongBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final LongBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract LongBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The longs between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n long at index p=position() is copied\n to index zero, the long at index p+1 is copied\n to index one, and so forth until the long at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of longs copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this long buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a long buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two long buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A long buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(LongBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two long buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of long elements are compared as if by invoking\n Long.compare(long,long).\n\n\n  A long buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(LongBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a long buffer created by allocation or by\n wrapping an existing long array is the native order of the underlying\n hardware.  The byte order of a long buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        },
        {
          "name": "MappedByteBuffer",
          "methods": [
            {
              "name": "isLoaded",
              "overloads": [
                {
                  "signature": "public final boolean isLoaded()",
                  "description": "Tells whether or not this buffer's content is resident in physical\n memory.\n\n  A return value of true implies that it is highly likely\n that all of the data in this buffer is resident in physical memory and\n may therefore be accessed without incurring any virtual-memory page\n faults or I/O operations.  A return value of false does not\n necessarily imply that the buffer's content is not resident in physical\n memory.\n\n  The returned value is a hint, rather than a guarantee, because the\n underlying operating system may have paged out some of the buffer's data\n by the time that an invocation of this method returns."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer load()",
                  "description": "Loads this buffer's content into physical memory.\n\n  This method makes a best effort to ensure that, when it returns,\n this buffer's content is resident in physical memory.  Invoking this\n method may cause some number of page faults and I/O operations to\n occur."
                }
              ]
            },
            {
              "name": "force",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer force()",
                  "description": "Forces any changes made to this buffer's content to be written to the\n storage device containing the mapped file.  The region starts at index\n zero in this buffer and is capacity() bytes.  An invocation of\n this method behaves in exactly the same way as the invocation\n force(0,capacity()).\n\n  If the file mapped into this buffer resides on a local storage\n device then when this method returns it is guaranteed that all changes\n made to the buffer since it was created, or since this method was last\n invoked, will have been written to that device.\n\n  If the file does not reside on a local device then no such guarantee\n is made.\n\n  If this buffer was not mapped in read/write mode (FileChannel.MapMode.READ_WRITE) then\n invoking this method may have no effect. In particular, the\n method has no effect for buffers mapped in read-only or private\n mapping modes. This method may or may not have an effect for\n implementation-specific mapping modes."
                },
                {
                  "signature": "public final MappedByteBuffer force(int index, int length)",
                  "description": "Forces any changes made to a region of this buffer's content to\n be written to the storage device containing the mapped\n file. The region starts at the given index in this\n buffer and is length bytes.\n\n  If the file mapped into this buffer resides on a local\n storage device then when this method returns it is guaranteed\n that all changes made to the selected region buffer since it\n was created, or since this method was last invoked, will have\n been written to that device. The force operation is free to\n write bytes that lie outside the specified region, for example\n to ensure that data blocks of some device-specific granularity\n are transferred in their entirety.\n\n  If the file does not reside on a local device then no such\n guarantee is made.\n\n  If this buffer was not mapped in read/write mode (FileChannel.MapMode.READ_WRITE) then\n invoking this method may have no effect. In particular, the\n method has no effect for buffers mapped in read-only or private\n mapping modes. This method may or may not have an effect for\n implementation-specific mapping modes."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final MappedByteBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer slice()",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of bytes remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only.  \n\n  Reading bytes into physical memory by invoking load() on the\n returned buffer, or writing bytes to the storage device by invoking\n force() on the returned buffer, will only act on the sub-range\n of this buffer that the returned buffer represents, namely\n [position(),limit())."
                },
                {
                  "signature": "public abstract MappedByteBuffer slice(int index, int length)",
                  "description": "Creates a new byte buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only. \n\n  Reading bytes into physical memory by invoking load() on the\n returned buffer, or writing bytes to the storage device by invoking\n force() on the returned buffer, will only act on the sub-range\n of this buffer that the returned buffer represents, namely\n [index,index+length), where index and length are\n assumed to satisfy the preconditions."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer duplicate()",
                  "description": "Creates a new byte buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n and mark values will be identical to those of this buffer, and its byte\n order will be BIG_ENDIAN.\n\n\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract MappedByteBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The bytes between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n byte at index p=position() is copied\n to index zero, the byte at index p+1 is copied\n to index one, and so forth until the byte at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of bytes copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method. \n\n\n\n  Invoke this method after writing data from a buffer in case the\n write was incomplete.  The following loop, for example, copies bytes\n from one channel to another via the buffer buf:\n\n \n   buf.clear();          // Prepare buffer for use\n   while (in.read(buf) >= 0 || buf.position != 0) {\n       buf.flip();\n       out.write(buf);\n       buf.compact();    // In case of partial write\n   }"
                }
              ]
            }
          ]
        },
        {
          "name": "ReadOnlyBufferException",
          "methods": [
            {
              "name": "ReadOnlyBufferException",
              "overloads": [
                {
                  "signature": "public ReadOnlyBufferException()",
                  "description": "Constructs an instance of this class."
                }
              ]
            }
          ]
        },
        {
          "name": "ShortBuffer",
          "methods": [
            {
              "name": "allocate",
              "overloads": [
                {
                  "signature": "public static ShortBuffer allocate(int capacity)",
                  "description": "Allocates a new short buffer.\n\n  The new buffer's position will be zero, its limit will be its\n capacity, its mark will be undefined, each of its elements will be\n initialized to zero, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n It will have a backing array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "wrap",
              "overloads": [
                {
                  "signature": "public static ShortBuffer wrap(short[] array, int offset, int length)",
                  "description": "Wraps a short array into a buffer.\n\n  The new buffer will be backed by the given short array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity will be\n array.length, its position will be offset, its limit\n will be offset + length, its mark will be undefined, and its\n byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and\n its array offset will be zero."
                },
                {
                  "signature": "public static ShortBuffer wrap(short[] array)",
                  "description": "Wraps a short array into a buffer.\n\n  The new buffer will be backed by the given short array;\n that is, modifications to the buffer will cause the array to be modified\n and vice versa.  The new buffer's capacity and limit will be\n array.length, its position will be zero, its mark will be\n undefined, and its byte order will be\n\n\n\n the native order of the underlying\n hardware.\n\n Its backing array will be the given array, and its\n array offset will be zero."
                }
              ]
            },
            {
              "name": "slice",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer slice()",
                  "description": "Creates a new short buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of shorts remaining in this buffer, its mark will be\n undefined, and its byte order will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                },
                {
                  "signature": "public abstract ShortBuffer slice(int index, int length)",
                  "description": "Creates a new short buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at position index\n in this buffer, and will contain length elements. Changes to\n this buffer's content will be visible in the new buffer, and vice versa;\n the two buffers' position, limit, and mark values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be length, its mark will be undefined, and its byte order\n will be\n\n\n\n identical to that of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct,\n and it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "duplicate",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer duplicate()",
                  "description": "Creates a new short buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n The new buffer will be direct if, and only if, this buffer is direct, and\n it will be read-only if, and only if, this buffer is read-only."
                }
              ]
            },
            {
              "name": "asReadOnlyBuffer",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer asReadOnlyBuffer()",
                  "description": "Creates a new, read-only short buffer that shares this buffer's\n content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer; the new\n buffer itself, however, will be read-only and will not allow the shared\n content to be modified.  The two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's capacity, limit, position,\n\n\n\n\n mark values, and byte order will be identical to those of this buffer.\n\n\n  If this buffer is itself read-only then this method behaves in\n exactly the same way as the duplicate method."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public abstract short get()",
                  "description": "Relative get method.  Reads the short at this buffer's\n current position, and then increments the position."
                },
                {
                  "signature": "public abstract short get(int index)",
                  "description": "Absolute get method.  Reads the short at the given\n index."
                },
                {
                  "signature": "public ShortBuffer get(short[] dst, int offset, int length)",
                  "description": "Relative bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  If there are fewer shorts remaining in the\n buffer than are required to satisfy the request, that is, if\n length>remaining(), then no\n shorts are transferred and a BufferUnderflowException is\n thrown.\n\n  Otherwise, this method copies length shorts from this\n buffer into the given array, starting at the current position of this\n buffer and at the given offset in the array.  The position of this\n buffer is then incremented by length.\n\n  In other words, an invocation of this method of the form\n src.get(dst,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst[i] = src.get();\n \n\n except that it first checks that there are sufficient shorts in\n this buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public ShortBuffer get(short[] dst)",
                  "description": "Relative bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  An invocation of this method of the form\n src.get(a) behaves in exactly the same way as the invocation\n\n      src.get(a, 0, a.length)"
                },
                {
                  "signature": "public ShortBuffer get(int index, short[] dst, int offset, int length)",
                  "description": "Absolute bulk get method.\n\n  This method transfers length shorts from this\n buffer into the given array, starting at the given index in this\n buffer and at the given offset in the array.  The position of this\n buffer is unchanged.\n\n  An invocation of this method of the form\n src.get(index,dst,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst[i] = src.get(j);"
                },
                {
                  "signature": "public ShortBuffer get(int index, short[] dst)",
                  "description": "Absolute bulk get method.\n\n  This method transfers shorts from this buffer into the given\n destination array.  The position of this buffer is unchanged.  An\n invocation of this method of the form\n src.get(index,dst) behaves in exactly the same\n way as the invocation:\n\n      src.get(index, dst, 0, dst.length)"
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer put(short s)",
                  "description": "Relative put method(optional operation).\n\n  Writes the given short into this buffer at the current\n position, and then increments the position."
                },
                {
                  "signature": "public abstract ShortBuffer put(int index, short s)",
                  "description": "Absolute put method(optional operation).\n\n  Writes the given short into this buffer at the given\n index."
                },
                {
                  "signature": "public ShortBuffer put(ShortBuffer src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the shorts remaining in the given source\n buffer into this buffer.  If there are more shorts remaining in the\n source buffer than in this buffer, that is, if\n src.remaining()>remaining(),\n then no shorts are transferred and a BufferOverflowException is thrown.\n\n  Otherwise, this method copies\n n=src.remaining() shorts from the given\n buffer into this buffer, starting at each buffer's current position.\n The positions of both buffers are then incremented by n.\n\n  In other words, an invocation of this method of the form\n dst.put(src) has exactly the same effect as the loop\n\n      while (src.hasRemaining())\n         dst.put(src.get()); \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ShortBuffer put(int index, ShortBuffer src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length shorts into this buffer from\n the given source buffer, starting at the given offset in the\n source buffer and the given index in this buffer. The positions\n of both buffers are unchanged.\n\n  In other words, an invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the loop\n\n \n for (int i = offset, j = index; i < offset + length; i++, j++)\n     dst.put(j, src.get(i));\n \n\n except that it first checks the consistency of the supplied parameters\n and it is potentially much more efficient.  If this buffer and\n the source buffer share the same backing array or memory, then the\n result will be as if the source elements were first copied to an\n intermediate location before being written into this buffer."
                },
                {
                  "signature": "public ShortBuffer put(short[] src, int offset, int length)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers shorts into this buffer from the given\n source array.  If there are more shorts to be copied from the array\n than remain in this buffer, that is, if\n length>remaining(), then no\n shorts are transferred and a BufferOverflowException is\n thrown.\n\n  Otherwise, this method copies length shorts from the\n given array into this buffer, starting at the given offset in the array\n and at the current position of this buffer.  The position of this buffer\n is then incremented by length.\n\n  In other words, an invocation of this method of the form\n dst.put(src,off,len) has exactly the same effect as\n the loop\n\n \n     for (int i = off; i < off + len; i++)\n         dst.put(src[i]);\n \n\n except that it first checks that there is sufficient space in this\n buffer and it is potentially much more efficient."
                },
                {
                  "signature": "public final ShortBuffer put(short[] src)",
                  "description": "Relative bulk put method(optional operation).\n\n  This method transfers the entire content of the given source\n short array into this buffer.  An invocation of this method of the\n form dst.put(a) behaves in exactly the same way as the\n invocation\n\n      dst.put(a, 0, a.length)"
                },
                {
                  "signature": "public ShortBuffer put(int index, short[] src, int offset, int length)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method transfers length shorts from the given\n array, starting at the given offset in the array and at the given index\n in this buffer.  The position of this buffer is unchanged.\n\n  An invocation of this method of the form\n dst.put(index,src,offset,length)\n has exactly the same effect as the following loop except that it first\n checks the consistency of the supplied parameters and it is potentially\n much more efficient:\n\n \n     for (int i = offset, j = index; i < offset + length; i++, j++)\n         dst.put(j, src[i]);"
                },
                {
                  "signature": "public ShortBuffer put(int index, short[] src)",
                  "description": "Absolute bulk put method(optional operation).\n\n  This method copies shorts into this buffer from the given source\n array.  The position of this buffer is unchanged.  An invocation of this\n method of the form dst.put(index,src)\n behaves in exactly the same way as the invocation:\n\n      dst.put(index, src, 0, src.length);"
                }
              ]
            },
            {
              "name": "hasArray",
              "overloads": [
                {
                  "signature": "public final boolean hasArray()",
                  "description": "Tells whether or not this buffer is backed by an accessible short\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked."
                }
              ]
            },
            {
              "name": "array",
              "overloads": [
                {
                  "signature": "public final short[] array()",
                  "description": "Returns the short array that backs this\n buffer(optional operation).\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "arrayOffset",
              "overloads": [
                {
                  "signature": "public final int arrayOffset()",
                  "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p+arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array."
                }
              ]
            },
            {
              "name": "position",
              "overloads": [
                {
                  "signature": "public final ShortBuffer position(int newPosition)",
                  "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."
                }
              ]
            },
            {
              "name": "limit",
              "overloads": [
                {
                  "signature": "public final ShortBuffer limit(int newLimit)",
                  "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."
                }
              ]
            },
            {
              "name": "mark",
              "overloads": [
                {
                  "signature": "public final ShortBuffer mark()",
                  "description": "Sets this buffer's mark at its position."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public final ShortBuffer reset()",
                  "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public final ShortBuffer clear()",
                  "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n  buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n\n  This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case."
                }
              ]
            },
            {
              "name": "flip",
              "overloads": [
                {
                  "signature": "public final ShortBuffer flip()",
                  "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n  buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n\n  This method is often used in conjunction with the compact method when transferring data from\n one place to another."
                }
              ]
            },
            {
              "name": "rewind",
              "overloads": [
                {
                  "signature": "public final ShortBuffer rewind()",
                  "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n  out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"
                }
              ]
            },
            {
              "name": "compact",
              "overloads": [
                {
                  "signature": "public abstract ShortBuffer compact()",
                  "description": "Compacts this buffer(optional operation).\n\n  The shorts between the buffer's current position and its limit,\n if any, are copied to the beginning of the buffer.  That is, the\n short at index p=position() is copied\n to index zero, the short at index p+1 is copied\n to index one, and so forth until the short at index\n limit()-1 is copied to index\n n=limit()-1-p.\n The buffer's position is then set to n+1 and its limit is set to\n its capacity.  The mark, if defined, is discarded.\n\n  The buffer's position is set to the number of shorts copied,\n rather than to zero, so that an invocation of this method can be\n followed immediately by an invocation of another relative put\n method."
                }
              ]
            },
            {
              "name": "isDirect",
              "overloads": [
                {
                  "signature": "public abstract boolean isDirect()",
                  "description": "Tells whether or not this short buffer is direct."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string summarizing the state of this buffer."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the current hash code of this buffer.\n\n  The hash code of a short buffer depends only upon its remaining\n elements; that is, upon the elements from position() up to, and\n including, the element at limit()-1.\n\n  Because buffer hash codes are content-dependent, it is inadvisable\n to use buffers as keys in hash maps or similar data structures unless it\n is known that their contents will not change."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object ob)",
                  "description": "Tells whether or not this buffer is equal to another object.\n\n  Two short buffers are equal if, and only if,\n\n \n\n    They have the same element type,  \n\n    They have the same number of remaining elements, and\n   \n\n    The two sequences of remaining elements, considered\n   independently of their starting positions, are pointwise equal.\n\n\n\n\n\n\n\n   \n\n \n\n  A short buffer is not equal to any other type of object."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ShortBuffer that)",
                  "description": "Compares this buffer to another.\n\n  Two short buffers are compared by comparing their sequences of\n remaining elements lexicographically, without regard to the starting\n position of each sequence within its corresponding buffer.\n\n\n\n\n\n\n\n\n Pairs of short elements are compared as if by invoking\n Short.compare(short,short).\n\n\n  A short buffer is not comparable to any other type of object."
                }
              ]
            },
            {
              "name": "mismatch",
              "overloads": [
                {
                  "signature": "public int mismatch(ShortBuffer that)",
                  "description": "Finds and returns the relative index of the first mismatch between this\n buffer and a given buffer.  The index is relative to the\n position of each buffer and will be in the range of\n 0 (inclusive) up to the smaller of the remaining\n elements in each buffer (exclusive).\n\n  If the two buffers share a common prefix then the returned index is\n the length of the common prefix and it follows that there is a mismatch\n between the two buffers at that index within the respective buffers.\n If one buffer is a proper prefix of the other then the returned index is\n the smaller of the remaining elements in each buffer, and it follows that\n the index is only valid for the buffer with the larger number of\n remaining elements.\n Otherwise, there is no mismatch."
                }
              ]
            },
            {
              "name": "order",
              "overloads": [
                {
                  "signature": "public abstract ByteOrder order()",
                  "description": "Retrieves this buffer's byte order.\n\n  The byte order of a short buffer created by allocation or by\n wrapping an existing short array is the native order of the underlying\n hardware.  The byte order of a short buffer created as a view of a byte buffer is that of the\n byte buffer at the moment that the view is created."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.text",
      "description": "Text formatting and parsing",
      "classes": [
        {
          "name": "Annotation",
          "methods": [
            {
              "name": "Annotation",
              "overloads": [
                {
                  "signature": "public Annotation(Object value)",
                  "description": "Constructs an annotation record with the given value, which\n may be null."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public Object getValue()",
                  "description": "Returns the value of the attribute, which may be null."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns the String representation of this Annotation."
                }
              ]
            }
          ]
        },
        {
          "name": "AttributedCharacterIterator",
          "methods": [
            {
              "name": "getRunStart",
              "overloads": [
                {
                  "signature": "int getRunStart()",
                  "description": "Returns the index of the first character of the run\n with respect to all attributes containing the current character.\n\n Any contiguous text segments having the same attributes (the\n same set of attribute/value pairs) are treated as separate runs\n if the attributes have been given to those text segments separately."
                },
                {
                  "signature": "int getRunStart(AttributedCharacterIterator.Attribute attribute)",
                  "description": "Returns the index of the first character of the run\n with respect to the given attribute containing the current character."
                },
                {
                  "signature": "int getRunStart(Set<? extends AttributedCharacterIterator.Attribute> attributes)",
                  "description": "Returns the index of the first character of the run\n with respect to the given attributes containing the current character."
                }
              ]
            },
            {
              "name": "getRunLimit",
              "overloads": [
                {
                  "signature": "int getRunLimit()",
                  "description": "Returns the index of the first character following the run\n with respect to all attributes containing the current character.\n\n Any contiguous text segments having the same attributes (the\n same set of attribute/value pairs) are treated as separate runs\n if the attributes have been given to those text segments separately."
                },
                {
                  "signature": "int getRunLimit(AttributedCharacterIterator.Attribute attribute)",
                  "description": "Returns the index of the first character following the run\n with respect to the given attribute containing the current character."
                },
                {
                  "signature": "int getRunLimit(Set<? extends AttributedCharacterIterator.Attribute> attributes)",
                  "description": "Returns the index of the first character following the run\n with respect to the given attributes containing the current character."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "Map<AttributedCharacterIterator.Attribute,Object> getAttributes()",
                  "description": "Returns a map with the attributes defined on the current\n character."
                }
              ]
            },
            {
              "name": "getAttribute",
              "overloads": [
                {
                  "signature": "Object getAttribute(AttributedCharacterIterator.Attribute attribute)",
                  "description": "Returns the value of the named attribute for the current character.\n Returns null if the attribute is not defined."
                }
              ]
            },
            {
              "name": "getAllAttributeKeys",
              "overloads": [
                {
                  "signature": "Set<AttributedCharacterIterator.Attribute> getAllAttributeKeys()",
                  "description": "Returns the keys of all attributes defined on the\n iterator's text range. The set is empty if no\n attributes are defined."
                }
              ]
            }
          ]
        },
        {
          "name": "AttributedCharacterIterator.Attribute",
          "methods": [
            {
              "name": "Attribute",
              "overloads": [
                {
                  "signature": "protected Attribute(String name)",
                  "description": "Constructs an Attribute with the given name."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object obj)",
                  "description": "Compares two objects for equality. This version only returns true\n for x.equals(y) if x and y refer\n to the same object, and guarantees this for all subclasses."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public final int hashCode()",
                  "description": "Returns a hash code value for the object. This version is identical to\n the one in Object, but is also final."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of the object. This version returns the\n concatenation of class name, \"(\", a name identifying the attribute\n and \")\"."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "protected String getName()",
                  "description": "Returns the name of the attribute."
                }
              ]
            },
            {
              "name": "readResolve",
              "overloads": [
                {
                  "signature": "protected Object readResolve() throws InvalidObjectException",
                  "description": "Resolves instances being deserialized to the predefined constants."
                }
              ]
            }
          ]
        },
        {
          "name": "AttributedString",
          "methods": [
            {
              "name": "AttributedString",
              "overloads": [
                {
                  "signature": "public AttributedString(String text)",
                  "description": "Constructs an AttributedString instance with the given text."
                },
                {
                  "signature": "public AttributedString(String text, Map<? extends AttributedCharacterIterator.Attribute,?> attributes)",
                  "description": "Constructs an AttributedString instance with the given text and attributes."
                },
                {
                  "signature": "public AttributedString(AttributedCharacterIterator text)",
                  "description": "Constructs an AttributedString instance with the given attributed\n text represented by AttributedCharacterIterator."
                },
                {
                  "signature": "public AttributedString(AttributedCharacterIterator text, int beginIndex, int endIndex)",
                  "description": "Constructs an AttributedString instance with the subrange of\n the given attributed text represented by\n AttributedCharacterIterator. If the given range produces an\n empty text, all attributes will be discarded.  Note that any\n attributes wrapped by an Annotation object are discarded for a\n subrange of the original attribute range."
                },
                {
                  "signature": "public AttributedString(AttributedCharacterIterator text, int beginIndex, int endIndex, AttributedCharacterIterator.Attribute[] attributes)",
                  "description": "Constructs an AttributedString instance with the subrange of\n the given attributed text represented by\n AttributedCharacterIterator.  Only attributes that match the\n given attributes will be incorporated into the instance. If the\n given range produces an empty text, all attributes will be\n discarded. Note that any attributes wrapped by an Annotation\n object are discarded for a subrange of the original attribute\n range."
                }
              ]
            },
            {
              "name": "addAttribute",
              "overloads": [
                {
                  "signature": "public void addAttribute(AttributedCharacterIterator.Attribute attribute, Object value)",
                  "description": "Adds an attribute to the entire string."
                },
                {
                  "signature": "public void addAttribute(AttributedCharacterIterator.Attribute attribute, Object value, int beginIndex, int endIndex)",
                  "description": "Adds an attribute to a subrange of the string."
                }
              ]
            },
            {
              "name": "addAttributes",
              "overloads": [
                {
                  "signature": "public void addAttributes(Map<? extends AttributedCharacterIterator.Attribute,?> attributes, int beginIndex, int endIndex)",
                  "description": "Adds a set of attributes to a subrange of the string."
                }
              ]
            },
            {
              "name": "getIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator getIterator()",
                  "description": "Creates an AttributedCharacterIterator instance that provides access to the entire contents of\n this string."
                },
                {
                  "signature": "public AttributedCharacterIterator getIterator(AttributedCharacterIterator.Attribute[] attributes)",
                  "description": "Creates an AttributedCharacterIterator instance that provides access to\n selected contents of this string.\n Information about attributes not listed in attributes that the\n implementor may have need not be made accessible through the iterator.\n If the list is null, all available attribute information should be made\n accessible."
                },
                {
                  "signature": "public AttributedCharacterIterator getIterator(AttributedCharacterIterator.Attribute[] attributes, int beginIndex, int endIndex)",
                  "description": "Creates an AttributedCharacterIterator instance that provides access to\n selected contents of this string.\n Information about attributes not listed in attributes that the\n implementor may have need not be made accessible through the iterator.\n If the list is null, all available attribute information should be made\n accessible."
                }
              ]
            }
          ]
        },
        {
          "name": "Bidi",
          "methods": [
            {
              "name": "Bidi",
              "overloads": [
                {
                  "signature": "public Bidi(String paragraph, int flags)",
                  "description": "Create Bidi from the given paragraph of text and base direction."
                },
                {
                  "signature": "public Bidi(AttributedCharacterIterator paragraph)",
                  "description": "Create Bidi from the given paragraph of text.\n \n The RUN_DIRECTION attribute in the text, if present, determines the base\n direction (left-to-right or right-to-left).  If not present, the base\n direction is computes using the Unicode Bidirectional Algorithm, defaulting to left-to-right\n if there are no strong directional characters in the text.  This attribute, if\n present, must be applied to all the text in the paragraph.\n \n The BIDI_EMBEDDING attribute in the text, if present, represents embedding level\n information.  Negative values from -1 to -62 indicate overrides at the absolute value\n of the level.  Positive values from 1 to 62 indicate embeddings.  Where values are\n zero or not defined, the base embedding level as determined by the base direction\n is assumed.\n \n The NUMERIC_SHAPING attribute in the text, if present, converts European digits to\n other decimal digits before running the bidi algorithm.  This attribute, if present,\n must be applied to all the text in the paragraph."
                },
                {
                  "signature": "public Bidi(char[] text, int textStart, byte[] embeddings, int embStart, int paragraphLength, int flags)",
                  "description": "Create Bidi from the given text, embedding, and direction information.\n The embeddings array may be null.  If present, the values represent embedding level\n information.  Negative values from -1 to -61 indicate overrides at the absolute value\n of the level.  Positive values from 1 to 61 indicate embeddings.  Where values are\n zero, the base embedding level as determined by the base direction is assumed."
                }
              ]
            },
            {
              "name": "createLineBidi",
              "overloads": [
                {
                  "signature": "public Bidi createLineBidi(int lineStart, int lineLimit)",
                  "description": "Create a Bidi object representing the bidi information on a line of text within\n the paragraph represented by the current Bidi.  This call is not required if the\n entire paragraph fits on one line."
                }
              ]
            },
            {
              "name": "isMixed",
              "overloads": [
                {
                  "signature": "public boolean isMixed()",
                  "description": "Return true if the line is not left-to-right or right-to-left.  This means it either has mixed runs of left-to-right\n and right-to-left text, or the base direction differs from the direction of the only run of text."
                }
              ]
            },
            {
              "name": "isLeftToRight",
              "overloads": [
                {
                  "signature": "public boolean isLeftToRight()",
                  "description": "Return true if the line is all left-to-right text and the base direction is left-to-right."
                }
              ]
            },
            {
              "name": "isRightToLeft",
              "overloads": [
                {
                  "signature": "public boolean isRightToLeft()",
                  "description": "Return true if the line is all right-to-left text, and the base direction is right-to-left."
                }
              ]
            },
            {
              "name": "getLength",
              "overloads": [
                {
                  "signature": "public int getLength()",
                  "description": "Return the length of text in the line."
                }
              ]
            },
            {
              "name": "baseIsLeftToRight",
              "overloads": [
                {
                  "signature": "public boolean baseIsLeftToRight()",
                  "description": "Return true if the base direction is left-to-right."
                }
              ]
            },
            {
              "name": "getBaseLevel",
              "overloads": [
                {
                  "signature": "public int getBaseLevel()",
                  "description": "Return the base level (0 if left-to-right, 1 if right-to-left)."
                }
              ]
            },
            {
              "name": "getLevelAt",
              "overloads": [
                {
                  "signature": "public int getLevelAt(int offset)",
                  "description": "Return the resolved level of the character at offset.  If offset is\n < 0 or  the length of the line, return the base direction\n level."
                }
              ]
            },
            {
              "name": "getRunCount",
              "overloads": [
                {
                  "signature": "public int getRunCount()",
                  "description": "Return the number of level runs."
                }
              ]
            },
            {
              "name": "getRunLevel",
              "overloads": [
                {
                  "signature": "public int getRunLevel(int run)",
                  "description": "Return the level of the nth logical run in this line."
                }
              ]
            },
            {
              "name": "getRunStart",
              "overloads": [
                {
                  "signature": "public int getRunStart(int run)",
                  "description": "Return the index of the character at the start of the nth logical run in this line, as\n an offset from the start of the line."
                }
              ]
            },
            {
              "name": "getRunLimit",
              "overloads": [
                {
                  "signature": "public int getRunLimit(int run)",
                  "description": "Return the index of the character past the end of the nth logical run in this line, as\n an offset from the start of the line.  For example, this will return the length\n of the line for the last run on the line."
                }
              ]
            },
            {
              "name": "requiresBidi",
              "overloads": [
                {
                  "signature": "public static boolean requiresBidi(char[] text, int start, int limit)",
                  "description": "Return true if the specified text requires bidi analysis.  If this returns false,\n the text will display left-to-right.  Clients can then avoid constructing a Bidi object.\n Text in the Arabic Presentation Forms area of Unicode is presumed to already be shaped\n and ordered for display, and so will not cause this function to return true."
                }
              ]
            },
            {
              "name": "reorderVisually",
              "overloads": [
                {
                  "signature": "public static void reorderVisually(byte[] levels, int levelStart, Object[] objects, int objectStart, int count)",
                  "description": "Reorder the objects in the array into visual order based on their levels.\n This is a utility function to use when you have a collection of objects\n representing runs of text in logical order, each run containing text\n at a single level.  The elements at index from\n objectStart up to objectStart + count\n in the objects array will be reordered into visual order assuming\n each run of text has the level indicated by the corresponding element\n in the levels array (at index - objectStart + levelStart)."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Display the bidi internal state, used in debugging."
                }
              ]
            }
          ]
        },
        {
          "name": "BreakIterator",
          "methods": [
            {
              "name": "BreakIterator",
              "overloads": [
                {
                  "signature": "protected BreakIterator()",
                  "description": "Constructor. BreakIterator is stateless and has no default behavior."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Create a copy of this iterator"
                }
              ]
            },
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "public abstract int first()",
                  "description": "Returns the first boundary. The iterator's current position is set\n to the first text boundary."
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "public abstract int last()",
                  "description": "Returns the last boundary. The iterator's current position is set\n to the last text boundary."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "public abstract int next(int n)",
                  "description": "Returns the nth boundary from the current boundary. If either\n the first or last text boundary has been reached, it returns\n BreakIterator.DONE and the current position is set to either\n the first or last text boundary depending on which one is reached. Otherwise,\n the iterator's current position is set to the new boundary.\n For example, if the iterator's current position is the mth text boundary\n and three more boundaries exist from the current boundary to the last text\n boundary, the next(2) call will return m + 2. The new text position is set\n to the (m + 2)th text boundary. A next(4) call would return\n BreakIterator.DONE and the last text boundary would become the\n new text position."
                },
                {
                  "signature": "public abstract int next()",
                  "description": "Returns the boundary following the current boundary. If the current boundary\n is the last text boundary, it returns BreakIterator.DONE and\n the iterator's current position is unchanged. Otherwise, the iterator's\n current position is set to the boundary following the current boundary."
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "public abstract int previous()",
                  "description": "Returns the boundary preceding the current boundary. If the current boundary\n is the first text boundary, it returns BreakIterator.DONE and\n the iterator's current position is unchanged. Otherwise, the iterator's\n current position is set to the boundary preceding the current boundary."
                }
              ]
            },
            {
              "name": "following",
              "overloads": [
                {
                  "signature": "public abstract int following(int offset)",
                  "description": "Returns the first boundary following the specified character offset. If the\n specified offset is equal to the last text boundary, it returns\n BreakIterator.DONE and the iterator's current position is unchanged.\n Otherwise, the iterator's current position is set to the returned boundary.\n The value returned is always greater than the offset or the value\n BreakIterator.DONE."
                }
              ]
            },
            {
              "name": "preceding",
              "overloads": [
                {
                  "signature": "public int preceding(int offset)",
                  "description": "Returns the last boundary preceding the specified character offset. If the\n specified offset is equal to the first text boundary, it returns\n BreakIterator.DONE and the iterator's current position is unchanged.\n Otherwise, the iterator's current position is set to the returned boundary.\n The value returned is always less than the offset or the value\n BreakIterator.DONE."
                }
              ]
            },
            {
              "name": "isBoundary",
              "overloads": [
                {
                  "signature": "public boolean isBoundary(int offset)",
                  "description": "Returns true if the specified character offset is a text boundary."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "public abstract int current()",
                  "description": "Returns character index of the text boundary that was most\n recently returned by next(), next(int), previous(), first(), last(),\n following(int) or preceding(int). If any of these methods returns\n BreakIterator.DONE because either first or last text boundary\n has been reached, it returns the first or last text boundary depending on\n which one is reached."
                }
              ]
            },
            {
              "name": "getText",
              "overloads": [
                {
                  "signature": "public abstract CharacterIterator getText()",
                  "description": "Get the text being scanned"
                }
              ]
            },
            {
              "name": "setText",
              "overloads": [
                {
                  "signature": "public void setText(String newText)",
                  "description": "Set a new text string to be scanned.  The current scan\n position is reset to first()."
                },
                {
                  "signature": "public abstract void setText(CharacterIterator newText)",
                  "description": "Set a new text for scanning.  The current scan\n position is reset to first()."
                }
              ]
            },
            {
              "name": "getWordInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getWordInstance()",
                  "description": "Returns a new BreakIterator instance\n for word breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getWordInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for word breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getLineInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getLineInstance()",
                  "description": "Returns a new BreakIterator instance\n for line breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getLineInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for line breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getCharacterInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getCharacterInstance()",
                  "description": "Returns a new BreakIterator instance\n for character breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getCharacterInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for character breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getSentenceInstance",
              "overloads": [
                {
                  "signature": "public static BreakIterator getSentenceInstance()",
                  "description": "Returns a new BreakIterator instance\n for sentence breaks\n for the default locale."
                },
                {
                  "signature": "public static BreakIterator getSentenceInstance(Locale locale)",
                  "description": "Returns a new BreakIterator instance\n for sentence breaks\n for the given locale."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n BreakIteratorProvider implementations.\n It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            }
          ]
        },
        {
          "name": "CharacterIterator",
          "methods": [
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "char first()",
                  "description": "Sets the position to getBeginIndex() and returns the character at that\n position."
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "char last()",
                  "description": "Sets the position to getEndIndex()-1 (getEndIndex() if the text is empty)\n and returns the character at that position."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "char current()",
                  "description": "Gets the character at the current position (as returned by getIndex())."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "char next()",
                  "description": "Increments the iterator's index by one and returns the character\n at the new index.  If the resulting index is greater or equal\n to getEndIndex(), the current index is reset to getEndIndex() and\n a value of DONE is returned."
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "char previous()",
                  "description": "Decrements the iterator's index by one and returns the character\n at the new index. If the current index is getBeginIndex(), the index\n remains at getBeginIndex() and a value of DONE is returned."
                }
              ]
            },
            {
              "name": "setIndex",
              "overloads": [
                {
                  "signature": "char setIndex(int position)",
                  "description": "Sets the position to the specified position in the text and returns that\n character."
                }
              ]
            },
            {
              "name": "getBeginIndex",
              "overloads": [
                {
                  "signature": "int getBeginIndex()",
                  "description": "Returns the start index of the text."
                }
              ]
            },
            {
              "name": "getEndIndex",
              "overloads": [
                {
                  "signature": "int getEndIndex()",
                  "description": "Returns the end index of the text.  This index is the index of the first\n character following the end of the text."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "int getIndex()",
                  "description": "Returns the current index."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "Object clone()",
                  "description": "Create a copy of this iterator"
                }
              ]
            }
          ]
        },
        {
          "name": "ChoiceFormat",
          "methods": [
            {
              "name": "ChoiceFormat",
              "overloads": [
                {
                  "signature": "public ChoiceFormat(String newPattern)",
                  "description": "Constructs with limits and corresponding formats based on the pattern."
                },
                {
                  "signature": "public ChoiceFormat(double[] limits, String[] formats)",
                  "description": "Constructs with the limits and the corresponding formats."
                }
              ]
            },
            {
              "name": "applyPattern",
              "overloads": [
                {
                  "signature": "public void applyPattern(String newPattern)",
                  "description": "Sets the pattern."
                }
              ]
            },
            {
              "name": "toPattern",
              "overloads": [
                {
                  "signature": "public String toPattern()",
                  "description": "Gets the pattern."
                }
              ]
            },
            {
              "name": "setChoices",
              "overloads": [
                {
                  "signature": "public void setChoices(double[] limits, String[] formats)",
                  "description": "Set the choices to be used in formatting."
                }
              ]
            },
            {
              "name": "getLimits",
              "overloads": [
                {
                  "signature": "public double[] getLimits()",
                  "description": "Get the limits passed in the constructor."
                }
              ]
            },
            {
              "name": "getFormats",
              "overloads": [
                {
                  "signature": "public Object[] getFormats()",
                  "description": "Get the formats passed in the constructor."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition status)",
                  "description": "Specialization of format. This method really calls\n format(double, StringBuffer, FieldPosition)\n thus the range of longs that are supported is only equal to\n the range that can be stored by double. This will never be\n a practical limitation."
                },
                {
                  "signature": "public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition status)",
                  "description": "Returns pattern with formatted double."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Number parse(String text, ParsePosition status)",
                  "description": "Parses a Number from the input text."
                }
              ]
            },
            {
              "name": "nextDouble",
              "overloads": [
                {
                  "signature": "public static final double nextDouble(double d)",
                  "description": "Finds the least double greater than d.\n If NaN, returns same value.\n Used to make half-open intervals."
                },
                {
                  "signature": "public static double nextDouble(double d, boolean positive)",
                  "description": "Finds the least double greater than d (if positive is\n true), or the greatest double less than d (if\n positive is false).\n If NaN, returns same value."
                }
              ]
            },
            {
              "name": "previousDouble",
              "overloads": [
                {
                  "signature": "public static final double previousDouble(double d)",
                  "description": "Finds the greatest double less than d.\n If NaN, returns same value."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Generates a hash code for the message format object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Equality comparison between two"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static NumberFormat.Style[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static NumberFormat.Style valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Normalizer.Form[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Normalizer.Form valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "CollationElementIterator",
          "methods": [
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the cursor to the beginning of the string.  The next call\n to next() will return the first collation element in the string."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "public int next()",
                  "description": "Get the next collation element in the string.  This iterator iterates\n over a sequence of collation elements that were built from the string.\n Because there isn't necessarily a one-to-one mapping from characters to\n collation elements, this doesn't mean the same thing as \"return the\n collation element [or ordering priority] of the next character in the\n string\".\n This function returns the collation element that the iterator is currently\n pointing to and then updates the internal pointer to point to the next element.\n previous() updates the pointer first and then returns the element.  This\n means that when you change direction while iterating (i.e., call next() and\n then call previous(), or call previous() and then call next()), you'll get\n back the same element twice."
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "public int previous()",
                  "description": "Get the previous collation element in the string.  This iterator iterates\n over a sequence of collation elements that were built from the string.\n Because there isn't necessarily a one-to-one mapping from characters to\n collation elements, this doesn't mean the same thing as \"return the\n collation element [or ordering priority] of the previous character in the\n string\".\n This function updates the iterator's internal pointer to point to the\n collation element preceding the one it's currently pointing to and then\n returns that element, while next() returns the current element and then\n updates the pointer.  This means that when you change direction while\n iterating (i.e., call next() and then call previous(), or call previous()\n and then call next()), you'll get back the same element twice."
                }
              ]
            },
            {
              "name": "primaryOrder",
              "overloads": [
                {
                  "signature": "public static final int primaryOrder(int order)",
                  "description": "Return the primary component of a collation element."
                }
              ]
            },
            {
              "name": "secondaryOrder",
              "overloads": [
                {
                  "signature": "public static final short secondaryOrder(int order)",
                  "description": "Return the secondary component of a collation element."
                }
              ]
            },
            {
              "name": "tertiaryOrder",
              "overloads": [
                {
                  "signature": "public static final short tertiaryOrder(int order)",
                  "description": "Return the tertiary component of a collation element."
                }
              ]
            },
            {
              "name": "setOffset",
              "overloads": [
                {
                  "signature": "public void setOffset(int newOffset)",
                  "description": "Sets the iterator to point to the collation element corresponding to\n the specified character (the parameter is a CHARACTER offset in the\n original string, not an offset into its corresponding sequence of\n collation elements).  The value returned by the next call to next()\n will be the collation element corresponding to the specified position\n in the text.  If that position is in the middle of a contracting\n character sequence, the result of the next call to next() is the\n collation element for that sequence.  This means that getOffset()\n is not guaranteed to return the same value as was passed to a preceding\n call to setOffset()."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public int getOffset()",
                  "description": "Returns the character offset in the original text corresponding to the next\n collation element.  (That is, getOffset() returns the position in the text\n corresponding to the collation element that will be returned by the next\n call to next().)  This value will always be the index of the FIRST character\n corresponding to the collation element (a contracting character sequence is\n when two or more characters all correspond to the same collation element).\n This means if you do setOffset(x) followed immediately by getOffset(), getOffset()\n won't necessarily return x."
                }
              ]
            },
            {
              "name": "getMaxExpansion",
              "overloads": [
                {
                  "signature": "public int getMaxExpansion(int order)",
                  "description": "Return the maximum length of any expansion sequences that end\n with the specified comparison order."
                }
              ]
            },
            {
              "name": "setText",
              "overloads": [
                {
                  "signature": "public void setText(String source)",
                  "description": "Set a new string over which to iterate."
                },
                {
                  "signature": "public void setText(CharacterIterator source)",
                  "description": "Set a new string over which to iterate."
                }
              ]
            }
          ]
        },
        {
          "name": "CollationKey",
          "methods": [
            {
              "name": "CollationKey",
              "overloads": [
                {
                  "signature": "protected CollationKey(String source)",
                  "description": "CollationKey constructor."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public abstract int compareTo(CollationKey target)",
                  "description": "Compare this CollationKey to the target CollationKey. The collation rules of the\n Collator object which created these keys are applied. Note:\n CollationKeys created by different Collators can not be compared."
                }
              ]
            },
            {
              "name": "getSourceString",
              "overloads": [
                {
                  "signature": "public String getSourceString()",
                  "description": "Returns the String that this CollationKey represents."
                }
              ]
            },
            {
              "name": "toByteArray",
              "overloads": [
                {
                  "signature": "public abstract byte[] toByteArray()",
                  "description": "Converts the CollationKey to a sequence of bits. If two CollationKeys\n could be legitimately compared, then one could compare the byte arrays\n for each of those keys to obtain the same result.  Byte arrays are\n organized most significant byte first."
                }
              ]
            }
          ]
        },
        {
          "name": "Collator",
          "methods": [
            {
              "name": "Collator",
              "overloads": [
                {
                  "signature": "protected Collator()",
                  "description": "Default constructor.  This constructor is\n protected so subclasses can get access to it. Users typically create\n a Collator sub-class by calling the factory method getInstance."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Collator getInstance()",
                  "description": "Gets the Collator for the current default locale.\n The default locale is determined by java.util.Locale.getDefault."
                },
                {
                  "signature": "public static Collator getInstance(Locale desiredLocale)",
                  "description": "Gets the Collator for the desired locale."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public abstract int compare(String source, String target)",
                  "description": "Compares the source string to the target string according to the\n collation rules for this Collator.  Returns an integer less than,\n equal to or greater than zero depending on whether the source String is\n less than, equal to or greater than the target string.  See the Collator\n class description for an example of use.\n \n For a one time comparison, this method has the best performance. If a\n given String will be involved in multiple comparisons, CollationKey.compareTo\n has the best performance. See the Collator class description for an example\n using CollationKeys."
                },
                {
                  "signature": "public int compare(Object o1, Object o2)",
                  "description": "Compares its two arguments for order.  Returns a negative integer,\n zero, or a positive integer as the first argument is less than, equal\n to, or greater than the second.\n \n This implementation merely returns\n   compare((String)o1, (String)o2) ."
                }
              ]
            },
            {
              "name": "getCollationKey",
              "overloads": [
                {
                  "signature": "public abstract CollationKey getCollationKey(String source)",
                  "description": "Transforms the String into a series of bits that can be compared bitwise\n to other CollationKeys. CollationKeys provide better performance than\n Collator.compare when Strings are involved in multiple comparisons.\n See the Collator class description for an example using CollationKeys."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(String source, String target)",
                  "description": "Convenience method for comparing the equality of two strings based on\n this Collator's collation rules."
                },
                {
                  "signature": "public boolean equals(Object that)",
                  "description": "Compares the equality of two Collators."
                }
              ]
            },
            {
              "name": "getStrength",
              "overloads": [
                {
                  "signature": "public int getStrength()",
                  "description": "Returns this Collator's strength property.  The strength property determines\n the minimum level of difference considered significant during comparison.\n See the Collator class description for an example of use."
                }
              ]
            },
            {
              "name": "setStrength",
              "overloads": [
                {
                  "signature": "public void setStrength(int newStrength)",
                  "description": "Sets this Collator's strength property.  The strength property determines\n the minimum level of difference considered significant during comparison.\n See the Collator class description for an example of use."
                }
              ]
            },
            {
              "name": "getDecomposition",
              "overloads": [
                {
                  "signature": "public int getDecomposition()",
                  "description": "Get the decomposition mode of this Collator. Decomposition mode\n determines how Unicode composed characters are handled. Adjusting\n decomposition mode allows the user to select between faster and more\n complete collation behavior.\n The three values for decomposition mode are:\n \n NO_DECOMPOSITION,\n CANONICAL_DECOMPOSITION\n FULL_DECOMPOSITION.\n \n See the documentation for these three constants for a description\n of their meaning."
                }
              ]
            },
            {
              "name": "setDecomposition",
              "overloads": [
                {
                  "signature": "public void setDecomposition(int decompositionMode)",
                  "description": "Set the decomposition mode of this Collator. See getDecomposition\n for a description of decomposition mode."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported\n by the Java runtime and by installed\n CollatorProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public abstract int hashCode()",
                  "description": "Generates the hash code for this Collator."
                }
              ]
            }
          ]
        },
        {
          "name": "CompactNumberFormat",
          "methods": [
            {
              "name": "CompactNumberFormat",
              "overloads": [
                {
                  "signature": "public CompactNumberFormat(String decimalPattern, DecimalFormatSymbols symbols, String[] compactPatterns)",
                  "description": "Creates a CompactNumberFormat using the given decimal pattern,\n decimal format symbols and compact patterns.\n To obtain the instance of CompactNumberFormat with the standard\n compact patterns for a Locale and Style,\n it is recommended to use the factory methods given by\n NumberFormat for compact number formatting. For example,\n NumberFormat.getCompactNumberInstance(Locale, Style)."
                },
                {
                  "signature": "public CompactNumberFormat(String decimalPattern, DecimalFormatSymbols symbols, String[] compactPatterns, String pluralRules)",
                  "description": "Creates a CompactNumberFormat using the given decimal pattern,\n decimal format symbols, compact patterns, and plural rules.\n To obtain the instance of CompactNumberFormat with the standard\n compact patterns for a Locale, Style, and pluralRules,\n it is recommended to use the factory methods given by\n NumberFormat for compact number formatting. For example,\n NumberFormat.getCompactNumberInstance(Locale, Style)."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition fieldPosition)",
                  "description": "Formats a number to produce a string representing its compact form.\n The number can be of any subclass of Number."
                },
                {
                  "signature": "public StringBuffer format(double number, StringBuffer result, FieldPosition fieldPosition)",
                  "description": "Formats a double to produce a string representing its compact form."
                },
                {
                  "signature": "public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition)",
                  "description": "Formats a long to produce a string representing its compact form."
                }
              ]
            },
            {
              "name": "formatToCharacterIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
                  "description": "Formats an Object producing an AttributedCharacterIterator.\n The returned AttributedCharacterIterator can be used\n to build the resulting string, as well as to determine information\n about the resulting string.\n \n Each attribute key of the AttributedCharacterIterator will\n be of type NumberFormat.Field, with the attribute value\n being the same as the attribute key. The prefix and the suffix\n parts of the returned iterator (if present) are represented by\n the attributes NumberFormat.Field.PREFIX and\n NumberFormat.Field.SUFFIX respectively."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Number parse(String text, ParsePosition pos)",
                  "description": "Parses a compact number from a string to produce a Number.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n number is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n The value is the numeric part in the given text multiplied\n by the numeric equivalent of the affix attached\n (For example, \"K\" = 1000 in US locale).\n The subclass returned depends on the value of\n isParseBigDecimal().\n \n If isParseBigDecimal() is false (the default),\n     most integer values are returned as Long\n     objects, no matter how they are written: \"17K\" and\n     \"17.000K\" both parse to Long.valueOf(17000).\n     If the value cannot fit into Long, then the result is\n     returned as Double. This includes values with a\n     fractional part, infinite values, NaN,\n     and the value -0.0.\n     \n     Callers may use the Number methods doubleValue,\n     longValue, etc., to obtain the type they want.\n\n If isParseBigDecimal() is true, values are returned\n     as BigDecimal objects. The special cases negative\n     and positive infinity and NaN are returned as Double\n     instances holding the values of the corresponding\n     Double constants.\n \n \n CompactNumberFormat parses all Unicode characters that represent\n decimal digits, as defined by Character.digit(). In\n addition, CompactNumberFormat also recognizes as digits the ten\n consecutive characters starting with the localized zero digit defined in\n the DecimalFormatSymbols object.\n \n CompactNumberFormat parse does not allow parsing scientific\n notations. For example, parsing a string \"1.05E4K\" in\n US locale breaks at character 'E'\n and returns 1.05."
                }
              ]
            },
            {
              "name": "setMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumIntegerDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the integer portion of a\n number.\n The maximum allowed integer range is 309, if the newValue > 309,\n then the maximum integer digits count is set to 309. Negative input\n values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumIntegerDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the integer portion of a\n number.\n The maximum allowed integer range is 309, if the newValue > 309,\n then the minimum integer digits count is set to 309. Negative input\n values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumFractionDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the fraction portion of a\n number.\n The maximum allowed fraction range is 340, if the newValue > 340,\n then the minimum fraction digits count is set to 340. Negative input\n values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumFractionDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the fraction portion of a\n number.\n The maximum allowed fraction range is 340, if the newValue > 340,\n then the maximum fraction digits count is set to 340. Negative input\n values are replaced with 0."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Gets the RoundingMode used in this\n CompactNumberFormat."
                }
              ]
            },
            {
              "name": "setRoundingMode",
              "overloads": [
                {
                  "signature": "public void setRoundingMode(RoundingMode roundingMode)",
                  "description": "Sets the RoundingMode used in this\n CompactNumberFormat."
                }
              ]
            },
            {
              "name": "getGroupingSize",
              "overloads": [
                {
                  "signature": "public int getGroupingSize()",
                  "description": "Returns the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number. For example,\n in the compact number \"12,347 trillion\" for the\n US locale, the grouping size is 3."
                }
              ]
            },
            {
              "name": "setGroupingSize",
              "overloads": [
                {
                  "signature": "public void setGroupingSize(int newValue)",
                  "description": "Sets the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number. For example,\n in the compact number \"12,347 trillion\" for the\n US locale, the grouping size is 3. The grouping\n size must be greater than or equal to zero and less than or equal to 127."
                }
              ]
            },
            {
              "name": "isGroupingUsed",
              "overloads": [
                {
                  "signature": "public boolean isGroupingUsed()",
                  "description": "Returns true if grouping is used in this format. For example, with\n grouping on and grouping size set to 3, the number 12346567890987654\n can be formatted as \"12,347 trillion\" in the\n US locale.\n The grouping separator is locale dependent."
                }
              ]
            },
            {
              "name": "setGroupingUsed",
              "overloads": [
                {
                  "signature": "public void setGroupingUsed(boolean newValue)",
                  "description": "Sets whether or not grouping will be used in this format."
                }
              ]
            },
            {
              "name": "isParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public boolean isParseIntegerOnly()",
                  "description": "Returns true if this format parses only an integer from the number\n component of a compact number.\n Parsing an integer means that only an integer is considered from the\n number component, prefix/suffix is still considered to compute the\n resulting output.\n For example, in the US locale, if this method\n returns true, the string \"1234.78 thousand\" would be\n parsed as the value 1234000 (1234 (integer part) * 1000\n (thousand)) and the fractional part would be skipped.\n The exact format accepted by the parse operation is locale dependent."
                }
              ]
            },
            {
              "name": "setParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public void setParseIntegerOnly(boolean value)",
                  "description": "Sets whether or not this format parses only an integer from the number\n component of a compact number."
                }
              ]
            },
            {
              "name": "isParseBigDecimal",
              "overloads": [
                {
                  "signature": "public boolean isParseBigDecimal()",
                  "description": "Returns whether the parse(String, ParsePosition)\n method returns BigDecimal. The default value is false."
                }
              ]
            },
            {
              "name": "setParseBigDecimal",
              "overloads": [
                {
                  "signature": "public void setParseBigDecimal(boolean newValue)",
                  "description": "Sets whether the parse(String, ParsePosition)\n method returns BigDecimal."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this CompactNumberFormat is equal to the\n specified obj. The objects of type CompactNumberFormat\n are compared, other types return false; obeys the general contract of\n Object.equals."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code for this CompactNumberFormat instance."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public CompactNumberFormat clone()",
                  "description": "Creates and returns a copy of this CompactNumberFormat\n instance."
                }
              ]
            }
          ]
        },
        {
          "name": "DateFormat",
          "methods": [
            {
              "name": "DateFormat",
              "overloads": [
                {
                  "signature": "protected DateFormat()",
                  "description": "Create a new date format."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition fieldPosition)",
                  "description": "Formats the given Object into a date-time string. The formatted\n string is appended to the given StringBuffer."
                },
                {
                  "signature": "public abstract StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)",
                  "description": "Formats a Date into a date-time string. The formatted\n string is appended to the given StringBuffer."
                },
                {
                  "signature": "public final String format(Date date)",
                  "description": "Formats a Date into a date-time string."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Date parse(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce a date.\n The method may not use the entire text of the given string.\n \n See the parse(String, ParsePosition) method for more information\n on date parsing."
                },
                {
                  "signature": "public abstract Date parse(String source, ParsePosition pos)",
                  "description": "Parse a date/time string according to the given parse position.  For\n example, a time text \"07/10/96 4:5 PM, PDT\" will be parsed into a Date\n that is equivalent to Date(837039900000L).\n\n  By default, parsing is lenient: If the input is not in the form used\n by this object's format method but can still be parsed as a date, then\n the parse succeeds.  Clients may insist on strict adherence to the\n format by calling setLenient(false).\n\n This parsing operation uses the calendar to produce\n a Date. As a result, the calendar's date-time\n fields and the TimeZone value may have been\n overwritten, depending on subclass implementations. Any \n TimeZone value that has previously been set by a call to\n setTimeZone may need\n to be restored for further operations."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Date.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n date is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n See the parse(String, ParsePosition) method for more information\n on date parsing."
                }
              ]
            },
            {
              "name": "getTimeInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getTimeInstance()",
                  "description": "Gets the time formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getTimeInstance(DEFAULT,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getTimeInstance(int style)",
                  "description": "Gets the time formatter with the given formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getTimeInstance(style,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getTimeInstance(int style, Locale aLocale)",
                  "description": "Gets the time formatter with the given formatting style\n for the given locale."
                }
              ]
            },
            {
              "name": "getDateInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getDateInstance()",
                  "description": "Gets the date formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateInstance(DEFAULT,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateInstance(int style)",
                  "description": "Gets the date formatter with the given formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateInstance(style,\n     Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateInstance(int style, Locale aLocale)",
                  "description": "Gets the date formatter with the given formatting style\n for the given locale."
                }
              ]
            },
            {
              "name": "getDateTimeInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getDateTimeInstance()",
                  "description": "Gets the date/time formatter with the default formatting style\n for the default FORMAT locale.\n This is equivalent to calling\n getDateTimeInstance(DEFAULT,\n     DEFAULT, Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle)",
                  "description": "Gets the date/time formatter with the given date and time\n formatting styles for the default FORMAT locale.\n This is equivalent to calling\n getDateTimeInstance(dateStyle,\n     timeStyle, Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)",
                  "description": "Gets the date/time formatter with the given formatting styles\n for the given locale."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormat getInstance()",
                  "description": "Get a default date/time formatter that uses the SHORT style for both the\n date and the time."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n DateFormatProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "setCalendar",
              "overloads": [
                {
                  "signature": "public void setCalendar(Calendar newCalendar)",
                  "description": "Set the calendar to be used by this date format.  Initially, the default\n calendar for the specified or default locale is used.\n\n Any TimeZone and leniency values that have previously been set are\n overwritten by newCalendar's values."
                }
              ]
            },
            {
              "name": "getCalendar",
              "overloads": [
                {
                  "signature": "public Calendar getCalendar()",
                  "description": "Gets the calendar associated with this date/time formatter."
                }
              ]
            },
            {
              "name": "setNumberFormat",
              "overloads": [
                {
                  "signature": "public void setNumberFormat(NumberFormat newNumberFormat)",
                  "description": "Allows you to set the number formatter."
                }
              ]
            },
            {
              "name": "getNumberFormat",
              "overloads": [
                {
                  "signature": "public NumberFormat getNumberFormat()",
                  "description": "Gets the number formatter which this date/time formatter uses to\n format and parse a time."
                }
              ]
            },
            {
              "name": "setTimeZone",
              "overloads": [
                {
                  "signature": "public void setTimeZone(TimeZone zone)",
                  "description": "Sets the time zone for the calendar of this DateFormat object.\n This method is equivalent to the following call.\n \n getCalendar().setTimeZone(zone)\n \n\n The TimeZone set by this method is overwritten by a\n setCalendar call.\n\n The TimeZone set by this method may be overwritten as\n a result of a call to the parse method."
                }
              ]
            },
            {
              "name": "getTimeZone",
              "overloads": [
                {
                  "signature": "public TimeZone getTimeZone()",
                  "description": "Gets the time zone.\n This method is equivalent to the following call.\n \n getCalendar().getTimeZone()"
                }
              ]
            },
            {
              "name": "setLenient",
              "overloads": [
                {
                  "signature": "public void setLenient(boolean lenient)",
                  "description": "Specify whether or not date/time parsing is to be lenient.  With\n lenient parsing, the parser may use heuristics to interpret inputs that\n do not precisely match this object's format.  With strict parsing,\n inputs must match this object's format.\n\n This method is equivalent to the following call.\n \n getCalendar().setLenient(lenient)\n \n\n This leniency value is overwritten by a call to setCalendar()."
                }
              ]
            },
            {
              "name": "isLenient",
              "overloads": [
                {
                  "signature": "public boolean isLenient()",
                  "description": "Tell whether date/time parsing is to be lenient.\n This method is equivalent to the following call.\n \n getCalendar().isLenient()"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Overrides hashCode"
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals"
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            }
          ]
        },
        {
          "name": "DateFormat.Field",
          "methods": [
            {
              "name": "Field",
              "overloads": [
                {
                  "signature": "protected Field(String name, int calendarField)",
                  "description": "Creates a Field."
                }
              ]
            },
            {
              "name": "ofCalendarField",
              "overloads": [
                {
                  "signature": "public static DateFormat.Field ofCalendarField(int calendarField)",
                  "description": "Returns the Field constant that corresponds to\n the Calendar constant calendarField.\n If there is no direct mapping between the Calendar\n constant and a Field, null is returned."
                }
              ]
            },
            {
              "name": "getCalendarField",
              "overloads": [
                {
                  "signature": "public int getCalendarField()",
                  "description": "Returns the Calendar field associated with this\n attribute. For example, if this represents the hours field of\n a Calendar, this would return\n Calendar.HOUR. If there is no corresponding\n Calendar constant, this will return -1."
                }
              ]
            },
            {
              "name": "readResolve",
              "overloads": [
                {
                  "signature": "protected Object readResolve() throws InvalidObjectException",
                  "description": "Resolves instances being deserialized to the predefined constants."
                }
              ]
            }
          ]
        },
        {
          "name": "DateFormatSymbols",
          "methods": [
            {
              "name": "DateFormatSymbols",
              "overloads": [
                {
                  "signature": "public DateFormatSymbols()",
                  "description": "Construct a DateFormatSymbols object by loading format data from\n resources for the default FORMAT\n locale. This constructor can only\n construct instances for the locales supported by the Java\n runtime environment, not for those supported by installed\n DateFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n This is equivalent to calling\n DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public DateFormatSymbols(Locale locale)",
                  "description": "Construct a DateFormatSymbols object by loading format data from\n resources for the given locale. This constructor can only\n construct instances for the locales supported by the Java\n runtime environment, not for those supported by installed\n DateFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the\n Java runtime and by installed\n DateFormatSymbolsProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DateFormatSymbols getInstance()",
                  "description": "Gets the DateFormatSymbols instance for the default\n locale.  This method provides access to DateFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DateFormatSymbolsProvider\n implementations.\n This is equivalent to calling getInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DateFormatSymbols getInstance(Locale locale)",
                  "description": "Gets the DateFormatSymbols instance for the specified\n locale.  This method provides access to DateFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DateFormatSymbolsProvider\n implementations."
                }
              ]
            },
            {
              "name": "getEras",
              "overloads": [
                {
                  "signature": "public String[] getEras()",
                  "description": "Gets era strings. For example: \"AD\" and \"BC\"."
                }
              ]
            },
            {
              "name": "setEras",
              "overloads": [
                {
                  "signature": "public void setEras(String[] newEras)",
                  "description": "Sets era strings. For example: \"AD\" and \"BC\"."
                }
              ]
            },
            {
              "name": "getMonths",
              "overloads": [
                {
                  "signature": "public String[] getMonths()",
                  "description": "Gets month strings. For example: \"January\", \"February\", etc.\n An array with either 12 or 13 elements will be returned depending\n on whether or not Calendar.UNDECIMBER\n is supported. Use\n Calendar.JANUARY,\n Calendar.FEBRUARY,\n etc. to index the result array.\n\n If the language requires different forms for formatting and\n stand-alone usages, this method returns month names in the\n formatting form. For example, the preferred month name for\n January in the Czech language is ledna in the\n formatting form, while it is leden in the stand-alone\n form. This method returns \"ledna\" in this case. Refer\n to the \n Calendar Elements in the Unicode Locale Data Markup Language\n (LDML) specification for more details."
                }
              ]
            },
            {
              "name": "setMonths",
              "overloads": [
                {
                  "signature": "public void setMonths(String[] newMonths)",
                  "description": "Sets month strings. For example: \"January\", \"February\", etc."
                }
              ]
            },
            {
              "name": "getShortMonths",
              "overloads": [
                {
                  "signature": "public String[] getShortMonths()",
                  "description": "Gets short month strings. For example: \"Jan\", \"Feb\", etc.\n An array with either 12 or 13 elements will be returned depending\n on whether or not Calendar.UNDECIMBER\n is supported. Use\n Calendar.JANUARY,\n Calendar.FEBRUARY,\n etc. to index the result array.\n\n If the language requires different forms for formatting and\n stand-alone usages, this method returns short month names in\n the formatting form. For example, the preferred abbreviation\n for January in the Catalan language is de gen. in the\n formatting form, while it is gen. in the stand-alone\n form. This method returns \"de gen.\" in this case. Refer\n to the \n Calendar Elements in the Unicode Locale Data Markup Language\n (LDML) specification for more details."
                }
              ]
            },
            {
              "name": "setShortMonths",
              "overloads": [
                {
                  "signature": "public void setShortMonths(String[] newShortMonths)",
                  "description": "Sets short month strings. For example: \"Jan\", \"Feb\", etc."
                }
              ]
            },
            {
              "name": "getWeekdays",
              "overloads": [
                {
                  "signature": "public String[] getWeekdays()",
                  "description": "Gets weekday strings. For example: \"Sunday\", \"Monday\", etc."
                }
              ]
            },
            {
              "name": "setWeekdays",
              "overloads": [
                {
                  "signature": "public void setWeekdays(String[] newWeekdays)",
                  "description": "Sets weekday strings. For example: \"Sunday\", \"Monday\", etc."
                }
              ]
            },
            {
              "name": "getShortWeekdays",
              "overloads": [
                {
                  "signature": "public String[] getShortWeekdays()",
                  "description": "Gets short weekday strings. For example: \"Sun\", \"Mon\", etc."
                }
              ]
            },
            {
              "name": "setShortWeekdays",
              "overloads": [
                {
                  "signature": "public void setShortWeekdays(String[] newShortWeekdays)",
                  "description": "Sets short weekday strings. For example: \"Sun\", \"Mon\", etc."
                }
              ]
            },
            {
              "name": "getAmPmStrings",
              "overloads": [
                {
                  "signature": "public String[] getAmPmStrings()",
                  "description": "Gets ampm strings. For example: \"AM\" and \"PM\"."
                }
              ]
            },
            {
              "name": "setAmPmStrings",
              "overloads": [
                {
                  "signature": "public void setAmPmStrings(String[] newAmpms)",
                  "description": "Sets ampm strings. For example: \"AM\" and \"PM\"."
                }
              ]
            },
            {
              "name": "getZoneStrings",
              "overloads": [
                {
                  "signature": "public String[][] getZoneStrings()",
                  "description": "Gets time zone strings.  Use of this method is discouraged; use\n TimeZone.getDisplayName()\n instead.\n \n The value returned is a\n two-dimensional array of strings of size n by m,\n where m is at least 5.  Each of the n rows is an\n entry containing the localized names for a single TimeZone.\n Each such row contains (with i ranging from\n 0..n-1):\n \n zoneStrings[i][0] - time zone ID\n zoneStrings[i][1] - long name of zone in standard\n time\n zoneStrings[i][2] - short name of zone in\n standard time\n zoneStrings[i][3] - long name of zone in daylight\n saving time\n zoneStrings[i][4] - short name of zone in daylight\n saving time\n \n The zone ID is not localized; it's one of the valid IDs of\n the TimeZone class that are not\n custom IDs.\n All other entries are localized names.  If a zone does not implement\n daylight saving time, the daylight saving time names should not be used.\n \n If setZoneStrings has been called\n on this DateFormatSymbols instance, then the strings\n provided by that call are returned. Otherwise, the returned array\n contains names provided by the Java runtime and by installed\n TimeZoneNameProvider\n implementations."
                }
              ]
            },
            {
              "name": "setZoneStrings",
              "overloads": [
                {
                  "signature": "public void setZoneStrings(String[][] newZoneStrings)",
                  "description": "Sets time zone strings.  The argument must be a\n two-dimensional array of strings of size n by m,\n where m is at least 5.  Each of the n rows is an\n entry containing the localized names for a single TimeZone.\n Each such row contains (with i ranging from\n 0..n-1):\n \n zoneStrings[i][0] - time zone ID\n zoneStrings[i][1] - long name of zone in standard\n time\n zoneStrings[i][2] - short name of zone in\n standard time\n zoneStrings[i][3] - long name of zone in daylight\n saving time\n zoneStrings[i][4] - short name of zone in daylight\n saving time\n \n The zone ID is not localized; it's one of the valid IDs of\n the TimeZone class that are not\n custom IDs.\n All other entries are localized names."
                }
              ]
            },
            {
              "name": "getLocalPatternChars",
              "overloads": [
                {
                  "signature": "public String getLocalPatternChars()",
                  "description": "Gets localized date-time pattern characters. For example: 'u', 't', etc."
                }
              ]
            },
            {
              "name": "setLocalPatternChars",
              "overloads": [
                {
                  "signature": "public void setLocalPatternChars(String newLocalPatternChars)",
                  "description": "Sets localized date-time pattern characters. For example: 'u', 't', etc."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode.\n Generates a hash code for the DateFormatSymbols object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Override equals"
                }
              ]
            }
          ]
        },
        {
          "name": "DecimalFormat",
          "methods": [
            {
              "name": "DecimalFormat",
              "overloads": [
                {
                  "signature": "public DecimalFormat()",
                  "description": "Creates a DecimalFormat using the default pattern and symbols\n for the default FORMAT locale.\n This is a convenient way to obtain a\n DecimalFormat when internationalization is not the main concern.\n \n To obtain standard formats for a given locale, use the factory methods\n on NumberFormat such as getNumberInstance. These factories will\n return the most appropriate sub-class of NumberFormat for a given\n locale."
                },
                {
                  "signature": "public DecimalFormat(String pattern)",
                  "description": "Creates a DecimalFormat using the given pattern and the symbols\n for the default FORMAT locale.\n This is a convenient way to obtain a\n DecimalFormat when internationalization is not the main concern.\n \n To obtain standard formats for a given locale, use the factory methods\n on NumberFormat such as getNumberInstance. These factories will\n return the most appropriate sub-class of NumberFormat for a given\n locale."
                },
                {
                  "signature": "public DecimalFormat(String pattern, DecimalFormatSymbols symbols)",
                  "description": "Creates a DecimalFormat using the given pattern and symbols.\n Use this constructor when you need to completely customize the\n behavior of the format.\n \n To obtain standard formats for a given\n locale, use the factory methods on NumberFormat such as\n getInstance or getCurrencyInstance. If you need only minor adjustments\n to a standard format, you can modify the format returned by\n a NumberFormat factory method."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Formats a number and appends the resulting text to the given string\n buffer.\n The number can be of any subclass of Number.\n \n This implementation uses the maximum precision permitted."
                },
                {
                  "signature": "public StringBuffer format(double number, StringBuffer result, FieldPosition fieldPosition)",
                  "description": "Formats a double to produce a string."
                },
                {
                  "signature": "public StringBuffer format(long number, StringBuffer result, FieldPosition fieldPosition)",
                  "description": "Format a long to produce a string."
                }
              ]
            },
            {
              "name": "formatToCharacterIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
                  "description": "Formats an Object producing an AttributedCharacterIterator.\n You can use the returned AttributedCharacterIterator\n to build the resulting String, as well as to determine information\n about the resulting String.\n \n Each attribute key of the AttributedCharacterIterator will be of type\n NumberFormat.Field, with the attribute value being the\n same as the attribute key."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Number parse(String text, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Number.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n number is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n The subclass returned depends on the value of isParseBigDecimal()\n as well as on the string being parsed.\n \n   If isParseBigDecimal() is false (the default),\n       most integer values are returned as Long\n       objects, no matter how they are written: \"17\" and\n       \"17.000\" both parse to Long(17).\n       Values that cannot fit into a Long are returned as\n       Doubles. This includes values with a fractional part,\n       infinite values, NaN, and the value -0.0.\n       DecimalFormat does not decide whether to\n       return a Double or a Long based on the\n       presence of a decimal separator in the source string. Doing so\n       would prevent integers that overflow the mantissa of a double,\n       such as \"-9,223,372,036,854,775,808.00\", from being\n       parsed accurately.\n       \n       Callers may use the Number methods\n       doubleValue, longValue, etc., to obtain\n       the type they want.\n   If isParseBigDecimal() is true, values are returned\n       as BigDecimal objects. The values are the ones\n       constructed by BigDecimal(String)\n       for corresponding strings in locale-independent format. The\n       special cases negative and positive infinity and NaN are returned\n       as Double instances holding the values of the\n       corresponding Double constants.\n \n \n DecimalFormat parses all Unicode characters that represent\n decimal digits, as defined by Character.digit(). In\n addition, DecimalFormat also recognizes as digits the ten\n consecutive characters starting with the localized zero digit defined in\n the DecimalFormatSymbols object."
                }
              ]
            },
            {
              "name": "getDecimalFormatSymbols",
              "overloads": [
                {
                  "signature": "public DecimalFormatSymbols getDecimalFormatSymbols()",
                  "description": "Returns a copy of the decimal format symbols, which is generally not\n changed by the programmer or user."
                }
              ]
            },
            {
              "name": "setDecimalFormatSymbols",
              "overloads": [
                {
                  "signature": "public void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols)",
                  "description": "Sets the decimal format symbols, which is generally not changed\n by the programmer or user."
                }
              ]
            },
            {
              "name": "getPositivePrefix",
              "overloads": [
                {
                  "signature": "public String getPositivePrefix()",
                  "description": "Get the positive prefix.\n Examples: +123, $123, sFr123"
                }
              ]
            },
            {
              "name": "setPositivePrefix",
              "overloads": [
                {
                  "signature": "public void setPositivePrefix(String newValue)",
                  "description": "Set the positive prefix.\n Examples: +123, $123, sFr123"
                }
              ]
            },
            {
              "name": "getNegativePrefix",
              "overloads": [
                {
                  "signature": "public String getNegativePrefix()",
                  "description": "Get the negative prefix.\n Examples: -123, ($123) (with negative suffix), sFr-123"
                }
              ]
            },
            {
              "name": "setNegativePrefix",
              "overloads": [
                {
                  "signature": "public void setNegativePrefix(String newValue)",
                  "description": "Set the negative prefix.\n Examples: -123, ($123) (with negative suffix), sFr-123"
                }
              ]
            },
            {
              "name": "getPositiveSuffix",
              "overloads": [
                {
                  "signature": "public String getPositiveSuffix()",
                  "description": "Get the positive suffix.\n Example: 123%"
                }
              ]
            },
            {
              "name": "setPositiveSuffix",
              "overloads": [
                {
                  "signature": "public void setPositiveSuffix(String newValue)",
                  "description": "Set the positive suffix.\n Example: 123%"
                }
              ]
            },
            {
              "name": "getNegativeSuffix",
              "overloads": [
                {
                  "signature": "public String getNegativeSuffix()",
                  "description": "Get the negative suffix.\n Examples: -123%, ($123) (with positive suffixes)"
                }
              ]
            },
            {
              "name": "setNegativeSuffix",
              "overloads": [
                {
                  "signature": "public void setNegativeSuffix(String newValue)",
                  "description": "Set the negative suffix.\n Examples: 123%"
                }
              ]
            },
            {
              "name": "getMultiplier",
              "overloads": [
                {
                  "signature": "public int getMultiplier()",
                  "description": "Gets the multiplier for use in percent, per mille, and similar\n formats."
                }
              ]
            },
            {
              "name": "setMultiplier",
              "overloads": [
                {
                  "signature": "public void setMultiplier(int newValue)",
                  "description": "Sets the multiplier for use in percent, per mille, and similar\n formats.\n For a percent format, set the multiplier to 100 and the suffixes to\n have '%' (for Arabic, use the Arabic percent sign).\n For a per mille format, set the multiplier to 1000 and the suffixes to\n have '\\u2030'.\n\n Example: with multiplier 100, 1.23 is formatted as \"123\", and\n \"123\" is parsed into 1.23."
                }
              ]
            },
            {
              "name": "getGroupingSize",
              "overloads": [
                {
                  "signature": "public int getGroupingSize()",
                  "description": "Return the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number.  For example,\n in the number \"123,456.78\", the grouping size is 3. Grouping size of\n zero designates that grouping is not used, which provides the same\n formatting as if calling setGroupingUsed(false)."
                }
              ]
            },
            {
              "name": "setGroupingSize",
              "overloads": [
                {
                  "signature": "public void setGroupingSize(int newValue)",
                  "description": "Set the grouping size. Grouping size is the number of digits between\n grouping separators in the integer portion of a number.  For example,\n in the number \"123,456.78\", the grouping size is 3. Grouping size of\n zero designates that grouping is not used, which provides the same\n formatting as if calling setGroupingUsed(false).\n \n The value passed in is converted to a byte, which may lose information.\n Values that are negative or greater than\n Byte.MAX_VALUE, will throw an\n IllegalArgumentException."
                }
              ]
            },
            {
              "name": "isDecimalSeparatorAlwaysShown",
              "overloads": [
                {
                  "signature": "public boolean isDecimalSeparatorAlwaysShown()",
                  "description": "Allows you to get the behavior of the decimal separator with integers.\n (The decimal separator will always appear with decimals.)\n Example: Decimal ON: 12345  12345.; OFF: 12345  12345"
                }
              ]
            },
            {
              "name": "setDecimalSeparatorAlwaysShown",
              "overloads": [
                {
                  "signature": "public void setDecimalSeparatorAlwaysShown(boolean newValue)",
                  "description": "Allows you to set the behavior of the decimal separator with integers.\n (The decimal separator will always appear with decimals.)\n Example: Decimal ON: 12345  12345.; OFF: 12345  12345"
                }
              ]
            },
            {
              "name": "isParseBigDecimal",
              "overloads": [
                {
                  "signature": "public boolean isParseBigDecimal()",
                  "description": "Returns whether the parse(java.lang.String, java.text.ParsePosition)\n method returns BigDecimal. The default value is false."
                }
              ]
            },
            {
              "name": "setParseBigDecimal",
              "overloads": [
                {
                  "signature": "public void setParseBigDecimal(boolean newValue)",
                  "description": "Sets whether the parse(java.lang.String, java.text.ParsePosition)\n method returns BigDecimal."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Standard override; no change in semantics."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Overrides hashCode"
                }
              ]
            },
            {
              "name": "toPattern",
              "overloads": [
                {
                  "signature": "public String toPattern()",
                  "description": "Synthesizes a pattern string that represents the current state\n of this Format object."
                }
              ]
            },
            {
              "name": "toLocalizedPattern",
              "overloads": [
                {
                  "signature": "public String toLocalizedPattern()",
                  "description": "Synthesizes a localized pattern string that represents the current\n state of this Format object."
                }
              ]
            },
            {
              "name": "applyPattern",
              "overloads": [
                {
                  "signature": "public void applyPattern(String pattern)",
                  "description": "Apply the given pattern to this Format object.  A pattern is a\n short-hand specification for the various formatting properties.\n These properties can also be changed individually through the\n various setter methods.\n \n There is no limit to integer digits set\n by this routine, since that is the typical end-user desire;\n use setMaximumInteger if you want to set a real value.\n For negative numbers, use a second pattern, separated by a semicolon\n Example \"#,#00.0#\"  1,234.56\n This means a minimum of 2 integer digits, 1 fraction digit, and\n a maximum of 2 fraction digits.\n Example: \"#,#00.0#;(#,#00.0#)\" for negatives in\n parentheses.\n In negative patterns, the minimum and maximum counts are ignored;\n these are presumed to be set in the positive pattern."
                }
              ]
            },
            {
              "name": "applyLocalizedPattern",
              "overloads": [
                {
                  "signature": "public void applyLocalizedPattern(String pattern)",
                  "description": "Apply the given pattern to this Format object.  The pattern\n is assumed to be in a localized notation. A pattern is a\n short-hand specification for the various formatting properties.\n These properties can also be changed individually through the\n various setter methods.\n \n There is no limit to integer digits set\n by this routine, since that is the typical end-user desire;\n use setMaximumInteger if you want to set a real value.\n For negative numbers, use a second pattern, separated by a semicolon\n Example \"#,#00.0#\"  1,234.56\n This means a minimum of 2 integer digits, 1 fraction digit, and\n a maximum of 2 fraction digits.\n Example: \"#,#00.0#;(#,#00.0#)\" for negatives in\n parentheses.\n In negative patterns, the minimum and maximum counts are ignored;\n these are presumed to be set in the positive pattern."
                }
              ]
            },
            {
              "name": "setMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumIntegerDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of newValue and\n 309 is used. Negative input values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumIntegerDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of newValue and\n 309 is used. Negative input values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumFractionDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of newValue and\n 340 is used. Negative input values are replaced with 0."
                }
              ]
            },
            {
              "name": "setMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumFractionDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of newValue and\n 340 is used. Negative input values are replaced with 0."
                }
              ]
            },
            {
              "name": "getMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumIntegerDigits()",
                  "description": "Gets the maximum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of the return value and\n 309 is used."
                }
              ]
            },
            {
              "name": "getMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumIntegerDigits()",
                  "description": "Gets the minimum number of digits allowed in the integer portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of the return value and\n 309 is used."
                }
              ]
            },
            {
              "name": "getMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumFractionDigits()",
                  "description": "Gets the maximum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of the return value and\n 340 is used."
                }
              ]
            },
            {
              "name": "getMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumFractionDigits()",
                  "description": "Gets the minimum number of digits allowed in the fraction portion of a\n number.\n For formatting numbers other than BigInteger and\n BigDecimal objects, the lower of the return value and\n 340 is used."
                }
              ]
            },
            {
              "name": "getCurrency",
              "overloads": [
                {
                  "signature": "public Currency getCurrency()",
                  "description": "Gets the currency used by this decimal format when formatting\n currency values.\n The currency is obtained by calling\n DecimalFormatSymbols.getCurrency\n on this number format's symbols."
                }
              ]
            },
            {
              "name": "setCurrency",
              "overloads": [
                {
                  "signature": "public void setCurrency(Currency currency)",
                  "description": "Sets the currency used by this number format when formatting\n currency values. This does not update the minimum or maximum\n number of fraction digits used by the number format.\n The currency is set by calling\n DecimalFormatSymbols.setCurrency\n on this number format's symbols."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Gets the RoundingMode used in this DecimalFormat."
                }
              ]
            },
            {
              "name": "setRoundingMode",
              "overloads": [
                {
                  "signature": "public void setRoundingMode(RoundingMode roundingMode)",
                  "description": "Sets the RoundingMode used in this DecimalFormat."
                }
              ]
            }
          ]
        },
        {
          "name": "DecimalFormatSymbols",
          "methods": [
            {
              "name": "DecimalFormatSymbols",
              "overloads": [
                {
                  "signature": "public DecimalFormatSymbols()",
                  "description": "Create a DecimalFormatSymbols object for the default\n FORMAT locale.\n This constructor can only construct instances for the locales\n supported by the Java runtime environment, not for those\n supported by installed\n DecimalFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n This is equivalent to calling\n DecimalFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public DecimalFormatSymbols(Locale locale)",
                  "description": "Create a DecimalFormatSymbols object for the given locale.\n This constructor can only construct instances for the locales\n supported by the Java runtime environment, not for those\n supported by installed\n DecimalFormatSymbolsProvider\n implementations. For full locale coverage, use the\n getInstance method.\n If the specified locale contains the Locale.UNICODE_LOCALE_EXTENSION\n for the numbering system, the instance is initialized with the specified numbering\n system if the JRE implementation supports it. For example,\n  NumberFormat.getNumberInstance(Locale.forLanguageTag(\"th-TH-u-nu-thai\"))\n \n This may return a NumberFormat instance with the Thai numbering system,\n instead of the Latin numbering system."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n DecimalFormatSymbolsProvider\n implementations.  It must contain at least a Locale\n instance equal to Locale.US."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final DecimalFormatSymbols getInstance()",
                  "description": "Gets the DecimalFormatSymbols instance for the default\n locale.  This method provides access to DecimalFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DecimalFormatSymbolsProvider implementations.\n This is equivalent to calling\n getInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static final DecimalFormatSymbols getInstance(Locale locale)",
                  "description": "Gets the DecimalFormatSymbols instance for the specified\n locale.  This method provides access to DecimalFormatSymbols\n instances for locales supported by the Java runtime itself as well\n as for those supported by installed\n DecimalFormatSymbolsProvider implementations.\n If the specified locale contains the Locale.UNICODE_LOCALE_EXTENSION\n for the numbering system, the instance is initialized with the specified numbering\n system if the JRE implementation supports it. For example,\n  NumberFormat.getNumberInstance(Locale.forLanguageTag(\"th-TH-u-nu-thai\"))\n \n This may return a NumberFormat instance with the Thai numbering system,\n instead of the Latin numbering system."
                }
              ]
            },
            {
              "name": "getZeroDigit",
              "overloads": [
                {
                  "signature": "public char getZeroDigit()",
                  "description": "Gets the character used for zero. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setZeroDigit",
              "overloads": [
                {
                  "signature": "public void setZeroDigit(char zeroDigit)",
                  "description": "Sets the character used for zero. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getGroupingSeparator",
              "overloads": [
                {
                  "signature": "public char getGroupingSeparator()",
                  "description": "Gets the character used for grouping separator. Different for French, etc."
                }
              ]
            },
            {
              "name": "setGroupingSeparator",
              "overloads": [
                {
                  "signature": "public void setGroupingSeparator(char groupingSeparator)",
                  "description": "Sets the character used for grouping separator. Different for French, etc."
                }
              ]
            },
            {
              "name": "getDecimalSeparator",
              "overloads": [
                {
                  "signature": "public char getDecimalSeparator()",
                  "description": "Gets the character used for decimal sign. Different for French, etc."
                }
              ]
            },
            {
              "name": "setDecimalSeparator",
              "overloads": [
                {
                  "signature": "public void setDecimalSeparator(char decimalSeparator)",
                  "description": "Sets the character used for decimal sign. Different for French, etc."
                }
              ]
            },
            {
              "name": "getPerMill",
              "overloads": [
                {
                  "signature": "public char getPerMill()",
                  "description": "Gets the character used for per mille sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setPerMill",
              "overloads": [
                {
                  "signature": "public void setPerMill(char perMill)",
                  "description": "Sets the character used for per mille sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getPercent",
              "overloads": [
                {
                  "signature": "public char getPercent()",
                  "description": "Gets the character used for percent sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "setPercent",
              "overloads": [
                {
                  "signature": "public void setPercent(char percent)",
                  "description": "Sets the character used for percent sign. Different for Arabic, etc."
                }
              ]
            },
            {
              "name": "getDigit",
              "overloads": [
                {
                  "signature": "public char getDigit()",
                  "description": "Gets the character used for a digit in a pattern."
                }
              ]
            },
            {
              "name": "setDigit",
              "overloads": [
                {
                  "signature": "public void setDigit(char digit)",
                  "description": "Sets the character used for a digit in a pattern."
                }
              ]
            },
            {
              "name": "getPatternSeparator",
              "overloads": [
                {
                  "signature": "public char getPatternSeparator()",
                  "description": "Gets the character used to separate positive and negative subpatterns\n in a pattern."
                }
              ]
            },
            {
              "name": "setPatternSeparator",
              "overloads": [
                {
                  "signature": "public void setPatternSeparator(char patternSeparator)",
                  "description": "Sets the character used to separate positive and negative subpatterns\n in a pattern."
                }
              ]
            },
            {
              "name": "getInfinity",
              "overloads": [
                {
                  "signature": "public String getInfinity()",
                  "description": "Gets the string used to represent infinity. Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "setInfinity",
              "overloads": [
                {
                  "signature": "public void setInfinity(String infinity)",
                  "description": "Sets the string used to represent infinity. Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "getNaN",
              "overloads": [
                {
                  "signature": "public String getNaN()",
                  "description": "Gets the string used to represent \"not a number\". Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "setNaN",
              "overloads": [
                {
                  "signature": "public void setNaN(String NaN)",
                  "description": "Sets the string used to represent \"not a number\". Almost always left\n unchanged."
                }
              ]
            },
            {
              "name": "getMinusSign",
              "overloads": [
                {
                  "signature": "public char getMinusSign()",
                  "description": "Gets the character used to represent minus sign. If no explicit\n negative format is specified, one is formed by prefixing\n minusSign to the positive format."
                }
              ]
            },
            {
              "name": "setMinusSign",
              "overloads": [
                {
                  "signature": "public void setMinusSign(char minusSign)",
                  "description": "Sets the character used to represent minus sign. If no explicit\n negative format is specified, one is formed by prefixing\n minusSign to the positive format."
                }
              ]
            },
            {
              "name": "getCurrencySymbol",
              "overloads": [
                {
                  "signature": "public String getCurrencySymbol()",
                  "description": "Returns the currency symbol for the currency of these\n DecimalFormatSymbols in their locale."
                }
              ]
            },
            {
              "name": "setCurrencySymbol",
              "overloads": [
                {
                  "signature": "public void setCurrencySymbol(String currency)",
                  "description": "Sets the currency symbol for the currency of these\n DecimalFormatSymbols in their locale."
                }
              ]
            },
            {
              "name": "getInternationalCurrencySymbol",
              "overloads": [
                {
                  "signature": "public String getInternationalCurrencySymbol()",
                  "description": "Returns the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols."
                }
              ]
            },
            {
              "name": "setInternationalCurrencySymbol",
              "overloads": [
                {
                  "signature": "public void setInternationalCurrencySymbol(String currencyCode)",
                  "description": "Sets the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols.\n If the currency code is valid (as defined by\n Currency.getInstance),\n this also sets the currency attribute to the corresponding Currency\n instance and the currency symbol attribute to the currency's symbol\n in the DecimalFormatSymbols' locale. If the currency code is not valid,\n then the currency attribute is set to null and the currency symbol\n attribute is not modified."
                }
              ]
            },
            {
              "name": "getCurrency",
              "overloads": [
                {
                  "signature": "public Currency getCurrency()",
                  "description": "Gets the currency of these DecimalFormatSymbols. May be null if the\n currency symbol attribute was previously set to a value that's not\n a valid ISO 4217 currency code."
                }
              ]
            },
            {
              "name": "setCurrency",
              "overloads": [
                {
                  "signature": "public void setCurrency(Currency currency)",
                  "description": "Sets the currency of these DecimalFormatSymbols.\n This also sets the currency symbol attribute to the currency's symbol\n in the DecimalFormatSymbols' locale, and the international currency\n symbol attribute to the currency's ISO 4217 currency code."
                }
              ]
            },
            {
              "name": "getMonetaryDecimalSeparator",
              "overloads": [
                {
                  "signature": "public char getMonetaryDecimalSeparator()",
                  "description": "Returns the monetary decimal separator."
                }
              ]
            },
            {
              "name": "setMonetaryDecimalSeparator",
              "overloads": [
                {
                  "signature": "public void setMonetaryDecimalSeparator(char sep)",
                  "description": "Sets the monetary decimal separator."
                }
              ]
            },
            {
              "name": "getExponentSeparator",
              "overloads": [
                {
                  "signature": "public String getExponentSeparator()",
                  "description": "Returns the string used to separate the mantissa from the exponent.\n Examples: \"x10^\" for 1.23x10^4, \"E\" for 1.23E4."
                }
              ]
            },
            {
              "name": "setExponentSeparator",
              "overloads": [
                {
                  "signature": "public void setExponentSeparator(String exp)",
                  "description": "Sets the string used to separate the mantissa from the exponent.\n Examples: \"x10^\" for 1.23x10^4, \"E\" for 1.23E4."
                }
              ]
            },
            {
              "name": "getMonetaryGroupingSeparator",
              "overloads": [
                {
                  "signature": "public char getMonetaryGroupingSeparator()",
                  "description": "Gets the character used for grouping separator for currencies.\n May be different from grouping separator in some locales,\n e.g, German in Austria."
                }
              ]
            },
            {
              "name": "setMonetaryGroupingSeparator",
              "overloads": [
                {
                  "signature": "public void setMonetaryGroupingSeparator(char monetaryGroupingSeparator)",
                  "description": "Sets the character used for grouping separator for currencies.\n Invocation of this method will not affect the normal\n grouping separator."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Standard override."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Override equals."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Override hashCode."
                }
              ]
            }
          ]
        },
        {
          "name": "FieldPosition",
          "methods": [
            {
              "name": "FieldPosition",
              "overloads": [
                {
                  "signature": "public FieldPosition(int field)",
                  "description": "Creates a FieldPosition object for the given field.  Fields are\n identified by constants, whose names typically end with _FIELD,\n in the various subclasses of Format."
                },
                {
                  "signature": "public FieldPosition(Format.Field attribute)",
                  "description": "Creates a FieldPosition object for the given field constant. Fields are\n identified by constants defined in the various Format\n subclasses. This is equivalent to calling\n new FieldPosition(attribute, -1)."
                },
                {
                  "signature": "public FieldPosition(Format.Field attribute, int fieldID)",
                  "description": "Creates a FieldPosition object for the given field.\n The field is identified by an attribute constant from one of the\n Field subclasses as well as an integer field ID\n defined by the Format subclasses. Format\n subclasses that are aware of Field should give precedence\n to attribute and ignore fieldID if\n attribute is not null. However, older Format\n subclasses may not be aware of Field and rely on\n fieldID. If the field has no corresponding integer\n constant, fieldID should be -1."
                }
              ]
            },
            {
              "name": "getFieldAttribute",
              "overloads": [
                {
                  "signature": "public Format.Field getFieldAttribute()",
                  "description": "Returns the field identifier as an attribute constant\n from one of the Field subclasses. May return null if\n the field is specified only by an integer field ID."
                }
              ]
            },
            {
              "name": "getField",
              "overloads": [
                {
                  "signature": "public int getField()",
                  "description": "Retrieves the field identifier."
                }
              ]
            },
            {
              "name": "getBeginIndex",
              "overloads": [
                {
                  "signature": "public int getBeginIndex()",
                  "description": "Retrieves the index of the first character in the requested field."
                }
              ]
            },
            {
              "name": "getEndIndex",
              "overloads": [
                {
                  "signature": "public int getEndIndex()",
                  "description": "Retrieves the index of the character following the last character in the\n requested field."
                }
              ]
            },
            {
              "name": "setBeginIndex",
              "overloads": [
                {
                  "signature": "public void setBeginIndex(int bi)",
                  "description": "Sets the begin index.  For use by subclasses of Format."
                }
              ]
            },
            {
              "name": "setEndIndex",
              "overloads": [
                {
                  "signature": "public void setEndIndex(int ei)",
                  "description": "Sets the end index.  For use by subclasses of Format."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this FieldPosition."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string representation of this FieldPosition."
                }
              ]
            }
          ]
        },
        {
          "name": "Format",
          "methods": [
            {
              "name": "Format",
              "overloads": [
                {
                  "signature": "protected Format()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final String format(Object obj)",
                  "description": "Formats an object to produce a string. This is equivalent to\n \n format(obj,\n         new StringBuffer(), new FieldPosition(0)).toString();"
                },
                {
                  "signature": "public abstract StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Formats an object and appends the resulting text to a given string\n buffer.\n If the pos argument identifies a field used by the format,\n then its indices are set to the beginning and end of the first such\n field encountered."
                }
              ]
            },
            {
              "name": "formatToCharacterIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
                  "description": "Formats an Object producing an AttributedCharacterIterator.\n You can use the returned AttributedCharacterIterator\n to build the resulting String, as well as to determine information\n about the resulting String.\n \n Each attribute key of the AttributedCharacterIterator will be of type\n Field. It is up to each Format implementation\n to define what the legal values are for each attribute in the\n AttributedCharacterIterator, but typically the attribute\n key is also used as the attribute value.\n The default implementation creates an\n AttributedCharacterIterator with no attributes. Subclasses\n that support fields should override this and create an\n AttributedCharacterIterator with meaningful attributes."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public abstract Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce an object.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n object is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned."
                },
                {
                  "signature": "public Object parseObject(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce an object.\n The method may not use the entire text of the given string."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates and returns a copy of this object."
                }
              ]
            }
          ]
        },
        {
          "name": "Format.Field",
          "methods": [
            {
              "name": "Field",
              "overloads": [
                {
                  "signature": "protected Field(String name)",
                  "description": "Creates a Field with the specified name."
                }
              ]
            }
          ]
        },
        {
          "name": "MessageFormat",
          "methods": [
            {
              "name": "MessageFormat",
              "overloads": [
                {
                  "signature": "public MessageFormat(String pattern)",
                  "description": "Constructs a MessageFormat for the default\n FORMAT locale and the\n specified pattern.\n The constructor first sets the locale, then parses the pattern and\n creates a list of subformats for the format elements contained in it.\n Patterns and their interpretation are specified in the\n class description."
                },
                {
                  "signature": "public MessageFormat(String pattern, Locale locale)",
                  "description": "Constructs a MessageFormat for the specified locale and\n pattern.\n The constructor first sets the locale, then parses the pattern and\n creates a list of subformats for the format elements contained in it.\n Patterns and their interpretation are specified in the\n class description."
                }
              ]
            },
            {
              "name": "setLocale",
              "overloads": [
                {
                  "signature": "public void setLocale(Locale locale)",
                  "description": "Sets the locale to be used when creating or comparing subformats.\n This affects subsequent calls\n \n to the applyPattern\n     and toPattern methods if format elements specify\n     a format type and therefore have the subformats created in the\n     applyPattern method, as well as\n to the format and\n     formatToCharacterIterator methods\n     if format elements do not specify a format type and therefore have\n     the subformats created in the formatting methods.\n \n Subformats that have already been created are not affected."
                }
              ]
            },
            {
              "name": "getLocale",
              "overloads": [
                {
                  "signature": "public Locale getLocale()",
                  "description": "Gets the locale that's used when creating or comparing subformats."
                }
              ]
            },
            {
              "name": "applyPattern",
              "overloads": [
                {
                  "signature": "public void applyPattern(String pattern)",
                  "description": "Sets the pattern used by this message format.\n The method parses the pattern and creates a list of subformats\n for the format elements contained in it.\n Patterns and their interpretation are specified in the\n class description."
                }
              ]
            },
            {
              "name": "toPattern",
              "overloads": [
                {
                  "signature": "public String toPattern()",
                  "description": "Returns a pattern representing the current state of the message format.\n The string is constructed from internal information and therefore\n does not necessarily equal the previously applied pattern."
                }
              ]
            },
            {
              "name": "setFormatsByArgumentIndex",
              "overloads": [
                {
                  "signature": "public void setFormatsByArgumentIndex(Format[] newFormats)",
                  "description": "Sets the formats to use for the values passed into\n format methods or returned from parse\n methods. The indices of elements in newFormats\n correspond to the argument indices used in the previously set\n pattern string.\n The order of formats in newFormats thus corresponds to\n the order of elements in the arguments array passed\n to the format methods or the result array returned\n by the parse methods.\n \n If an argument index is used for more than one format element\n in the pattern string, then the corresponding new format is used\n for all such format elements. If an argument index is not used\n for any format element in the pattern string, then the\n corresponding new format is ignored. If fewer formats are provided\n than needed, then only the formats for argument indices less\n than newFormats.length are replaced."
                }
              ]
            },
            {
              "name": "setFormats",
              "overloads": [
                {
                  "signature": "public void setFormats(Format[] newFormats)",
                  "description": "Sets the formats to use for the format elements in the\n previously set pattern string.\n The order of formats in newFormats corresponds to\n the order of format elements in the pattern string.\n \n If more formats are provided than needed by the pattern string,\n the remaining ones are ignored. If fewer formats are provided\n than needed, then only the first newFormats.length\n formats are replaced.\n \n Since the order of format elements in a pattern string often\n changes during localization, it is generally better to use the\n setFormatsByArgumentIndex\n method, which assumes an order of formats corresponding to the\n order of elements in the arguments array passed to\n the format methods or the result array returned by\n the parse methods."
                }
              ]
            },
            {
              "name": "setFormatByArgumentIndex",
              "overloads": [
                {
                  "signature": "public void setFormatByArgumentIndex(int argumentIndex, Format newFormat)",
                  "description": "Sets the format to use for the format elements within the\n previously set pattern string that use the given argument\n index.\n The argument index is part of the format element definition and\n represents an index into the arguments array passed\n to the format methods or the result array returned\n by the parse methods.\n \n If the argument index is used for more than one format element\n in the pattern string, then the new format is used for all such\n format elements. If the argument index is not used for any format\n element in the pattern string, then the new format is ignored."
                }
              ]
            },
            {
              "name": "setFormat",
              "overloads": [
                {
                  "signature": "public void setFormat(int formatElementIndex, Format newFormat)",
                  "description": "Sets the format to use for the format element with the given\n format element index within the previously set pattern string.\n The format element index is the zero-based number of the format\n element counting from the start of the pattern string.\n \n Since the order of format elements in a pattern string often\n changes during localization, it is generally better to use the\n setFormatByArgumentIndex\n method, which accesses format elements based on the argument\n index they specify."
                }
              ]
            },
            {
              "name": "getFormatsByArgumentIndex",
              "overloads": [
                {
                  "signature": "public Format[] getFormatsByArgumentIndex()",
                  "description": "Gets the formats used for the values passed into\n format methods or returned from parse\n methods. The indices of elements in the returned array\n correspond to the argument indices used in the previously set\n pattern string.\n The order of formats in the returned array thus corresponds to\n the order of elements in the arguments array passed\n to the format methods or the result array returned\n by the parse methods.\n \n If an argument index is used for more than one format element\n in the pattern string, then the format used for the last such\n format element is returned in the array. If an argument index\n is not used for any format element in the pattern string, then\n null is returned in the array."
                }
              ]
            },
            {
              "name": "getFormats",
              "overloads": [
                {
                  "signature": "public Format[] getFormats()",
                  "description": "Gets the formats used for the format elements in the\n previously set pattern string.\n The order of formats in the returned array corresponds to\n the order of format elements in the pattern string.\n \n Since the order of format elements in a pattern string often\n changes during localization, it's generally better to use the\n getFormatsByArgumentIndex\n method, which assumes an order of formats corresponding to the\n order of elements in the arguments array passed to\n the format methods or the result array returned by\n the parse methods."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public final StringBuffer format(Object[] arguments, StringBuffer result, FieldPosition pos)",
                  "description": "Formats an array of objects and appends the MessageFormat's\n pattern, with format elements replaced by the formatted objects, to the\n provided StringBuffer.\n \n The text substituted for the individual format elements is derived from\n the current subformat of the format element and the\n arguments element at the format element's argument index\n as indicated by the first matching line of the following table. An\n argument is unavailable if arguments is\n null or has fewer than argumentIndex+1 elements.\n\n \n Examples of subformat,argument,and formatted text\n \n    \n       Subformat\n       Argument\n       Formatted Text\n \n \n    \n       any\n       unavailable\n       \"{\" + argumentIndex + \"}\"\n    \n       null\n       \"null\"\n    \n       instanceof ChoiceFormat\n       any\n       subformat.format(argument).indexOf('{') >= 0 ?\n           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :\n           subformat.format(argument)\n    \n       != null\n       any\n       subformat.format(argument)\n    \n       null\n       instanceof Number\n       NumberFormat.getInstance(getLocale()).format(argument)\n    \n       instanceof Date\n       DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)\n    \n       instanceof String\n       argument\n    \n       any\n       argument.toString()\n \n \n \n If pos is non-null, and refers to\n Field.ARGUMENT, the location of the first formatted\n string will be returned."
                },
                {
                  "signature": "public static String format(String pattern, Object... arguments)",
                  "description": "Creates a MessageFormat with the given pattern and uses it\n to format the given arguments. This is equivalent to\n \n     (new MessageFormat(pattern)).format(arguments, new StringBuffer(), null).toString()"
                },
                {
                  "signature": "public final StringBuffer format(Object arguments, StringBuffer result, FieldPosition pos)",
                  "description": "Formats an array of objects and appends the MessageFormat's\n pattern, with format elements replaced by the formatted objects, to the\n provided StringBuffer.\n This is equivalent to\n \n     format((Object[]) arguments, result, pos)"
                }
              ]
            },
            {
              "name": "formatToCharacterIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator formatToCharacterIterator(Object arguments)",
                  "description": "Formats an array of objects and inserts them into the\n MessageFormat's pattern, producing an\n AttributedCharacterIterator.\n You can use the returned AttributedCharacterIterator\n to build the resulting String, as well as to determine information\n about the resulting String.\n \n The text of the returned AttributedCharacterIterator is\n the same that would be returned by\n \n     format(arguments, new StringBuffer(), null).toString()\n \n \n In addition, the AttributedCharacterIterator contains at\n least attributes indicating where text was generated from an\n argument in the arguments array. The keys of these attributes are of\n type MessageFormat.Field, their values are\n Integer objects indicating the index in the arguments\n array of the argument from which the text was generated.\n \n The attributes/value from the underlying Format\n instances that MessageFormat uses will also be\n placed in the resulting AttributedCharacterIterator.\n This allows you to not only find where an argument is placed in the\n resulting String, but also which fields it contains in turn."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Object[] parse(String source, ParsePosition pos)",
                  "description": "Parses the string.\n\n Caveats: The parse may fail in a number of circumstances.\n For example:\n \n If one of the arguments does not occur in the pattern.\n If the format of an argument loses information, such as\n     with a choice format where a large number formats to \"many\".\n Does not yet handle recursion (where\n     the substituted strings contain {n} references.)\n Will not always find a match (or the correct match)\n     if some part of the parse is ambiguous.\n     For example, if the pattern \"{1},{2}\" is used with the\n     string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\".\n     When the result is parsed, it will return {\"a\", \"b,c\"}.\n If a single argument is parsed more than once in the string,\n     then the later parse wins.\n \n When the parse fails, use ParsePosition.getErrorIndex() to find out\n where in the string the parsing failed.  The returned error\n index is the starting offset of the sub-patterns that the string\n is comparing with.  For example, if the parsing string \"AAA {0} BBB\"\n is comparing against the pattern \"AAD {0} BBB\", the error index is\n 0. When an error occurs, the call to this method will return null.\n If the source is null, return an empty array."
                },
                {
                  "signature": "public Object[] parse(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce an object\n array.\n The method may not use the entire text of the given string.\n \n See the parse(String, ParsePosition) method for more information\n on message parsing."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce an object array.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n object array is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n See the parse(String, ParsePosition) method for more information\n on message parsing."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates and returns a copy of this object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Equality comparison between two message format objects"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Generates a hash code for the message format object."
                }
              ]
            }
          ]
        },
        {
          "name": "MessageFormat.Field",
          "methods": [
            {
              "name": "Field",
              "overloads": [
                {
                  "signature": "protected Field(String name)",
                  "description": "Creates a Field with the specified name."
                }
              ]
            },
            {
              "name": "readResolve",
              "overloads": [
                {
                  "signature": "protected Object readResolve() throws InvalidObjectException",
                  "description": "Resolves instances being deserialized to the predefined constants."
                }
              ]
            }
          ]
        },
        {
          "name": "Normalizer",
          "methods": [
            {
              "name": "normalize",
              "overloads": [
                {
                  "signature": "public static String normalize(CharSequence src, Normalizer.Form form)",
                  "description": "Normalize a sequence of char values.\n The sequence will be normalized according to the specified normalization\n form."
                }
              ]
            },
            {
              "name": "isNormalized",
              "overloads": [
                {
                  "signature": "public static boolean isNormalized(CharSequence src, Normalizer.Form form)",
                  "description": "Determines if the given sequence of char values is normalized."
                }
              ]
            }
          ]
        },
        {
          "name": "NumberFormat",
          "methods": [
            {
              "name": "NumberFormat",
              "overloads": [
                {
                  "signature": "protected NumberFormat()",
                  "description": "Sole constructor.  (For invocation by subclass constructors, typically\n implicit.)"
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Formats a number and appends the resulting text to the given string\n buffer.\n The number can be of any subclass of Number.\n \n This implementation extracts the number's value using\n Number.longValue() for all integral type values that\n can be converted to long without loss of information,\n including BigInteger values with a\n bit length of less than 64,\n and Number.doubleValue() for all other types. It\n then calls\n format(long,java.lang.StringBuffer,java.text.FieldPosition)\n or format(double,java.lang.StringBuffer,java.text.FieldPosition).\n This may result in loss of magnitude information and precision for\n BigInteger and BigDecimal values."
                },
                {
                  "signature": "public final String format(double number)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public final String format(long number)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Specialization of format."
                },
                {
                  "signature": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Specialization of format."
                }
              ]
            },
            {
              "name": "parseObject",
              "overloads": [
                {
                  "signature": "public final Object parseObject(String source, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Number.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n number is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n \n See the parse(String, ParsePosition) method for more information\n on number parsing."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public abstract Number parse(String source, ParsePosition parsePosition)",
                  "description": "Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n Long.MAX_VALUE] and with no decimals), otherwise a Double.\n If IntegerOnly is set, will stop at a decimal\n point (or equivalent; e.g., for rational numbers \"1 2/3\", will stop\n after the 1).\n Does not throw an exception; if no object can be parsed, index is\n unchanged!"
                },
                {
                  "signature": "public Number parse(String source) throws ParseException",
                  "description": "Parses text from the beginning of the given string to produce a number.\n The method may not use the entire text of the given string.\n \n See the parse(String, ParsePosition) method for more information\n on number parsing."
                }
              ]
            },
            {
              "name": "isParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public boolean isParseIntegerOnly()",
                  "description": "Returns true if this format will parse numbers as integers only.\n For example in the English locale, with ParseIntegerOnly true, the\n string \"1234.\" would be parsed as the integer value 1234 and parsing\n would stop at the \".\" character.  Of course, the exact format accepted\n by the parse operation is locale dependent and determined by sub-classes\n of NumberFormat."
                }
              ]
            },
            {
              "name": "setParseIntegerOnly",
              "overloads": [
                {
                  "signature": "public void setParseIntegerOnly(boolean value)",
                  "description": "Sets whether or not numbers should be parsed as integers only."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getInstance()",
                  "description": "Returns a general-purpose number format for the current default\n FORMAT locale.\n This is the same as calling\n getNumberInstance()."
                },
                {
                  "signature": "public static NumberFormat getInstance(Locale inLocale)",
                  "description": "Returns a general-purpose number format for the specified locale.\n This is the same as calling\n getNumberInstance(inLocale)."
                }
              ]
            },
            {
              "name": "getNumberInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getNumberInstance()",
                  "description": "Returns a general-purpose number format for the current default\n FORMAT locale.\n This is equivalent to calling\n getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getNumberInstance(Locale inLocale)",
                  "description": "Returns a general-purpose number format for the specified locale."
                }
              ]
            },
            {
              "name": "getIntegerInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getIntegerInstance()",
                  "description": "Returns an integer number format for the current default\n FORMAT locale. The\n returned number format is configured to round floating point numbers\n to the nearest integer using half-even rounding (see RoundingMode.HALF_EVEN) for formatting,\n and to parse only the integer part of an input string (see isParseIntegerOnly).\n This is equivalent to calling\n getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getIntegerInstance(Locale inLocale)",
                  "description": "Returns an integer number format for the specified locale. The\n returned number format is configured to round floating point numbers\n to the nearest integer using half-even rounding (see RoundingMode.HALF_EVEN) for formatting,\n and to parse only the integer part of an input string (see isParseIntegerOnly)."
                }
              ]
            },
            {
              "name": "getCurrencyInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getCurrencyInstance()",
                  "description": "Returns a currency format for the current default\n FORMAT locale.\n This is equivalent to calling\n getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getCurrencyInstance(Locale inLocale)",
                  "description": "Returns a currency format for the specified locale.\n\n If the specified locale contains the \"cf\" (\n \n currency format style)\n Unicode extension,\n the returned currency format uses the style if it is available.\n Otherwise, the style uses the default \"standard\" currency format.\n For example, if the style designates \"account\", negative\n currency amounts use a pair of parentheses in some locales."
                }
              ]
            },
            {
              "name": "getPercentInstance",
              "overloads": [
                {
                  "signature": "public static final NumberFormat getPercentInstance()",
                  "description": "Returns a percentage format for the current default\n FORMAT locale.\n This is equivalent to calling\n getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public static NumberFormat getPercentInstance(Locale inLocale)",
                  "description": "Returns a percentage format for the specified locale."
                }
              ]
            },
            {
              "name": "getCompactNumberInstance",
              "overloads": [
                {
                  "signature": "public static NumberFormat getCompactNumberInstance()",
                  "description": "Returns a compact number format for the default\n FORMAT locale with\n \"SHORT\" format style."
                },
                {
                  "signature": "public static NumberFormat getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle)",
                  "description": "Returns a compact number format for the specified locale\n and formatStyle."
                }
              ]
            },
            {
              "name": "getAvailableLocales",
              "overloads": [
                {
                  "signature": "public static Locale[] getAvailableLocales()",
                  "description": "Returns an array of all locales for which the\n get*Instance methods of this class can return\n localized instances.\n The returned array represents the union of locales supported by the Java\n runtime and by installed\n NumberFormatProvider implementations.\n It must contain at least a Locale instance equal to\n Locale.US."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Overrides hashCode."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Overrides Cloneable."
                }
              ]
            },
            {
              "name": "isGroupingUsed",
              "overloads": [
                {
                  "signature": "public boolean isGroupingUsed()",
                  "description": "Returns true if grouping is used in this format. For example, in the\n English locale, with grouping on, the number 1234567 might be formatted\n as \"1,234,567\". The grouping separator as well as the size of each group\n is locale dependent and is determined by sub-classes of NumberFormat."
                }
              ]
            },
            {
              "name": "setGroupingUsed",
              "overloads": [
                {
                  "signature": "public void setGroupingUsed(boolean newValue)",
                  "description": "Set whether or not grouping will be used in this format."
                }
              ]
            },
            {
              "name": "getMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumIntegerDigits()",
                  "description": "Returns the maximum number of digits allowed in the integer portion of a\n number."
                }
              ]
            },
            {
              "name": "setMaximumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumIntegerDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the integer portion of a\n number. maximumIntegerDigits must be  minimumIntegerDigits.  If the\n new value for maximumIntegerDigits is less than the current value\n of minimumIntegerDigits, then minimumIntegerDigits will also be set to\n the new value."
                }
              ]
            },
            {
              "name": "getMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumIntegerDigits()",
                  "description": "Returns the minimum number of digits allowed in the integer portion of a\n number."
                }
              ]
            },
            {
              "name": "setMinimumIntegerDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumIntegerDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the integer portion of a\n number. minimumIntegerDigits must be  maximumIntegerDigits.  If the\n new value for minimumIntegerDigits exceeds the current value\n of maximumIntegerDigits, then maximumIntegerDigits will also be set to\n the new value"
                }
              ]
            },
            {
              "name": "getMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMaximumFractionDigits()",
                  "description": "Returns the maximum number of digits allowed in the fraction portion of a\n number."
                }
              ]
            },
            {
              "name": "setMaximumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMaximumFractionDigits(int newValue)",
                  "description": "Sets the maximum number of digits allowed in the fraction portion of a\n number. maximumFractionDigits must be  minimumFractionDigits.  If the\n new value for maximumFractionDigits is less than the current value\n of minimumFractionDigits, then minimumFractionDigits will also be set to\n the new value."
                }
              ]
            },
            {
              "name": "getMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public int getMinimumFractionDigits()",
                  "description": "Returns the minimum number of digits allowed in the fraction portion of a\n number."
                }
              ]
            },
            {
              "name": "setMinimumFractionDigits",
              "overloads": [
                {
                  "signature": "public void setMinimumFractionDigits(int newValue)",
                  "description": "Sets the minimum number of digits allowed in the fraction portion of a\n number. minimumFractionDigits must be  maximumFractionDigits.  If the\n new value for minimumFractionDigits exceeds the current value\n of maximumFractionDigits, then maximumFractionDigits will also be set to\n the new value"
                }
              ]
            },
            {
              "name": "getCurrency",
              "overloads": [
                {
                  "signature": "public Currency getCurrency()",
                  "description": "Gets the currency used by this number format when formatting\n currency values. The initial value is derived in a locale dependent\n way. The returned value may be null if no valid\n currency could be determined and no currency has been set using\n setCurrency.\n \n The default implementation throws\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "setCurrency",
              "overloads": [
                {
                  "signature": "public void setCurrency(Currency currency)",
                  "description": "Sets the currency used by this number format when formatting\n currency values. This does not update the minimum or maximum\n number of fraction digits used by the number format.\n \n The default implementation throws\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "getRoundingMode",
              "overloads": [
                {
                  "signature": "public RoundingMode getRoundingMode()",
                  "description": "Gets the RoundingMode used in this NumberFormat.\n The default implementation of this method in NumberFormat\n always throws UnsupportedOperationException.\n Subclasses which handle different rounding modes should override\n this method."
                }
              ]
            },
            {
              "name": "setRoundingMode",
              "overloads": [
                {
                  "signature": "public void setRoundingMode(RoundingMode roundingMode)",
                  "description": "Sets the RoundingMode used in this NumberFormat.\n The default implementation of this method in NumberFormat always\n throws UnsupportedOperationException.\n Subclasses which handle different rounding modes should override\n this method."
                }
              ]
            }
          ]
        },
        {
          "name": "NumberFormat.Field",
          "methods": [
            {
              "name": "Field",
              "overloads": [
                {
                  "signature": "protected Field(String name)",
                  "description": "Creates a Field instance with the specified\n name."
                }
              ]
            },
            {
              "name": "readResolve",
              "overloads": [
                {
                  "signature": "protected Object readResolve() throws InvalidObjectException",
                  "description": "Resolves instances being deserialized to the predefined constants."
                }
              ]
            }
          ]
        },
        {
          "name": "ParseException",
          "methods": [
            {
              "name": "ParseException",
              "overloads": [
                {
                  "signature": "public ParseException(String s, int errorOffset)",
                  "description": "Constructs a ParseException with the specified detail message and\n offset.\n A detail message is a String that describes this particular exception."
                }
              ]
            },
            {
              "name": "getErrorOffset",
              "overloads": [
                {
                  "signature": "public int getErrorOffset()",
                  "description": "Returns the position where the error was found."
                }
              ]
            }
          ]
        },
        {
          "name": "ParsePosition",
          "methods": [
            {
              "name": "ParsePosition",
              "overloads": [
                {
                  "signature": "public ParsePosition(int index)",
                  "description": "Create a new ParsePosition with the given initial index."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Retrieve the current parse position.  On input to a parse method, this\n is the index of the character at which parsing will begin; on output, it\n is the index of the character following the last character parsed."
                }
              ]
            },
            {
              "name": "setIndex",
              "overloads": [
                {
                  "signature": "public void setIndex(int index)",
                  "description": "Set the current parse position."
                }
              ]
            },
            {
              "name": "setErrorIndex",
              "overloads": [
                {
                  "signature": "public void setErrorIndex(int ei)",
                  "description": "Set the index at which a parse error occurred.  Formatters\n should set this before returning an error code from their\n parseObject method.  The default value is -1 if this is not set."
                }
              ]
            },
            {
              "name": "getErrorIndex",
              "overloads": [
                {
                  "signature": "public int getErrorIndex()",
                  "description": "Retrieve the index at which an error occurred, or -1 if the\n error index has not been set."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Overrides equals"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this ParsePosition."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a string representation of this ParsePosition."
                }
              ]
            }
          ]
        },
        {
          "name": "RuleBasedCollator",
          "methods": [
            {
              "name": "RuleBasedCollator",
              "overloads": [
                {
                  "signature": "public RuleBasedCollator(String rules) throws ParseException",
                  "description": "RuleBasedCollator constructor.  This takes the table rules and builds\n a collation table out of them.  Please see RuleBasedCollator class\n description for more details on the collation rule syntax."
                }
              ]
            },
            {
              "name": "getRules",
              "overloads": [
                {
                  "signature": "public String getRules()",
                  "description": "Gets the table-based rules for the collation object."
                }
              ]
            },
            {
              "name": "getCollationElementIterator",
              "overloads": [
                {
                  "signature": "public CollationElementIterator getCollationElementIterator(String source)",
                  "description": "Returns a CollationElementIterator for the given String."
                },
                {
                  "signature": "public CollationElementIterator getCollationElementIterator(CharacterIterator source)",
                  "description": "Returns a CollationElementIterator for the given CharacterIterator."
                }
              ]
            },
            {
              "name": "compare",
              "overloads": [
                {
                  "signature": "public int compare(String source, String target)",
                  "description": "Compares the character data stored in two different strings based on the\n collation rules.  Returns information about whether a string is less\n than, greater than or equal to another string in a language.\n This can be overridden in a subclass."
                }
              ]
            },
            {
              "name": "getCollationKey",
              "overloads": [
                {
                  "signature": "public CollationKey getCollationKey(String source)",
                  "description": "Transforms the string into a series of characters that can be compared\n with CollationKey.compareTo. This overrides java.text.Collator.getCollationKey.\n It can be overridden in a subclass."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Standard override; no change in semantics."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the equality of two collation objects."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Generates the hash code for the table-based collation object"
                }
              ]
            }
          ]
        },
        {
          "name": "SimpleDateFormat",
          "methods": [
            {
              "name": "SimpleDateFormat",
              "overloads": [
                {
                  "signature": "public SimpleDateFormat()",
                  "description": "Constructs a SimpleDateFormat using the default pattern and\n date format symbols for the default\n FORMAT locale.\n Note: This constructor may not support all locales.\n For full coverage, use the factory methods in the DateFormat\n class."
                },
                {
                  "signature": "public SimpleDateFormat(String pattern)",
                  "description": "Constructs a SimpleDateFormat using the given pattern and\n the default date format symbols for the default\n FORMAT locale.\n Note: This constructor may not support all locales.\n For full coverage, use the factory methods in the DateFormat\n class.\n This is equivalent to calling\n SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))."
                },
                {
                  "signature": "public SimpleDateFormat(String pattern, Locale locale)",
                  "description": "Constructs a SimpleDateFormat using the given pattern and\n the default date format symbols for the given locale.\n Note: This constructor may not support all locales.\n For full coverage, use the factory methods in the DateFormat\n class."
                },
                {
                  "signature": "public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols)",
                  "description": "Constructs a SimpleDateFormat using the given pattern and\n date format symbols."
                }
              ]
            },
            {
              "name": "set2DigitYearStart",
              "overloads": [
                {
                  "signature": "public void set2DigitYearStart(Date startDate)",
                  "description": "Sets the 100-year period 2-digit years will be interpreted as being in\n to begin on the date the user specifies."
                }
              ]
            },
            {
              "name": "get2DigitYearStart",
              "overloads": [
                {
                  "signature": "public Date get2DigitYearStart()",
                  "description": "Returns the beginning date of the 100-year period 2-digit years are interpreted\n as being within."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)",
                  "description": "Formats the given Date into a date/time string and appends\n the result to the given StringBuffer."
                }
              ]
            },
            {
              "name": "formatToCharacterIterator",
              "overloads": [
                {
                  "signature": "public AttributedCharacterIterator formatToCharacterIterator(Object obj)",
                  "description": "Formats an Object producing an AttributedCharacterIterator.\n You can use the returned AttributedCharacterIterator\n to build the resulting String, as well as to determine information\n about the resulting String.\n \n Each attribute key of the AttributedCharacterIterator will be of type\n DateFormat.Field, with the corresponding attribute value\n being the same as the attribute key."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public Date parse(String text, ParsePosition pos)",
                  "description": "Parses text from a string to produce a Date.\n \n The method attempts to parse text starting at the index given by\n pos.\n If parsing succeeds, then the index of pos is updated\n to the index after the last character used (parsing does not necessarily\n use all characters up to the end of the string), and the parsed\n date is returned. The updated pos can be used to\n indicate the starting point for the next call to this method.\n If an error occurs, then the index of pos is not\n changed, the error index of pos is set to the index of\n the character where the error occurred, and null is returned.\n\n This parsing operation uses the calendar to produce a Date. All of the \n calendar's date-time fields are cleared before parsing, and the calendar's default\n values of the date-time fields are used for any missing\n date-time information. For example, the year value of the\n parsed Date is 1970 with GregorianCalendar if\n no year value is given from the parsing operation.  The \n TimeZone value may be overwritten, depending on the given\n pattern and the time zone value in text. Any \n TimeZone value that has previously been set by a call to\n setTimeZone may need\n to be restored for further operations."
                }
              ]
            },
            {
              "name": "toPattern",
              "overloads": [
                {
                  "signature": "public String toPattern()",
                  "description": "Returns a pattern string describing this date format."
                }
              ]
            },
            {
              "name": "toLocalizedPattern",
              "overloads": [
                {
                  "signature": "public String toLocalizedPattern()",
                  "description": "Returns a localized pattern string describing this date format."
                }
              ]
            },
            {
              "name": "applyPattern",
              "overloads": [
                {
                  "signature": "public void applyPattern(String pattern)",
                  "description": "Applies the given pattern string to this date format."
                }
              ]
            },
            {
              "name": "applyLocalizedPattern",
              "overloads": [
                {
                  "signature": "public void applyLocalizedPattern(String pattern)",
                  "description": "Applies the given localized pattern string to this date format."
                }
              ]
            },
            {
              "name": "getDateFormatSymbols",
              "overloads": [
                {
                  "signature": "public DateFormatSymbols getDateFormatSymbols()",
                  "description": "Gets a copy of the date and time format symbols of this date format."
                }
              ]
            },
            {
              "name": "setDateFormatSymbols",
              "overloads": [
                {
                  "signature": "public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)",
                  "description": "Sets the date and time format symbols of this date format."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates a copy of this SimpleDateFormat. This also\n clones the format's date format symbols."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this SimpleDateFormat object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the given object with this SimpleDateFormat for\n equality."
                }
              ]
            }
          ]
        },
        {
          "name": "StringCharacterIterator",
          "methods": [
            {
              "name": "StringCharacterIterator",
              "overloads": [
                {
                  "signature": "public StringCharacterIterator(String text)",
                  "description": "Constructs an iterator with an initial index of 0."
                },
                {
                  "signature": "public StringCharacterIterator(String text, int pos)",
                  "description": "Constructs an iterator with the specified initial index."
                },
                {
                  "signature": "public StringCharacterIterator(String text, int begin, int end, int pos)",
                  "description": "Constructs an iterator over the given range of the given string, with the\n index set at the specified position."
                }
              ]
            },
            {
              "name": "setText",
              "overloads": [
                {
                  "signature": "public void setText(String text)",
                  "description": "Reset this iterator to point to a new string.  This package-visible\n method is used by other java.text classes that want to avoid allocating\n new StringCharacterIterator objects every time their setText method\n is called."
                }
              ]
            },
            {
              "name": "first",
              "overloads": [
                {
                  "signature": "public char first()",
                  "description": "Implements CharacterIterator.first() for String."
                }
              ]
            },
            {
              "name": "last",
              "overloads": [
                {
                  "signature": "public char last()",
                  "description": "Implements CharacterIterator.last() for String."
                }
              ]
            },
            {
              "name": "setIndex",
              "overloads": [
                {
                  "signature": "public char setIndex(int p)",
                  "description": "Implements CharacterIterator.setIndex() for String."
                }
              ]
            },
            {
              "name": "current",
              "overloads": [
                {
                  "signature": "public char current()",
                  "description": "Implements CharacterIterator.current() for String."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "public char next()",
                  "description": "Implements CharacterIterator.next() for String."
                }
              ]
            },
            {
              "name": "previous",
              "overloads": [
                {
                  "signature": "public char previous()",
                  "description": "Implements CharacterIterator.previous() for String."
                }
              ]
            },
            {
              "name": "getBeginIndex",
              "overloads": [
                {
                  "signature": "public int getBeginIndex()",
                  "description": "Implements CharacterIterator.getBeginIndex() for String."
                }
              ]
            },
            {
              "name": "getEndIndex",
              "overloads": [
                {
                  "signature": "public int getEndIndex()",
                  "description": "Implements CharacterIterator.getEndIndex() for String."
                }
              ]
            },
            {
              "name": "getIndex",
              "overloads": [
                {
                  "signature": "public int getIndex()",
                  "description": "Implements CharacterIterator.getIndex() for String."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares the equality of two StringCharacterIterator objects."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Computes a hashcode for this iterator."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone()",
                  "description": "Creates a copy of this iterator."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.time",
      "description": "Date and time API",
      "classes": [
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static DayOfWeek[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static DayOfWeek valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static DayOfWeek of(int dayOfWeek)",
                  "description": "Obtains an instance of DayOfWeek from an int value.\n \n DayOfWeek is an enum representing the 7 days of the week.\n This factory allows the enum to be obtained from the int value.\n The int value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday)."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static DayOfWeek from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of DayOfWeek from a temporal object.\n \n This obtains a day-of-week based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of DayOfWeek.\n \n The conversion extracts the DAY_OF_WEEK field.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, DayOfWeek::from."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public int getValue()",
                  "description": "Gets the day-of-week int value.\n \n The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n See WeekFields.dayOfWeek() for localized week-numbering."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName(TextStyle style, Locale locale)",
                  "description": "Gets the textual representation, such as 'Mon' or 'Friday'.\n \n This returns the textual name used to identify the day-of-week,\n suitable for presentation to the user.\n The parameters control the style of the returned text and the locale.\n \n If no textual mapping is found then the numeric value is returned."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this day-of-week can be queried for the specified field.\n If false, then calling the range and\n get methods will throw an exception.\n \n If the field is DAY_OF_WEEK then\n this method returns true.\n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This day-of-week is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is DAY_OF_WEEK then the\n range of the day-of-week, from 1 to 7, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this day-of-week as an int.\n \n This queries this day-of-week for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is DAY_OF_WEEK then the\n value of the day-of-week, from 1 to 7, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this day-of-week as a long.\n \n This queries this day-of-week for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is DAY_OF_WEEK then the\n value of the day-of-week, from 1 to 7, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public DayOfWeek plus(long days)",
                  "description": "Returns the day-of-week that is the specified number of days after this one.\n \n The calculation rolls around the end of the week from Sunday to Monday.\n The specified period may be negative.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public DayOfWeek minus(long days)",
                  "description": "Returns the day-of-week that is the specified number of days before this one.\n \n The calculation rolls around the start of the year from Monday to Sunday.\n The specified period may be negative.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this day-of-week using the specified query.\n \n This queries this day-of-week using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this day-of-week.\n \n This returns a temporal object of the same observable type as the input\n with the day-of-week changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.DAY_OF_WEEK as the field.\n Note that this adjusts forwards or backwards within a Monday to Sunday week.\n See WeekFields.dayOfWeek() for localized week start days.\n See TemporalAdjuster for other adjusters with more control,\n such as next(MONDAY).\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisDayOfWeek.adjustInto(temporal);\n   temporal = temporal.with(thisDayOfWeek);\n \n \n For example, given a date that is a Wednesday, the following are output:\n    dateOnWed.with(MONDAY);     // two days earlier\n   dateOnWed.with(TUESDAY);    // one day earlier\n   dateOnWed.with(WEDNESDAY);  // same date\n   dateOnWed.with(THURSDAY);   // one day later\n   dateOnWed.with(FRIDAY);     // two days later\n   dateOnWed.with(SATURDAY);   // three days later\n   dateOnWed.with(SUNDAY);     // four days later\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static Month[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static Month valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Month of(int month)",
                  "description": "Obtains an instance of Month from an int value.\n \n Month is an enum representing the 12 months of the year.\n This factory allows the enum to be obtained from the int value.\n The int value follows the ISO-8601 standard, from 1 (January) to 12 (December)."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Month from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of Month from a temporal object.\n \n This obtains a month based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of Month.\n \n The conversion extracts the MONTH_OF_YEAR field.\n The extraction is only permitted if the temporal object has an ISO\n chronology, or can be converted to a LocalDate.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, Month::from."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public int getValue()",
                  "description": "Gets the month-of-year int value.\n \n The values are numbered following the ISO-8601 standard,\n from 1 (January) to 12 (December)."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName(TextStyle style, Locale locale)",
                  "description": "Gets the textual representation, such as 'Jan' or 'December'.\n \n This returns the textual name used to identify the month-of-year,\n suitable for presentation to the user.\n The parameters control the style of the returned text and the locale.\n \n If no textual mapping is found then the numeric value is returned."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this month-of-year can be queried for the specified field.\n If false, then calling the range and\n get methods will throw an exception.\n \n If the field is MONTH_OF_YEAR then\n this method returns true.\n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This month is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is MONTH_OF_YEAR then the\n range of the month-of-year, from 1 to 12, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this month-of-year as an int.\n \n This queries this month for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is MONTH_OF_YEAR then the\n value of the month-of-year, from 1 to 12, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this month-of-year as a long.\n \n This queries this month for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is MONTH_OF_YEAR then the\n value of the month-of-year, from 1 to 12, will be returned.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public Month plus(long months)",
                  "description": "Returns the month-of-year that is the specified number of months after this one.\n \n The calculation rolls around the end of the year from December to January.\n The specified period may be negative.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public Month minus(long months)",
                  "description": "Returns the month-of-year that is the specified number of months before this one.\n \n The calculation rolls around the start of the year from January to December.\n The specified period may be negative.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length(boolean leapYear)",
                  "description": "Gets the length of this month in days.\n \n This takes a flag to determine whether to return the length for a leap year or not.\n \n February has 28 days in a standard year and 29 days in a leap year.\n April, June, September and November have 30 days.\n All other months have 31 days."
                }
              ]
            },
            {
              "name": "minLength",
              "overloads": [
                {
                  "signature": "public int minLength()",
                  "description": "Gets the minimum length of this month in days.\n \n February has a minimum length of 28 days.\n April, June, September and November have 30 days.\n All other months have 31 days."
                }
              ]
            },
            {
              "name": "maxLength",
              "overloads": [
                {
                  "signature": "public int maxLength()",
                  "description": "Gets the maximum length of this month in days.\n \n February has a maximum length of 29 days.\n April, June, September and November have 30 days.\n All other months have 31 days."
                }
              ]
            },
            {
              "name": "firstDayOfYear",
              "overloads": [
                {
                  "signature": "public int firstDayOfYear(boolean leapYear)",
                  "description": "Gets the day-of-year corresponding to the first day of this month.\n \n This returns the day-of-year that this month begins on, using the leap\n year flag to determine the length of February."
                }
              ]
            },
            {
              "name": "firstMonthOfQuarter",
              "overloads": [
                {
                  "signature": "public Month firstMonthOfQuarter()",
                  "description": "Gets the month corresponding to the first month of this quarter.\n \n The year can be divided into four quarters.\n This method returns the first month of the quarter for the base month.\n January, February and March return January.\n April, May and June return April.\n July, August and September return July.\n October, November and December return October."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this month-of-year using the specified query.\n \n This queries this month-of-year using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this month-of-year.\n \n This returns a temporal object of the same observable type as the input\n with the month-of-year changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.MONTH_OF_YEAR as the field.\n If the specified temporal object does not use the ISO calendar system then\n a DateTimeException is thrown.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisMonth.adjustInto(temporal);\n   temporal = temporal.with(thisMonth);\n \n \n For example, given a date in May, the following are output:\n    dateInMay.with(JANUARY);    // four months earlier\n   dateInMay.with(APRIL);      // one months earlier\n   dateInMay.with(MAY);        // same date\n   dateInMay.with(JUNE);       // one month later\n   dateInMay.with(DECEMBER);   // seven months later\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            }
          ]
        },
        {
          "name": "Clock",
          "methods": [
            {
              "name": "Clock",
              "overloads": [
                {
                  "signature": "protected Clock()",
                  "description": "Constructor accessible by subclasses."
                }
              ]
            },
            {
              "name": "systemUTC",
              "overloads": [
                {
                  "signature": "public static Clock systemUTC()",
                  "description": "Obtains a clock that returns the current instant using the best available\n system clock, converting to date and time using the UTC time-zone.\n \n This clock, rather than systemDefaultZone(), should be used when\n you need the current instant without the date or time.\n \n This clock is based on the best available system clock.\n This may use System.currentTimeMillis(), or a higher resolution\n clock if one is available.\n \n Conversion from instant to date or time uses the UTC time-zone.\n \n The returned implementation is immutable, thread-safe and Serializable.\n It is equivalent to system(ZoneOffset.UTC)."
                }
              ]
            },
            {
              "name": "systemDefaultZone",
              "overloads": [
                {
                  "signature": "public static Clock systemDefaultZone()",
                  "description": "Obtains a clock that returns the current instant using the best available\n system clock, converting to date and time using the default time-zone.\n \n This clock is based on the best available system clock.\n This may use System.currentTimeMillis(), or a higher resolution\n clock if one is available.\n \n Using this method hard codes a dependency to the default time-zone into your application.\n It is recommended to avoid this and use a specific time-zone whenever possible.\n The UTC clock should be used when you need the current instant\n without the date or time.\n \n The returned implementation is immutable, thread-safe and Serializable.\n It is equivalent to system(ZoneId.systemDefault())."
                }
              ]
            },
            {
              "name": "system",
              "overloads": [
                {
                  "signature": "public static Clock system(ZoneId zone)",
                  "description": "Obtains a clock that returns the current instant using the best available\n system clock.\n \n This clock is based on the best available system clock.\n This may use System.currentTimeMillis(), or a higher resolution\n clock if one is available.\n \n Conversion from instant to date or time uses the specified time-zone.\n \n The returned implementation is immutable, thread-safe and Serializable."
                }
              ]
            },
            {
              "name": "tickMillis",
              "overloads": [
                {
                  "signature": "public static Clock tickMillis(ZoneId zone)",
                  "description": "Obtains a clock that returns the current instant ticking in whole milliseconds\n using the best available system clock.\n \n This clock will always have the nano-of-second field truncated to milliseconds.\n This ensures that the visible time ticks in whole milliseconds.\n The underlying clock is the best available system clock, equivalent to\n using system(ZoneId).\n \n Implementations may use a caching strategy for performance reasons.\n As such, it is possible that the start of the millisecond observed via this\n clock will be later than that observed directly via the underlying clock.\n \n The returned implementation is immutable, thread-safe and Serializable.\n It is equivalent to tick(system(zone), Duration.ofMillis(1))."
                }
              ]
            },
            {
              "name": "tickSeconds",
              "overloads": [
                {
                  "signature": "public static Clock tickSeconds(ZoneId zone)",
                  "description": "Obtains a clock that returns the current instant ticking in whole seconds\n using the best available system clock.\n \n This clock will always have the nano-of-second field set to zero.\n This ensures that the visible time ticks in whole seconds.\n The underlying clock is the best available system clock, equivalent to\n using system(ZoneId).\n \n Implementations may use a caching strategy for performance reasons.\n As such, it is possible that the start of the second observed via this\n clock will be later than that observed directly via the underlying clock.\n \n The returned implementation is immutable, thread-safe and Serializable.\n It is equivalent to tick(system(zone), Duration.ofSeconds(1))."
                }
              ]
            },
            {
              "name": "tickMinutes",
              "overloads": [
                {
                  "signature": "public static Clock tickMinutes(ZoneId zone)",
                  "description": "Obtains a clock that returns the current instant ticking in whole minutes\n using the best available system clock.\n \n This clock will always have the nano-of-second and second-of-minute fields set to zero.\n This ensures that the visible time ticks in whole minutes.\n The underlying clock is the best available system clock, equivalent to\n using system(ZoneId).\n \n Implementations may use a caching strategy for performance reasons.\n As such, it is possible that the start of the minute observed via this\n clock will be later than that observed directly via the underlying clock.\n \n The returned implementation is immutable, thread-safe and Serializable.\n It is equivalent to tick(system(zone), Duration.ofMinutes(1))."
                }
              ]
            },
            {
              "name": "tick",
              "overloads": [
                {
                  "signature": "public static Clock tick(Clock baseClock, Duration tickDuration)",
                  "description": "Obtains a clock that returns instants from the specified clock truncated\n to the nearest occurrence of the specified duration.\n \n This clock will only tick as per the specified duration. Thus, if the duration\n is half a second, the clock will return instants truncated to the half second.\n \n The tick duration must be positive. If it has a part smaller than a whole\n millisecond, then the whole duration must divide into one second without\n leaving a remainder. All normal tick durations will match these criteria,\n including any multiple of hours, minutes, seconds and milliseconds, and\n sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.\n \n A duration of zero or one nanosecond would have no truncation effect.\n Passing one of these will return the underlying clock.\n \n Implementations may use a caching strategy for performance reasons.\n As such, it is possible that the start of the requested duration observed\n via this clock will be later than that observed directly via the underlying clock.\n \n The returned implementation is immutable, thread-safe and Serializable\n providing that the base clock is."
                }
              ]
            },
            {
              "name": "fixed",
              "overloads": [
                {
                  "signature": "public static Clock fixed(Instant fixedInstant, ZoneId zone)",
                  "description": "Obtains a clock that always returns the same instant.\n \n This clock simply returns the specified instant.\n As such, it is not a clock in the conventional sense.\n The main use case for this is in testing, where the fixed clock ensures\n tests are not dependent on the current clock.\n \n The returned implementation is immutable, thread-safe and Serializable."
                }
              ]
            },
            {
              "name": "offset",
              "overloads": [
                {
                  "signature": "public static Clock offset(Clock baseClock, Duration offsetDuration)",
                  "description": "Obtains a clock that returns instants from the specified clock with the\n specified duration added.\n \n This clock wraps another clock, returning instants that are later by the\n specified duration. If the duration is negative, the instants will be\n earlier than the current date and time.\n The main use case for this is to simulate running in the future or in the past.\n \n A duration of zero would have no offsetting effect.\n Passing zero will return the underlying clock.\n \n The returned implementation is immutable, thread-safe and Serializable\n providing that the base clock is."
                }
              ]
            },
            {
              "name": "getZone",
              "overloads": [
                {
                  "signature": "public abstract ZoneId getZone()",
                  "description": "Gets the time-zone being used to create dates and times.\n \n A clock will typically obtain the current instant and then convert that\n to a date or time using a time-zone. This method returns the time-zone used."
                }
              ]
            },
            {
              "name": "withZone",
              "overloads": [
                {
                  "signature": "public abstract Clock withZone(ZoneId zone)",
                  "description": "Returns a copy of this clock with a different time-zone.\n \n A clock will typically obtain the current instant and then convert that\n to a date or time using a time-zone. This method returns a clock with\n similar properties but using a different time-zone."
                }
              ]
            },
            {
              "name": "millis",
              "overloads": [
                {
                  "signature": "public long millis()",
                  "description": "Gets the current millisecond instant of the clock.\n \n This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n This is equivalent to the definition of System.currentTimeMillis().\n \n Most applications should avoid this method and use Instant to represent\n an instant on the time-line rather than a raw millisecond value.\n This method is provided to allow the use of the clock in high performance use cases\n where the creation of an object would be unacceptable.\n \n The default implementation currently calls instant()."
                }
              ]
            },
            {
              "name": "instant",
              "overloads": [
                {
                  "signature": "public abstract Instant instant()",
                  "description": "Gets the current instant of the clock.\n \n This returns an instant representing the current instant as defined by the clock."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this clock is equal to another clock.\n \n Clocks should override this method to compare equals based on\n their state and to meet the contract of Object.equals(java.lang.Object).\n If not overridden, the behavior is defined by Object.equals(java.lang.Object)"
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this clock.\n \n Clocks should override this method based on\n their state and to meet the contract of Object.hashCode().\n If not overridden, the behavior is defined by Object.hashCode()"
                }
              ]
            }
          ]
        },
        {
          "name": "DateTimeException",
          "methods": [
            {
              "name": "DateTimeException",
              "overloads": [
                {
                  "signature": "public DateTimeException(String message)",
                  "description": "Constructs a new date-time exception with the specified message."
                },
                {
                  "signature": "public DateTimeException(String message, Throwable cause)",
                  "description": "Constructs a new date-time exception with the specified message and cause."
                }
              ]
            }
          ]
        },
        {
          "name": "Duration",
          "methods": [
            {
              "name": "ofDays",
              "overloads": [
                {
                  "signature": "public static Duration ofDays(long days)",
                  "description": "Obtains a Duration representing a number of standard 24 hour days.\n \n The seconds are calculated based on the standard definition of a day,\n where each day is 86400 seconds which implies a 24 hour day.\n The nanosecond in second field is set to zero."
                }
              ]
            },
            {
              "name": "ofHours",
              "overloads": [
                {
                  "signature": "public static Duration ofHours(long hours)",
                  "description": "Obtains a Duration representing a number of standard hours.\n \n The seconds are calculated based on the standard definition of an hour,\n where each hour is 3600 seconds.\n The nanosecond in second field is set to zero."
                }
              ]
            },
            {
              "name": "ofMinutes",
              "overloads": [
                {
                  "signature": "public static Duration ofMinutes(long minutes)",
                  "description": "Obtains a Duration representing a number of standard minutes.\n \n The seconds are calculated based on the standard definition of a minute,\n where each minute is 60 seconds.\n The nanosecond in second field is set to zero."
                }
              ]
            },
            {
              "name": "ofSeconds",
              "overloads": [
                {
                  "signature": "public static Duration ofSeconds(long seconds)",
                  "description": "Obtains a Duration representing a number of seconds.\n \n The nanosecond in second field is set to zero."
                },
                {
                  "signature": "public static Duration ofSeconds(long seconds, long nanoAdjustment)",
                  "description": "Obtains a Duration representing a number of seconds and an\n adjustment in nanoseconds.\n \n This method allows an arbitrary number of nanoseconds to be passed in.\n The factory will alter the values of the second and nanosecond in order\n to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n For example, the following will result in exactly the same duration:\n   Duration.ofSeconds(3, 1);\n  Duration.ofSeconds(4, -999_999_999);\n  Duration.ofSeconds(2, 1000_000_001);"
                }
              ]
            },
            {
              "name": "ofMillis",
              "overloads": [
                {
                  "signature": "public static Duration ofMillis(long millis)",
                  "description": "Obtains a Duration representing a number of milliseconds.\n \n The seconds and nanoseconds are extracted from the specified milliseconds."
                }
              ]
            },
            {
              "name": "ofNanos",
              "overloads": [
                {
                  "signature": "public static Duration ofNanos(long nanos)",
                  "description": "Obtains a Duration representing a number of nanoseconds.\n \n The seconds and nanoseconds are extracted from the specified nanoseconds."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Duration of(long amount, TemporalUnit unit)",
                  "description": "Obtains a Duration representing an amount in the specified unit.\n \n The parameters represent the two parts of a phrase like '6 Hours'. For example:\n   Duration.of(3, SECONDS);\n  Duration.of(465, HOURS);\n \n Only a subset of units are accepted by this method.\n The unit must either have an exact duration or\n be ChronoUnit.DAYS which is treated as 24 hours. Other units throw an exception."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Duration from(TemporalAmount amount)",
                  "description": "Obtains an instance of Duration from a temporal amount.\n \n This obtains a duration based on the specified amount.\n A TemporalAmount represents an  amount of time, which may be\n date-based or time-based, which this factory extracts to a duration.\n \n The conversion loops around the set of units from the amount and uses\n the duration of the unit to\n calculate the total Duration.\n Only a subset of units are accepted by this method. The unit must either\n have an exact duration\n or be ChronoUnit.DAYS which is treated as 24 hours.\n If any other units are found then an exception is thrown."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Duration parse(CharSequence text)",
                  "description": "Obtains a Duration from a text string such as PnDTnHnMn.nS.\n \n This will parse a textual representation of a duration, including the\n string produced by toString(). The formats accepted are based\n on the ISO-8601 duration format PnDTnHnMn.nS with days\n considered to be exactly 24 hours.\n \n The string starts with an optional sign, denoted by the ASCII negative\n or positive symbol. If negative, the whole period is negated.\n The ASCII letter \"P\" is next in upper or lower case.\n There are then four sections, each consisting of a number and a suffix.\n The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n days, hours, minutes and seconds, accepted in upper or lower case.\n The suffixes must occur in order. The ASCII letter \"T\" must occur before\n the first occurrence, if any, of an hour, minute or second section.\n At least one of the four sections must be present, and if \"T\" is present\n there must be at least one section after the \"T\".\n The number part of each section must consist of one or more ASCII digits.\n The number may be prefixed by the ASCII negative or positive symbol.\n The number of days, hours and minutes must parse to a long.\n The number of seconds must parse to a long with optional fraction.\n The decimal point may be either a dot or a comma.\n The fractional part may have from zero to 9 digits.\n \n The leading plus/minus sign, and negative values for other units are\n not part of the ISO-8601 standard.\n \n Examples:\n     \"PT20.345S\" -- parses as \"20.345 seconds\"\n    \"PT15M\"     -- parses as \"15 minutes\" (where a minute is 60 seconds)\n    \"PT10H\"     -- parses as \"10 hours\" (where an hour is 3600 seconds)\n    \"P2D\"       -- parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n    \"P2DT3H4M\"  -- parses as \"2 days, 3 hours and 4 minutes\"\n    \"PT-6H3M\"    -- parses as \"-6 hours and +3 minutes\"\n    \"-PT6H3M\"    -- parses as \"-6 hours and -3 minutes\"\n    \"-PT-6H+3M\"  -- parses as \"+6 hours and -3 minutes\""
                }
              ]
            },
            {
              "name": "between",
              "overloads": [
                {
                  "signature": "public static Duration between(Temporal startInclusive, Temporal endExclusive)",
                  "description": "Obtains a Duration representing the duration between two temporal objects.\n \n This calculates the duration between two temporal objects. If the objects\n are of different types, then the duration is calculated based on the type\n of the first object. For example, if the first argument is a LocalTime\n then the second argument is converted to a LocalTime.\n \n The specified temporal objects must support the SECONDS unit.\n For full accuracy, either the NANOS unit or the\n NANO_OF_SECOND field should be supported.\n \n The result of this method can be a negative period if the end is before the start.\n To guarantee to obtain a positive duration call abs() on the result."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public long get(TemporalUnit unit)",
                  "description": "Gets the value of the requested unit.\n \n This returns a value for each of the two supported units,\n SECONDS and NANOS.\n All other units throw an exception."
                }
              ]
            },
            {
              "name": "getUnits",
              "overloads": [
                {
                  "signature": "public List<TemporalUnit> getUnits()",
                  "description": "Gets the set of units supported by this duration.\n \n The supported units are SECONDS,\n and NANOS.\n They are returned in the order seconds, nanos.\n \n This set can be used in conjunction with get(TemporalUnit)\n to access the entire state of the duration."
                }
              ]
            },
            {
              "name": "isZero",
              "overloads": [
                {
                  "signature": "public boolean isZero()",
                  "description": "Checks if this duration is zero length.\n \n A Duration represents a directed distance between two points on\n the time-line and can therefore be positive, zero or negative.\n This method checks whether the length is zero."
                }
              ]
            },
            {
              "name": "isNegative",
              "overloads": [
                {
                  "signature": "public boolean isNegative()",
                  "description": "Checks if this duration is negative, excluding zero.\n \n A Duration represents a directed distance between two points on\n the time-line and can therefore be positive, zero or negative.\n This method checks whether the length is less than zero."
                }
              ]
            },
            {
              "name": "getSeconds",
              "overloads": [
                {
                  "signature": "public long getSeconds()",
                  "description": "Gets the number of seconds in this duration.\n \n The length of the duration is stored using two fields - seconds and nanoseconds.\n The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n the length in seconds.\n The total duration is defined by calling this method and getNano().\n \n A Duration represents a directed distance between two points on the time-line.\n A negative duration is expressed by the negative sign of the seconds part.\n A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the number of nanoseconds within the second in this duration.\n \n The length of the duration is stored using two fields - seconds and nanoseconds.\n The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n the length in seconds.\n The total duration is defined by calling this method and getSeconds().\n \n A Duration represents a directed distance between two points on the time-line.\n A negative duration is expressed by the negative sign of the seconds part.\n A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds."
                }
              ]
            },
            {
              "name": "withSeconds",
              "overloads": [
                {
                  "signature": "public Duration withSeconds(long seconds)",
                  "description": "Returns a copy of this duration with the specified amount of seconds.\n \n This returns a duration with the specified seconds, retaining the\n nano-of-second part of this duration.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNanos",
              "overloads": [
                {
                  "signature": "public Duration withNanos(int nanoOfSecond)",
                  "description": "Returns a copy of this duration with the specified nano-of-second.\n \n This returns a duration with the specified nano-of-second, retaining the\n seconds part of this duration.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public Duration plus(Duration duration)",
                  "description": "Returns a copy of this duration with the specified duration added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Duration plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this duration with the specified duration added.\n \n The duration amount is measured in terms of the specified unit.\n Only a subset of units are accepted by this method.\n The unit must either have an exact duration or\n be ChronoUnit.DAYS which is treated as 24 hours. Other units throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public Duration plusDays(long daysToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in standard 24 hour days added.\n \n The number of days is multiplied by 86400 to obtain the number of seconds to add.\n This is based on the standard definition of a day as 24 hours.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public Duration plusHours(long hoursToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in hours added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public Duration plusMinutes(long minutesToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in minutes added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public Duration plusSeconds(long secondsToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in seconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMillis",
              "overloads": [
                {
                  "signature": "public Duration plusMillis(long millisToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in milliseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public Duration plusNanos(long nanosToAdd)",
                  "description": "Returns a copy of this duration with the specified duration in nanoseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public Duration minus(Duration duration)",
                  "description": "Returns a copy of this duration with the specified duration subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Duration minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this duration with the specified duration subtracted.\n \n The duration amount is measured in terms of the specified unit.\n Only a subset of units are accepted by this method.\n The unit must either have an exact duration or\n be ChronoUnit.DAYS which is treated as 24 hours. Other units throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public Duration minusDays(long daysToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.\n \n The number of days is multiplied by 86400 to obtain the number of seconds to subtract.\n This is based on the standard definition of a day as 24 hours.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public Duration minusHours(long hoursToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in hours subtracted.\n \n The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public Duration minusMinutes(long minutesToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in minutes subtracted.\n \n The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public Duration minusSeconds(long secondsToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in seconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMillis",
              "overloads": [
                {
                  "signature": "public Duration minusMillis(long millisToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in milliseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public Duration minusNanos(long nanosToSubtract)",
                  "description": "Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "multipliedBy",
              "overloads": [
                {
                  "signature": "public Duration multipliedBy(long multiplicand)",
                  "description": "Returns a copy of this duration multiplied by the scalar.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "dividedBy",
              "overloads": [
                {
                  "signature": "public Duration dividedBy(long divisor)",
                  "description": "Returns a copy of this duration divided by the specified value.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public long dividedBy(Duration divisor)",
                  "description": "Returns number of whole times a specified Duration occurs within this Duration.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "negated",
              "overloads": [
                {
                  "signature": "public Duration negated()",
                  "description": "Returns a copy of this duration with the length negated.\n \n This method swaps the sign of the total length of this duration.\n For example, PT1.3S will be returned as PT-1.3S.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "abs",
              "overloads": [
                {
                  "signature": "public Duration abs()",
                  "description": "Returns a copy of this duration with a positive length.\n \n This method returns a positive duration by effectively removing the sign from any negative total length.\n For example, PT-1.3S will be returned as PT1.3S.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "addTo",
              "overloads": [
                {
                  "signature": "public Temporal addTo(Temporal temporal)",
                  "description": "Adds this duration to the specified temporal object.\n \n This returns a temporal object of the same observable type as the input\n with this duration added.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.plus(TemporalAmount).\n    // these two lines are equivalent, but the second approach is recommended\n   dateTime = thisDuration.addTo(dateTime);\n   dateTime = dateTime.plus(thisDuration);\n \n \n The calculation will add the seconds, then nanos.\n Only non-zero amounts will be added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "subtractFrom",
              "overloads": [
                {
                  "signature": "public Temporal subtractFrom(Temporal temporal)",
                  "description": "Subtracts this duration from the specified temporal object.\n \n This returns a temporal object of the same observable type as the input\n with this duration subtracted.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.minus(TemporalAmount).\n    // these two lines are equivalent, but the second approach is recommended\n   dateTime = thisDuration.subtractFrom(dateTime);\n   dateTime = dateTime.minus(thisDuration);\n \n \n The calculation will subtract the seconds, then nanos.\n Only non-zero amounts will be added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toDays",
              "overloads": [
                {
                  "signature": "public long toDays()",
                  "description": "Gets the number of days in this duration.\n \n This returns the total number of days in the duration by dividing the\n number of seconds by 86400.\n This is based on the standard definition of a day as 24 hours.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toHours",
              "overloads": [
                {
                  "signature": "public long toHours()",
                  "description": "Gets the number of hours in this duration.\n \n This returns the total number of hours in the duration by dividing the\n number of seconds by 3600.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toMinutes",
              "overloads": [
                {
                  "signature": "public long toMinutes()",
                  "description": "Gets the number of minutes in this duration.\n \n This returns the total number of minutes in the duration by dividing the\n number of seconds by 60.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toSeconds",
              "overloads": [
                {
                  "signature": "public long toSeconds()",
                  "description": "Gets the number of seconds in this duration.\n \n This returns the total number of whole seconds in the duration.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toMillis",
              "overloads": [
                {
                  "signature": "public long toMillis()",
                  "description": "Converts this duration to the total length in milliseconds.\n \n If this duration is too large to fit in a long milliseconds, then an\n exception is thrown.\n \n If this duration has greater than millisecond precision, then the conversion\n will drop any excess precision information as though the amount in nanoseconds\n was subject to integer division by one million."
                }
              ]
            },
            {
              "name": "toNanos",
              "overloads": [
                {
                  "signature": "public long toNanos()",
                  "description": "Converts this duration to the total length in nanoseconds expressed as a long.\n \n If this duration is too large to fit in a long nanoseconds, then an\n exception is thrown."
                }
              ]
            },
            {
              "name": "toDaysPart",
              "overloads": [
                {
                  "signature": "public long toDaysPart()",
                  "description": "Extracts the number of days in the duration.\n \n This returns the total number of days in the duration by dividing the\n number of seconds by 86400.\n This is based on the standard definition of a day as 24 hours.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toHoursPart",
              "overloads": [
                {
                  "signature": "public int toHoursPart()",
                  "description": "Extracts the number of hours part in the duration.\n \n This returns the number of remaining hours when dividing toHours()\n by hours in a day.\n This is based on the standard definition of a day as 24 hours.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toMinutesPart",
              "overloads": [
                {
                  "signature": "public int toMinutesPart()",
                  "description": "Extracts the number of minutes part in the duration.\n \n This returns the number of remaining minutes when dividing toMinutes()\n by minutes in an hour.\n This is based on the standard definition of an hour as 60 minutes.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toSecondsPart",
              "overloads": [
                {
                  "signature": "public int toSecondsPart()",
                  "description": "Extracts the number of seconds part in the duration.\n \n This returns the remaining seconds when dividing toSeconds()\n by seconds in a minute.\n This is based on the standard definition of a minute as 60 seconds.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toMillisPart",
              "overloads": [
                {
                  "signature": "public int toMillisPart()",
                  "description": "Extracts the number of milliseconds part of the duration.\n \n This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.\n The length of the duration is stored using two fields - seconds and nanoseconds.\n The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n the length in seconds.\n The total duration is defined by calling getNano() and getSeconds().\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toNanosPart",
              "overloads": [
                {
                  "signature": "public int toNanosPart()",
                  "description": "Get the nanoseconds part within seconds of the duration.\n \n The length of the duration is stored using two fields - seconds and nanoseconds.\n The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n the length in seconds.\n The total duration is defined by calling getNano() and getSeconds().\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public Duration truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this Duration truncated to the specified unit.\n \n Truncating the duration returns a copy of the original with conceptual fields\n smaller than the specified unit set to zero.\n For example, truncating with the MINUTES unit will\n round down towards zero to the nearest minute, setting the seconds and\n nanoseconds to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all\n time-based units on ChronoUnit\n and DAYS. Other ChronoUnits throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Duration otherDuration)",
                  "description": "Compares this duration to the specified Duration.\n \n The comparison is based on the total length of the durations.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object other)",
                  "description": "Checks if this duration is equal to the specified Duration.\n \n The comparison is based on the total length of the durations."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this duration."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "A string representation of this duration using ISO-8601 seconds\n based representation, such as PT8H6M12.345S.\n \n The format of the returned string will be PTnHnMnS, where n is\n the relevant hours, minutes or seconds part of the duration.\n Any fractional seconds are placed after a decimal point in the seconds section.\n If a section has a zero value, it is omitted.\n The hours, minutes and seconds will all have the same sign.\n \n Examples:\n     \"20.345 seconds\"                 -- \"PT20.345S\n    \"15 minutes\" (15 * 60 seconds)   -- \"PT15M\"\n    \"10 hours\" (10 * 3600 seconds)   -- \"PT10H\"\n    \"2 days\" (2 * 86400 seconds)     -- \"PT48H\"\n \n Note that multiples of 24 hours are not output as days to avoid confusion\n with Period."
                }
              ]
            }
          ]
        },
        {
          "name": "Instant",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static Instant now()",
                  "description": "Obtains the current instant from the system clock.\n \n This will query the system UTC clock to\n obtain the current instant.\n \n Using this method will prevent the ability to use an alternate time-source for\n testing because the clock is effectively hard-coded."
                },
                {
                  "signature": "public static Instant now(Clock clock)",
                  "description": "Obtains the current instant from the specified clock.\n \n This will query the specified clock to obtain the current time.\n \n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "ofEpochSecond",
              "overloads": [
                {
                  "signature": "public static Instant ofEpochSecond(long epochSecond)",
                  "description": "Obtains an instance of Instant using seconds from the\n epoch of 1970-01-01T00:00:00Z.\n \n The nanosecond field is set to zero."
                },
                {
                  "signature": "public static Instant ofEpochSecond(long epochSecond, long nanoAdjustment)",
                  "description": "Obtains an instance of Instant using seconds from the\n epoch of 1970-01-01T00:00:00Z and nanosecond fraction of second.\n \n This method allows an arbitrary number of nanoseconds to be passed in.\n The factory will alter the values of the second and nanosecond in order\n to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n For example, the following will result in exactly the same instant:\n   Instant.ofEpochSecond(3, 1);\n  Instant.ofEpochSecond(4, -999_999_999);\n  Instant.ofEpochSecond(2, 1000_000_001);"
                }
              ]
            },
            {
              "name": "ofEpochMilli",
              "overloads": [
                {
                  "signature": "public static Instant ofEpochMilli(long epochMilli)",
                  "description": "Obtains an instance of Instant using milliseconds from the\n epoch of 1970-01-01T00:00:00Z.\n \n The seconds and nanoseconds are extracted from the specified milliseconds."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Instant from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of Instant from a temporal object.\n \n This obtains an instant based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of Instant.\n \n The conversion extracts the INSTANT_SECONDS\n and NANO_OF_SECOND fields.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, Instant::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Instant parse(CharSequence text)",
                  "description": "Obtains an instance of Instant from a text string such as\n 2007-12-03T10:15:30.00Z.\n \n The string must represent a valid instant in UTC and is parsed using\n DateTimeFormatter.ISO_INSTANT."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this instant can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n MICRO_OF_SECOND\n MILLI_OF_SECOND\n INSTANT_SECONDS\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this date-time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n DAYS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This instant is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this instant as an int.\n \n This queries this instant for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time, except INSTANT_SECONDS which is too\n large to fit in an int and throws a DateTimeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this instant as a long.\n \n This queries this instant for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getEpochSecond",
              "overloads": [
                {
                  "signature": "public long getEpochSecond()",
                  "description": "Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n \n The epoch second count is a simple incrementing count of seconds where\n second 0 is 1970-01-01T00:00:00Z.\n The nanosecond part is returned by getNano()."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the number of nanoseconds, later along the time-line, from the start\n of the second.\n \n The nanosecond-of-second value measures the total number of nanoseconds from\n the second returned by getEpochSecond()."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public Instant with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this instant.\n \n This returns an Instant, based on this one, with the instant adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Instant with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this instant with the specified field set to a new value.\n \n This returns an Instant, based on this one, with the value\n for the specified field changed.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields behave as follows:\n \n NANO_OF_SECOND -\n  Returns an Instant with the specified nano-of-second.\n  The epoch-second will be unchanged.\n MICRO_OF_SECOND -\n  Returns an Instant with the nano-of-second replaced by the specified\n  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n MILLI_OF_SECOND -\n  Returns an Instant with the nano-of-second replaced by the specified\n  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n INSTANT_SECONDS -\n  Returns an Instant with the specified epoch-second.\n  The nano-of-second will be unchanged.\n \n \n In all cases, if the new value is outside the valid range of values for the field\n then a DateTimeException will be thrown.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public Instant truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this Instant truncated to the specified unit.\n \n Truncating the instant returns a copy of the original with fields\n smaller than the specified unit set to zero.\n The fields are calculated on the basis of using a UTC offset as seen\n in toString.\n For example, truncating with the MINUTES unit will\n round down to the nearest minute, setting the seconds and nanoseconds to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public Instant plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this instant with the specified amount added.\n \n This returns an Instant, based on this one, with the specified amount added.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Instant plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this instant with the specified amount added.\n \n This returns an Instant, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The supported fields behave as follows:\n \n NANOS -\n  Returns an Instant with the specified number of nanoseconds added.\n  This is equivalent to plusNanos(long).\n MICROS -\n  Returns an Instant with the specified number of microseconds added.\n  This is equivalent to plusNanos(long) with the amount\n  multiplied by 1,000.\n MILLIS -\n  Returns an Instant with the specified number of milliseconds added.\n  This is equivalent to plusNanos(long) with the amount\n  multiplied by 1,000,000.\n SECONDS -\n  Returns an Instant with the specified number of seconds added.\n  This is equivalent to plusSeconds(long).\n MINUTES -\n  Returns an Instant with the specified number of minutes added.\n  This is equivalent to plusSeconds(long) with the amount\n  multiplied by 60.\n HOURS -\n  Returns an Instant with the specified number of hours added.\n  This is equivalent to plusSeconds(long) with the amount\n  multiplied by 3,600.\n HALF_DAYS -\n  Returns an Instant with the specified number of half-days added.\n  This is equivalent to plusSeconds(long) with the amount\n  multiplied by 43,200 (12 hours).\n DAYS -\n  Returns an Instant with the specified number of days added.\n  This is equivalent to plusSeconds(long) with the amount\n  multiplied by 86,400 (24 hours).\n \n \n All other ChronoUnit instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public Instant plusSeconds(long secondsToAdd)",
                  "description": "Returns a copy of this instant with the specified duration in seconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMillis",
              "overloads": [
                {
                  "signature": "public Instant plusMillis(long millisToAdd)",
                  "description": "Returns a copy of this instant with the specified duration in milliseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public Instant plusNanos(long nanosToAdd)",
                  "description": "Returns a copy of this instant with the specified duration in nanoseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public Instant minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this instant with the specified amount subtracted.\n \n This returns an Instant, based on this one, with the specified amount subtracted.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Instant minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this instant with the specified amount subtracted.\n \n This returns an Instant, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public Instant minusSeconds(long secondsToSubtract)",
                  "description": "Returns a copy of this instant with the specified duration in seconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMillis",
              "overloads": [
                {
                  "signature": "public Instant minusMillis(long millisToSubtract)",
                  "description": "Returns a copy of this instant with the specified duration in milliseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public Instant minusNanos(long nanosToSubtract)",
                  "description": "Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this instant using the specified query.\n \n This queries this instant using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this instant.\n \n This returns a temporal object of the same observable type as the input\n with the instant changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n twice, passing ChronoField.INSTANT_SECONDS and\n ChronoField.NANO_OF_SECOND as the fields.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisInstant.adjustInto(temporal);\n   temporal = temporal.with(thisInstant);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another instant in terms of the specified unit.\n \n This calculates the amount of time between two Instant\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified instant.\n The result will be negative if the end is before the start.\n The calculation returns a whole number, representing the number of\n complete units between the two instants.\n The Temporal passed to this method is converted to a\n Instant using from(TemporalAccessor).\n For example, the amount in seconds between two dates can be calculated\n using startInstant.until(endInstant, SECONDS).\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, SECONDS);\n   amount = SECONDS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS, HALF_DAYS and DAYS\n are supported. Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "atOffset",
              "overloads": [
                {
                  "signature": "public OffsetDateTime atOffset(ZoneOffset offset)",
                  "description": "Combines this instant with an offset to create an OffsetDateTime.\n \n This returns an OffsetDateTime formed from this instant at the\n specified offset from UTC/Greenwich. An exception will be thrown if the\n instant is too large to fit into an offset date-time.\n \n This method is equivalent to\n OffsetDateTime.ofInstant(this, offset)."
                }
              ]
            },
            {
              "name": "atZone",
              "overloads": [
                {
                  "signature": "public ZonedDateTime atZone(ZoneId zone)",
                  "description": "Combines this instant with a time-zone to create a ZonedDateTime.\n \n This returns an ZonedDateTime formed from this instant at the\n specified time-zone. An exception will be thrown if the instant is too\n large to fit into a zoned date-time.\n \n This method is equivalent to\n ZonedDateTime.ofInstant(this, zone)."
                }
              ]
            },
            {
              "name": "toEpochMilli",
              "overloads": [
                {
                  "signature": "public long toEpochMilli()",
                  "description": "Converts this instant to the number of milliseconds from the epoch\n of 1970-01-01T00:00:00Z.\n \n If this instant represents a point on the time-line too far in the future\n or past to fit in a long milliseconds, then an exception is thrown.\n \n If this instant has greater than millisecond precision, then the conversion\n will drop any excess precision information as though the amount in nanoseconds\n was subject to integer division by one million."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Instant otherInstant)",
                  "description": "Compares this instant to the specified instant.\n \n The comparison is based on the time-line position of the instants.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(Instant otherInstant)",
                  "description": "Checks if this instant is after the specified instant.\n \n The comparison is based on the time-line position of the instants."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(Instant otherInstant)",
                  "description": "Checks if this instant is before the specified instant.\n \n The comparison is based on the time-line position of the instants."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object other)",
                  "description": "Checks if this instant is equal to the specified instant.\n \n The comparison is based on the time-line position of the instants."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hash code for this instant."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "A string representation of this instant using ISO-8601 representation.\n \n The format used is the same as DateTimeFormatter.ISO_INSTANT."
                }
              ]
            }
          ]
        },
        {
          "name": "InstantSource",
          "methods": [
            {
              "name": "system",
              "overloads": [
                {
                  "signature": "static InstantSource system()",
                  "description": "Obtains a source that returns the current instant using the best available\n system clock.\n \n This source is based on the best available system clock. This may use\n System.currentTimeMillis(), or a higher resolution system clock if\n one is available.\n \n The returned implementation is immutable, thread-safe and\n Serializable."
                }
              ]
            },
            {
              "name": "tick",
              "overloads": [
                {
                  "signature": "static InstantSource tick(InstantSource baseSource, Duration tickDuration)",
                  "description": "Obtains a source that returns instants from the specified source truncated to\n the nearest occurrence of the specified duration.\n \n This source will only tick as per the specified duration. Thus, if the\n duration is half a second, the source will return instants truncated to the\n half second.\n \n The tick duration must be positive. If it has a part smaller than a whole\n millisecond, then the whole duration must divide into one second without\n leaving a remainder. All normal tick durations will match these criteria,\n including any multiple of hours, minutes, seconds and milliseconds, and\n sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.\n \n A duration of zero or one nanosecond would have no truncation effect. Passing\n one of these will return the underlying source.\n \n Implementations may use a caching strategy for performance reasons. As such,\n it is possible that the start of the requested duration observed via this\n source will be later than that observed directly via the underlying source.\n \n The returned implementation is immutable, thread-safe and\n Serializable providing that the base source is."
                }
              ]
            },
            {
              "name": "fixed",
              "overloads": [
                {
                  "signature": "static InstantSource fixed(Instant fixedInstant)",
                  "description": "Obtains a source that always returns the same instant.\n \n This source simply returns the specified instant.\n As such, it is not a source that represents the current instant.\n The main use case for this is in testing, where the fixed source ensures\n tests are not dependent on the current source.\n \n The returned implementation is immutable, thread-safe and Serializable."
                }
              ]
            },
            {
              "name": "offset",
              "overloads": [
                {
                  "signature": "static InstantSource offset(InstantSource baseSource, Duration offsetDuration)",
                  "description": "Obtains a source that returns instants from the specified source with the\n specified duration added.\n \n This source wraps another source, returning instants that are later by the\n specified duration. If the duration is negative, the instants will be\n earlier than the current date and time.\n The main use case for this is to simulate running in the future or in the past.\n \n A duration of zero would have no offsetting effect.\n Passing zero will return the underlying source.\n \n The returned implementation is immutable, thread-safe and Serializable\n providing that the base source is."
                }
              ]
            },
            {
              "name": "instant",
              "overloads": [
                {
                  "signature": "Instant instant()",
                  "description": "Gets the current instant of the source.\n \n This returns an instant representing the current instant as defined by the source."
                }
              ]
            },
            {
              "name": "millis",
              "overloads": [
                {
                  "signature": "default long millis()",
                  "description": "Gets the current millisecond instant of the source.\n \n This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n This is equivalent to the definition of System.currentTimeMillis().\n \n Most applications should avoid this method and use Instant to represent\n an instant on the time-line rather than a raw millisecond value.\n This method is provided to allow the use of the source in high performance use cases\n where the creation of an object would be unacceptable."
                }
              ]
            },
            {
              "name": "withZone",
              "overloads": [
                {
                  "signature": "default Clock withZone(ZoneId zone)",
                  "description": "Returns a clock with the specified time-zone.\n \n This returns a Clock, which is an extension of this interface\n that combines this source and the specified time-zone.\n \n The returned implementation is immutable, thread-safe and Serializable\n providing that this source is."
                }
              ]
            }
          ]
        },
        {
          "name": "LocalDate",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static LocalDate now()",
                  "description": "Obtains the current date from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current date.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalDate now(ZoneId zone)",
                  "description": "Obtains the current date from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current date.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalDate now(Clock clock)",
                  "description": "Obtains the current date from the specified clock.\n \n This will query the specified clock to obtain the current date - today.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static LocalDate of(int year, Month month, int dayOfMonth)",
                  "description": "Obtains an instance of LocalDate from a year, month and day.\n \n This returns a LocalDate with the specified year, month and day-of-month.\n The day must be valid for the year and month, otherwise an exception will be thrown."
                },
                {
                  "signature": "public static LocalDate of(int year, int month, int dayOfMonth)",
                  "description": "Obtains an instance of LocalDate from a year, month and day.\n \n This returns a LocalDate with the specified year, month and day-of-month.\n The day must be valid for the year and month, otherwise an exception will be thrown."
                }
              ]
            },
            {
              "name": "ofYearDay",
              "overloads": [
                {
                  "signature": "public static LocalDate ofYearDay(int year, int dayOfYear)",
                  "description": "Obtains an instance of LocalDate from a year and day-of-year.\n \n This returns a LocalDate with the specified year and day-of-year.\n The day-of-year must be valid for the year, otherwise an exception will be thrown."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static LocalDate ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of LocalDate from an Instant and zone ID.\n \n This creates a local date based on the specified instant.\n First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n which is simple as there is only one valid offset for each instant.\n Then, the instant and offset are used to calculate the local date."
                }
              ]
            },
            {
              "name": "ofEpochDay",
              "overloads": [
                {
                  "signature": "public static LocalDate ofEpochDay(long epochDay)",
                  "description": "Obtains an instance of LocalDate from the epoch day count.\n \n This returns a LocalDate with the specified epoch-day.\n The EPOCH_DAY is a simple incrementing count\n of days where day 0 is 1970-01-01. Negative numbers represent earlier days."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static LocalDate from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of LocalDate from a temporal object.\n \n This obtains a local date based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of LocalDate.\n \n The conversion uses the TemporalQueries.localDate() query, which relies\n on extracting the EPOCH_DAY field.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, LocalDate::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static LocalDate parse(CharSequence text)",
                  "description": "Obtains an instance of LocalDate from a text string such as 2007-12-03.\n \n The string must represent a valid date and is parsed using\n DateTimeFormatter.ISO_LOCAL_DATE."
                },
                {
                  "signature": "public static LocalDate parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of LocalDate from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a date."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this date can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n DAY_OF_WEEK\n ALIGNED_DAY_OF_WEEK_IN_MONTH\n ALIGNED_DAY_OF_WEEK_IN_YEAR\n DAY_OF_MONTH\n DAY_OF_YEAR\n EPOCH_DAY\n ALIGNED_WEEK_OF_MONTH\n ALIGNED_WEEK_OF_YEAR\n MONTH_OF_YEAR\n PROLEPTIC_MONTH\n YEAR_OF_ERA\n YEAR\n ERA\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this date.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n DAYS\n WEEKS\n MONTHS\n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This date is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this date as an int.\n \n This queries this date for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date, except EPOCH_DAY and PROLEPTIC_MONTH\n which are too large to fit in an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this date as a long.\n \n This queries this date for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getChronology",
              "overloads": [
                {
                  "signature": "public IsoChronology getChronology()",
                  "description": "Gets the chronology of this date, which is the ISO calendar system.\n \n The Chronology represents the calendar system in use.\n The ISO-8601 calendar system is the modern civil calendar system used today\n in most of the world. It is equivalent to the proleptic Gregorian calendar\n system, in which today's rules for leap years are applied for all time."
                }
              ]
            },
            {
              "name": "getEra",
              "overloads": [
                {
                  "signature": "public IsoEra getEra()",
                  "description": "Gets the era applicable at this date.\n \n The official ISO-8601 standard does not define eras, however IsoChronology does.\n It defines two eras, 'CE' from year one onwards and 'BCE' from year zero backwards.\n Since dates before the Julian-Gregorian cutover are not in line with history,\n the cutover between 'BCE' and 'CE' is also not aligned with the commonly used\n eras, often referred to using 'BC' and 'AD'.\n \n Users of this class should typically ignore this method as it exists primarily\n to fulfill the ChronoLocalDate contract where it is necessary to support\n the Japanese calendar system."
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "public int getYear()",
                  "description": "Gets the year field.\n \n This method returns the primitive int value for the year.\n \n The year returned by this method is proleptic as per get(YEAR).\n To obtain the year-of-era, use get(YEAR_OF_ERA)."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "getDayOfMonth",
              "overloads": [
                {
                  "signature": "public int getDayOfMonth()",
                  "description": "Gets the day-of-month field.\n \n This method returns the primitive int value for the day-of-month."
                }
              ]
            },
            {
              "name": "getDayOfYear",
              "overloads": [
                {
                  "signature": "public int getDayOfYear()",
                  "description": "Gets the day-of-year field.\n \n This method returns the primitive int value for the day-of-year."
                }
              ]
            },
            {
              "name": "getDayOfWeek",
              "overloads": [
                {
                  "signature": "public DayOfWeek getDayOfWeek()",
                  "description": "Gets the day-of-week field, which is an enum DayOfWeek.\n \n This method returns the enum DayOfWeek for the day-of-week.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value.\n \n Additional information can be obtained from the DayOfWeek.\n This includes textual names of the values."
                }
              ]
            },
            {
              "name": "isLeapYear",
              "overloads": [
                {
                  "signature": "public boolean isLeapYear()",
                  "description": "Checks if the year is a leap year, according to the ISO proleptic\n calendar system rules.\n \n This method applies the current rules for leap years across the whole time-line.\n In general, a year is a leap year if it is divisible by four without\n remainder. However, years divisible by 100, are not leap years, with\n the exception of years divisible by 400 which are.\n \n For example, 1904 is a leap year it is divisible by 4.\n 1900 was not a leap year as it is divisible by 100, however 2000 was a\n leap year as it is divisible by 400.\n \n The calculation is proleptic - applying the same rules into the far future and far past.\n This is historically inaccurate, but is correct for the ISO-8601 standard."
                }
              ]
            },
            {
              "name": "lengthOfMonth",
              "overloads": [
                {
                  "signature": "public int lengthOfMonth()",
                  "description": "Returns the length of the month represented by this date.\n \n This returns the length of the month in days.\n For example, a date in January would return 31."
                }
              ]
            },
            {
              "name": "lengthOfYear",
              "overloads": [
                {
                  "signature": "public int lengthOfYear()",
                  "description": "Returns the length of the year represented by this date.\n \n This returns the length of the year in days, either 365 or 366."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public LocalDate with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this date.\n \n This returns a LocalDate, based on this one, with the date adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the year field.\n A more complex adjuster might set the date to the last day of the month.\n \n A selection of common adjustments is provided in\n TemporalAdjusters.\n These include finding the \"last day of the month\" and \"next Wednesday\".\n Key date-time classes also implement the TemporalAdjuster interface,\n such as Month and MonthDay.\n The adjuster is responsible for handling special cases, such as the varying\n lengths of month and leap years.\n \n For example this code returns a date on the last day of July:\n   import static java.time.Month.*;\n  import static java.time.temporal.TemporalAdjusters.*;\n\n  result = localDate.with(JULY).with(lastDayOfMonth());\n \n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDate with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this date with the specified field set to a new value.\n \n This returns a LocalDate, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the year, month or day-of-month.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n In some cases, changing the specified field can cause the resulting date to become invalid,\n such as changing the month from 31st January to February would make the day-of-month invalid.\n In cases like this, the field is responsible for resolving the date. Typically it will choose\n the previous valid date, which would be the last valid day of February in this example.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields behave as follows:\n \n DAY_OF_WEEK -\n  Returns a LocalDate with the specified day-of-week.\n  The date is adjusted up to 6 days forward or backward within the boundary\n  of a Monday to Sunday week.\n ALIGNED_DAY_OF_WEEK_IN_MONTH -\n  Returns a LocalDate with the specified aligned-day-of-week.\n  The date is adjusted to the specified month-based aligned-day-of-week.\n  Aligned weeks are counted such that the first week of a given month starts\n  on the first day of that month.\n  This may cause the date to be moved up to 6 days into the following month.\n ALIGNED_DAY_OF_WEEK_IN_YEAR -\n  Returns a LocalDate with the specified aligned-day-of-week.\n  The date is adjusted to the specified year-based aligned-day-of-week.\n  Aligned weeks are counted such that the first week of a given year starts\n  on the first day of that year.\n  This may cause the date to be moved up to 6 days into the following year.\n DAY_OF_MONTH -\n  Returns a LocalDate with the specified day-of-month.\n  The month and year will be unchanged. If the day-of-month is invalid for the\n  year and month, then a DateTimeException is thrown.\n DAY_OF_YEAR -\n  Returns a LocalDate with the specified day-of-year.\n  The year will be unchanged. If the day-of-year is invalid for the\n  year, then a DateTimeException is thrown.\n EPOCH_DAY -\n  Returns a LocalDate with the specified epoch-day.\n  This completely replaces the date and is equivalent to ofEpochDay(long).\n ALIGNED_WEEK_OF_MONTH -\n  Returns a LocalDate with the specified aligned-week-of-month.\n  Aligned weeks are counted such that the first week of a given month starts\n  on the first day of that month.\n  This adjustment moves the date in whole week chunks to match the specified week.\n  The result will have the same day-of-week as this date.\n  This may cause the date to be moved into the following month.\n ALIGNED_WEEK_OF_YEAR -\n  Returns a LocalDate with the specified aligned-week-of-year.\n  Aligned weeks are counted such that the first week of a given year starts\n  on the first day of that year.\n  This adjustment moves the date in whole week chunks to match the specified week.\n  The result will have the same day-of-week as this date.\n  This may cause the date to be moved into the following year.\n MONTH_OF_YEAR -\n  Returns a LocalDate with the specified month-of-year.\n  The year will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n PROLEPTIC_MONTH -\n  Returns a LocalDate with the specified proleptic-month.\n  The day-of-month will be unchanged, unless it would be invalid for the new month\n  and year. In that case, the day-of-month is adjusted to the maximum valid value\n  for the new month and year.\n YEAR_OF_ERA -\n  Returns a LocalDate with the specified year-of-era.\n  The era and month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n YEAR -\n  Returns a LocalDate with the specified year.\n  The month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n ERA -\n  Returns a LocalDate with the specified era.\n  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n \n \n In all cases, if the new value is outside the valid range of values for the field\n then a DateTimeException will be thrown.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withYear",
              "overloads": [
                {
                  "signature": "public LocalDate withYear(int year)",
                  "description": "Returns a copy of this LocalDate with the year altered.\n \n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public LocalDate withMonth(int month)",
                  "description": "Returns a copy of this LocalDate with the month-of-year altered.\n \n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfMonth",
              "overloads": [
                {
                  "signature": "public LocalDate withDayOfMonth(int dayOfMonth)",
                  "description": "Returns a copy of this LocalDate with the day-of-month altered.\n \n If the resulting date is invalid, an exception is thrown.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfYear",
              "overloads": [
                {
                  "signature": "public LocalDate withDayOfYear(int dayOfYear)",
                  "description": "Returns a copy of this LocalDate with the day-of-year altered.\n \n If the resulting date is invalid, an exception is thrown.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public LocalDate plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this date with the specified amount added.\n \n This returns a LocalDate, based on this one, with the specified amount added.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDate plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this date with the specified amount added.\n \n This returns a LocalDate, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n In some cases, adding the amount can cause the resulting date to become invalid.\n For example, adding one month to 31st January would result in 31st February.\n In cases like this, the unit is responsible for resolving the date.\n Typically it will choose the previous valid date, which would be the last valid\n day of February in this example.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The supported fields behave as follows:\n \n DAYS -\n  Returns a LocalDate with the specified number of days added.\n  This is equivalent to plusDays(long).\n WEEKS -\n  Returns a LocalDate with the specified number of weeks added.\n  This is equivalent to plusWeeks(long) and uses a 7 day week.\n MONTHS -\n  Returns a LocalDate with the specified number of months added.\n  This is equivalent to plusMonths(long).\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n YEARS -\n  Returns a LocalDate with the specified number of years added.\n  This is equivalent to plusYears(long).\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n DECADES -\n  Returns a LocalDate with the specified number of decades added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 10.\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n CENTURIES -\n  Returns a LocalDate with the specified number of centuries added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 100.\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n MILLENNIA -\n  Returns a LocalDate with the specified number of millennia added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 1,000.\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n ERAS -\n  Returns a LocalDate with the specified number of eras added.\n  Only two eras are supported so the amount must be one, zero or minus one.\n  If the amount is non-zero then the year is changed such that the year-of-era\n  is unchanged.\n  The day-of-month will be unchanged unless it would be invalid for the new\n  month and year. In that case, the day-of-month is adjusted to the maximum\n  valid value for the new month and year.\n \n \n All other ChronoUnit instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public LocalDate plusYears(long yearsToAdd)",
                  "description": "Returns a copy of this LocalDate with the specified number of years added.\n \n This method adds the specified amount to the years field in three steps:\n \n Add the input years to the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) plus one year would result in the\n invalid date 2009-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2009-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public LocalDate plusMonths(long monthsToAdd)",
                  "description": "Returns a copy of this LocalDate with the specified number of months added.\n \n This method adds the specified amount to the months field in three steps:\n \n Add the input months to the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 plus one month would result in the invalid date\n 2007-04-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-04-30, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusWeeks",
              "overloads": [
                {
                  "signature": "public LocalDate plusWeeks(long weeksToAdd)",
                  "description": "Returns a copy of this LocalDate with the specified number of weeks added.\n \n This method adds the specified amount in weeks to the days field incrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one week would result in 2009-01-07.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public LocalDate plusDays(long daysToAdd)",
                  "description": "Returns a copy of this LocalDate with the specified number of days added.\n \n This method adds the specified amount to the days field incrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one day would result in 2009-01-01.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public LocalDate minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this date with the specified amount subtracted.\n \n This returns a LocalDate, based on this one, with the specified amount subtracted.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDate minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this date with the specified amount subtracted.\n \n This returns a LocalDate, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public LocalDate minusYears(long yearsToSubtract)",
                  "description": "Returns a copy of this LocalDate with the specified number of years subtracted.\n \n This method subtracts the specified amount from the years field in three steps:\n \n Subtract the input years from the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) minus one year would result in the\n invalid date 2007-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public LocalDate minusMonths(long monthsToSubtract)",
                  "description": "Returns a copy of this LocalDate with the specified number of months subtracted.\n \n This method subtracts the specified amount from the months field in three steps:\n \n Subtract the input months from the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 minus one month would result in the invalid date\n 2007-02-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusWeeks",
              "overloads": [
                {
                  "signature": "public LocalDate minusWeeks(long weeksToSubtract)",
                  "description": "Returns a copy of this LocalDate with the specified number of weeks subtracted.\n \n This method subtracts the specified amount in weeks from the days field decrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-07 minus one week would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public LocalDate minusDays(long daysToSubtract)",
                  "description": "Returns a copy of this LocalDate with the specified number of days subtracted.\n \n This method subtracts the specified amount from the days field decrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-01 minus one day would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this date using the specified query.\n \n This queries this date using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same date as this object.\n \n This returns a temporal object of the same observable type as the input\n with the date changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.EPOCH_DAY as the field.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisLocalDate.adjustInto(temporal);\n   temporal = temporal.with(thisLocalDate);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another date in terms of the specified unit.\n \n This calculates the amount of time between two LocalDate\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified date.\n The result will be negative if the end is before the start.\n The Temporal passed to this method is converted to a\n LocalDate using from(TemporalAccessor).\n For example, the amount in days between two dates can be calculated\n using startDate.until(endDate, DAYS).\n \n The calculation returns a whole number, representing the number of\n complete units between the two dates.\n For example, the amount in months between 2012-06-15 and 2012-08-14\n will only be one month as it is one day short of two months.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MONTHS);\n   amount = MONTHS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units DAYS, WEEKS, MONTHS, YEARS,\n DECADES, CENTURIES, MILLENNIA and ERAS\n are supported. Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Period until(ChronoLocalDate endDateExclusive)",
                  "description": "Calculates the period between this date and another date as a Period.\n \n This calculates the period between two dates in terms of years, months and days.\n The start and end points are this and the specified date.\n The result will be negative if the end is before the start.\n The negative sign will be the same in each of year, month and day.\n \n The calculation is performed using the ISO calendar system.\n If necessary, the input date will be converted to ISO.\n \n The start date is included, but the end date is not.\n The period is calculated by removing complete months, then calculating\n the remaining number of days, adjusting to ensure that both have the same sign.\n The number of months is then normalized into years and months based on a 12 month year.\n A month is considered to be complete if the end day-of-month is greater\n than or equal to the start day-of-month.\n For example, from 2010-01-15 to 2011-03-18 is \"1 year, 2 months and 3 days\".\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use Period.between(LocalDate, LocalDate):\n    // these two lines are equivalent\n   period = start.until(end);\n   period = Period.between(start, end);\n \n The choice should be made based on which makes the code more readable."
                }
              ]
            },
            {
              "name": "datesUntil",
              "overloads": [
                {
                  "signature": "public Stream<LocalDate> datesUntil(LocalDate endExclusive)",
                  "description": "Returns a sequential ordered stream of dates. The returned stream starts from this date\n (inclusive) and goes to endExclusive (exclusive) by an incremental step of 1 day.\n \n This method is equivalent to datesUntil(endExclusive, Period.ofDays(1))."
                },
                {
                  "signature": "public Stream<LocalDate> datesUntil(LocalDate endExclusive, Period step)",
                  "description": "Returns a sequential ordered stream of dates by given incremental step. The returned stream\n starts from this date (inclusive) and goes to endExclusive (exclusive).\n \n The n-th date which appears in the stream is equal to this.plus(step.multipliedBy(n))\n (but the result of step multiplication never overflows). For example, if this date is\n 2015-01-31, the end date is 2015-05-01 and the step is 1 month, then the\n stream contains 2015-01-31, 2015-02-28, 2015-03-31, and\n 2015-04-30."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this date using the specified formatter.\n \n This date will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atTime",
              "overloads": [
                {
                  "signature": "public LocalDateTime atTime(LocalTime time)",
                  "description": "Combines this date with a time to create a LocalDateTime.\n \n This returns a LocalDateTime formed from this date at the specified time.\n All possible combinations of date and time are valid."
                },
                {
                  "signature": "public LocalDateTime atTime(int hour, int minute)",
                  "description": "Combines this date with a time to create a LocalDateTime.\n \n This returns a LocalDateTime formed from this date at the\n specified hour and minute.\n The seconds and nanosecond fields will be set to zero.\n The individual time fields must be within their valid range.\n All possible combinations of date and time are valid."
                },
                {
                  "signature": "public LocalDateTime atTime(int hour, int minute, int second)",
                  "description": "Combines this date with a time to create a LocalDateTime.\n \n This returns a LocalDateTime formed from this date at the\n specified hour, minute and second.\n The nanosecond field will be set to zero.\n The individual time fields must be within their valid range.\n All possible combinations of date and time are valid."
                },
                {
                  "signature": "public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond)",
                  "description": "Combines this date with a time to create a LocalDateTime.\n \n This returns a LocalDateTime formed from this date at the\n specified hour, minute, second and nanosecond.\n The individual time fields must be within their valid range.\n All possible combinations of date and time are valid."
                },
                {
                  "signature": "public OffsetDateTime atTime(OffsetTime time)",
                  "description": "Combines this date with an offset time to create an OffsetDateTime.\n \n This returns an OffsetDateTime formed from this date at the specified time.\n All possible combinations of date and time are valid."
                }
              ]
            },
            {
              "name": "atStartOfDay",
              "overloads": [
                {
                  "signature": "public LocalDateTime atStartOfDay()",
                  "description": "Combines this date with the time of midnight to create a LocalDateTime\n at the start of this date.\n \n This returns a LocalDateTime formed from this date at the time of\n midnight, 00:00, at the start of this date."
                },
                {
                  "signature": "public ZonedDateTime atStartOfDay(ZoneId zone)",
                  "description": "Returns a zoned date-time from this date at the earliest valid time according\n to the rules in the time-zone.\n \n Time-zone rules, such as daylight savings, mean that not every local date-time\n is valid for the specified zone, thus the local date-time may not be midnight.\n \n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, there are two valid offsets, and the earlier one is used,\n corresponding to the first occurrence of midnight on the date.\n In the case of a gap, the zoned date-time will represent the instant just after the gap.\n \n If the zone ID is a ZoneOffset, then the result always has a time of midnight.\n \n To convert to a specific time in a given time-zone call atTime(LocalTime)\n followed by LocalDateTime.atZone(ZoneId)."
                }
              ]
            },
            {
              "name": "toEpochSecond",
              "overloads": [
                {
                  "signature": "public long toEpochSecond(LocalTime time, ZoneOffset offset)",
                  "description": "Converts this LocalDate to the number of seconds since the epoch\n of 1970-01-01T00:00:00Z.\n \n This combines this local date with the specified time and\n offset to calculate the epoch-second value, which is the\n number of elapsed seconds from 1970-01-01T00:00:00Z.\n Instants on the time-line after the epoch are positive, earlier\n are negative."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ChronoLocalDate other)",
                  "description": "Compares this date to another date.\n \n The comparison is primarily based on the date, from earliest to latest.\n It is \"consistent with equals\", as defined by Comparable.\n \n If all the dates being compared are instances of LocalDate,\n then the comparison will be entirely based on the date.\n If some dates being compared are in different chronologies, then the\n chronology is also considered, see ChronoLocalDate.compareTo(java.time.chrono.ChronoLocalDate)."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(ChronoLocalDate other)",
                  "description": "Checks if this date is after the specified date.\n \n This checks to see if this date represents a point on the\n local time-line after the other date.\n    LocalDate a = LocalDate.of(2012, 6, 30);\n   LocalDate b = LocalDate.of(2012, 7, 1);\n   a.isAfter(b) == false\n   a.isAfter(a) == false\n   b.isAfter(a) == true\n \n \n This method only considers the position of the two dates on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDate),\n but is the same approach as ChronoLocalDate.timeLineOrder()."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(ChronoLocalDate other)",
                  "description": "Checks if this date is before the specified date.\n \n This checks to see if this date represents a point on the\n local time-line before the other date.\n    LocalDate a = LocalDate.of(2012, 6, 30);\n   LocalDate b = LocalDate.of(2012, 7, 1);\n   a.isBefore(b) == true\n   a.isBefore(a) == false\n   b.isBefore(a) == false\n \n \n This method only considers the position of the two dates on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDate),\n but is the same approach as ChronoLocalDate.timeLineOrder()."
                }
              ]
            },
            {
              "name": "isEqual",
              "overloads": [
                {
                  "signature": "public boolean isEqual(ChronoLocalDate other)",
                  "description": "Checks if this date is equal to the specified date.\n \n This checks to see if this date represents the same point on the\n local time-line as the other date.\n    LocalDate a = LocalDate.of(2012, 6, 30);\n   LocalDate b = LocalDate.of(2012, 7, 1);\n   a.isEqual(b) == false\n   a.isEqual(a) == true\n   b.isEqual(a) == false\n \n \n This method only considers the position of the two dates on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDate)\n but is the same approach as ChronoLocalDate.timeLineOrder()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this date is equal to another date.\n \n Compares this LocalDate with another ensuring that the date is the same.\n \n Only objects of type LocalDate are compared, other types return false.\n To compare the dates of two TemporalAccessor instances, including dates\n in two different chronologies, use ChronoField.EPOCH_DAY as a comparator."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this date."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this date as a String, such as 2007-12-03.\n \n The output will be in the ISO-8601 format uuuu-MM-dd."
                }
              ]
            }
          ]
        },
        {
          "name": "LocalDateTime",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static LocalDateTime now()",
                  "description": "Obtains the current date-time from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current date-time.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalDateTime now(ZoneId zone)",
                  "description": "Obtains the current date-time from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current date-time.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalDateTime now(Clock clock)",
                  "description": "Obtains the current date-time from the specified clock.\n \n This will query the specified clock to obtain the current date-time.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour and minute, setting the second and nanosecond to zero.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour and minute.\n The day must be valid for the year and month, otherwise an exception will be thrown.\n The second and nanosecond fields will be set to zero."
                },
                {
                  "signature": "public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour, minute and second, setting the nanosecond to zero.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour, minute and second.\n The day must be valid for the year and month, otherwise an exception will be thrown.\n The nanosecond field will be set to zero."
                },
                {
                  "signature": "public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour, minute, second and nanosecond.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour, minute, second and nanosecond.\n The day must be valid for the year and month, otherwise an exception will be thrown."
                },
                {
                  "signature": "public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour and minute, setting the second and nanosecond to zero.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour and minute.\n The day must be valid for the year and month, otherwise an exception will be thrown.\n The second and nanosecond fields will be set to zero."
                },
                {
                  "signature": "public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour, minute and second, setting the nanosecond to zero.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour, minute and second.\n The day must be valid for the year and month, otherwise an exception will be thrown.\n The nanosecond field will be set to zero."
                },
                {
                  "signature": "public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)",
                  "description": "Obtains an instance of LocalDateTime from year, month,\n day, hour, minute, second and nanosecond.\n \n This returns a LocalDateTime with the specified year, month,\n day-of-month, hour, minute, second and nanosecond.\n The day must be valid for the year and month, otherwise an exception will be thrown."
                },
                {
                  "signature": "public static LocalDateTime of(LocalDate date, LocalTime time)",
                  "description": "Obtains an instance of LocalDateTime from a date and time."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static LocalDateTime ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of LocalDateTime from an Instant and zone ID.\n \n This creates a local date-time based on the specified instant.\n First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n which is simple as there is only one valid offset for each instant.\n Then, the instant and offset are used to calculate the local date-time."
                }
              ]
            },
            {
              "name": "ofEpochSecond",
              "overloads": [
                {
                  "signature": "public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)",
                  "description": "Obtains an instance of LocalDateTime using seconds from the\n epoch of 1970-01-01T00:00:00Z.\n \n This allows the epoch-second field\n to be converted to a local date-time. This is primarily intended for\n low-level conversions rather than general application usage."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static LocalDateTime from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of LocalDateTime from a temporal object.\n \n This obtains a local date-time based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of LocalDateTime.\n \n The conversion extracts and combines the LocalDate and the\n LocalTime from the temporal object.\n Implementations are permitted to perform optimizations such as accessing\n those fields that are equivalent to the relevant objects.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, LocalDateTime::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static LocalDateTime parse(CharSequence text)",
                  "description": "Obtains an instance of LocalDateTime from a text string such as 2007-12-03T10:15:30.\n \n The string must represent a valid date-time and is parsed using\n DateTimeFormatter.ISO_LOCAL_DATE_TIME."
                },
                {
                  "signature": "public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of LocalDateTime from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a date-time."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this date-time can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n NANO_OF_DAY\n MICRO_OF_SECOND\n MICRO_OF_DAY\n MILLI_OF_SECOND\n MILLI_OF_DAY\n SECOND_OF_MINUTE\n SECOND_OF_DAY\n MINUTE_OF_HOUR\n MINUTE_OF_DAY\n HOUR_OF_AMPM\n CLOCK_HOUR_OF_AMPM\n HOUR_OF_DAY\n CLOCK_HOUR_OF_DAY\n AMPM_OF_DAY\n DAY_OF_WEEK\n ALIGNED_DAY_OF_WEEK_IN_MONTH\n ALIGNED_DAY_OF_WEEK_IN_YEAR\n DAY_OF_MONTH\n DAY_OF_YEAR\n EPOCH_DAY\n ALIGNED_WEEK_OF_MONTH\n ALIGNED_WEEK_OF_YEAR\n MONTH_OF_YEAR\n PROLEPTIC_MONTH\n YEAR_OF_ERA\n YEAR\n ERA\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this date-time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n DAYS\n WEEKS\n MONTHS\n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This date-time is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as an int.\n \n This queries this date-time for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time, except NANO_OF_DAY, MICRO_OF_DAY,\n EPOCH_DAY and PROLEPTIC_MONTH which are too large to fit in\n an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as a long.\n \n This queries this date-time for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "toLocalDate",
              "overloads": [
                {
                  "signature": "public LocalDate toLocalDate()",
                  "description": "Gets the LocalDate part of this date-time.\n \n This returns a LocalDate with the same year, month and day\n as this date-time."
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "public int getYear()",
                  "description": "Gets the year field.\n \n This method returns the primitive int value for the year.\n \n The year returned by this method is proleptic as per get(YEAR).\n To obtain the year-of-era, use get(YEAR_OF_ERA)."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "getDayOfMonth",
              "overloads": [
                {
                  "signature": "public int getDayOfMonth()",
                  "description": "Gets the day-of-month field.\n \n This method returns the primitive int value for the day-of-month."
                }
              ]
            },
            {
              "name": "getDayOfYear",
              "overloads": [
                {
                  "signature": "public int getDayOfYear()",
                  "description": "Gets the day-of-year field.\n \n This method returns the primitive int value for the day-of-year."
                }
              ]
            },
            {
              "name": "getDayOfWeek",
              "overloads": [
                {
                  "signature": "public DayOfWeek getDayOfWeek()",
                  "description": "Gets the day-of-week field, which is an enum DayOfWeek.\n \n This method returns the enum DayOfWeek for the day-of-week.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value.\n \n Additional information can be obtained from the DayOfWeek.\n This includes textual names of the values."
                }
              ]
            },
            {
              "name": "toLocalTime",
              "overloads": [
                {
                  "signature": "public LocalTime toLocalTime()",
                  "description": "Gets the LocalTime part of this date-time.\n \n This returns a LocalTime with the same hour, minute, second and\n nanosecond as this date-time."
                }
              ]
            },
            {
              "name": "getHour",
              "overloads": [
                {
                  "signature": "public int getHour()",
                  "description": "Gets the hour-of-day field."
                }
              ]
            },
            {
              "name": "getMinute",
              "overloads": [
                {
                  "signature": "public int getMinute()",
                  "description": "Gets the minute-of-hour field."
                }
              ]
            },
            {
              "name": "getSecond",
              "overloads": [
                {
                  "signature": "public int getSecond()",
                  "description": "Gets the second-of-minute field."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the nano-of-second field."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public LocalDateTime with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this date-time.\n \n This returns a LocalDateTime, based on this one, with the date-time adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the year field.\n A more complex adjuster might set the date to the last day of the month.\n \n A selection of common adjustments is provided in\n TemporalAdjusters.\n These include finding the \"last day of the month\" and \"next Wednesday\".\n Key date-time classes also implement the TemporalAdjuster interface,\n such as Month and MonthDay.\n The adjuster is responsible for handling special cases, such as the varying\n lengths of month and leap years.\n \n For example this code returns a date on the last day of July:\n   import static java.time.Month.*;\n  import static java.time.temporal.TemporalAdjusters.*;\n\n  result = localDateTime.with(JULY).with(lastDayOfMonth());\n \n \n The classes LocalDate and LocalTime implement TemporalAdjuster,\n thus this method can be used to change the date, time or offset:\n   result = localDateTime.with(date);\n  result = localDateTime.with(time);\n \n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDateTime with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this date-time with the specified field set to a new value.\n \n This returns a LocalDateTime, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the year, month or day-of-month.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n In some cases, changing the specified field can cause the resulting date-time to become invalid,\n such as changing the month from 31st January to February would make the day-of-month invalid.\n In cases like this, the field is responsible for resolving the date. Typically it will choose\n the previous valid date, which would be the last valid day of February in this example.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields will behave as per\n the matching method on LocalDate\n or LocalTime.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withYear",
              "overloads": [
                {
                  "signature": "public LocalDateTime withYear(int year)",
                  "description": "Returns a copy of this LocalDateTime with the year altered.\n \n The time does not affect the calculation and will be the same in the result.\n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public LocalDateTime withMonth(int month)",
                  "description": "Returns a copy of this LocalDateTime with the month-of-year altered.\n \n The time does not affect the calculation and will be the same in the result.\n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfMonth",
              "overloads": [
                {
                  "signature": "public LocalDateTime withDayOfMonth(int dayOfMonth)",
                  "description": "Returns a copy of this LocalDateTime with the day-of-month altered.\n \n If the resulting date-time is invalid, an exception is thrown.\n The time does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfYear",
              "overloads": [
                {
                  "signature": "public LocalDateTime withDayOfYear(int dayOfYear)",
                  "description": "Returns a copy of this LocalDateTime with the day-of-year altered.\n \n If the resulting date-time is invalid, an exception is thrown.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withHour",
              "overloads": [
                {
                  "signature": "public LocalDateTime withHour(int hour)",
                  "description": "Returns a copy of this LocalDateTime with the hour-of-day altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMinute",
              "overloads": [
                {
                  "signature": "public LocalDateTime withMinute(int minute)",
                  "description": "Returns a copy of this LocalDateTime with the minute-of-hour altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withSecond",
              "overloads": [
                {
                  "signature": "public LocalDateTime withSecond(int second)",
                  "description": "Returns a copy of this LocalDateTime with the second-of-minute altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNano",
              "overloads": [
                {
                  "signature": "public LocalDateTime withNano(int nanoOfSecond)",
                  "description": "Returns a copy of this LocalDateTime with the nano-of-second altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public LocalDateTime truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this LocalDateTime with the time truncated.\n \n Truncation returns a copy of the original date-time with fields\n smaller than the specified unit set to zero.\n For example, truncating with the minutes unit\n will set the second-of-minute and nano-of-second field to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public LocalDateTime plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns a LocalDateTime, based on this one, with the specified amount added.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDateTime plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns a LocalDateTime, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n Date units are added as per LocalDate.plus(long, TemporalUnit).\n Time units are added as per LocalTime.plus(long, TemporalUnit) with\n any overflow in days added equivalent to using plusDays(long).\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusYears(long years)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of years added.\n \n This method adds the specified amount to the years field in three steps:\n \n Add the input years to the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) plus one year would result in the\n invalid date 2009-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2009-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusMonths(long months)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of months added.\n \n This method adds the specified amount to the months field in three steps:\n \n Add the input months to the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 plus one month would result in the invalid date\n 2007-04-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-04-30, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusWeeks",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusWeeks(long weeks)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of weeks added.\n \n This method adds the specified amount in weeks to the days field incrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one week would result in 2009-01-07.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusDays(long days)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of days added.\n \n This method adds the specified amount to the days field incrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one day would result in 2009-01-01.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusHours(long hours)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of hours added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusMinutes(long minutes)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of minutes added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusSeconds(long seconds)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of seconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public LocalDateTime plusNanos(long nanos)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of nanoseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public LocalDateTime minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns a LocalDateTime, based on this one, with the specified amount subtracted.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalDateTime minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns a LocalDateTime, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusYears(long years)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of years subtracted.\n \n This method subtracts the specified amount from the years field in three steps:\n \n Subtract the input years from the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) minus one year would result in the\n invalid date 2007-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusMonths(long months)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of months subtracted.\n \n This method subtracts the specified amount from the months field in three steps:\n \n Subtract the input months from the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 minus one month would result in the invalid date\n 2007-02-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusWeeks",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusWeeks(long weeks)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of weeks subtracted.\n \n This method subtracts the specified amount in weeks from the days field decrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-07 minus one week would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusDays(long days)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of days subtracted.\n \n This method subtracts the specified amount from the days field decrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-01 minus one day would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusHours(long hours)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of hours subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusMinutes(long minutes)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of minutes subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusSeconds(long seconds)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of seconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public LocalDateTime minusNanos(long nanos)",
                  "description": "Returns a copy of this LocalDateTime with the specified number of nanoseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this date-time using the specified query.\n \n This queries this date-time using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same date and time as this object.\n \n This returns a temporal object of the same observable type as the input\n with the date and time changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n twice, passing ChronoField.EPOCH_DAY and\n ChronoField.NANO_OF_DAY as the fields.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisLocalDateTime.adjustInto(temporal);\n   temporal = temporal.with(thisLocalDateTime);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another date-time in terms of the specified unit.\n \n This calculates the amount of time between two LocalDateTime\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified date-time.\n The result will be negative if the end is before the start.\n The Temporal passed to this method is converted to a\n LocalDateTime using from(TemporalAccessor).\n For example, the amount in days between two date-times can be calculated\n using startDateTime.until(endDateTime, DAYS).\n \n The calculation returns a whole number, representing the number of\n complete units between the two date-times.\n For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n will only be one month as it is one minute short of two months.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MONTHS);\n   amount = MONTHS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS and HALF_DAYS, DAYS,\n WEEKS, MONTHS, YEARS, DECADES,\n CENTURIES, MILLENNIA and ERAS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this date-time using the specified formatter.\n \n This date-time will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atOffset",
              "overloads": [
                {
                  "signature": "public OffsetDateTime atOffset(ZoneOffset offset)",
                  "description": "Combines this date-time with an offset to create an OffsetDateTime.\n \n This returns an OffsetDateTime formed from this date-time at the specified offset.\n All possible combinations of date-time and offset are valid."
                }
              ]
            },
            {
              "name": "atZone",
              "overloads": [
                {
                  "signature": "public ZonedDateTime atZone(ZoneId zone)",
                  "description": "Combines this date-time with a time-zone to create a ZonedDateTime.\n \n This returns a ZonedDateTime formed from this date-time at the\n specified time-zone. The result will match this date-time as closely as possible.\n Time-zone rules, such as daylight savings, mean that not every local date-time\n is valid for the specified zone, thus the local date-time may be adjusted.\n \n The local date-time is resolved to a single instant on the time-line.\n This is achieved by finding a valid offset from UTC/Greenwich for the local\n date-time as defined by the rules of the zone ID.\n\n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, where clocks are set back, there are two valid offsets.\n This method uses the earlier offset typically corresponding to \"summer\".\n \n In the case of a gap, where clocks jump forward, there is no valid offset.\n Instead, the local date-time is adjusted to be later by the length of the gap.\n For a typical one hour daylight savings change, the local date-time will be\n moved one hour later into the offset typically corresponding to \"summer\".\n \n To obtain the later offset during an overlap, call\n ZonedDateTime.withLaterOffsetAtOverlap() on the result of this method.\n To throw an exception when there is a gap or overlap, use\n ZonedDateTime.ofStrict(LocalDateTime, ZoneOffset, ZoneId)."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ChronoLocalDateTime<?> other)",
                  "description": "Compares this date-time to another date-time.\n \n The comparison is primarily based on the date-time, from earliest to latest.\n It is \"consistent with equals\", as defined by Comparable.\n \n If all the date-times being compared are instances of LocalDateTime,\n then the comparison will be entirely based on the date-time.\n If some dates being compared are in different chronologies, then the\n chronology is also considered, see ChronoLocalDateTime.compareTo(java.time.chrono.ChronoLocalDateTime<?>)."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(ChronoLocalDateTime<?> other)",
                  "description": "Checks if this date-time is after the specified date-time.\n \n This checks to see if this date-time represents a point on the\n local time-line after the other date-time.\n    LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n   a.isAfter(b) == false\n   a.isAfter(a) == false\n   b.isAfter(a) == true\n \n \n This method only considers the position of the two date-times on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDateTime),\n but is the same approach as ChronoLocalDateTime.timeLineOrder()."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(ChronoLocalDateTime<?> other)",
                  "description": "Checks if this date-time is before the specified date-time.\n \n This checks to see if this date-time represents a point on the\n local time-line before the other date-time.\n    LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n   a.isBefore(b) == true\n   a.isBefore(a) == false\n   b.isBefore(a) == false\n \n \n This method only considers the position of the two date-times on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDateTime),\n but is the same approach as ChronoLocalDateTime.timeLineOrder()."
                }
              ]
            },
            {
              "name": "isEqual",
              "overloads": [
                {
                  "signature": "public boolean isEqual(ChronoLocalDateTime<?> other)",
                  "description": "Checks if this date-time is equal to the specified date-time.\n \n This checks to see if this date-time represents the same point on the\n local time-line as the other date-time.\n    LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n   a.isEqual(b) == false\n   a.isEqual(a) == true\n   b.isEqual(a) == false\n \n \n This method only considers the position of the two date-times on the local time-line.\n It does not take into account the chronology, or calendar system.\n This is different from the comparison in compareTo(ChronoLocalDateTime),\n but is the same approach as ChronoLocalDateTime.timeLineOrder()."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this date-time is equal to another date-time.\n \n Compares this LocalDateTime with another ensuring that the date-time is the same.\n Only objects of type LocalDateTime are compared, other types return false."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this date-time."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this date-time as a String, such as 2007-12-03T10:15:30.\n \n The output will be one of the following ISO-8601 formats:\n \n uuuu-MM-dd'T'HH:mm\n uuuu-MM-dd'T'HH:mm:ss\n uuuu-MM-dd'T'HH:mm:ss.SSS\n uuuu-MM-dd'T'HH:mm:ss.SSSSSS\n uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSS\n \n The format used will be the shortest that outputs the full value of\n the time where the omitted parts are implied to be zero."
                }
              ]
            }
          ]
        },
        {
          "name": "LocalTime",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static LocalTime now()",
                  "description": "Obtains the current time from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current time.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalTime now(ZoneId zone)",
                  "description": "Obtains the current time from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current time.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static LocalTime now(Clock clock)",
                  "description": "Obtains the current time from the specified clock.\n \n This will query the specified clock to obtain the current time.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static LocalTime of(int hour, int minute)",
                  "description": "Obtains an instance of LocalTime from an hour and minute.\n \n This returns a LocalTime with the specified hour and minute.\n The second and nanosecond fields will be set to zero."
                },
                {
                  "signature": "public static LocalTime of(int hour, int minute, int second)",
                  "description": "Obtains an instance of LocalTime from an hour, minute and second.\n \n This returns a LocalTime with the specified hour, minute and second.\n The nanosecond field will be set to zero."
                },
                {
                  "signature": "public static LocalTime of(int hour, int minute, int second, int nanoOfSecond)",
                  "description": "Obtains an instance of LocalTime from an hour, minute, second and nanosecond.\n \n This returns a LocalTime with the specified hour, minute, second and nanosecond."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static LocalTime ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of LocalTime from an Instant and zone ID.\n \n This creates a local time based on the specified instant.\n First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n which is simple as there is only one valid offset for each instant.\n Then, the instant and offset are used to calculate the local time."
                }
              ]
            },
            {
              "name": "ofSecondOfDay",
              "overloads": [
                {
                  "signature": "public static LocalTime ofSecondOfDay(long secondOfDay)",
                  "description": "Obtains an instance of LocalTime from a second-of-day value.\n \n This returns a LocalTime with the specified second-of-day.\n The nanosecond field will be set to zero."
                }
              ]
            },
            {
              "name": "ofNanoOfDay",
              "overloads": [
                {
                  "signature": "public static LocalTime ofNanoOfDay(long nanoOfDay)",
                  "description": "Obtains an instance of LocalTime from a nanos-of-day value.\n \n This returns a LocalTime with the specified nanosecond-of-day."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static LocalTime from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of LocalTime from a temporal object.\n \n This obtains a local time based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of LocalTime.\n \n The conversion uses the TemporalQueries.localTime() query, which relies\n on extracting the NANO_OF_DAY field.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, LocalTime::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static LocalTime parse(CharSequence text)",
                  "description": "Obtains an instance of LocalTime from a text string such as 10:15.\n \n The string must represent a valid time and is parsed using\n DateTimeFormatter.ISO_LOCAL_TIME."
                },
                {
                  "signature": "public static LocalTime parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of LocalTime from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a time."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this time can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n NANO_OF_DAY\n MICRO_OF_SECOND\n MICRO_OF_DAY\n MILLI_OF_SECOND\n MILLI_OF_DAY\n SECOND_OF_MINUTE\n SECOND_OF_DAY\n MINUTE_OF_HOUR\n MINUTE_OF_DAY\n HOUR_OF_AMPM\n CLOCK_HOUR_OF_AMPM\n HOUR_OF_DAY\n CLOCK_HOUR_OF_DAY\n AMPM_OF_DAY\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This time is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this time as an int.\n \n This queries this time for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this time, except NANO_OF_DAY and MICRO_OF_DAY\n which are too large to fit in an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this time as a long.\n \n This queries this time for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getHour",
              "overloads": [
                {
                  "signature": "public int getHour()",
                  "description": "Gets the hour-of-day field."
                }
              ]
            },
            {
              "name": "getMinute",
              "overloads": [
                {
                  "signature": "public int getMinute()",
                  "description": "Gets the minute-of-hour field."
                }
              ]
            },
            {
              "name": "getSecond",
              "overloads": [
                {
                  "signature": "public int getSecond()",
                  "description": "Gets the second-of-minute field."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the nano-of-second field."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public LocalTime with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this time.\n \n This returns a LocalTime, based on this one, with the time adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the hour field.\n A more complex adjuster might set the time to the last hour of the day.\n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalTime with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this time with the specified field set to a new value.\n \n This returns a LocalTime, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the hour, minute or second.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields behave as follows:\n \n NANO_OF_SECOND -\n  Returns a LocalTime with the specified nano-of-second.\n  The hour, minute and second will be unchanged.\n NANO_OF_DAY -\n  Returns a LocalTime with the specified nano-of-day.\n  This completely replaces the time and is equivalent to ofNanoOfDay(long).\n MICRO_OF_SECOND -\n  Returns a LocalTime with the nano-of-second replaced by the specified\n  micro-of-second multiplied by 1,000.\n  The hour, minute and second will be unchanged.\n MICRO_OF_DAY -\n  Returns a LocalTime with the specified micro-of-day.\n  This completely replaces the time and is equivalent to using ofNanoOfDay(long)\n  with the micro-of-day multiplied by 1,000.\n MILLI_OF_SECOND -\n  Returns a LocalTime with the nano-of-second replaced by the specified\n  milli-of-second multiplied by 1,000,000.\n  The hour, minute and second will be unchanged.\n MILLI_OF_DAY -\n  Returns a LocalTime with the specified milli-of-day.\n  This completely replaces the time and is equivalent to using ofNanoOfDay(long)\n  with the milli-of-day multiplied by 1,000,000.\n SECOND_OF_MINUTE -\n  Returns a LocalTime with the specified second-of-minute.\n  The hour, minute and nano-of-second will be unchanged.\n SECOND_OF_DAY -\n  Returns a LocalTime with the specified second-of-day.\n  The nano-of-second will be unchanged.\n MINUTE_OF_HOUR -\n  Returns a LocalTime with the specified minute-of-hour.\n  The hour, second-of-minute and nano-of-second will be unchanged.\n MINUTE_OF_DAY -\n  Returns a LocalTime with the specified minute-of-day.\n  The second-of-minute and nano-of-second will be unchanged.\n HOUR_OF_AMPM -\n  Returns a LocalTime with the specified hour-of-am-pm.\n  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n CLOCK_HOUR_OF_AMPM -\n  Returns a LocalTime with the specified clock-hour-of-am-pm.\n  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n HOUR_OF_DAY -\n  Returns a LocalTime with the specified hour-of-day.\n  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n CLOCK_HOUR_OF_DAY -\n  Returns a LocalTime with the specified clock-hour-of-day.\n  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n AMPM_OF_DAY -\n  Returns a LocalTime with the specified AM/PM.\n  The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n \n \n In all cases, if the new value is outside the valid range of values for the field\n then a DateTimeException will be thrown.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withHour",
              "overloads": [
                {
                  "signature": "public LocalTime withHour(int hour)",
                  "description": "Returns a copy of this LocalTime with the hour-of-day altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMinute",
              "overloads": [
                {
                  "signature": "public LocalTime withMinute(int minute)",
                  "description": "Returns a copy of this LocalTime with the minute-of-hour altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withSecond",
              "overloads": [
                {
                  "signature": "public LocalTime withSecond(int second)",
                  "description": "Returns a copy of this LocalTime with the second-of-minute altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNano",
              "overloads": [
                {
                  "signature": "public LocalTime withNano(int nanoOfSecond)",
                  "description": "Returns a copy of this LocalTime with the nano-of-second altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public LocalTime truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this LocalTime with the time truncated.\n \n Truncation returns a copy of the original time with fields\n smaller than the specified unit set to zero.\n For example, truncating with the minutes unit\n will set the second-of-minute and nano-of-second field to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public LocalTime plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this time with the specified amount added.\n \n This returns a LocalTime, based on this one, with the specified amount added.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalTime plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this time with the specified amount added.\n \n This returns a LocalTime, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The supported fields behave as follows:\n \n NANOS -\n  Returns a LocalTime with the specified number of nanoseconds added.\n  This is equivalent to plusNanos(long).\n MICROS -\n  Returns a LocalTime with the specified number of microseconds added.\n  This is equivalent to plusNanos(long) with the amount\n  multiplied by 1,000.\n MILLIS -\n  Returns a LocalTime with the specified number of milliseconds added.\n  This is equivalent to plusNanos(long) with the amount\n  multiplied by 1,000,000.\n SECONDS -\n  Returns a LocalTime with the specified number of seconds added.\n  This is equivalent to plusSeconds(long).\n MINUTES -\n  Returns a LocalTime with the specified number of minutes added.\n  This is equivalent to plusMinutes(long).\n HOURS -\n  Returns a LocalTime with the specified number of hours added.\n  This is equivalent to plusHours(long).\n HALF_DAYS -\n  Returns a LocalTime with the specified number of half-days added.\n  This is equivalent to plusHours(long) with the amount\n  multiplied by 12.\n \n \n All other ChronoUnit instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public LocalTime plusHours(long hoursToAdd)",
                  "description": "Returns a copy of this LocalTime with the specified number of hours added.\n \n This adds the specified number of hours to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public LocalTime plusMinutes(long minutesToAdd)",
                  "description": "Returns a copy of this LocalTime with the specified number of minutes added.\n \n This adds the specified number of minutes to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public LocalTime plusSeconds(long secondstoAdd)",
                  "description": "Returns a copy of this LocalTime with the specified number of seconds added.\n \n This adds the specified number of seconds to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public LocalTime plusNanos(long nanosToAdd)",
                  "description": "Returns a copy of this LocalTime with the specified number of nanoseconds added.\n \n This adds the specified number of nanoseconds to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public LocalTime minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this time with the specified amount subtracted.\n \n This returns a LocalTime, based on this one, with the specified amount subtracted.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public LocalTime minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this time with the specified amount subtracted.\n \n This returns a LocalTime, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public LocalTime minusHours(long hoursToSubtract)",
                  "description": "Returns a copy of this LocalTime with the specified number of hours subtracted.\n \n This subtracts the specified number of hours from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public LocalTime minusMinutes(long minutesToSubtract)",
                  "description": "Returns a copy of this LocalTime with the specified number of minutes subtracted.\n \n This subtracts the specified number of minutes from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public LocalTime minusSeconds(long secondsToSubtract)",
                  "description": "Returns a copy of this LocalTime with the specified number of seconds subtracted.\n \n This subtracts the specified number of seconds from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public LocalTime minusNanos(long nanosToSubtract)",
                  "description": "Returns a copy of this LocalTime with the specified number of nanoseconds subtracted.\n \n This subtracts the specified number of nanoseconds from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this time using the specified query.\n \n This queries this time using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same time as this object.\n \n This returns a temporal object of the same observable type as the input\n with the time changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.NANO_OF_DAY as the field.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisLocalTime.adjustInto(temporal);\n   temporal = temporal.with(thisLocalTime);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another time in terms of the specified unit.\n \n This calculates the amount of time between two LocalTime\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified time.\n The result will be negative if the end is before the start.\n The Temporal passed to this method is converted to a\n LocalTime using from(TemporalAccessor).\n For example, the amount in hours between two times can be calculated\n using startTime.until(endTime, HOURS).\n \n The calculation returns a whole number, representing the number of\n complete units between the two times.\n For example, the amount in hours between 11:30 and 13:29 will only\n be one hour as it is one minute short of two hours.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MINUTES);\n   amount = MINUTES.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS and HALF_DAYS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this time using the specified formatter.\n \n This time will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atDate",
              "overloads": [
                {
                  "signature": "public LocalDateTime atDate(LocalDate date)",
                  "description": "Combines this time with a date to create a LocalDateTime.\n \n This returns a LocalDateTime formed from this time at the specified date.\n All possible combinations of date and time are valid."
                }
              ]
            },
            {
              "name": "atOffset",
              "overloads": [
                {
                  "signature": "public OffsetTime atOffset(ZoneOffset offset)",
                  "description": "Combines this time with an offset to create an OffsetTime.\n \n This returns an OffsetTime formed from this time at the specified offset.\n All possible combinations of time and offset are valid."
                }
              ]
            },
            {
              "name": "toSecondOfDay",
              "overloads": [
                {
                  "signature": "public int toSecondOfDay()",
                  "description": "Extracts the time as seconds of day,\n from 0 to 24 * 60 * 60 - 1."
                }
              ]
            },
            {
              "name": "toNanoOfDay",
              "overloads": [
                {
                  "signature": "public long toNanoOfDay()",
                  "description": "Extracts the time as nanos of day,\n from 0 to 24 * 60 * 60 * 1,000,000,000 - 1."
                }
              ]
            },
            {
              "name": "toEpochSecond",
              "overloads": [
                {
                  "signature": "public long toEpochSecond(LocalDate date, ZoneOffset offset)",
                  "description": "Converts this LocalTime to the number of seconds since the epoch\n of 1970-01-01T00:00:00Z.\n \n This combines this local time with the specified date and\n offset to calculate the epoch-second value, which is the\n number of elapsed seconds from 1970-01-01T00:00:00Z.\n Instants on the time-line after the epoch are positive, earlier\n are negative."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(LocalTime other)",
                  "description": "Compares this time to another time.\n \n The comparison is based on the time-line position of the local times within a day.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(LocalTime other)",
                  "description": "Checks if this time is after the specified time.\n \n The comparison is based on the time-line position of the time within a day."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(LocalTime other)",
                  "description": "Checks if this time is before the specified time.\n \n The comparison is based on the time-line position of the time within a day."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this time is equal to another time.\n \n The comparison is based on the time-line position of the time within a day.\n \n Only objects of type LocalTime are compared, other types return false.\n To compare the date of two TemporalAccessor instances, use\n ChronoField.NANO_OF_DAY as a comparator."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this time."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this time as a String, such as 10:15.\n \n The output will be one of the following ISO-8601 formats:\n \n HH:mm\n HH:mm:ss\n HH:mm:ss.SSS\n HH:mm:ss.SSSSSS\n HH:mm:ss.SSSSSSSSS\n \n The format used will be the shortest that outputs the full value of\n the time where the omitted parts are implied to be zero."
                }
              ]
            }
          ]
        },
        {
          "name": "MonthDay",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static MonthDay now()",
                  "description": "Obtains the current month-day from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current month-day.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static MonthDay now(ZoneId zone)",
                  "description": "Obtains the current month-day from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current month-day.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static MonthDay now(Clock clock)",
                  "description": "Obtains the current month-day from the specified clock.\n \n This will query the specified clock to obtain the current month-day.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static MonthDay of(Month month, int dayOfMonth)",
                  "description": "Obtains an instance of MonthDay.\n \n The day-of-month must be valid for the month within a leap year.\n Hence, for February, day 29 is valid.\n \n For example, passing in April and day 31 will throw an exception, as\n there can never be April 31st in any year. By contrast, passing in\n February 29th is permitted, as that month-day can sometimes be valid."
                },
                {
                  "signature": "public static MonthDay of(int month, int dayOfMonth)",
                  "description": "Obtains an instance of MonthDay.\n \n The day-of-month must be valid for the month within a leap year.\n Hence, for month 2 (February), day 29 is valid.\n \n For example, passing in month 4 (April) and day 31 will throw an exception, as\n there can never be April 31st in any year. By contrast, passing in\n February 29th is permitted, as that month-day can sometimes be valid."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static MonthDay from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of MonthDay from a temporal object.\n \n This obtains a month-day based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of MonthDay.\n \n The conversion extracts the MONTH_OF_YEAR and\n DAY_OF_MONTH fields.\n The extraction is only permitted if the temporal object has an ISO\n chronology, or can be converted to a LocalDate.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, MonthDay::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static MonthDay parse(CharSequence text)",
                  "description": "Obtains an instance of MonthDay from a text string such as --12-03.\n \n The string must represent a valid month-day.\n The format is --MM-dd."
                },
                {
                  "signature": "public static MonthDay parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of MonthDay from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a month-day."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this month-day can be queried for the specified field.\n If false, then calling the range and\n get methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n MONTH_OF_YEAR\n YEAR\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This month-day is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this month-day as an int.\n \n This queries this month-day for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this month-day.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this month-day as a long.\n \n This queries this month-day for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this month-day.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "getDayOfMonth",
              "overloads": [
                {
                  "signature": "public int getDayOfMonth()",
                  "description": "Gets the day-of-month field.\n \n This method returns the primitive int value for the day-of-month."
                }
              ]
            },
            {
              "name": "isValidYear",
              "overloads": [
                {
                  "signature": "public boolean isValidYear(int year)",
                  "description": "Checks if the year is valid for this month-day.\n \n This method checks whether this month and day and the input year form\n a valid date. This can only return false for February 29th."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public MonthDay withMonth(int month)",
                  "description": "Returns a copy of this MonthDay with the month-of-year altered.\n \n This returns a month-day with the specified month.\n If the day-of-month is invalid for the specified month, the day will\n be adjusted to the last valid day-of-month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public MonthDay with(Month month)",
                  "description": "Returns a copy of this MonthDay with the month-of-year altered.\n \n This returns a month-day with the specified month.\n If the day-of-month is invalid for the specified month, the day will\n be adjusted to the last valid day-of-month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfMonth",
              "overloads": [
                {
                  "signature": "public MonthDay withDayOfMonth(int dayOfMonth)",
                  "description": "Returns a copy of this MonthDay with the day-of-month altered.\n \n This returns a month-day with the specified day-of-month.\n If the day-of-month is invalid for the month, an exception is thrown.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this month-day using the specified query.\n \n This queries this month-day using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this month-day.\n \n This returns a temporal object of the same observable type as the input\n with the month and day-of-month changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n twice, passing ChronoField.MONTH_OF_YEAR and\n ChronoField.DAY_OF_MONTH as the fields.\n If the specified temporal object does not use the ISO calendar system then\n a DateTimeException is thrown.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisMonthDay.adjustInto(temporal);\n   temporal = temporal.with(thisMonthDay);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this month-day using the specified formatter.\n \n This month-day will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atYear",
              "overloads": [
                {
                  "signature": "public LocalDate atYear(int year)",
                  "description": "Combines this month-day with a year to create a LocalDate.\n \n This returns a LocalDate formed from this month-day and the specified year.\n \n A month-day of February 29th will be adjusted to February 28th in the resulting\n date if the year is not a leap year.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(MonthDay other)",
                  "description": "Compares this month-day to another month-day.\n \n The comparison is based first on value of the month, then on the value of the day.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(MonthDay other)",
                  "description": "Checks if this month-day is after the specified month-day."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(MonthDay other)",
                  "description": "Checks if this month-day is before the specified month-day."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this month-day is equal to another month-day.\n \n The comparison is based on the time-line position of the month-day within a year."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this month-day."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this month-day as a String, such as --12-03.\n \n The output will be in the format --MM-dd:"
                }
              ]
            }
          ]
        },
        {
          "name": "OffsetDateTime",
          "methods": [
            {
              "name": "timeLineOrder",
              "overloads": [
                {
                  "signature": "public static Comparator<OffsetDateTime> timeLineOrder()",
                  "description": "Gets a comparator that compares two OffsetDateTime instances\n based solely on the instant.\n \n This method differs from the comparison in compareTo(java.time.OffsetDateTime) in that it\n only compares the underlying instant."
                }
              ]
            },
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static OffsetDateTime now()",
                  "description": "Obtains the current date-time from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current date-time.\n The offset will be calculated from the time-zone in the clock.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static OffsetDateTime now(ZoneId zone)",
                  "description": "Obtains the current date-time from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current date-time.\n Specifying the time-zone avoids dependence on the default time-zone.\n The offset will be calculated from the specified time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static OffsetDateTime now(Clock clock)",
                  "description": "Obtains the current date-time from the specified clock.\n \n This will query the specified clock to obtain the current date-time.\n The offset will be calculated from the time-zone in the clock.\n \n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static OffsetDateTime of(LocalDate date, LocalTime time, ZoneOffset offset)",
                  "description": "Obtains an instance of OffsetDateTime from a date, time and offset.\n \n This creates an offset date-time with the specified local date, time and offset."
                },
                {
                  "signature": "public static OffsetDateTime of(LocalDateTime dateTime, ZoneOffset offset)",
                  "description": "Obtains an instance of OffsetDateTime from a date-time and offset.\n \n This creates an offset date-time with the specified local date-time and offset."
                },
                {
                  "signature": "public static OffsetDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset)",
                  "description": "Obtains an instance of OffsetDateTime from a year, month, day,\n hour, minute, second, nanosecond and offset.\n \n This creates an offset date-time with the seven specified fields.\n \n This method exists primarily for writing test cases.\n Non test-code will typically use other methods to create an offset time.\n LocalDateTime has five additional convenience variants of the\n equivalent factory method taking fewer arguments.\n They are not provided here to reduce the footprint of the API."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static OffsetDateTime ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of OffsetDateTime from an Instant and zone ID.\n \n This creates an offset date-time with the same instant as that specified.\n Finding the offset from UTC/Greenwich is simple as there is only one valid\n offset for each instant."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static OffsetDateTime from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of OffsetDateTime from a temporal object.\n \n This obtains an offset date-time based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of OffsetDateTime.\n \n The conversion will first obtain a ZoneOffset from the temporal object.\n It will then try to obtain a LocalDateTime, falling back to an Instant if necessary.\n The result will be the combination of ZoneOffset with either\n with LocalDateTime or Instant.\n Implementations are permitted to perform optimizations such as accessing\n those fields that are equivalent to the relevant objects.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, OffsetDateTime::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static OffsetDateTime parse(CharSequence text)",
                  "description": "Obtains an instance of OffsetDateTime from a text string\n such as 2007-12-03T10:15:30+01:00.\n \n The string must represent a valid date-time and is parsed using\n DateTimeFormatter.ISO_OFFSET_DATE_TIME."
                },
                {
                  "signature": "public static OffsetDateTime parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of OffsetDateTime from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a date-time."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this date-time can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n NANO_OF_DAY\n MICRO_OF_SECOND\n MICRO_OF_DAY\n MILLI_OF_SECOND\n MILLI_OF_DAY\n SECOND_OF_MINUTE\n SECOND_OF_DAY\n MINUTE_OF_HOUR\n MINUTE_OF_DAY\n HOUR_OF_AMPM\n CLOCK_HOUR_OF_AMPM\n HOUR_OF_DAY\n CLOCK_HOUR_OF_DAY\n AMPM_OF_DAY\n DAY_OF_WEEK\n ALIGNED_DAY_OF_WEEK_IN_MONTH\n ALIGNED_DAY_OF_WEEK_IN_YEAR\n DAY_OF_MONTH\n DAY_OF_YEAR\n EPOCH_DAY\n ALIGNED_WEEK_OF_MONTH\n ALIGNED_WEEK_OF_YEAR\n MONTH_OF_YEAR\n PROLEPTIC_MONTH\n YEAR_OF_ERA\n YEAR\n ERA\n INSTANT_SECONDS\n OFFSET_SECONDS\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this date-time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n DAYS\n WEEKS\n MONTHS\n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This date-time is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as an int.\n \n This queries this date-time for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time, except NANO_OF_DAY, MICRO_OF_DAY,\n EPOCH_DAY, PROLEPTIC_MONTH and INSTANT_SECONDS which are too\n large to fit in an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as a long.\n \n This queries this date-time for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public ZoneOffset getOffset()",
                  "description": "Gets the zone offset, such as '+01:00'.\n \n This is the offset of the local date-time from UTC/Greenwich."
                }
              ]
            },
            {
              "name": "withOffsetSameLocal",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withOffsetSameLocal(ZoneOffset offset)",
                  "description": "Returns a copy of this OffsetDateTime with the specified offset ensuring\n that the result has the same local date-time.\n \n This method returns an object with the same LocalDateTime and the specified ZoneOffset.\n No calculation is needed or performed.\n For example, if this time represents 2007-12-03T10:30+02:00 and the offset specified is\n +03:00, then this method will return 2007-12-03T10:30+03:00.\n \n To take into account the difference between the offsets, and adjust the time fields,\n use withOffsetSameInstant(java.time.ZoneOffset).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withOffsetSameInstant",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withOffsetSameInstant(ZoneOffset offset)",
                  "description": "Returns a copy of this OffsetDateTime with the specified offset ensuring\n that the result is at the same instant.\n \n This method returns an object with the specified ZoneOffset and a LocalDateTime\n adjusted by the difference between the two offsets.\n This will result in the old and new objects representing the same instant.\n This is useful for finding the local time in a different offset.\n For example, if this time represents 2007-12-03T10:30+02:00 and the offset specified is\n +03:00, then this method will return 2007-12-03T11:30+03:00.\n \n To change the offset without adjusting the local time use withOffsetSameLocal(java.time.ZoneOffset).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toLocalDateTime",
              "overloads": [
                {
                  "signature": "public LocalDateTime toLocalDateTime()",
                  "description": "Gets the LocalDateTime part of this date-time.\n \n This returns a LocalDateTime with the same year, month, day and time\n as this date-time."
                }
              ]
            },
            {
              "name": "toLocalDate",
              "overloads": [
                {
                  "signature": "public LocalDate toLocalDate()",
                  "description": "Gets the LocalDate part of this date-time.\n \n This returns a LocalDate with the same year, month and day\n as this date-time."
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "public int getYear()",
                  "description": "Gets the year field.\n \n This method returns the primitive int value for the year.\n \n The year returned by this method is proleptic as per get(YEAR).\n To obtain the year-of-era, use get(YEAR_OF_ERA)."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "getDayOfMonth",
              "overloads": [
                {
                  "signature": "public int getDayOfMonth()",
                  "description": "Gets the day-of-month field.\n \n This method returns the primitive int value for the day-of-month."
                }
              ]
            },
            {
              "name": "getDayOfYear",
              "overloads": [
                {
                  "signature": "public int getDayOfYear()",
                  "description": "Gets the day-of-year field.\n \n This method returns the primitive int value for the day-of-year."
                }
              ]
            },
            {
              "name": "getDayOfWeek",
              "overloads": [
                {
                  "signature": "public DayOfWeek getDayOfWeek()",
                  "description": "Gets the day-of-week field, which is an enum DayOfWeek.\n \n This method returns the enum DayOfWeek for the day-of-week.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value.\n \n Additional information can be obtained from the DayOfWeek.\n This includes textual names of the values."
                }
              ]
            },
            {
              "name": "toLocalTime",
              "overloads": [
                {
                  "signature": "public LocalTime toLocalTime()",
                  "description": "Gets the LocalTime part of this date-time.\n \n This returns a LocalTime with the same hour, minute, second and\n nanosecond as this date-time."
                }
              ]
            },
            {
              "name": "getHour",
              "overloads": [
                {
                  "signature": "public int getHour()",
                  "description": "Gets the hour-of-day field."
                }
              ]
            },
            {
              "name": "getMinute",
              "overloads": [
                {
                  "signature": "public int getMinute()",
                  "description": "Gets the minute-of-hour field."
                }
              ]
            },
            {
              "name": "getSecond",
              "overloads": [
                {
                  "signature": "public int getSecond()",
                  "description": "Gets the second-of-minute field."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the nano-of-second field."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public OffsetDateTime with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this date-time.\n \n This returns an OffsetDateTime, based on this one, with the date-time adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the year field.\n A more complex adjuster might set the date to the last day of the month.\n A selection of common adjustments is provided in\n TemporalAdjusters.\n These include finding the \"last day of the month\" and \"next Wednesday\".\n Key date-time classes also implement the TemporalAdjuster interface,\n such as Month and MonthDay.\n The adjuster is responsible for handling special cases, such as the varying\n lengths of month and leap years.\n \n For example this code returns a date on the last day of July:\n   import static java.time.Month.*;\n  import static java.time.temporal.TemporalAdjusters.*;\n\n  result = offsetDateTime.with(JULY).with(lastDayOfMonth());\n \n \n The classes LocalDate, LocalTime and ZoneOffset implement\n TemporalAdjuster, thus this method can be used to change the date, time or offset:\n   result = offsetDateTime.with(date);\n  result = offsetDateTime.with(time);\n  result = offsetDateTime.with(offset);\n \n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetDateTime with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this date-time with the specified field set to a new value.\n \n This returns an OffsetDateTime, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the year, month or day-of-month.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n In some cases, changing the specified field can cause the resulting date-time to become invalid,\n such as changing the month from 31st January to February would make the day-of-month invalid.\n In cases like this, the field is responsible for resolving the date. Typically it will choose\n the previous valid date, which would be the last valid day of February in this example.\n \n If the field is a ChronoField then the adjustment is implemented here.\n \n The INSTANT_SECONDS field will return a date-time with the specified instant.\n The offset and nano-of-second are unchanged.\n If the new instant value is outside the valid range then a DateTimeException will be thrown.\n \n The OFFSET_SECONDS field will return a date-time with the specified offset.\n The local date-time is unaltered. If the new offset value is outside the valid range\n then a DateTimeException will be thrown.\n \n The other supported fields will behave as per\n the matching method on LocalDateTime.\n In this case, the offset is not part of the calculation and will be unchanged.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withYear",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withYear(int year)",
                  "description": "Returns a copy of this OffsetDateTime with the year altered.\n \n The time and offset do not affect the calculation and will be the same in the result.\n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withMonth(int month)",
                  "description": "Returns a copy of this OffsetDateTime with the month-of-year altered.\n \n The time and offset do not affect the calculation and will be the same in the result.\n If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfMonth",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withDayOfMonth(int dayOfMonth)",
                  "description": "Returns a copy of this OffsetDateTime with the day-of-month altered.\n \n If the resulting OffsetDateTime is invalid, an exception is thrown.\n The time and offset do not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfYear",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withDayOfYear(int dayOfYear)",
                  "description": "Returns a copy of this OffsetDateTime with the day-of-year altered.\n \n The time and offset do not affect the calculation and will be the same in the result.\n If the resulting OffsetDateTime is invalid, an exception is thrown.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withHour",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withHour(int hour)",
                  "description": "Returns a copy of this OffsetDateTime with the hour-of-day altered.\n \n The date and offset do not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMinute",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withMinute(int minute)",
                  "description": "Returns a copy of this OffsetDateTime with the minute-of-hour altered.\n \n The date and offset do not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withSecond",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withSecond(int second)",
                  "description": "Returns a copy of this OffsetDateTime with the second-of-minute altered.\n \n The date and offset do not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNano",
              "overloads": [
                {
                  "signature": "public OffsetDateTime withNano(int nanoOfSecond)",
                  "description": "Returns a copy of this OffsetDateTime with the nano-of-second altered.\n \n The date and offset do not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public OffsetDateTime truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this OffsetDateTime with the time truncated.\n \n Truncation returns a copy of the original date-time with fields\n smaller than the specified unit set to zero.\n For example, truncating with the minutes unit\n will set the second-of-minute and nano-of-second field to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns an OffsetDateTime, based on this one, with the specified amount added.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetDateTime plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns an OffsetDateTime, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented by\n LocalDateTime.plus(long, TemporalUnit).\n The offset is not part of the calculation and will be unchanged in the result.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusYears(long years)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of years added.\n \n This method adds the specified amount to the years field in three steps:\n \n Add the input years to the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) plus one year would result in the\n invalid date 2009-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2009-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusMonths(long months)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of months added.\n \n This method adds the specified amount to the months field in three steps:\n \n Add the input months to the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 plus one month would result in the invalid date\n 2007-04-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-04-30, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusWeeks",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusWeeks(long weeks)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of weeks added.\n \n This method adds the specified amount in weeks to the days field incrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one week would result in 2009-01-07.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusDays(long days)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of days added.\n \n This method adds the specified amount to the days field incrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2008-12-31 plus one day would result in 2009-01-01.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusHours(long hours)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of hours added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusMinutes(long minutes)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of minutes added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusSeconds(long seconds)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of seconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public OffsetDateTime plusNanos(long nanos)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of nanoseconds added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns an OffsetDateTime, based on this one, with the specified amount subtracted.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetDateTime minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns an OffsetDateTime, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusYears(long years)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of years subtracted.\n \n This method subtracts the specified amount from the years field in three steps:\n \n Subtract the input years from the year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2008-02-29 (leap year) minus one year would result in the\n invalid date 2007-02-29 (standard year). Instead of returning an invalid\n result, the last valid day of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusMonths(long months)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of months subtracted.\n \n This method subtracts the specified amount from the months field in three steps:\n \n Subtract the input months from the month-of-year field\n Check if the resulting date would be invalid\n Adjust the day-of-month to the last valid day if necessary\n \n \n For example, 2007-03-31 minus one month would result in the invalid date\n 2007-02-31. Instead of returning an invalid result, the last valid day\n of the month, 2007-02-28, is selected instead.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusWeeks",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusWeeks(long weeks)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of weeks subtracted.\n \n This method subtracts the specified amount in weeks from the days field decrementing\n the month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-07 minus one week would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusDays(long days)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of days subtracted.\n \n This method subtracts the specified amount from the days field decrementing the\n month and year fields as necessary to ensure the result remains valid.\n The result is only invalid if the maximum/minimum year is exceeded.\n \n For example, 2009-01-01 minus one day would result in 2008-12-31.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusHours(long hours)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of hours subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusMinutes(long minutes)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of minutes subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusSeconds(long seconds)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of seconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public OffsetDateTime minusNanos(long nanos)",
                  "description": "Returns a copy of this OffsetDateTime with the specified number of nanoseconds subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this date-time using the specified query.\n \n This queries this date-time using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same offset, date\n and time as this object.\n \n This returns a temporal object of the same observable type as the input\n with the offset, date and time changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n three times, passing ChronoField.EPOCH_DAY,\n ChronoField.NANO_OF_DAY and ChronoField.OFFSET_SECONDS as the fields.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisOffsetDateTime.adjustInto(temporal);\n   temporal = temporal.with(thisOffsetDateTime);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another date-time in terms of the specified unit.\n \n This calculates the amount of time between two OffsetDateTime\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified date-time.\n The result will be negative if the end is before the start.\n For example, the amount in days between two date-times can be calculated\n using startDateTime.until(endDateTime, DAYS).\n \n The Temporal passed to this method is converted to a\n OffsetDateTime using from(TemporalAccessor).\n If the offset differs between the two date-times, the specified\n end date-time is normalized to have the same offset as this date-time.\n \n The calculation returns a whole number, representing the number of\n complete units between the two date-times.\n For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n will only be one month as it is one minute short of two months.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MONTHS);\n   amount = MONTHS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS and HALF_DAYS, DAYS,\n WEEKS, MONTHS, YEARS, DECADES,\n CENTURIES, MILLENNIA and ERAS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this date-time using the specified formatter.\n \n This date-time will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atZoneSameInstant",
              "overloads": [
                {
                  "signature": "public ZonedDateTime atZoneSameInstant(ZoneId zone)",
                  "description": "Combines this date-time with a time-zone to create a ZonedDateTime\n ensuring that the result has the same instant.\n \n This returns a ZonedDateTime formed from this date-time and the specified time-zone.\n This conversion will ignore the visible local date-time and use the underlying instant instead.\n This avoids any problems with local time-line gaps or overlaps.\n The result might have different values for fields such as hour, minute an even day.\n \n To attempt to retain the values of the fields, use atZoneSimilarLocal(ZoneId).\n To use the offset as the zone ID, use toZonedDateTime()."
                }
              ]
            },
            {
              "name": "atZoneSimilarLocal",
              "overloads": [
                {
                  "signature": "public ZonedDateTime atZoneSimilarLocal(ZoneId zone)",
                  "description": "Combines this date-time with a time-zone to create a ZonedDateTime\n trying to keep the same local date and time.\n \n This returns a ZonedDateTime formed from this date-time and the specified time-zone.\n Where possible, the result will have the same local date-time as this object.\n \n Time-zone rules, such as daylight savings, mean that not every time on the\n local time-line exists. If the local date-time is in a gap or overlap according to\n the rules then a resolver is used to determine the resultant local time and offset.\n This method uses ZonedDateTime.ofLocal(LocalDateTime, ZoneId, ZoneOffset)\n to retain the offset from this instance if possible.\n \n Finer control over gaps and overlaps is available in two ways.\n If you simply want to use the later offset at overlaps then call\n ZonedDateTime.withLaterOffsetAtOverlap() immediately after this method.\n \n To create a zoned date-time at the same instant irrespective of the local time-line,\n use atZoneSameInstant(ZoneId).\n To use the offset as the zone ID, use toZonedDateTime()."
                }
              ]
            },
            {
              "name": "toOffsetTime",
              "overloads": [
                {
                  "signature": "public OffsetTime toOffsetTime()",
                  "description": "Converts this date-time to an OffsetTime.\n \n This returns an offset time with the same local time and offset."
                }
              ]
            },
            {
              "name": "toZonedDateTime",
              "overloads": [
                {
                  "signature": "public ZonedDateTime toZonedDateTime()",
                  "description": "Converts this date-time to a ZonedDateTime using the offset as the zone ID.\n \n This creates the simplest possible ZonedDateTime using the offset\n as the zone ID.\n \n To control the time-zone used, see atZoneSameInstant(ZoneId) and\n atZoneSimilarLocal(ZoneId)."
                }
              ]
            },
            {
              "name": "toInstant",
              "overloads": [
                {
                  "signature": "public Instant toInstant()",
                  "description": "Converts this date-time to an Instant.\n \n This returns an Instant representing the same point on the\n time-line as this date-time."
                }
              ]
            },
            {
              "name": "toEpochSecond",
              "overloads": [
                {
                  "signature": "public long toEpochSecond()",
                  "description": "Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n \n This allows this date-time to be converted to a value of the\n epoch-seconds field. This is primarily\n intended for low-level conversions rather than general application usage."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(OffsetDateTime other)",
                  "description": "Compares this date-time to another date-time.\n \n The comparison is based on the instant then on the local date-time.\n It is \"consistent with equals\", as defined by Comparable.\n \n For example, the following is the comparator order:\n \n 2008-12-03T10:30+01:00\n 2008-12-03T11:00+01:00\n 2008-12-03T12:00+02:00\n 2008-12-03T11:30+01:00\n 2008-12-03T12:00+01:00\n 2008-12-03T12:30+01:00\n \n Values #2 and #3 represent the same instant on the time-line.\n When two values represent the same instant, the local date-time is compared\n to distinguish them. This step is needed to make the ordering\n consistent with equals()."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(OffsetDateTime other)",
                  "description": "Checks if the instant of this date-time is after that of the specified date-time.\n \n This method differs from the comparison in compareTo(java.time.OffsetDateTime) and equals(java.lang.Object) in that it\n only compares the instant of the date-time. This is equivalent to using\n dateTime1.toInstant().isAfter(dateTime2.toInstant());."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(OffsetDateTime other)",
                  "description": "Checks if the instant of this date-time is before that of the specified date-time.\n \n This method differs from the comparison in compareTo(java.time.OffsetDateTime) in that it\n only compares the instant of the date-time. This is equivalent to using\n dateTime1.toInstant().isBefore(dateTime2.toInstant());."
                }
              ]
            },
            {
              "name": "isEqual",
              "overloads": [
                {
                  "signature": "public boolean isEqual(OffsetDateTime other)",
                  "description": "Checks if the instant of this date-time is equal to that of the specified date-time.\n \n This method differs from the comparison in compareTo(java.time.OffsetDateTime) and equals(java.lang.Object)\n in that it only compares the instant of the date-time. This is equivalent to using\n dateTime1.toInstant().equals(dateTime2.toInstant());."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this date-time is equal to another date-time.\n \n The comparison is based on the local date-time and the offset.\n To compare for the same instant on the time-line, use isEqual(java.time.OffsetDateTime).\n Only objects of type OffsetDateTime are compared, other types return false."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this date-time."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this date-time as a String, such as 2007-12-03T10:15:30+01:00.\n \n The output will be one of the following ISO-8601 formats:\n \n uuuu-MM-dd'T'HH:mmXXXXX\n uuuu-MM-dd'T'HH:mm:ssXXXXX\n uuuu-MM-dd'T'HH:mm:ss.SSSXXXXX\n uuuu-MM-dd'T'HH:mm:ss.SSSSSSXXXXX\n uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSSXXXXX\n \n The format used will be the shortest that outputs the full value of\n the time where the omitted parts are implied to be zero."
                }
              ]
            }
          ]
        },
        {
          "name": "OffsetTime",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static OffsetTime now()",
                  "description": "Obtains the current time from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current time.\n The offset will be calculated from the time-zone in the clock.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static OffsetTime now(ZoneId zone)",
                  "description": "Obtains the current time from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current time.\n Specifying the time-zone avoids dependence on the default time-zone.\n The offset will be calculated from the specified time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static OffsetTime now(Clock clock)",
                  "description": "Obtains the current time from the specified clock.\n \n This will query the specified clock to obtain the current time.\n The offset will be calculated from the time-zone in the clock.\n \n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static OffsetTime of(LocalTime time, ZoneOffset offset)",
                  "description": "Obtains an instance of OffsetTime from a local time and an offset."
                },
                {
                  "signature": "public static OffsetTime of(int hour, int minute, int second, int nanoOfSecond, ZoneOffset offset)",
                  "description": "Obtains an instance of OffsetTime from an hour, minute, second and nanosecond.\n \n This creates an offset time with the four specified fields.\n \n This method exists primarily for writing test cases.\n Non test-code will typically use other methods to create an offset time.\n LocalTime has two additional convenience variants of the\n equivalent factory method taking fewer arguments.\n They are not provided here to reduce the footprint of the API."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static OffsetTime ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of OffsetTime from an Instant and zone ID.\n \n This creates an offset time with the same instant as that specified.\n Finding the offset from UTC/Greenwich is simple as there is only one valid\n offset for each instant.\n \n The date component of the instant is dropped during the conversion.\n This means that the conversion can never fail due to the instant being\n out of the valid range of dates."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static OffsetTime from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of OffsetTime from a temporal object.\n \n This obtains an offset time based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of OffsetTime.\n \n The conversion extracts and combines the ZoneOffset and the\n LocalTime from the temporal object.\n Implementations are permitted to perform optimizations such as accessing\n those fields that are equivalent to the relevant objects.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, OffsetTime::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static OffsetTime parse(CharSequence text)",
                  "description": "Obtains an instance of OffsetTime from a text string such as 10:15:30+01:00.\n \n The string must represent a valid time and is parsed using\n DateTimeFormatter.ISO_OFFSET_TIME."
                },
                {
                  "signature": "public static OffsetTime parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of OffsetTime from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a time."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this time can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n NANO_OF_DAY\n MICRO_OF_SECOND\n MICRO_OF_DAY\n MILLI_OF_SECOND\n MILLI_OF_DAY\n SECOND_OF_MINUTE\n SECOND_OF_DAY\n MINUTE_OF_HOUR\n MINUTE_OF_DAY\n HOUR_OF_AMPM\n CLOCK_HOUR_OF_AMPM\n HOUR_OF_DAY\n CLOCK_HOUR_OF_DAY\n AMPM_OF_DAY\n OFFSET_SECONDS\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this offset-time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This time is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this time as an int.\n \n This queries this time for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this time, except NANO_OF_DAY and MICRO_OF_DAY\n which are too large to fit in an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this time as a long.\n \n This queries this time for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public ZoneOffset getOffset()",
                  "description": "Gets the zone offset, such as '+01:00'.\n \n This is the offset of the local time from UTC/Greenwich."
                }
              ]
            },
            {
              "name": "withOffsetSameLocal",
              "overloads": [
                {
                  "signature": "public OffsetTime withOffsetSameLocal(ZoneOffset offset)",
                  "description": "Returns a copy of this OffsetTime with the specified offset ensuring\n that the result has the same local time.\n \n This method returns an object with the same LocalTime and the specified ZoneOffset.\n No calculation is needed or performed.\n For example, if this time represents 10:30+02:00 and the offset specified is\n +03:00, then this method will return 10:30+03:00.\n \n To take into account the difference between the offsets, and adjust the time fields,\n use withOffsetSameInstant(java.time.ZoneOffset).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withOffsetSameInstant",
              "overloads": [
                {
                  "signature": "public OffsetTime withOffsetSameInstant(ZoneOffset offset)",
                  "description": "Returns a copy of this OffsetTime with the specified offset ensuring\n that the result is at the same instant on an implied day.\n \n This method returns an object with the specified ZoneOffset and a LocalTime\n adjusted by the difference between the two offsets.\n This will result in the old and new objects representing the same instant on an implied day.\n This is useful for finding the local time in a different offset.\n For example, if this time represents 10:30+02:00 and the offset specified is\n +03:00, then this method will return 11:30+03:00.\n \n To change the offset without adjusting the local time use withOffsetSameLocal(java.time.ZoneOffset).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toLocalTime",
              "overloads": [
                {
                  "signature": "public LocalTime toLocalTime()",
                  "description": "Gets the LocalTime part of this date-time.\n \n This returns a LocalTime with the same hour, minute, second and\n nanosecond as this date-time."
                }
              ]
            },
            {
              "name": "getHour",
              "overloads": [
                {
                  "signature": "public int getHour()",
                  "description": "Gets the hour-of-day field."
                }
              ]
            },
            {
              "name": "getMinute",
              "overloads": [
                {
                  "signature": "public int getMinute()",
                  "description": "Gets the minute-of-hour field."
                }
              ]
            },
            {
              "name": "getSecond",
              "overloads": [
                {
                  "signature": "public int getSecond()",
                  "description": "Gets the second-of-minute field."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the nano-of-second field."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public OffsetTime with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this time.\n \n This returns an OffsetTime, based on this one, with the time adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the hour field.\n A more complex adjuster might set the time to the last hour of the day.\n \n The classes LocalTime and ZoneOffset implement TemporalAdjuster,\n thus this method can be used to change the time or offset:\n   result = offsetTime.with(time);\n  result = offsetTime.with(offset);\n \n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetTime with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this time with the specified field set to a new value.\n \n This returns an OffsetTime, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the hour, minute or second.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n If the field is a ChronoField then the adjustment is implemented here.\n \n The OFFSET_SECONDS field will return a time with the specified offset.\n The local time is unaltered. If the new offset value is outside the valid range\n then a DateTimeException will be thrown.\n \n The other supported fields will behave as per\n the matching method on LocalTime.with(TemporalField, long) LocalTime}.\n In this case, the offset is not part of the calculation and will be unchanged.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withHour",
              "overloads": [
                {
                  "signature": "public OffsetTime withHour(int hour)",
                  "description": "Returns a copy of this OffsetTime with the hour-of-day altered.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMinute",
              "overloads": [
                {
                  "signature": "public OffsetTime withMinute(int minute)",
                  "description": "Returns a copy of this OffsetTime with the minute-of-hour altered.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withSecond",
              "overloads": [
                {
                  "signature": "public OffsetTime withSecond(int second)",
                  "description": "Returns a copy of this OffsetTime with the second-of-minute altered.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNano",
              "overloads": [
                {
                  "signature": "public OffsetTime withNano(int nanoOfSecond)",
                  "description": "Returns a copy of this OffsetTime with the nano-of-second altered.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public OffsetTime truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this OffsetTime with the time truncated.\n \n Truncation returns a copy of the original time with fields\n smaller than the specified unit set to zero.\n For example, truncating with the minutes unit\n will set the second-of-minute and nano-of-second field to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n The offset does not affect the calculation and will be the same in the result.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public OffsetTime plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this time with the specified amount added.\n \n This returns an OffsetTime, based on this one, with the specified amount added.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetTime plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this time with the specified amount added.\n \n This returns an OffsetTime, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented by\n LocalTime.plus(long, TemporalUnit).\n The offset is not part of the calculation and will be unchanged in the result.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public OffsetTime plusHours(long hours)",
                  "description": "Returns a copy of this OffsetTime with the specified number of hours added.\n \n This adds the specified number of hours to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public OffsetTime plusMinutes(long minutes)",
                  "description": "Returns a copy of this OffsetTime with the specified number of minutes added.\n \n This adds the specified number of minutes to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public OffsetTime plusSeconds(long seconds)",
                  "description": "Returns a copy of this OffsetTime with the specified number of seconds added.\n \n This adds the specified number of seconds to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public OffsetTime plusNanos(long nanos)",
                  "description": "Returns a copy of this OffsetTime with the specified number of nanoseconds added.\n \n This adds the specified number of nanoseconds to this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public OffsetTime minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this time with the specified amount subtracted.\n \n This returns an OffsetTime, based on this one, with the specified amount subtracted.\n The amount is typically Duration but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public OffsetTime minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this time with the specified amount subtracted.\n \n This returns an OffsetTime, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public OffsetTime minusHours(long hours)",
                  "description": "Returns a copy of this OffsetTime with the specified number of hours subtracted.\n \n This subtracts the specified number of hours from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public OffsetTime minusMinutes(long minutes)",
                  "description": "Returns a copy of this OffsetTime with the specified number of minutes subtracted.\n \n This subtracts the specified number of minutes from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public OffsetTime minusSeconds(long seconds)",
                  "description": "Returns a copy of this OffsetTime with the specified number of seconds subtracted.\n \n This subtracts the specified number of seconds from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public OffsetTime minusNanos(long nanos)",
                  "description": "Returns a copy of this OffsetTime with the specified number of nanoseconds subtracted.\n \n This subtracts the specified number of nanoseconds from this time, returning a new time.\n The calculation wraps around midnight.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this time using the specified query.\n \n This queries this time using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same offset and time\n as this object.\n \n This returns a temporal object of the same observable type as the input\n with the offset and time changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n twice, passing ChronoField.NANO_OF_DAY and\n ChronoField.OFFSET_SECONDS as the fields.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisOffsetTime.adjustInto(temporal);\n   temporal = temporal.with(thisOffsetTime);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another time in terms of the specified unit.\n \n This calculates the amount of time between two OffsetTime\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified time.\n The result will be negative if the end is before the start.\n For example, the amount in hours between two times can be calculated\n using startTime.until(endTime, HOURS).\n \n The Temporal passed to this method is converted to a\n OffsetTime using from(TemporalAccessor).\n If the offset differs between the two times, then the specified\n end time is normalized to have the same offset as this time.\n \n The calculation returns a whole number, representing the number of\n complete units between the two times.\n For example, the amount in hours between 11:30Z and 13:29Z will only\n be one hour as it is one minute short of two hours.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MINUTES);\n   amount = MINUTES.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS and HALF_DAYS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this time using the specified formatter.\n \n This time will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atDate",
              "overloads": [
                {
                  "signature": "public OffsetDateTime atDate(LocalDate date)",
                  "description": "Combines this time with a date to create an OffsetDateTime.\n \n This returns an OffsetDateTime formed from this time and the specified date.\n All possible combinations of date and time are valid."
                }
              ]
            },
            {
              "name": "toEpochSecond",
              "overloads": [
                {
                  "signature": "public long toEpochSecond(LocalDate date)",
                  "description": "Converts this OffsetTime to the number of seconds since the epoch\n of 1970-01-01T00:00:00Z.\n \n This combines this offset time with the specified date to calculate the\n epoch-second value, which is the number of elapsed seconds from\n 1970-01-01T00:00:00Z.\n Instants on the time-line after the epoch are positive, earlier\n are negative."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(OffsetTime other)",
                  "description": "Compares this OffsetTime to another time.\n \n The comparison is based first on the UTC equivalent instant, then on the local time.\n It is \"consistent with equals\", as defined by Comparable.\n \n For example, the following is the comparator order:\n \n 10:30+01:00\n 11:00+01:00\n 12:00+02:00\n 11:30+01:00\n 12:00+01:00\n 12:30+01:00\n \n Values #2 and #3 represent the same instant on the time-line.\n When two values represent the same instant, the local time is compared\n to distinguish them. This step is needed to make the ordering\n consistent with equals().\n \n To compare the underlying local time of two TemporalAccessor instances,\n use ChronoField.NANO_OF_DAY as a comparator."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(OffsetTime other)",
                  "description": "Checks if the instant of this OffsetTime is after that of the\n specified time applying both times to a common date.\n \n This method differs from the comparison in compareTo(java.time.OffsetTime) in that it\n only compares the instant of the time. This is equivalent to converting both\n times to an instant using the same date and comparing the instants."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(OffsetTime other)",
                  "description": "Checks if the instant of this OffsetTime is before that of the\n specified time applying both times to a common date.\n \n This method differs from the comparison in compareTo(java.time.OffsetTime) in that it\n only compares the instant of the time. This is equivalent to converting both\n times to an instant using the same date and comparing the instants."
                }
              ]
            },
            {
              "name": "isEqual",
              "overloads": [
                {
                  "signature": "public boolean isEqual(OffsetTime other)",
                  "description": "Checks if the instant of this OffsetTime is equal to that of the\n specified time applying both times to a common date.\n \n This method differs from the comparison in compareTo(java.time.OffsetTime) and equals(java.lang.Object)\n in that it only compares the instant of the time. This is equivalent to converting both\n times to an instant using the same date and comparing the instants."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this time is equal to another time.\n \n The comparison is based on the local-time and the offset.\n To compare for the same instant on the time-line, use isEqual(OffsetTime).\n \n Only objects of type OffsetTime are compared, other types return false.\n To compare the underlying local time of two TemporalAccessor instances,\n use ChronoField.NANO_OF_DAY as a comparator."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this time."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this time as a String, such as 10:15:30+01:00.\n \n The output will be one of the following ISO-8601 formats:\n \n HH:mmXXXXX\n HH:mm:ssXXXXX\n HH:mm:ss.SSSXXXXX\n HH:mm:ss.SSSSSSXXXXX\n HH:mm:ss.SSSSSSSSSXXXXX\n \n The format used will be the shortest that outputs the full value of\n the time where the omitted parts are implied to be zero."
                }
              ]
            }
          ]
        },
        {
          "name": "Period",
          "methods": [
            {
              "name": "ofYears",
              "overloads": [
                {
                  "signature": "public static Period ofYears(int years)",
                  "description": "Obtains a Period representing a number of years.\n \n The resulting period will have the specified years.\n The months and days units will be zero."
                }
              ]
            },
            {
              "name": "ofMonths",
              "overloads": [
                {
                  "signature": "public static Period ofMonths(int months)",
                  "description": "Obtains a Period representing a number of months.\n \n The resulting period will have the specified months.\n The years and days units will be zero."
                }
              ]
            },
            {
              "name": "ofWeeks",
              "overloads": [
                {
                  "signature": "public static Period ofWeeks(int weeks)",
                  "description": "Obtains a Period representing a number of weeks.\n \n The resulting period will be day-based, with the amount of days\n equal to the number of weeks multiplied by 7.\n The years and months units will be zero."
                }
              ]
            },
            {
              "name": "ofDays",
              "overloads": [
                {
                  "signature": "public static Period ofDays(int days)",
                  "description": "Obtains a Period representing a number of days.\n \n The resulting period will have the specified days.\n The years and months units will be zero."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Period of(int years, int months, int days)",
                  "description": "Obtains a Period representing a number of years, months and days.\n \n This creates an instance based on years, months and days."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Period from(TemporalAmount amount)",
                  "description": "Obtains an instance of Period from a temporal amount.\n \n This obtains a period based on the specified amount.\n A TemporalAmount represents an  amount of time, which may be\n date-based or time-based, which this factory extracts to a Period.\n \n The conversion loops around the set of units from the amount and uses\n the YEARS, MONTHS\n and DAYS units to create a period.\n If any other units are found then an exception is thrown.\n \n If the amount is a ChronoPeriod then it must use the ISO chronology."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Period parse(CharSequence text)",
                  "description": "Obtains a Period from a text string such as PnYnMnD.\n \n This will parse the string produced by toString() which is\n based on the ISO-8601 period formats PnYnMnD and PnW.\n \n The string starts with an optional sign, denoted by the ASCII negative\n or positive symbol. If negative, the whole period is negated.\n The ASCII letter \"P\" is next in upper or lower case.\n There are then four sections, each consisting of a number and a suffix.\n At least one of the four sections must be present.\n The sections have suffixes in ASCII of \"Y\", \"M\", \"W\" and \"D\" for\n years, months, weeks and days, accepted in upper or lower case.\n The suffixes must occur in order.\n The number part of each section must consist of ASCII digits.\n The number may be prefixed by the ASCII negative or positive symbol.\n The number must parse to an int.\n \n The leading plus/minus sign, and negative values for other units are\n not part of the ISO-8601 standard. In addition, ISO-8601 does not\n permit mixing between the PnYnMnD and PnW formats.\n Any week-based input is multiplied by 7 and treated as a number of days.\n \n For example, the following are valid inputs:\n    \"P2Y\"             -- Period.ofYears(2)\n   \"P3M\"             -- Period.ofMonths(3)\n   \"P4W\"             -- Period.ofWeeks(4)\n   \"P5D\"             -- Period.ofDays(5)\n   \"P1Y2M3D\"         -- Period.of(1, 2, 3)\n   \"P1Y2M3W4D\"       -- Period.of(1, 2, 25)\n   \"P-1Y2M\"          -- Period.of(-1, 2, 0)\n   \"-P1Y2M\"          -- Period.of(-1, -2, 0)"
                }
              ]
            },
            {
              "name": "between",
              "overloads": [
                {
                  "signature": "public static Period between(LocalDate startDateInclusive, LocalDate endDateExclusive)",
                  "description": "Obtains a Period consisting of the number of years, months,\n and days between two dates.\n \n The start date is included, but the end date is not.\n The period is calculated by removing complete months, then calculating\n the remaining number of days, adjusting to ensure that both have the same sign.\n The number of months is then split into years and months based on a 12 month year.\n A month is considered if the end day-of-month is greater than or equal to the start day-of-month.\n For example, from 2010-01-15 to 2011-03-18 is one year, two months and three days.\n \n The result of this method can be a negative period if the end is before the start.\n The negative sign will be the same in each of year, month and day."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public long get(TemporalUnit unit)",
                  "description": "Gets the value of the requested unit.\n \n This returns a value for each of the three supported units,\n YEARS, MONTHS and\n DAYS.\n All other units throw an exception."
                }
              ]
            },
            {
              "name": "getUnits",
              "overloads": [
                {
                  "signature": "public List<TemporalUnit> getUnits()",
                  "description": "Gets the set of units supported by this period.\n \n The supported units are YEARS,\n MONTHS and DAYS.\n They are returned in the order years, months, days.\n \n This set can be used in conjunction with get(TemporalUnit)\n to access the entire state of the period."
                }
              ]
            },
            {
              "name": "getChronology",
              "overloads": [
                {
                  "signature": "public IsoChronology getChronology()",
                  "description": "Gets the chronology of this period, which is the ISO calendar system.\n \n The Chronology represents the calendar system in use.\n The ISO-8601 calendar system is the modern civil calendar system used today\n in most of the world. It is equivalent to the proleptic Gregorian calendar\n system, in which today's rules for leap years are applied for all time."
                }
              ]
            },
            {
              "name": "isZero",
              "overloads": [
                {
                  "signature": "public boolean isZero()",
                  "description": "Checks if all three units of this period are zero.\n \n A zero period has the value zero for the years, months and days units."
                }
              ]
            },
            {
              "name": "isNegative",
              "overloads": [
                {
                  "signature": "public boolean isNegative()",
                  "description": "Checks if any of the three units of this period are negative.\n \n This checks whether the years, months or days units are less than zero."
                }
              ]
            },
            {
              "name": "getYears",
              "overloads": [
                {
                  "signature": "public int getYears()",
                  "description": "Gets the amount of years of this period.\n \n This returns the years unit.\n \n The months unit is not automatically normalized with the years unit.\n This means that a period of \"15 months\" is different to a period\n of \"1 year and 3 months\"."
                }
              ]
            },
            {
              "name": "getMonths",
              "overloads": [
                {
                  "signature": "public int getMonths()",
                  "description": "Gets the amount of months of this period.\n \n This returns the months unit.\n \n The months unit is not automatically normalized with the years unit.\n This means that a period of \"15 months\" is different to a period\n of \"1 year and 3 months\"."
                }
              ]
            },
            {
              "name": "getDays",
              "overloads": [
                {
                  "signature": "public int getDays()",
                  "description": "Gets the amount of days of this period.\n \n This returns the days unit."
                }
              ]
            },
            {
              "name": "withYears",
              "overloads": [
                {
                  "signature": "public Period withYears(int years)",
                  "description": "Returns a copy of this period with the specified amount of years.\n \n This sets the amount of the years unit in a copy of this period.\n The months and days units are unaffected.\n \n The months unit is not automatically normalized with the years unit.\n This means that a period of \"15 months\" is different to a period\n of \"1 year and 3 months\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonths",
              "overloads": [
                {
                  "signature": "public Period withMonths(int months)",
                  "description": "Returns a copy of this period with the specified amount of months.\n \n This sets the amount of the months unit in a copy of this period.\n The years and days units are unaffected.\n \n The months unit is not automatically normalized with the years unit.\n This means that a period of \"15 months\" is different to a period\n of \"1 year and 3 months\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDays",
              "overloads": [
                {
                  "signature": "public Period withDays(int days)",
                  "description": "Returns a copy of this period with the specified amount of days.\n \n This sets the amount of the days unit in a copy of this period.\n The years and months units are unaffected.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public Period plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this period with the specified period added.\n \n This operates separately on the years, months and days.\n No normalization is performed.\n \n For example, \"1 year, 6 months and 3 days\" plus \"2 years, 2 months and 2 days\"\n returns \"3 years, 8 months and 5 days\".\n \n The specified amount is typically an instance of Period.\n Other types are interpreted using from(TemporalAmount).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public Period plusYears(long yearsToAdd)",
                  "description": "Returns a copy of this period with the specified years added.\n \n This adds the amount to the years unit in a copy of this period.\n The months and days units are unaffected.\n For example, \"1 year, 6 months and 3 days\" plus 2 years returns \"3 years, 6 months and 3 days\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public Period plusMonths(long monthsToAdd)",
                  "description": "Returns a copy of this period with the specified months added.\n \n This adds the amount to the months unit in a copy of this period.\n The years and days units are unaffected.\n For example, \"1 year, 6 months and 3 days\" plus 2 months returns \"1 year, 8 months and 3 days\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public Period plusDays(long daysToAdd)",
                  "description": "Returns a copy of this period with the specified days added.\n \n This adds the amount to the days unit in a copy of this period.\n The years and months units are unaffected.\n For example, \"1 year, 6 months and 3 days\" plus 2 days returns \"1 year, 6 months and 5 days\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public Period minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this period with the specified period subtracted.\n \n This operates separately on the years, months and days.\n No normalization is performed.\n \n For example, \"1 year, 6 months and 3 days\" minus \"2 years, 2 months and 2 days\"\n returns \"-1 years, 4 months and 1 day\".\n \n The specified amount is typically an instance of Period.\n Other types are interpreted using from(TemporalAmount).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public Period minusYears(long yearsToSubtract)",
                  "description": "Returns a copy of this period with the specified years subtracted.\n \n This subtracts the amount from the years unit in a copy of this period.\n The months and days units are unaffected.\n For example, \"1 year, 6 months and 3 days\" minus 2 years returns \"-1 years, 6 months and 3 days\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public Period minusMonths(long monthsToSubtract)",
                  "description": "Returns a copy of this period with the specified months subtracted.\n \n This subtracts the amount from the months unit in a copy of this period.\n The years and days units are unaffected.\n For example, \"1 year, 6 months and 3 days\" minus 2 months returns \"1 year, 4 months and 3 days\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public Period minusDays(long daysToSubtract)",
                  "description": "Returns a copy of this period with the specified days subtracted.\n \n This subtracts the amount from the days unit in a copy of this period.\n The years and months units are unaffected.\n For example, \"1 year, 6 months and 3 days\" minus 2 days returns \"1 year, 6 months and 1 day\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "multipliedBy",
              "overloads": [
                {
                  "signature": "public Period multipliedBy(int scalar)",
                  "description": "Returns a new instance with each element in this period multiplied\n by the specified scalar.\n \n This returns a period with each of the years, months and days units\n individually multiplied.\n For example, a period of \"2 years, -3 months and 4 days\" multiplied by\n 3 will return \"6 years, -9 months and 12 days\".\n No normalization is performed."
                }
              ]
            },
            {
              "name": "negated",
              "overloads": [
                {
                  "signature": "public Period negated()",
                  "description": "Returns a new instance with each amount in this period negated.\n \n This returns a period with each of the years, months and days units\n individually negated.\n For example, a period of \"2 years, -3 months and 4 days\" will be\n negated to \"-2 years, 3 months and -4 days\".\n No normalization is performed."
                }
              ]
            },
            {
              "name": "normalized",
              "overloads": [
                {
                  "signature": "public Period normalized()",
                  "description": "Returns a copy of this period with the years and months normalized.\n \n This normalizes the years and months units, leaving the days unit unchanged.\n The months unit is adjusted to have an absolute value less than 12,\n with the years unit being adjusted to compensate. For example, a period of\n \"1 Year and 15 months\" will be normalized to \"2 years and 3 months\".\n \n The sign of the years and months units will be the same after normalization.\n For example, a period of \"1 year and -25 months\" will be normalized to\n \"-1 year and -1 month\".\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "toTotalMonths",
              "overloads": [
                {
                  "signature": "public long toTotalMonths()",
                  "description": "Gets the total number of months in this period.\n \n This returns the total number of months in the period by multiplying the\n number of years by 12 and adding the number of months.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "addTo",
              "overloads": [
                {
                  "signature": "public Temporal addTo(Temporal temporal)",
                  "description": "Adds this period to the specified temporal object.\n \n This returns a temporal object of the same observable type as the input\n with this period added.\n If the temporal has a chronology, it must be the ISO chronology.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.plus(TemporalAmount).\n    // these two lines are equivalent, but the second approach is recommended\n   dateTime = thisPeriod.addTo(dateTime);\n   dateTime = dateTime.plus(thisPeriod);\n \n \n The calculation operates as follows.\n First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n Second, if the months are zero, the years are added if non-zero, otherwise\n the combination of years and months is added if non-zero.\n Finally, any days are added.\n \n This approach ensures that a partial period can be added to a partial date.\n For example, a period of years and/or months can be added to a YearMonth,\n but a period including days cannot.\n The approach also adds years and months together when necessary, which ensures\n correct behaviour at the end of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "subtractFrom",
              "overloads": [
                {
                  "signature": "public Temporal subtractFrom(Temporal temporal)",
                  "description": "Subtracts this period from the specified temporal object.\n \n This returns a temporal object of the same observable type as the input\n with this period subtracted.\n If the temporal has a chronology, it must be the ISO chronology.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.minus(TemporalAmount).\n    // these two lines are equivalent, but the second approach is recommended\n   dateTime = thisPeriod.subtractFrom(dateTime);\n   dateTime = dateTime.minus(thisPeriod);\n \n \n The calculation operates as follows.\n First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n Second, if the months are zero, the years are subtracted if non-zero, otherwise\n the combination of years and months is subtracted if non-zero.\n Finally, any days are subtracted.\n \n This approach ensures that a partial period can be subtracted from a partial date.\n For example, a period of years and/or months can be subtracted from a YearMonth,\n but a period including days cannot.\n The approach also subtracts years and months together when necessary, which ensures\n correct behaviour at the end of the month.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this period is equal to another period.\n \n The comparison is based on the type Period and each of the three amounts.\n To be equal, the years, months and days units must be individually equal.\n Note that this means that a period of \"15 Months\" is not equal to a period\n of \"1 Year and 3 Months\"."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this period."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this period as a String, such as P6Y3M1D.\n \n The output will be in the ISO-8601 period format.\n A zero period will be represented as zero days, 'P0D'."
                }
              ]
            }
          ]
        },
        {
          "name": "Year",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static Year now()",
                  "description": "Obtains the current year from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current year.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static Year now(ZoneId zone)",
                  "description": "Obtains the current year from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current year.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static Year now(Clock clock)",
                  "description": "Obtains the current year from the specified clock.\n \n This will query the specified clock to obtain the current year.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static Year of(int isoYear)",
                  "description": "Obtains an instance of Year.\n \n This method accepts a year value from the proleptic ISO calendar system.\n \n The year 2AD/CE is represented by 2.\n The year 1AD/CE is represented by 1.\n The year 1BC/BCE is represented by 0.\n The year 2BC/BCE is represented by -1."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static Year from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of Year from a temporal object.\n \n This obtains a year based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of Year.\n \n The conversion extracts the year field.\n The extraction is only permitted if the temporal object has an ISO\n chronology, or can be converted to a LocalDate.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, Year::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static Year parse(CharSequence text)",
                  "description": "Obtains an instance of Year from a text string such as 2007.\n \n The string must represent a valid year."
                },
                {
                  "signature": "public static Year parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of Year from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a year."
                }
              ]
            },
            {
              "name": "isLeap",
              "overloads": [
                {
                  "signature": "public static boolean isLeap(long year)",
                  "description": "Checks if the year is a leap year, according to the ISO proleptic\n calendar system rules.\n \n This method applies the current rules for leap years across the whole time-line.\n In general, a year is a leap year if it is divisible by four without\n remainder. However, years divisible by 100, are not leap years, with\n the exception of years divisible by 400 which are.\n \n For example, 1904 is a leap year it is divisible by 4.\n 1900 was not a leap year as it is divisible by 100, however 2000 was a\n leap year as it is divisible by 400.\n \n The calculation is proleptic - applying the same rules into the far future and far past.\n This is historically inaccurate, but is correct for the ISO-8601 standard."
                },
                {
                  "signature": "public boolean isLeap()",
                  "description": "Checks if the year is a leap year, according to the ISO proleptic\n calendar system rules.\n \n This method applies the current rules for leap years across the whole time-line.\n In general, a year is a leap year if it is divisible by four without\n remainder. However, years divisible by 100, are not leap years, with\n the exception of years divisible by 400 which are.\n \n For example, 1904 is a leap year it is divisible by 4.\n 1900 was not a leap year as it is divisible by 100, however 2000 was a\n leap year as it is divisible by 400.\n \n The calculation is proleptic - applying the same rules into the far future and far past.\n This is historically inaccurate, but is correct for the ISO-8601 standard."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public int getValue()",
                  "description": "Gets the year value.\n \n The year returned by this method is proleptic as per get(YEAR)."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this year can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n YEAR_OF_ERA\n YEAR\n ERA\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this year.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This year is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this year as an int.\n \n This queries this year for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this year.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this year as a long.\n \n This queries this year for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this year.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "isValidMonthDay",
              "overloads": [
                {
                  "signature": "public boolean isValidMonthDay(MonthDay monthDay)",
                  "description": "Checks if the month-day is valid for this year.\n \n This method checks whether this year and the input month and day form\n a valid date."
                }
              ]
            },
            {
              "name": "length",
              "overloads": [
                {
                  "signature": "public int length()",
                  "description": "Gets the length of this year in days."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public Year with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this year.\n \n This returns a Year, based on this one, with the year adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Year with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this year with the specified field set to a new value.\n \n This returns a Year, based on this one, with the value\n for the specified field changed.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields behave as follows:\n \n YEAR_OF_ERA -\n  Returns a Year with the specified year-of-era\n  The era will be unchanged.\n YEAR -\n  Returns a Year with the specified year.\n  This completely replaces the date and is equivalent to of(int).\n ERA -\n  Returns a Year with the specified era.\n  The year-of-era will be unchanged.\n \n \n In all cases, if the new value is outside the valid range of values for the field\n then a DateTimeException will be thrown.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public Year plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this year with the specified amount added.\n \n This returns a Year, based on this one, with the specified amount added.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Year plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this year with the specified amount added.\n \n This returns a Year, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The supported fields behave as follows:\n \n YEARS -\n  Returns a Year with the specified number of years added.\n  This is equivalent to plusYears(long).\n DECADES -\n  Returns a Year with the specified number of decades added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 10.\n CENTURIES -\n  Returns a Year with the specified number of centuries added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 100.\n MILLENNIA -\n  Returns a Year with the specified number of millennia added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 1,000.\n ERAS -\n  Returns a Year with the specified number of eras added.\n  Only two eras are supported so the amount must be one, zero or minus one.\n  If the amount is non-zero then the year is changed such that the year-of-era\n  is unchanged.\n \n \n All other ChronoUnit instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public Year plusYears(long yearsToAdd)",
                  "description": "Returns a copy of this Year with the specified number of years added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public Year minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this year with the specified amount subtracted.\n \n This returns a Year, based on this one, with the specified amount subtracted.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public Year minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this year with the specified amount subtracted.\n \n This returns a Year, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public Year minusYears(long yearsToSubtract)",
                  "description": "Returns a copy of this Year with the specified number of years subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this year using the specified query.\n \n This queries this year using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this year.\n \n This returns a temporal object of the same observable type as the input\n with the year changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.YEAR as the field.\n If the specified temporal object does not use the ISO calendar system then\n a DateTimeException is thrown.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisYear.adjustInto(temporal);\n   temporal = temporal.with(thisYear);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another year in terms of the specified unit.\n \n This calculates the amount of time between two Year\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified year.\n The result will be negative if the end is before the start.\n The Temporal passed to this method is converted to a\n Year using from(TemporalAccessor).\n For example, the amount in decades between two year can be calculated\n using startYear.until(endYear, DECADES).\n \n The calculation returns a whole number, representing the number of\n complete units between the two years.\n For example, the amount in decades between 2012 and 2031\n will only be one decade as it is one year short of two decades.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, YEARS);\n   amount = YEARS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units YEARS, DECADES, CENTURIES,\n MILLENNIA and ERAS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this year using the specified formatter.\n \n This year will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atDay",
              "overloads": [
                {
                  "signature": "public LocalDate atDay(int dayOfYear)",
                  "description": "Combines this year with a day-of-year to create a LocalDate.\n \n This returns a LocalDate formed from this year and the specified day-of-year.\n \n The day-of-year value 366 is only valid in a leap year."
                }
              ]
            },
            {
              "name": "atMonth",
              "overloads": [
                {
                  "signature": "public YearMonth atMonth(Month month)",
                  "description": "Combines this year with a month to create a YearMonth.\n \n This returns a YearMonth formed from this year and the specified month.\n All possible combinations of year and month are valid.\n \n This method can be used as part of a chain to produce a date:\n   LocalDate date = year.atMonth(month).atDay(day);"
                },
                {
                  "signature": "public YearMonth atMonth(int month)",
                  "description": "Combines this year with a month to create a YearMonth.\n \n This returns a YearMonth formed from this year and the specified month.\n All possible combinations of year and month are valid.\n \n This method can be used as part of a chain to produce a date:\n   LocalDate date = year.atMonth(month).atDay(day);"
                }
              ]
            },
            {
              "name": "atMonthDay",
              "overloads": [
                {
                  "signature": "public LocalDate atMonthDay(MonthDay monthDay)",
                  "description": "Combines this year with a month-day to create a LocalDate.\n \n This returns a LocalDate formed from this year and the specified month-day.\n \n A month-day of February 29th will be adjusted to February 28th in the resulting\n date if the year is not a leap year."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(Year other)",
                  "description": "Compares this year to another year.\n \n The comparison is based on the value of the year.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(Year other)",
                  "description": "Checks if this year is after the specified year."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(Year other)",
                  "description": "Checks if this year is before the specified year."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this year is equal to another year.\n \n The comparison is based on the time-line position of the years."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this year."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this year as a String."
                }
              ]
            }
          ]
        },
        {
          "name": "YearMonth",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static YearMonth now()",
                  "description": "Obtains the current year-month from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current year-month.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static YearMonth now(ZoneId zone)",
                  "description": "Obtains the current year-month from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current year-month.\n Specifying the time-zone avoids dependence on the default time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static YearMonth now(Clock clock)",
                  "description": "Obtains the current year-month from the specified clock.\n \n This will query the specified clock to obtain the current year-month.\n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static YearMonth of(int year, Month month)",
                  "description": "Obtains an instance of YearMonth from a year and month."
                },
                {
                  "signature": "public static YearMonth of(int year, int month)",
                  "description": "Obtains an instance of YearMonth from a year and month."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static YearMonth from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of YearMonth from a temporal object.\n \n This obtains a year-month based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of YearMonth.\n \n The conversion extracts the YEAR and\n MONTH_OF_YEAR fields.\n The extraction is only permitted if the temporal object has an ISO\n chronology, or can be converted to a LocalDate.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, YearMonth::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static YearMonth parse(CharSequence text)",
                  "description": "Obtains an instance of YearMonth from a text string such as 2007-12.\n \n The string must represent a valid year-month.\n The format must be uuuu-MM.\n Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol."
                },
                {
                  "signature": "public static YearMonth parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of YearMonth from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a year-month."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this year-month can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n MONTH_OF_YEAR\n PROLEPTIC_MONTH\n YEAR_OF_ERA\n YEAR\n ERA\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this year-month.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n MONTHS\n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This year-month is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this year-month as an int.\n \n This queries this year-month for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this year-month, except PROLEPTIC_MONTH which is too\n large to fit in an int and throw a DateTimeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this year-month as a long.\n \n This queries this year-month for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this year-month.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "public int getYear()",
                  "description": "Gets the year field.\n \n This method returns the primitive int value for the year.\n \n The year returned by this method is proleptic as per get(YEAR)."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "isLeapYear",
              "overloads": [
                {
                  "signature": "public boolean isLeapYear()",
                  "description": "Checks if the year is a leap year, according to the ISO proleptic\n calendar system rules.\n \n This method applies the current rules for leap years across the whole time-line.\n In general, a year is a leap year if it is divisible by four without\n remainder. However, years divisible by 100, are not leap years, with\n the exception of years divisible by 400 which are.\n \n For example, 1904 is a leap year it is divisible by 4.\n 1900 was not a leap year as it is divisible by 100, however 2000 was a\n leap year as it is divisible by 400.\n \n The calculation is proleptic - applying the same rules into the far future and far past.\n This is historically inaccurate, but is correct for the ISO-8601 standard."
                }
              ]
            },
            {
              "name": "isValidDay",
              "overloads": [
                {
                  "signature": "public boolean isValidDay(int dayOfMonth)",
                  "description": "Checks if the day-of-month is valid for this year-month.\n \n This method checks whether this year and month and the input day form\n a valid date."
                }
              ]
            },
            {
              "name": "lengthOfMonth",
              "overloads": [
                {
                  "signature": "public int lengthOfMonth()",
                  "description": "Returns the length of the month, taking account of the year.\n \n This returns the length of the month in days.\n For example, a date in January would return 31."
                }
              ]
            },
            {
              "name": "lengthOfYear",
              "overloads": [
                {
                  "signature": "public int lengthOfYear()",
                  "description": "Returns the length of the year.\n \n This returns the length of the year in days, either 365 or 366."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public YearMonth with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this year-month.\n \n This returns a YearMonth, based on this one, with the year-month adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the year field.\n A more complex adjuster might set the year-month to the next month that\n Halley's comet will pass the Earth.\n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public YearMonth with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this year-month with the specified field set to a new value.\n \n This returns a YearMonth, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the year or month.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n If the field is a ChronoField then the adjustment is implemented here.\n The supported fields behave as follows:\n \n MONTH_OF_YEAR -\n  Returns a YearMonth with the specified month-of-year.\n  The year will be unchanged.\n PROLEPTIC_MONTH -\n  Returns a YearMonth with the specified proleptic-month.\n  This completely replaces the year and month of this object.\n YEAR_OF_ERA -\n  Returns a YearMonth with the specified year-of-era\n  The month and era will be unchanged.\n YEAR -\n  Returns a YearMonth with the specified year.\n  The month will be unchanged.\n ERA -\n  Returns a YearMonth with the specified era.\n  The month and year-of-era will be unchanged.\n \n \n In all cases, if the new value is outside the valid range of values for the field\n then a DateTimeException will be thrown.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withYear",
              "overloads": [
                {
                  "signature": "public YearMonth withYear(int year)",
                  "description": "Returns a copy of this YearMonth with the year altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public YearMonth withMonth(int month)",
                  "description": "Returns a copy of this YearMonth with the month-of-year altered.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public YearMonth plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this year-month with the specified amount added.\n \n This returns a YearMonth, based on this one, with the specified amount added.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public YearMonth plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this year-month with the specified amount added.\n \n This returns a YearMonth, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The supported fields behave as follows:\n \n MONTHS -\n  Returns a YearMonth with the specified number of months added.\n  This is equivalent to plusMonths(long).\n YEARS -\n  Returns a YearMonth with the specified number of years added.\n  This is equivalent to plusYears(long).\n DECADES -\n  Returns a YearMonth with the specified number of decades added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 10.\n CENTURIES -\n  Returns a YearMonth with the specified number of centuries added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 100.\n MILLENNIA -\n  Returns a YearMonth with the specified number of millennia added.\n  This is equivalent to calling plusYears(long) with the amount\n  multiplied by 1,000.\n ERAS -\n  Returns a YearMonth with the specified number of eras added.\n  Only two eras are supported so the amount must be one, zero or minus one.\n  If the amount is non-zero then the year is changed such that the year-of-era\n  is unchanged.\n \n \n All other ChronoUnit instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public YearMonth plusYears(long yearsToAdd)",
                  "description": "Returns a copy of this YearMonth with the specified number of years added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public YearMonth plusMonths(long monthsToAdd)",
                  "description": "Returns a copy of this YearMonth with the specified number of months added.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public YearMonth minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this year-month with the specified amount subtracted.\n \n This returns a YearMonth, based on this one, with the specified amount subtracted.\n The amount is typically Period but may be any other type implementing\n the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public YearMonth minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this year-month with the specified amount subtracted.\n \n This returns a YearMonth, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public YearMonth minusYears(long yearsToSubtract)",
                  "description": "Returns a copy of this YearMonth with the specified number of years subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public YearMonth minusMonths(long monthsToSubtract)",
                  "description": "Returns a copy of this YearMonth with the specified number of months subtracted.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this year-month using the specified query.\n \n This queries this year-month using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have this year-month.\n \n This returns a temporal object of the same observable type as the input\n with the year and month changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.PROLEPTIC_MONTH as the field.\n If the specified temporal object does not use the ISO calendar system then\n a DateTimeException is thrown.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisYearMonth.adjustInto(temporal);\n   temporal = temporal.with(thisYearMonth);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another year-month in terms of the specified unit.\n \n This calculates the amount of time between two YearMonth\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified year-month.\n The result will be negative if the end is before the start.\n The Temporal passed to this method is converted to a\n YearMonth using from(TemporalAccessor).\n For example, the amount in years between two year-months can be calculated\n using startYearMonth.until(endYearMonth, YEARS).\n \n The calculation returns a whole number, representing the number of\n complete units between the two year-months.\n For example, the amount in decades between 2012-06 and 2032-05\n will only be one decade as it is one month short of two decades.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MONTHS);\n   amount = MONTHS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units MONTHS, YEARS, DECADES,\n CENTURIES, MILLENNIA and ERAS are supported.\n Other ChronoUnit values will throw an exception.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this year-month using the specified formatter.\n \n This year-month will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "atDay",
              "overloads": [
                {
                  "signature": "public LocalDate atDay(int dayOfMonth)",
                  "description": "Combines this year-month with a day-of-month to create a LocalDate.\n \n This returns a LocalDate formed from this year-month and the specified day-of-month.\n \n The day-of-month value must be valid for the year-month.\n \n This method can be used as part of a chain to produce a date:\n   LocalDate date = year.atMonth(month).atDay(day);"
                }
              ]
            },
            {
              "name": "atEndOfMonth",
              "overloads": [
                {
                  "signature": "public LocalDate atEndOfMonth()",
                  "description": "Returns a LocalDate at the end of the month.\n \n This returns a LocalDate based on this year-month.\n The day-of-month is set to the last valid day of the month, taking\n into account leap years.\n \n This method can be used as part of a chain to produce a date:\n   LocalDate date = year.atMonth(month).atEndOfMonth();"
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(YearMonth other)",
                  "description": "Compares this year-month to another year-month.\n \n The comparison is based first on the value of the year, then on the value of the month.\n It is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "isAfter",
              "overloads": [
                {
                  "signature": "public boolean isAfter(YearMonth other)",
                  "description": "Checks if this year-month is after the specified year-month."
                }
              ]
            },
            {
              "name": "isBefore",
              "overloads": [
                {
                  "signature": "public boolean isBefore(YearMonth other)",
                  "description": "Checks if this year-month is before the specified year-month."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this year-month is equal to another year-month.\n \n The comparison is based on the time-line position of the year-months."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this year-month."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this year-month as a String, such as 2007-12.\n \n The output will be in the format uuuu-MM:"
                }
              ]
            }
          ]
        },
        {
          "name": "ZonedDateTime",
          "methods": [
            {
              "name": "now",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime now()",
                  "description": "Obtains the current date-time from the system clock in the default time-zone.\n \n This will query the system clock in the default\n time-zone to obtain the current date-time.\n The zone and offset will be set based on the time-zone in the clock.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static ZonedDateTime now(ZoneId zone)",
                  "description": "Obtains the current date-time from the system clock in the specified time-zone.\n \n This will query the system clock to obtain the current date-time.\n Specifying the time-zone avoids dependence on the default time-zone.\n The offset will be calculated from the specified time-zone.\n \n Using this method will prevent the ability to use an alternate clock for testing\n because the clock is hard-coded."
                },
                {
                  "signature": "public static ZonedDateTime now(Clock clock)",
                  "description": "Obtains the current date-time from the specified clock.\n \n This will query the specified clock to obtain the current date-time.\n The zone and offset will be set based on the time-zone in the clock.\n \n Using this method allows the use of an alternate clock for testing.\n The alternate clock may be introduced using dependency injection."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime from a local date and time.\n \n This creates a zoned date-time matching the input local date and time as closely as possible.\n Time-zone rules, such as daylight savings, mean that not every local date-time\n is valid for the specified zone, thus the local date-time may be adjusted.\n \n The local date time and first combined to form a local date-time.\n The local date-time is then resolved to a single instant on the time-line.\n This is achieved by finding a valid offset from UTC/Greenwich for the local\n date-time as defined by the rules of the zone ID.\n\n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, when clocks are set back, there are two valid offsets.\n This method uses the earlier offset typically corresponding to \"summer\".\n \n In the case of a gap, when clocks jump forward, there is no valid offset.\n Instead, the local date-time is adjusted to be later by the length of the gap.\n For a typical one hour daylight savings change, the local date-time will be\n moved one hour later into the offset typically corresponding to \"summer\"."
                },
                {
                  "signature": "public static ZonedDateTime of(LocalDateTime localDateTime, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime from a local date-time.\n \n This creates a zoned date-time matching the input local date-time as closely as possible.\n Time-zone rules, such as daylight savings, mean that not every local date-time\n is valid for the specified zone, thus the local date-time may be adjusted.\n \n The local date-time is resolved to a single instant on the time-line.\n This is achieved by finding a valid offset from UTC/Greenwich for the local\n date-time as defined by the rules of the zone ID.\n\n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, when clocks are set back, there are two valid offsets.\n This method uses the earlier offset typically corresponding to \"summer\".\n \n In the case of a gap, when clocks jump forward, there is no valid offset.\n Instead, the local date-time is adjusted to be later by the length of the gap.\n For a typical one hour daylight savings change, the local date-time will be\n moved one hour later into the offset typically corresponding to \"summer\"."
                },
                {
                  "signature": "public static ZonedDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime from a year, month, day,\n hour, minute, second, nanosecond and time-zone.\n \n This creates a zoned date-time matching the local date-time of the seven\n specified fields as closely as possible.\n Time-zone rules, such as daylight savings, mean that not every local date-time\n is valid for the specified zone, thus the local date-time may be adjusted.\n \n The local date-time is resolved to a single instant on the time-line.\n This is achieved by finding a valid offset from UTC/Greenwich for the local\n date-time as defined by the rules of the zone ID.\n\n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, when clocks are set back, there are two valid offsets.\n This method uses the earlier offset typically corresponding to \"summer\".\n \n In the case of a gap, when clocks jump forward, there is no valid offset.\n Instead, the local date-time is adjusted to be later by the length of the gap.\n For a typical one hour daylight savings change, the local date-time will be\n moved one hour later into the offset typically corresponding to \"summer\".\n \n This method exists primarily for writing test cases.\n Non test-code will typically use other methods to create an offset time.\n LocalDateTime has five additional convenience variants of the\n equivalent factory method taking fewer arguments.\n They are not provided here to reduce the footprint of the API."
                }
              ]
            },
            {
              "name": "ofLocal",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime ofLocal(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset)",
                  "description": "Obtains an instance of ZonedDateTime from a local date-time\n using the preferred offset if possible.\n \n The local date-time is resolved to a single instant on the time-line.\n This is achieved by finding a valid offset from UTC/Greenwich for the local\n date-time as defined by the rules of the zone ID.\n\n In most cases, there is only one valid offset for a local date-time.\n In the case of an overlap, where clocks are set back, there are two valid offsets.\n If the preferred offset is one of the valid offsets then it is used.\n Otherwise the earlier valid offset is used, typically corresponding to \"summer\".\n \n In the case of a gap, where clocks jump forward, there is no valid offset.\n Instead, the local date-time is adjusted to be later by the length of the gap.\n For a typical one hour daylight savings change, the local date-time will be\n moved one hour later into the offset typically corresponding to \"summer\"."
                }
              ]
            },
            {
              "name": "ofInstant",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime ofInstant(Instant instant, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime from an Instant.\n \n This creates a zoned date-time with the same instant as that specified.\n Calling ChronoZonedDateTime.toInstant() will return an instant equal to the one used here.\n \n Converting an instant to a zoned date-time is simple as there is only one valid\n offset for each instant."
                },
                {
                  "signature": "public static ZonedDateTime ofInstant(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime from the instant formed by combining\n the local date-time and offset.\n \n This creates a zoned date-time by combining\n the LocalDateTime and ZoneOffset.\n This combination uniquely specifies an instant without ambiguity.\n \n Converting an instant to a zoned date-time is simple as there is only one valid\n offset for each instant. If the valid offset is different to the offset specified,\n then the date-time and offset of the zoned date-time will differ from those specified.\n \n If the ZoneId to be used is a ZoneOffset, this method is equivalent\n to of(LocalDateTime, ZoneId)."
                }
              ]
            },
            {
              "name": "ofStrict",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime ofStrict(LocalDateTime localDateTime, ZoneOffset offset, ZoneId zone)",
                  "description": "Obtains an instance of ZonedDateTime strictly validating the\n combination of local date-time, offset and zone ID.\n \n This creates a zoned date-time ensuring that the offset is valid for the\n local date-time according to the rules of the specified zone.\n If the offset is invalid, an exception is thrown."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of ZonedDateTime from a temporal object.\n \n This obtains a zoned date-time based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of ZonedDateTime.\n \n The conversion will first obtain a ZoneId from the temporal object,\n falling back to a ZoneOffset if necessary. It will then try to obtain\n an Instant, falling back to a LocalDateTime if necessary.\n The result will be either the combination of ZoneId or ZoneOffset\n with Instant or LocalDateTime.\n Implementations are permitted to perform optimizations such as accessing\n those fields that are equivalent to the relevant objects.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, ZonedDateTime::from."
                }
              ]
            },
            {
              "name": "parse",
              "overloads": [
                {
                  "signature": "public static ZonedDateTime parse(CharSequence text)",
                  "description": "Obtains an instance of ZonedDateTime from a text string such as\n 2007-12-03T10:15:30+01:00[Europe/Paris].\n \n The string must represent a valid date-time and is parsed using\n DateTimeFormatter.ISO_ZONED_DATE_TIME."
                },
                {
                  "signature": "public static ZonedDateTime parse(CharSequence text, DateTimeFormatter formatter)",
                  "description": "Obtains an instance of ZonedDateTime from a text string using a specific formatter.\n \n The text is parsed using the formatter, returning a date-time."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this date-time can be queried for the specified field.\n If false, then calling the range,\n get and with(TemporalField, long)\n methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields are:\n \n NANO_OF_SECOND\n NANO_OF_DAY\n MICRO_OF_SECOND\n MICRO_OF_DAY\n MILLI_OF_SECOND\n MILLI_OF_DAY\n SECOND_OF_MINUTE\n SECOND_OF_DAY\n MINUTE_OF_HOUR\n MINUTE_OF_DAY\n HOUR_OF_AMPM\n CLOCK_HOUR_OF_AMPM\n HOUR_OF_DAY\n CLOCK_HOUR_OF_DAY\n AMPM_OF_DAY\n DAY_OF_WEEK\n ALIGNED_DAY_OF_WEEK_IN_MONTH\n ALIGNED_DAY_OF_WEEK_IN_YEAR\n DAY_OF_MONTH\n DAY_OF_YEAR\n EPOCH_DAY\n ALIGNED_WEEK_OF_MONTH\n ALIGNED_WEEK_OF_YEAR\n MONTH_OF_YEAR\n PROLEPTIC_MONTH\n YEAR_OF_ERA\n YEAR\n ERA\n INSTANT_SECONDS\n OFFSET_SECONDS\n \n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                },
                {
                  "signature": "public boolean isSupported(TemporalUnit unit)",
                  "description": "Checks if the specified unit is supported.\n \n This checks if the specified unit can be added to, or subtracted from, this date-time.\n If false, then calling the plus(long, TemporalUnit) and\n minus methods will throw an exception.\n \n If the unit is a ChronoUnit then the query is implemented here.\n The supported units are:\n \n NANOS\n MICROS\n MILLIS\n SECONDS\n MINUTES\n HOURS\n HALF_DAYS\n DAYS\n WEEKS\n MONTHS\n YEARS\n DECADES\n CENTURIES\n MILLENNIA\n ERAS\n \n All other ChronoUnit instances will return false.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.isSupportedBy(Temporal)\n passing this as the argument.\n Whether the unit is supported is determined by the unit."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This date-time is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as an int.\n \n This queries this date-time for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time, except NANO_OF_DAY, MICRO_OF_DAY,\n EPOCH_DAY, PROLEPTIC_MONTH and INSTANT_SECONDS which are too\n large to fit in an int and throw an UnsupportedTemporalTypeException.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this date-time as a long.\n \n This queries this date-time for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return valid\n values based on this date-time.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getOffset",
              "overloads": [
                {
                  "signature": "public ZoneOffset getOffset()",
                  "description": "Gets the zone offset, such as '+01:00'.\n \n This is the offset of the local date-time from UTC/Greenwich."
                }
              ]
            },
            {
              "name": "withEarlierOffsetAtOverlap",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withEarlierOffsetAtOverlap()",
                  "description": "Returns a copy of this date-time changing the zone offset to the\n earlier of the two valid offsets at a local time-line overlap.\n \n This method only has any effect when the local time-line overlaps, such as\n at an autumn daylight savings cutover. In this scenario, there are two\n valid offsets for the local date-time. Calling this method will return\n a zoned date-time with the earlier of the two selected.\n \n If this method is called when it is not an overlap, this\n is returned.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withLaterOffsetAtOverlap",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withLaterOffsetAtOverlap()",
                  "description": "Returns a copy of this date-time changing the zone offset to the\n later of the two valid offsets at a local time-line overlap.\n \n This method only has any effect when the local time-line overlaps, such as\n at an autumn daylight savings cutover. In this scenario, there are two\n valid offsets for the local date-time. Calling this method will return\n a zoned date-time with the later of the two selected.\n \n If this method is called when it is not an overlap, this\n is returned.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "getZone",
              "overloads": [
                {
                  "signature": "public ZoneId getZone()",
                  "description": "Gets the time-zone, such as 'Europe/Paris'.\n \n This returns the zone ID. This identifies the time-zone rules\n that determine when and how the offset from UTC/Greenwich changes.\n \n The zone ID may be same as the offset.\n If this is true, then any future calculations, such as addition or subtraction,\n have no complex edge cases due to time-zone rules.\n See also withFixedOffsetZone()."
                }
              ]
            },
            {
              "name": "withZoneSameLocal",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withZoneSameLocal(ZoneId zone)",
                  "description": "Returns a copy of this date-time with a different time-zone,\n retaining the local date-time if possible.\n \n This method changes the time-zone and retains the local date-time.\n The local date-time is only changed if it is invalid for the new zone,\n determined using the same approach as\n ofLocal(LocalDateTime, ZoneId, ZoneOffset).\n \n To change the zone and adjust the local date-time,\n use withZoneSameInstant(ZoneId).\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withZoneSameInstant",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withZoneSameInstant(ZoneId zone)",
                  "description": "Returns a copy of this date-time with a different time-zone,\n retaining the instant.\n \n This method changes the time-zone and retains the instant.\n This normally results in a change to the local date-time.\n \n This method is based on retaining the same instant, thus gaps and overlaps\n in the local time-line have no effect on the result.\n \n To change the offset while keeping the local time,\n use withZoneSameLocal(ZoneId)."
                }
              ]
            },
            {
              "name": "withFixedOffsetZone",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withFixedOffsetZone()",
                  "description": "Returns a copy of this date-time with the zone ID set to the offset.\n \n This returns a zoned date-time where the zone ID is the same as getOffset().\n The local date-time, offset and instant of the result will be the same as in this date-time.\n \n Setting the date-time to a fixed single offset means that any future\n calculations, such as addition or subtraction, have no complex edge cases\n due to time-zone rules.\n This might also be useful when sending a zoned date-time across a network,\n as most protocols, such as ISO-8601, only handle offsets,\n and not region-based zone IDs.\n \n This is equivalent to ZonedDateTime.of(zdt.toLocalDateTime(), zdt.getOffset())."
                }
              ]
            },
            {
              "name": "toLocalDateTime",
              "overloads": [
                {
                  "signature": "public LocalDateTime toLocalDateTime()",
                  "description": "Gets the LocalDateTime part of this date-time.\n \n This returns a LocalDateTime with the same year, month, day and time\n as this date-time."
                }
              ]
            },
            {
              "name": "toLocalDate",
              "overloads": [
                {
                  "signature": "public LocalDate toLocalDate()",
                  "description": "Gets the LocalDate part of this date-time.\n \n This returns a LocalDate with the same year, month and day\n as this date-time."
                }
              ]
            },
            {
              "name": "getYear",
              "overloads": [
                {
                  "signature": "public int getYear()",
                  "description": "Gets the year field.\n \n This method returns the primitive int value for the year.\n \n The year returned by this method is proleptic as per get(YEAR).\n To obtain the year-of-era, use get(YEAR_OF_ERA)."
                }
              ]
            },
            {
              "name": "getMonthValue",
              "overloads": [
                {
                  "signature": "public int getMonthValue()",
                  "description": "Gets the month-of-year field from 1 to 12.\n \n This method returns the month as an int from 1 to 12.\n Application code is frequently clearer if the enum Month\n is used by calling getMonth()."
                }
              ]
            },
            {
              "name": "getMonth",
              "overloads": [
                {
                  "signature": "public Month getMonth()",
                  "description": "Gets the month-of-year field using the Month enum.\n \n This method returns the enum Month for the month.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value."
                }
              ]
            },
            {
              "name": "getDayOfMonth",
              "overloads": [
                {
                  "signature": "public int getDayOfMonth()",
                  "description": "Gets the day-of-month field.\n \n This method returns the primitive int value for the day-of-month."
                }
              ]
            },
            {
              "name": "getDayOfYear",
              "overloads": [
                {
                  "signature": "public int getDayOfYear()",
                  "description": "Gets the day-of-year field.\n \n This method returns the primitive int value for the day-of-year."
                }
              ]
            },
            {
              "name": "getDayOfWeek",
              "overloads": [
                {
                  "signature": "public DayOfWeek getDayOfWeek()",
                  "description": "Gets the day-of-week field, which is an enum DayOfWeek.\n \n This method returns the enum DayOfWeek for the day-of-week.\n This avoids confusion as to what int values mean.\n If you need access to the primitive int value then the enum\n provides the int value.\n \n Additional information can be obtained from the DayOfWeek.\n This includes textual names of the values."
                }
              ]
            },
            {
              "name": "toLocalTime",
              "overloads": [
                {
                  "signature": "public LocalTime toLocalTime()",
                  "description": "Gets the LocalTime part of this date-time.\n \n This returns a LocalTime with the same hour, minute, second and\n nanosecond as this date-time."
                }
              ]
            },
            {
              "name": "getHour",
              "overloads": [
                {
                  "signature": "public int getHour()",
                  "description": "Gets the hour-of-day field."
                }
              ]
            },
            {
              "name": "getMinute",
              "overloads": [
                {
                  "signature": "public int getMinute()",
                  "description": "Gets the minute-of-hour field."
                }
              ]
            },
            {
              "name": "getSecond",
              "overloads": [
                {
                  "signature": "public int getSecond()",
                  "description": "Gets the second-of-minute field."
                }
              ]
            },
            {
              "name": "getNano",
              "overloads": [
                {
                  "signature": "public int getNano()",
                  "description": "Gets the nano-of-second field."
                }
              ]
            },
            {
              "name": "with",
              "overloads": [
                {
                  "signature": "public ZonedDateTime with(TemporalAdjuster adjuster)",
                  "description": "Returns an adjusted copy of this date-time.\n \n This returns a ZonedDateTime, based on this one, with the date-time adjusted.\n The adjustment takes place using the specified adjuster strategy object.\n Read the documentation of the adjuster to understand what adjustment will be made.\n \n A simple adjuster might simply set the one of the fields, such as the year field.\n A more complex adjuster might set the date to the last day of the month.\n A selection of common adjustments is provided in\n TemporalAdjusters.\n These include finding the \"last day of the month\" and \"next Wednesday\".\n Key date-time classes also implement the TemporalAdjuster interface,\n such as Month and MonthDay.\n The adjuster is responsible for handling special cases, such as the varying\n lengths of month and leap years.\n \n For example this code returns a date on the last day of July:\n   import static java.time.Month.*;\n  import static java.time.temporal.TemporalAdjusters.*;\n\n  result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n \n \n The classes LocalDate and LocalTime implement TemporalAdjuster,\n thus this method can be used to change the date, time or offset:\n   result = zonedDateTime.with(date);\n  result = zonedDateTime.with(time);\n \n \n ZoneOffset also implements TemporalAdjuster however using it\n as an argument typically has no effect. The offset of a ZonedDateTime is\n controlled primarily by the time-zone. As such, changing the offset does not generally\n make sense, because there is only one valid offset for the local date-time and zone.\n If the zoned date-time is in a daylight savings overlap, then the offset is used\n to switch between the two valid offsets. In all other cases, the offset is ignored.\n \n The result of this method is obtained by invoking the\n TemporalAdjuster.adjustInto(Temporal) method on the\n specified adjuster passing this as the argument.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public ZonedDateTime with(TemporalField field, long newValue)",
                  "description": "Returns a copy of this date-time with the specified field set to a new value.\n \n This returns a ZonedDateTime, based on this one, with the value\n for the specified field changed.\n This can be used to change any supported field, such as the year, month or day-of-month.\n If it is not possible to set the value, because the field is not supported or for\n some other reason, an exception is thrown.\n \n In some cases, changing the specified field can cause the resulting date-time to become invalid,\n such as changing the month from 31st January to February would make the day-of-month invalid.\n In cases like this, the field is responsible for resolving the date. Typically it will choose\n the previous valid date, which would be the last valid day of February in this example.\n \n If the field is a ChronoField then the adjustment is implemented here.\n \n The INSTANT_SECONDS field will return a date-time with the specified instant.\n The zone and nano-of-second are unchanged.\n The result will have an offset derived from the new instant and original zone.\n If the new instant value is outside the valid range then a DateTimeException will be thrown.\n \n The OFFSET_SECONDS field will typically be ignored.\n The offset of a ZonedDateTime is controlled primarily by the time-zone.\n As such, changing the offset does not generally make sense, because there is only\n one valid offset for the local date-time and zone.\n If the zoned date-time is in a daylight savings overlap, then the offset is used\n to switch between the two valid offsets. In all other cases, the offset is ignored.\n If the new offset value is outside the valid range then a DateTimeException will be thrown.\n \n The other supported fields will behave as per\n the matching method on LocalDateTime.\n The zone is not part of the calculation and will be unchanged.\n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.adjustInto(Temporal, long)\n passing this as the argument. In this case, the field determines\n whether and how to adjust the instant.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withYear",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withYear(int year)",
                  "description": "Returns a copy of this ZonedDateTime with the year altered.\n \n This operates on the local time-line,\n changing the year of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMonth",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withMonth(int month)",
                  "description": "Returns a copy of this ZonedDateTime with the month-of-year altered.\n \n This operates on the local time-line,\n changing the month of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfMonth",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withDayOfMonth(int dayOfMonth)",
                  "description": "Returns a copy of this ZonedDateTime with the day-of-month altered.\n \n This operates on the local time-line,\n changing the day-of-month of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withDayOfYear",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withDayOfYear(int dayOfYear)",
                  "description": "Returns a copy of this ZonedDateTime with the day-of-year altered.\n \n This operates on the local time-line,\n changing the day-of-year of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withHour",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withHour(int hour)",
                  "description": "Returns a copy of this ZonedDateTime with the hour-of-day altered.\n \n This operates on the local time-line,\n changing the time of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withMinute",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withMinute(int minute)",
                  "description": "Returns a copy of this ZonedDateTime with the minute-of-hour altered.\n \n This operates on the local time-line,\n changing the time of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withSecond",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withSecond(int second)",
                  "description": "Returns a copy of this ZonedDateTime with the second-of-minute altered.\n \n This operates on the local time-line,\n changing the time of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "withNano",
              "overloads": [
                {
                  "signature": "public ZonedDateTime withNano(int nanoOfSecond)",
                  "description": "Returns a copy of this ZonedDateTime with the nano-of-second altered.\n \n This operates on the local time-line,\n changing the time of the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "truncatedTo",
              "overloads": [
                {
                  "signature": "public ZonedDateTime truncatedTo(TemporalUnit unit)",
                  "description": "Returns a copy of this ZonedDateTime with the time truncated.\n \n Truncation returns a copy of the original date-time with fields\n smaller than the specified unit set to zero.\n For example, truncating with the minutes unit\n will set the second-of-minute and nano-of-second field to zero.\n \n The unit must have a duration\n that divides into the length of a standard day without remainder.\n This includes all supplied time units on ChronoUnit and\n DAYS. Other units throw an exception.\n \n This operates on the local time-line,\n truncating\n the underlying local date-time. This is then converted back to a\n ZonedDateTime, using the zone ID to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plus",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plus(TemporalAmount amountToAdd)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns a ZonedDateTime, based on this one, with the specified amount added.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.addTo(Temporal). The amount implementation is free\n to implement the addition in any way it wishes, however it typically\n calls back to plus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully added.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public ZonedDateTime plus(long amountToAdd, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount added.\n \n This returns a ZonedDateTime, based on this one, with the amount\n in terms of the unit added. If it is not possible to add the amount, because the\n unit is not supported or for some other reason, an exception is thrown.\n \n If the field is a ChronoUnit then the addition is implemented here.\n The zone is not part of the calculation and will be unchanged in the result.\n The calculation for date and time units differ.\n \n Date units operate on the local time-line.\n The period is first added to the local date-time, then converted back\n to a zoned date-time using the zone ID.\n The conversion uses ofLocal(LocalDateTime, ZoneId, ZoneOffset)\n with the offset before the addition.\n \n Time units operate on the instant time-line.\n The period is first added to the local date-time, then converted back to\n a zoned date-time using the zone ID.\n The conversion uses ofInstant(LocalDateTime, ZoneOffset, ZoneId)\n with the offset before the addition.\n \n If the field is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.addTo(Temporal, long)\n passing this as the argument. In this case, the unit determines\n whether and how to perform the addition.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusYears",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusYears(long years)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of years added.\n \n This operates on the local time-line,\n adding years to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMonths",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusMonths(long months)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of months added.\n \n This operates on the local time-line,\n adding months to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusWeeks",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusWeeks(long weeks)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of weeks added.\n \n This operates on the local time-line,\n adding weeks to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusDays",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusDays(long days)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of days added.\n \n This operates on the local time-line,\n adding days to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusHours",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusHours(long hours)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of hours added.\n \n This operates on the instant time-line, such that adding one hour will\n always be a duration of one hour later.\n This may cause the local date-time to change by an amount other than one hour.\n Note that this is a different approach to that used by days, months and years,\n thus adding one day is not the same as adding 24 hours.\n \n For example, consider a time-zone, such as 'Europe/Paris', where the\n Autumn DST cutover means that the local times 02:00 to 02:59 occur twice\n changing from offset +02:00 in summer to +01:00 in winter.\n \n Adding one hour to 01:30+02:00 will result in 02:30+02:00\n     (both in summer time)\n Adding one hour to 02:30+02:00 will result in 02:30+01:00\n     (moving from summer to winter time)\n Adding one hour to 02:30+01:00 will result in 03:30+01:00\n     (both in winter time)\n Adding three hours to 01:30+02:00 will result in 03:30+01:00\n     (moving from summer to winter time)\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusMinutes",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusMinutes(long minutes)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of minutes added.\n \n This operates on the instant time-line, such that adding one minute will\n always be a duration of one minute later.\n This may cause the local date-time to change by an amount other than one minute.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusSeconds",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusSeconds(long seconds)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of seconds added.\n \n This operates on the instant time-line, such that adding one second will\n always be a duration of one second later.\n This may cause the local date-time to change by an amount other than one second.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "plusNanos",
              "overloads": [
                {
                  "signature": "public ZonedDateTime plusNanos(long nanos)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of nanoseconds added.\n \n This operates on the instant time-line, such that adding one nano will\n always be a duration of one nano later.\n This may cause the local date-time to change by an amount other than one nano.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minus",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minus(TemporalAmount amountToSubtract)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns a ZonedDateTime, based on this one, with the specified amount subtracted.\n The amount is typically Period or Duration but may be\n any other type implementing the TemporalAmount interface.\n \n The calculation is delegated to the amount object by calling\n TemporalAmount.subtractFrom(Temporal). The amount implementation is free\n to implement the subtraction in any way it wishes, however it typically\n calls back to minus(long, TemporalUnit). Consult the documentation\n of the amount implementation to determine if it can be successfully subtracted.\n \n This instance is immutable and unaffected by this method call."
                },
                {
                  "signature": "public ZonedDateTime minus(long amountToSubtract, TemporalUnit unit)",
                  "description": "Returns a copy of this date-time with the specified amount subtracted.\n \n This returns a ZonedDateTime, based on this one, with the amount\n in terms of the unit subtracted. If it is not possible to subtract the amount,\n because the unit is not supported or for some other reason, an exception is thrown.\n \n The calculation for date and time units differ.\n \n Date units operate on the local time-line.\n The period is first subtracted from the local date-time, then converted back\n to a zoned date-time using the zone ID.\n The conversion uses ofLocal(LocalDateTime, ZoneId, ZoneOffset)\n with the offset before the subtraction.\n \n Time units operate on the instant time-line.\n The period is first subtracted from the local date-time, then converted back to\n a zoned date-time using the zone ID.\n The conversion uses ofInstant(LocalDateTime, ZoneOffset, ZoneId)\n with the offset before the subtraction.\n \n This method is equivalent to plus(long, TemporalUnit) with the amount negated.\n See that method for a full description of how addition, and thus subtraction, works.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusYears",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusYears(long years)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of years subtracted.\n \n This operates on the local time-line,\n subtracting years to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMonths",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusMonths(long months)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of months subtracted.\n \n This operates on the local time-line,\n subtracting months to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusWeeks",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusWeeks(long weeks)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of weeks subtracted.\n \n This operates on the local time-line,\n subtracting weeks to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusDays",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusDays(long days)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of days subtracted.\n \n This operates on the local time-line,\n subtracting days to the local date-time.\n This is then converted back to a ZonedDateTime, using the zone ID\n to obtain the offset.\n \n When converting back to ZonedDateTime, if the local date-time is in an overlap,\n then the offset will be retained if possible, otherwise the earlier offset will be used.\n If in a gap, the local date-time will be adjusted forward by the length of the gap.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusHours",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusHours(long hours)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of hours subtracted.\n \n This operates on the instant time-line, such that subtracting one hour will\n always be a duration of one hour earlier.\n This may cause the local date-time to change by an amount other than one hour.\n Note that this is a different approach to that used by days, months and years,\n thus subtracting one day is not the same as adding 24 hours.\n \n For example, consider a time-zone, such as 'Europe/Paris', where the\n Autumn DST cutover means that the local times 02:00 to 02:59 occur twice\n changing from offset +02:00 in summer to +01:00 in winter.\n \n Subtracting one hour from 03:30+01:00 will result in 02:30+01:00\n     (both in winter time)\n Subtracting one hour from 02:30+01:00 will result in 02:30+02:00\n     (moving from winter to summer time)\n Subtracting one hour from 02:30+02:00 will result in 01:30+02:00\n     (both in summer time)\n Subtracting three hours from 03:30+01:00 will result in 01:30+02:00\n     (moving from winter to summer time)\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusMinutes",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusMinutes(long minutes)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of minutes subtracted.\n \n This operates on the instant time-line, such that subtracting one minute will\n always be a duration of one minute earlier.\n This may cause the local date-time to change by an amount other than one minute.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusSeconds",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusSeconds(long seconds)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of seconds subtracted.\n \n This operates on the instant time-line, such that subtracting one second will\n always be a duration of one second earlier.\n This may cause the local date-time to change by an amount other than one second.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "minusNanos",
              "overloads": [
                {
                  "signature": "public ZonedDateTime minusNanos(long nanos)",
                  "description": "Returns a copy of this ZonedDateTime with the specified number of nanoseconds subtracted.\n \n This operates on the instant time-line, such that subtracting one nano will\n always be a duration of one nano earlier.\n This may cause the local date-time to change by an amount other than one nano.\n Note that this is a different approach to that used by days, months and years.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this date-time using the specified query.\n \n This queries this date-time using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "until",
              "overloads": [
                {
                  "signature": "public long until(Temporal endExclusive, TemporalUnit unit)",
                  "description": "Calculates the amount of time until another date-time in terms of the specified unit.\n \n This calculates the amount of time between two ZonedDateTime\n objects in terms of a single TemporalUnit.\n The start and end points are this and the specified date-time.\n The result will be negative if the end is before the start.\n For example, the amount in days between two date-times can be calculated\n using startDateTime.until(endDateTime, DAYS).\n \n The Temporal passed to this method is converted to a\n ZonedDateTime using from(TemporalAccessor).\n If the time-zone differs between the two zoned date-times, the specified\n end date-time is normalized to have the same zone as this date-time.\n \n The calculation returns a whole number, representing the number of\n complete units between the two date-times.\n For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n will only be one month as it is one minute short of two months.\n \n There are two equivalent ways of using this method.\n The first is to invoke this method.\n The second is to use TemporalUnit.between(Temporal, Temporal):\n    // these two lines are equivalent\n   amount = start.until(end, MONTHS);\n   amount = MONTHS.between(start, end);\n \n The choice should be made based on which makes the code more readable.\n \n The calculation is implemented in this method for ChronoUnit.\n The units NANOS, MICROS, MILLIS, SECONDS,\n MINUTES, HOURS and HALF_DAYS, DAYS,\n WEEKS, MONTHS, YEARS, DECADES,\n CENTURIES, MILLENNIA and ERAS are supported.\n Other ChronoUnit values will throw an exception.\n \n The calculation for date and time units differ.\n \n Date units operate on the local time-line, using the local date-time.\n For example, the period from noon on day 1 to noon the following day\n in days will always be counted as exactly one day, irrespective of whether\n there was a daylight savings change or not.\n \n Time units operate on the instant time-line.\n The calculation effectively converts both zoned date-times to instants\n and then calculates the period between the instants.\n For example, the period from noon on day 1 to noon the following day\n in hours may be 23, 24 or 25 hours (or some other amount) depending on\n whether there was a daylight savings change or not.\n \n If the unit is not a ChronoUnit, then the result of this method\n is obtained by invoking TemporalUnit.between(Temporal, Temporal)\n passing this as the first argument and the converted input temporal\n as the second argument.\n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "format",
              "overloads": [
                {
                  "signature": "public String format(DateTimeFormatter formatter)",
                  "description": "Formats this date-time using the specified formatter.\n \n This date-time will be passed to the formatter to produce a string."
                }
              ]
            },
            {
              "name": "toOffsetDateTime",
              "overloads": [
                {
                  "signature": "public OffsetDateTime toOffsetDateTime()",
                  "description": "Converts this date-time to an OffsetDateTime.\n \n This creates an offset date-time using the local date-time and offset.\n The zone ID is ignored."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this date-time is equal to another date-time.\n \n The comparison is based on the offset date-time and the zone.\n Only objects of type ZonedDateTime are compared, other types return false."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this date-time."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this date-time as a String, such as\n 2007-12-03T10:15:30+01:00[Europe/Paris].\n \n The format consists of the LocalDateTime followed by the ZoneOffset.\n If the ZoneId is not the same as the offset, then the ID is output.\n The output is compatible with ISO-8601 if the offset and ID are the same."
                }
              ]
            }
          ]
        },
        {
          "name": "ZoneId",
          "methods": [
            {
              "name": "systemDefault",
              "overloads": [
                {
                  "signature": "public static ZoneId systemDefault()",
                  "description": "Gets the system default time-zone.\n \n This queries TimeZone.getDefault() to find the default time-zone\n and converts it to a ZoneId. If the system default time-zone is changed,\n then the result of this method will also change."
                }
              ]
            },
            {
              "name": "getAvailableZoneIds",
              "overloads": [
                {
                  "signature": "public static Set<String> getAvailableZoneIds()",
                  "description": "Gets the set of available zone IDs.\n \n This set includes the string form of all available region-based IDs.\n Offset-based zone IDs are not included in the returned set.\n The ID can be passed to of(String) to create a ZoneId.\n \n The set of zone IDs can increase over time, although in a typical application\n the set of IDs is fixed. Each call to this method is thread-safe."
                }
              ]
            },
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static ZoneId of(String zoneId, Map<String,String> aliasMap)",
                  "description": "Obtains an instance of ZoneId using its ID using a map\n of aliases to supplement the standard zone IDs.\n \n Many users of time-zones use short abbreviations, such as PST for\n 'Pacific Standard Time' and PDT for 'Pacific Daylight Time'.\n These abbreviations are not unique, and so cannot be used as IDs.\n This method allows a map of string to time-zone to be setup and reused\n within an application."
                },
                {
                  "signature": "public static ZoneId of(String zoneId)",
                  "description": "Obtains an instance of ZoneId from an ID ensuring that the\n ID is valid and available for use.\n \n This method parses the ID producing a ZoneId or ZoneOffset.\n A ZoneOffset is returned if the ID is 'Z', or starts with '+' or '-'.\n The result will always be a valid ID for which ZoneRules can be obtained.\n \n Parsing matches the zone ID step by step as follows.\n \n If the zone ID equals 'Z', the result is ZoneOffset.UTC.\n If the zone ID consists of a single letter, the zone ID is invalid\n  and DateTimeException is thrown.\n If the zone ID starts with '+' or '-', the ID is parsed as a\n  ZoneOffset using ZoneOffset.of(String).\n If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a ZoneId\n  with the same ID and rules equivalent to ZoneOffset.UTC.\n If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n  then the ID is a prefixed offset-based ID. The ID is split in two, with\n  a two or three letter prefix and a suffix starting with the sign.\n  The suffix is parsed as a ZoneOffset.\n  The result will be a ZoneId with the specified UTC/GMT/UT prefix\n  and the normalized offset ID as per ZoneOffset.getId().\n  The rules of the returned ZoneId will be equivalent to the\n  parsed ZoneOffset.\n All other IDs are parsed as region-based zone IDs. Region IDs must\n  match the regular expression [A-Za-z][A-Za-z0-9~/._+-]+\n  otherwise a DateTimeException is thrown. If the zone ID is not\n  in the configured set of IDs, ZoneRulesException is thrown.\n  The detailed format of the region ID depends on the group supplying the data.\n  The default set of data is supplied by the IANA Time Zone Database (TZDB).\n  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n  This is compatible with most IDs from TimeZone."
                }
              ]
            },
            {
              "name": "ofOffset",
              "overloads": [
                {
                  "signature": "public static ZoneId ofOffset(String prefix, ZoneOffset offset)",
                  "description": "Obtains an instance of ZoneId wrapping an offset.\n \n If the prefix is \"GMT\", \"UTC\", or \"UT\" a ZoneId\n with the prefix and the non-zero offset is returned.\n If the prefix is empty \"\" the ZoneOffset is returned."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static ZoneId from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of ZoneId from a temporal object.\n \n This obtains a zone based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of ZoneId.\n \n A TemporalAccessor represents some form of date and time information.\n This factory converts the arbitrary temporal object to an instance of ZoneId.\n \n The conversion will try to obtain the zone in a way that favours region-based\n zones over offset-based zones using TemporalQueries.zone().\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, ZoneId::from."
                }
              ]
            },
            {
              "name": "getId",
              "overloads": [
                {
                  "signature": "public abstract String getId()",
                  "description": "Gets the unique time-zone ID.\n \n This ID uniquely defines this object.\n The format of an offset based ID is defined by ZoneOffset.getId()."
                }
              ]
            },
            {
              "name": "getDisplayName",
              "overloads": [
                {
                  "signature": "public String getDisplayName(TextStyle style, Locale locale)",
                  "description": "Gets the textual representation of the zone, such as 'British Time' or\n '+02:00'.\n \n This returns the textual name used to identify the time-zone ID,\n suitable for presentation to the user.\n The parameters control the style of the returned text and the locale.\n \n If no textual mapping is found then the full ID is returned."
                }
              ]
            },
            {
              "name": "getRules",
              "overloads": [
                {
                  "signature": "public abstract ZoneRules getRules()",
                  "description": "Gets the time-zone rules for this ID allowing calculations to be performed.\n \n The rules provide the functionality associated with a time-zone,\n such as finding the offset for a given instant or local date-time.\n \n A time-zone can be invalid if it is deserialized in a Java Runtime which\n does not have the same rules loaded as the Java Runtime that stored it.\n In this case, calling this method will throw a ZoneRulesException.\n \n The rules are supplied by ZoneRulesProvider. An advanced provider may\n support dynamic updates to the rules without restarting the Java Runtime.\n If so, then the result of this method may change over time.\n Each individual call will be still remain thread-safe.\n \n ZoneOffset will always return a set of rules where the offset never changes."
                }
              ]
            },
            {
              "name": "normalized",
              "overloads": [
                {
                  "signature": "public ZoneId normalized()",
                  "description": "Normalizes the time-zone ID, returning a ZoneOffset where possible.\n \n The returns a normalized ZoneId that can be used in place of this ID.\n The result will have ZoneRules equivalent to those returned by this object,\n however the ID returned by getId() may be different.\n \n The normalization checks if the rules of this ZoneId have a fixed offset.\n If they do, then the ZoneOffset equal to that offset is returned.\n Otherwise this is returned."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this time-zone ID is equal to another time-zone ID.\n \n The comparison is based on the ID."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this time-zone ID."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this zone as a String, using the ID."
                }
              ]
            }
          ]
        },
        {
          "name": "ZoneOffset",
          "methods": [
            {
              "name": "of",
              "overloads": [
                {
                  "signature": "public static ZoneOffset of(String offsetId)",
                  "description": "Obtains an instance of ZoneOffset using the ID.\n \n This method parses the string ID of a ZoneOffset to\n return an instance. The parsing accepts all the formats generated by\n getId(), plus some additional formats:\n \n Z - for UTC\n +h\n +hh\n +hh:mm\n -hh:mm\n +hhmm\n -hhmm\n +hh:mm:ss\n -hh:mm:ss\n +hhmmss\n -hhmmss\n \n Note that  means either the plus or minus symbol.\n \n The ID of the returned offset will be normalized to one of the formats\n described by getId().\n \n The maximum supported range is from +18:00 to -18:00 inclusive."
                }
              ]
            },
            {
              "name": "ofHours",
              "overloads": [
                {
                  "signature": "public static ZoneOffset ofHours(int hours)",
                  "description": "Obtains an instance of ZoneOffset using an offset in hours."
                }
              ]
            },
            {
              "name": "ofHoursMinutes",
              "overloads": [
                {
                  "signature": "public static ZoneOffset ofHoursMinutes(int hours, int minutes)",
                  "description": "Obtains an instance of ZoneOffset using an offset in\n hours and minutes.\n \n The sign of the hours and minutes components must match.\n Thus, if the hours is negative, the minutes must be negative or zero.\n If the hours is zero, the minutes may be positive, negative or zero."
                }
              ]
            },
            {
              "name": "ofHoursMinutesSeconds",
              "overloads": [
                {
                  "signature": "public static ZoneOffset ofHoursMinutesSeconds(int hours, int minutes, int seconds)",
                  "description": "Obtains an instance of ZoneOffset using an offset in\n hours, minutes and seconds.\n \n The sign of the hours, minutes and seconds components must match.\n Thus, if the hours is negative, the minutes and seconds must be negative or zero."
                }
              ]
            },
            {
              "name": "from",
              "overloads": [
                {
                  "signature": "public static ZoneOffset from(TemporalAccessor temporal)",
                  "description": "Obtains an instance of ZoneOffset from a temporal object.\n \n This obtains an offset based on the specified temporal.\n A TemporalAccessor represents an arbitrary set of date and time information,\n which this factory converts to an instance of ZoneOffset.\n \n A TemporalAccessor represents some form of date and time information.\n This factory converts the arbitrary temporal object to an instance of ZoneOffset.\n \n The conversion uses the TemporalQueries.offset() query, which relies\n on extracting the OFFSET_SECONDS field.\n \n This method matches the signature of the functional interface TemporalQuery\n allowing it to be used as a query via method reference, ZoneOffset::from."
                }
              ]
            },
            {
              "name": "ofTotalSeconds",
              "overloads": [
                {
                  "signature": "public static ZoneOffset ofTotalSeconds(int totalSeconds)",
                  "description": "Obtains an instance of ZoneOffset specifying the total offset in seconds\n \n The offset must be in the range -18:00 to +18:00, which corresponds to -64800 to +64800."
                }
              ]
            },
            {
              "name": "getTotalSeconds",
              "overloads": [
                {
                  "signature": "public int getTotalSeconds()",
                  "description": "Gets the total zone offset in seconds.\n \n This is the primary way to access the offset amount.\n It returns the total of the hours, minutes and seconds fields as a\n single offset that can be added to a time."
                }
              ]
            },
            {
              "name": "getId",
              "overloads": [
                {
                  "signature": "public String getId()",
                  "description": "Gets the normalized zone offset ID.\n \n The ID is minor variation to the standard ISO-8601 formatted string\n for the offset. There are three formats:\n \n Z - for UTC (ISO-8601)\n +hh:mm or -hh:mm - if the seconds are zero (ISO-8601)\n +hh:mm:ss or -hh:mm:ss - if the seconds are non-zero (not ISO-8601)"
                }
              ]
            },
            {
              "name": "getRules",
              "overloads": [
                {
                  "signature": "public ZoneRules getRules()",
                  "description": "Gets the associated time-zone rules.\n \n The rules will always return this offset when queried.\n The implementation class is immutable, thread-safe and serializable."
                }
              ]
            },
            {
              "name": "isSupported",
              "overloads": [
                {
                  "signature": "public boolean isSupported(TemporalField field)",
                  "description": "Checks if the specified field is supported.\n \n This checks if this offset can be queried for the specified field.\n If false, then calling the range and\n get methods will throw an exception.\n \n If the field is a ChronoField then the query is implemented here.\n The OFFSET_SECONDS field returns true.\n All other ChronoField instances will return false.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)\n passing this as the argument.\n Whether the field is supported is determined by the field."
                }
              ]
            },
            {
              "name": "range",
              "overloads": [
                {
                  "signature": "public ValueRange range(TemporalField field)",
                  "description": "Gets the range of valid values for the specified field.\n \n The range object expresses the minimum and maximum valid values for a field.\n This offset is used to enhance the accuracy of the returned range.\n If it is not possible to return the range, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The supported fields will return\n appropriate range instances.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)\n passing this as the argument.\n Whether the range can be obtained is determined by the field."
                }
              ]
            },
            {
              "name": "get",
              "overloads": [
                {
                  "signature": "public int get(TemporalField field)",
                  "description": "Gets the value of the specified field from this offset as an int.\n \n This queries this offset for the value of the specified field.\n The returned value will always be within the valid range of values for the field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The OFFSET_SECONDS field returns the value of the offset.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "getLong",
              "overloads": [
                {
                  "signature": "public long getLong(TemporalField field)",
                  "description": "Gets the value of the specified field from this offset as a long.\n \n This queries this offset for the value of the specified field.\n If it is not possible to return the value, because the field is not supported\n or for some other reason, an exception is thrown.\n \n If the field is a ChronoField then the query is implemented here.\n The OFFSET_SECONDS field returns the value of the offset.\n All other ChronoField instances will throw an UnsupportedTemporalTypeException.\n \n If the field is not a ChronoField, then the result of this method\n is obtained by invoking TemporalField.getFrom(TemporalAccessor)\n passing this as the argument. Whether the value can be obtained,\n and what the value represents, is determined by the field."
                }
              ]
            },
            {
              "name": "query",
              "overloads": [
                {
                  "signature": "public <R> R query(TemporalQuery<R> query)",
                  "description": "Queries this offset using the specified query.\n \n This queries this offset using the specified query strategy object.\n The TemporalQuery object defines the logic to be used to\n obtain the result. Read the documentation of the query to understand\n what the result of this method will be.\n \n The result of this method is obtained by invoking the\n TemporalQuery.queryFrom(TemporalAccessor) method on the\n specified query passing this as the argument."
                }
              ]
            },
            {
              "name": "adjustInto",
              "overloads": [
                {
                  "signature": "public Temporal adjustInto(Temporal temporal)",
                  "description": "Adjusts the specified temporal object to have the same offset as this object.\n \n This returns a temporal object of the same observable type as the input\n with the offset changed to be the same as this.\n \n The adjustment is equivalent to using Temporal.with(TemporalField, long)\n passing ChronoField.OFFSET_SECONDS as the field.\n \n In most cases, it is clearer to reverse the calling pattern by using\n Temporal.with(TemporalAdjuster):\n    // these two lines are equivalent, but the second approach is recommended\n   temporal = thisOffset.adjustInto(temporal);\n   temporal = temporal.with(thisOffset);\n \n \n This instance is immutable and unaffected by this method call."
                }
              ]
            },
            {
              "name": "compareTo",
              "overloads": [
                {
                  "signature": "public int compareTo(ZoneOffset other)",
                  "description": "Compares this offset to another offset in descending order.\n \n The offsets are compared in the order that they occur for the same time\n of day around the world. Thus, an offset of +10:00 comes before an\n offset of +09:00 and so on down to -18:00.\n \n The comparison is \"consistent with equals\", as defined by Comparable."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks if this offset is equal to another offset.\n \n The comparison is based on the amount of the offset in seconds.\n This is equivalent to a comparison by ID."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "A hash code for this offset."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Outputs this offset as a String, using the normalized ID."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "package": "java.security",
      "description": "Security framework",
      "classes": [
        {
          "name": "AccessControlContext",
          "methods": [
            {
              "name": "AccessControlContext",
              "overloads": [
                {
                  "signature": "public AccessControlContext(ProtectionDomain[] context)",
                  "description": "Create an AccessControlContext with the given array of ProtectionDomains.\n Context must not be null. Duplicate domains will be removed from the\n context.",
                  "deprecated": true
                },
                {
                  "signature": "public AccessControlContext(AccessControlContext acc, DomainCombiner combiner)",
                  "description": "Create a new AccessControlContext with the given\n AccessControlContext and DomainCombiner.\n This constructor associates the provided\n DomainCombiner with the provided\n AccessControlContext.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getDomainCombiner",
              "overloads": [
                {
                  "signature": "public DomainCombiner getDomainCombiner()",
                  "description": "Get the DomainCombiner associated with this\n AccessControlContext.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public void checkPermission(Permission perm) throws AccessControlException",
                  "description": "Determines whether the access request indicated by the\n specified permission should be allowed or denied, based on\n the security policy currently in effect, and the context in\n this object. The request is allowed only if every ProtectionDomain\n in the context implies the permission. Otherwise the request is\n denied.\n\n \n This method quietly returns if the access request\n is permitted, or throws a suitable AccessControlException otherwise.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two AccessControlContext objects for equality.\n Checks that obj is\n an AccessControlContext and has the same set of ProtectionDomains\n as this context.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this context. The hash code\n is computed by exclusive or-ing the hash code of all the protection\n domains in the context together.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AccessControlException",
          "methods": [
            {
              "name": "AccessControlException",
              "overloads": [
                {
                  "signature": "public AccessControlException(String s)",
                  "description": "Constructs an AccessControlException with the\n specified, detailed message.",
                  "deprecated": true
                },
                {
                  "signature": "public AccessControlException(String s, Permission p)",
                  "description": "Constructs an AccessControlException with the\n specified, detailed message, and the requested permission that caused\n the exception.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPermission",
              "overloads": [
                {
                  "signature": "public Permission getPermission()",
                  "description": "Gets the Permission object associated with this exception, or\n null if there was no corresponding Permission object.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AccessController",
          "methods": [
            {
              "name": "doPrivileged",
              "overloads": [
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified AccessControlContext.\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context, Permission... perms)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action, AccessControlContext context) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext.  The action is performed with the\n intersection of the permissions possessed by the caller's\n protection domain, and those possessed by the domains represented by the\n specified AccessControlContext.\n \n If the action's run method throws an unchecked\n exception, it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivileged(PrivilegedExceptionAction<T> action, AccessControlContext context, Permission... perms) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "doPrivilegedWithCombiner",
              "overloads": [
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action, AccessControlContext context, Permission... perms)",
                  "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.",
                  "deprecated": true
                },
                {
                  "signature": "public static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action, AccessControlContext context, Permission... perms) throws PrivilegedActionException",
                  "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getContext",
              "overloads": [
                {
                  "signature": "public static AccessControlContext getContext()",
                  "description": "This method takes a \"snapshot\" of the current calling context, which\n includes the current Thread's inherited AccessControlContext and any\n limited privilege scope, and places it in an AccessControlContext object.\n This context may then be checked at a later point, possibly in another thread.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "checkPermission",
              "overloads": [
                {
                  "signature": "public static void checkPermission(Permission perm) throws AccessControlException",
                  "description": "Determines whether the access request indicated by the\n specified permission should be allowed or denied, based on\n the current AccessControlContext and security policy.\n This method quietly returns if the access request\n is permitted, or throws an AccessControlException otherwise. The\n getPermission method of the AccessControlException returns the\n perm Permission object instance.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmConstraints",
          "methods": [
            {
              "name": "permits",
              "overloads": [
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, String algorithm, AlgorithmParameters parameters)",
                  "description": "Determines whether an algorithm is granted permission for the\n specified cryptographic primitives."
                },
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, Key key)",
                  "description": "Determines whether a key is granted permission for the specified\n cryptographic primitives.\n \n This method is usually used to check key size and key usage."
                },
                {
                  "signature": "boolean permits(Set<CryptoPrimitive> primitives, String algorithm, Key key, AlgorithmParameters parameters)",
                  "description": "Determines whether an algorithm and the corresponding key are granted\n permission for the specified cryptographic primitives."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameterGenerator",
          "methods": [
            {
              "name": "AlgorithmParameterGenerator",
              "overloads": [
                {
                  "signature": "protected AlgorithmParameterGenerator(AlgorithmParameterGeneratorSpi paramGenSpi, Provider provider, String algorithm)",
                  "description": "Creates an AlgorithmParameterGenerator object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns the standard name of the algorithm this parameter\n generator is associated with."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static AlgorithmParameterGenerator getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.\n\n  A new AlgorithmParameterGenerator object encapsulating the\n AlgorithmParameterGeneratorSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this algorithm parameter generator object."
                }
              ]
            },
            {
              "name": "init",
              "overloads": [
                {
                  "signature": "public final void init(int size)",
                  "description": "Initializes this parameter generator for a certain size.\n To create the parameters, the SecureRandom\n implementation of the highest-priority installed provider is used as\n the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)"
                },
                {
                  "signature": "public final void init(int size, SecureRandom random)",
                  "description": "Initializes this parameter generator for a certain size and source\n of randomness."
                },
                {
                  "signature": "public final void init(AlgorithmParameterSpec genParamSpec) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values.\n To generate the parameters, the SecureRandom\n implementation of the highest-priority installed provider is used as\n the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)"
                },
                {
                  "signature": "public final void init(AlgorithmParameterSpec genParamSpec, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values."
                }
              ]
            },
            {
              "name": "generateParameters",
              "overloads": [
                {
                  "signature": "public final AlgorithmParameters generateParameters()",
                  "description": "Generates the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameterGeneratorSpi",
          "methods": [
            {
              "name": "AlgorithmParameterGeneratorSpi",
              "overloads": [
                {
                  "signature": "public AlgorithmParameterGeneratorSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineInit",
              "overloads": [
                {
                  "signature": "protected abstract void engineInit(int size, SecureRandom random)",
                  "description": "Initializes this parameter generator for a certain size\n and source of randomness."
                },
                {
                  "signature": "protected abstract void engineInit(AlgorithmParameterSpec genParamSpec, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this parameter generator with a set of\n algorithm-specific parameter generation values."
                }
              ]
            },
            {
              "name": "engineGenerateParameters",
              "overloads": [
                {
                  "signature": "protected abstract AlgorithmParameters engineGenerateParameters()",
                  "description": "Generates the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParameters",
          "methods": [
            {
              "name": "AlgorithmParameters",
              "overloads": [
                {
                  "signature": "protected AlgorithmParameters(AlgorithmParametersSpi paramSpi, Provider provider, String algorithm)",
                  "description": "Creates an AlgorithmParameters object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns the name of the algorithm associated with this parameter object."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n  The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                },
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                },
                {
                  "signature": "public static AlgorithmParameters getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a parameter object for the specified algorithm.\n\n  A new AlgorithmParameters object encapsulating the\n AlgorithmParametersSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list.\n\n The returned parameter object must be initialized via a call to\n init, using an appropriate parameter specification or\n parameter encoding."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this parameter object."
                }
              ]
            },
            {
              "name": "init",
              "overloads": [
                {
                  "signature": "public final void init(AlgorithmParameterSpec paramSpec) throws InvalidParameterSpecException",
                  "description": "Initializes this parameter object using the parameters\n specified in paramSpec."
                },
                {
                  "signature": "public final void init(byte[] params) throws IOException",
                  "description": "Imports the specified parameters and decodes them according to the\n primary decoding format for parameters. The primary decoding\n format for parameters is ASN.1, if an ASN.1 specification for this type\n of parameters exists."
                },
                {
                  "signature": "public final void init(byte[] params, String format) throws IOException",
                  "description": "Imports the parameters from params and decodes them\n according to the specified decoding scheme.\n If format is null, the\n primary decoding format for parameters is used. The primary decoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "getParameterSpec",
              "overloads": [
                {
                  "signature": "public final <T extends AlgorithmParameterSpec> T getParameterSpec(Class<T> paramSpec) throws InvalidParameterSpecException",
                  "description": "Returns a (transparent) specification of this parameter object.\n paramSpec identifies the specification class in which\n the parameters should be returned. It could, for example, be\n DSAParameterSpec.class, to indicate that the\n parameters should be returned in an instance of the\n DSAParameterSpec class."
                }
              ]
            },
            {
              "name": "getEncoded",
              "overloads": [
                {
                  "signature": "public final byte[] getEncoded() throws IOException",
                  "description": "Returns the parameters in their primary encoding format.\n The primary encoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "public final byte[] getEncoded(String format) throws IOException",
                  "description": "Returns the parameters encoded in the specified scheme.\n If format is null, the\n primary encoding format for parameters is used. The primary encoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public final String toString()",
                  "description": "Returns a formatted string describing the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AlgorithmParametersSpi",
          "methods": [
            {
              "name": "AlgorithmParametersSpi",
              "overloads": [
                {
                  "signature": "public AlgorithmParametersSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineInit",
              "overloads": [
                {
                  "signature": "protected abstract void engineInit(AlgorithmParameterSpec paramSpec) throws InvalidParameterSpecException",
                  "description": "Initializes this parameters object using the parameters\n specified in paramSpec."
                },
                {
                  "signature": "protected abstract void engineInit(byte[] params) throws IOException",
                  "description": "Imports the specified parameters and decodes them\n according to the primary decoding format for parameters.\n The primary decoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "protected abstract void engineInit(byte[] params, String format) throws IOException",
                  "description": "Imports the parameters from params and\n decodes them according to the specified decoding format.\n If format is null, the\n primary decoding format for parameters is used. The primary decoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "engineGetParameterSpec",
              "overloads": [
                {
                  "signature": "protected abstract <T extends AlgorithmParameterSpec> T engineGetParameterSpec(Class<T> paramSpec) throws InvalidParameterSpecException",
                  "description": "Returns a (transparent) specification of this parameters\n object.\n paramSpec identifies the specification class in which\n the parameters should be returned. It could, for example, be\n DSAParameterSpec.class, to indicate that the\n parameters should be returned in an instance of the\n DSAParameterSpec class."
                }
              ]
            },
            {
              "name": "engineGetEncoded",
              "overloads": [
                {
                  "signature": "protected abstract byte[] engineGetEncoded() throws IOException",
                  "description": "Returns the parameters in their primary encoding format.\n The primary encoding format for parameters is ASN.1, if an ASN.1\n specification for this type of parameters exists."
                },
                {
                  "signature": "protected abstract byte[] engineGetEncoded(String format) throws IOException",
                  "description": "Returns the parameters encoded in the specified format.\n If format is null, the\n primary encoding format for parameters is used. The primary encoding\n format is ASN.1, if an ASN.1 specification for these parameters\n exists."
                }
              ]
            },
            {
              "name": "engineToString",
              "overloads": [
                {
                  "signature": "protected abstract String engineToString()",
                  "description": "Returns a formatted string describing the parameters."
                }
              ]
            }
          ]
        },
        {
          "name": "AllPermission",
          "methods": [
            {
              "name": "AllPermission",
              "overloads": [
                {
                  "signature": "public AllPermission()",
                  "description": "Creates a new AllPermission object."
                },
                {
                  "signature": "public AllPermission(String name, String actions)",
                  "description": "Creates a new AllPermission object. This\n constructor exists for use by the Policy object\n to instantiate new Permission objects."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if the specified permission is \"implied\" by\n this object. This method always returns true."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two AllPermission objects for equality. Two AllPermission\n objects are always equal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing AllPermission\n objects."
                }
              ]
            }
          ]
        },
        {
          "name": "AuthProvider",
          "methods": [
            {
              "name": "AuthProvider",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected AuthProvider(String name, double version, String info)",
                  "description": "Constructs a provider with the specified name, version number,\n and information.",
                  "deprecated": true
                },
                {
                  "signature": "protected AuthProvider(String name, String versionStr, String info)",
                  "description": "Constructs a provider with the specified name, version string,\n and information."
                }
              ]
            },
            {
              "name": "login",
              "overloads": [
                {
                  "signature": "public abstract void login(Subject subject, CallbackHandler handler) throws LoginException",
                  "description": "Log in to this provider.\n\n  The provider relies on a CallbackHandler\n to obtain authentication information from the caller\n (a PIN, for example).  If the caller passes a null\n handler to this method, the provider uses the handler set in the\n setCallbackHandler method.\n If no handler was set in that method, the provider queries the\n auth.login.defaultCallbackHandler security property\n for the fully qualified class name of a default handler implementation.\n If the security property is not set,\n the provider is assumed to have alternative means\n for obtaining authentication information."
                }
              ]
            },
            {
              "name": "logout",
              "overloads": [
                {
                  "signature": "public abstract void logout() throws LoginException",
                  "description": "Log out from this provider."
                }
              ]
            },
            {
              "name": "setCallbackHandler",
              "overloads": [
                {
                  "signature": "public abstract void setCallbackHandler(CallbackHandler handler)",
                  "description": "Set a CallbackHandler.\n\n  The provider uses this handler if one is not passed to the\n login method.  The provider also uses this handler\n if it invokes login on behalf of callers.\n In either case if a handler is not set via this method,\n the provider queries the\n auth.login.defaultCallbackHandler security property\n for the fully qualified class name of a default handler implementation.\n If the security property is not set,\n the provider is assumed to have alternative means\n for obtaining authentication information."
                }
              ]
            }
          ]
        },
        {
          "name": "BasicPermission",
          "methods": [
            {
              "name": "BasicPermission",
              "overloads": [
                {
                  "signature": "public BasicPermission(String name)",
                  "description": "Creates a new BasicPermission with the specified name.\n Name is the symbolic name of the permission, such as\n \"setFactory\",\n \"print.queueJob\", or \"topLevelWindow\", etc."
                },
                {
                  "signature": "public BasicPermission(String name, String actions)",
                  "description": "Creates a new BasicPermission object with the specified name.\n The name is the symbolic name of the BasicPermission, and the\n actions String is currently unused."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "Checks if the specified permission is \"implied\" by\n this object.\n \n More specifically, this method returns true if:\n \n  p's class is the same as this object's class, and\n  p's name equals or (in the case of wildcards)\n      is implied by this object's\n      name. For example, \"a.b.*\" implies \"a.b.c\"."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two BasicPermission objects for equality.\n Checks that obj's class is the same as this object's class\n and has the same name as this object."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object.\n The hash code used is the hash code of the name, that is,\n getName().hashCode(), where getName is\n from the Permission superclass."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions,\n which currently is the empty string \"\", since there are no actions for\n a BasicPermission."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing BasicPermission\n objects.\n\n BasicPermission objects must be stored in a manner that allows them\n to be inserted in any order, but that also enables the\n PermissionCollection implies method\n to be implemented in an efficient (and consistent) manner."
                }
              ]
            }
          ]
        },
        {
          "name": "Certificate",
          "methods": [
            {
              "name": "getGuarantor",
              "overloads": [
                {
                  "signature": "Principal getGuarantor()",
                  "description": "Returns the guarantor of the certificate, that is, the principal\n guaranteeing that the public key associated with this certificate\n is that of the principal associated with this certificate. For X.509\n certificates, the guarantor will typically be a Certificate Authority\n (such as the United States Postal Service or Verisign, Inc.).",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPrincipal",
              "overloads": [
                {
                  "signature": "Principal getPrincipal()",
                  "description": "Returns the principal of the principal-key pair being guaranteed by\n the guarantor.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPublicKey",
              "overloads": [
                {
                  "signature": "PublicKey getPublicKey()",
                  "description": "Returns the key of the principal-key pair being guaranteed by\n the guarantor.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "encode",
              "overloads": [
                {
                  "signature": "void encode(OutputStream stream) throws KeyException, IOException",
                  "description": "Encodes the certificate to an output stream in a format that can\n be decoded by the decode method.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "decode",
              "overloads": [
                {
                  "signature": "void decode(InputStream stream) throws KeyException, IOException",
                  "description": "Decodes a certificate from an input stream. The format should be\n that returned by getFormat and produced by\n encode.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getFormat",
              "overloads": [
                {
                  "signature": "String getFormat()",
                  "description": "Returns the name of the coding format. This is used as a hint to find\n an appropriate parser. It could be \"X.509\", \"PGP\", etc. This is\n the format produced and understood by the encode\n and decode methods.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "String toString(boolean detailed)",
                  "description": "Returns a string that represents the contents of the certificate.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static KeyRep.Type[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static KeyRep.Type valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static CryptoPrimitive[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static CryptoPrimitive valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            }
          ]
        },
        {
          "name": "Class",
          "methods": [
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public static DrbgParameters.Capability[] values()",
                  "description": "Returns an array containing the constants of this enum class, in\nthe order they are declared."
                }
              ]
            },
            {
              "name": "valueOf",
              "overloads": [
                {
                  "signature": "public static DrbgParameters.Capability valueOf(String name)",
                  "description": "Returns the enum constant of this class with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this class.  (Extraneous whitespace characters are \nnot permitted.)"
                }
              ]
            },
            {
              "name": "supportsReseeding",
              "overloads": [
                {
                  "signature": "public boolean supportsReseeding()",
                  "description": "Returns whether this capability supports reseeding."
                }
              ]
            },
            {
              "name": "supportsPredictionResistance",
              "overloads": [
                {
                  "signature": "public boolean supportsPredictionResistance()",
                  "description": "Returns whether this capability supports prediction resistance."
                }
              ]
            }
          ]
        },
        {
          "name": "CodeSigner",
          "methods": [
            {
              "name": "CodeSigner",
              "overloads": [
                {
                  "signature": "public CodeSigner(CertPath signerCertPath, Timestamp timestamp)",
                  "description": "Constructs a CodeSigner object."
                }
              ]
            },
            {
              "name": "getSignerCertPath",
              "overloads": [
                {
                  "signature": "public CertPath getSignerCertPath()",
                  "description": "Returns the signer's certificate path."
                }
              ]
            },
            {
              "name": "getTimestamp",
              "overloads": [
                {
                  "signature": "public Timestamp getTimestamp()",
                  "description": "Returns the signature timestamp."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this code signer.\n The hash code is generated using the signer's certificate path and the\n timestamp, if present."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Tests for equality between the specified object and this\n code signer. Two code signers are considered equal if their\n signer certificate paths are equal and if their timestamps are equal,\n if present in both."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this code signer."
                }
              ]
            }
          ]
        },
        {
          "name": "CodeSource",
          "methods": [
            {
              "name": "CodeSource",
              "overloads": [
                {
                  "signature": "public CodeSource(URL url, Certificate[] certs)",
                  "description": "Constructs a CodeSource and associates it with the specified\n location and set of certificates."
                },
                {
                  "signature": "public CodeSource(URL url, CodeSigner[] signers)",
                  "description": "Constructs a CodeSource and associates it with the specified\n location and set of code signers."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Tests for equality between the specified object and this\n object. Two CodeSource objects are considered equal if their\n locations are of identical value and if their signer certificate\n chains are of identical value. It is not required that\n the certificate chains be in the same order."
                }
              ]
            },
            {
              "name": "getLocation",
              "overloads": [
                {
                  "signature": "public final URL getLocation()",
                  "description": "Returns the location associated with this CodeSource."
                }
              ]
            },
            {
              "name": "getCertificates",
              "overloads": [
                {
                  "signature": "public final Certificate[] getCertificates()",
                  "description": "Returns the certificates associated with this CodeSource.\n \n If this CodeSource object was created using the\n CodeSource(URL url, CodeSigner[] signers)\n constructor then its certificate chains are extracted and used to\n create an array of Certificate objects. Each signer certificate is\n followed by its supporting certificate chain (which may be empty).\n Each signer certificate and its supporting certificate chain is ordered\n bottom-to-top (i.e., with the signer certificate first and the (root)\n certificate authority last)."
                }
              ]
            },
            {
              "name": "getCodeSigners",
              "overloads": [
                {
                  "signature": "public final CodeSigner[] getCodeSigners()",
                  "description": "Returns the code signers associated with this CodeSource.\n \n If this CodeSource object was created using the\n CodeSource(URL url, java.security.cert.Certificate[] certs)\n constructor then its certificate chains are extracted and used to\n create an array of CodeSigner objects. Note that only X.509 certificates\n are examined - all other certificate types are ignored."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(CodeSource codesource)",
                  "description": "Returns true if this CodeSource object \"implies\" the specified CodeSource.\n \n More specifically, this method makes the following checks.\n If any fail, it returns false. If they all succeed, it returns true.\n \n  codesource must not be null.\n  If this object's certificates are not null, then all\n of this object's certificates must be present in codesource's\n certificates.\n  If this object's location (getLocation()) is not null, then the\n following checks are made against this object's location and\n codesource's:\n   \n       codesource's location must not be null.\n\n       If this object's location\n           equals codesource's location, then return true.\n\n       This object's protocol (getLocation().getProtocol()) must be\n           equal to codesource's protocol, ignoring case.\n\n       If this object's host (getLocation().getHost()) is not null,\n           then the SocketPermission\n           constructed with this object's host must imply the\n           SocketPermission constructed with codesource's host.\n\n       If this object's port (getLocation().getPort()) is not\n           equal to -1 (that is, if a port is specified), it must equal\n           codesource's port or default port\n           (codesource.getLocation().getDefaultPort()).\n\n       If this object's file (getLocation().getFile()) doesn't equal\n           codesource's file, then the following checks are made:\n           If this object's file ends with \"/-\",\n           then codesource's file must start with this object's\n           file (exclusive the trailing \"-\").\n           If this object's file ends with a \"/*\",\n           then codesource's file must start with this object's\n           file and must not have any further \"/\" separators.\n           If this object's file doesn't end with a \"/\",\n           then codesource's file must match this object's\n           file with a '/' appended.\n\n       If this object's reference (getLocation().getRef()) is\n           not null, it must equal codesource's reference.\n\n   \n \n \n For example, the codesource objects with the following locations\n and null certificates all imply\n the codesource with the location \"http://www.example.com/classes/foo.jar\"\n and null certificates:\n      http:\n     http://*.example.com/classes/*\n     http://www.example.com/classes/-\n     http://www.example.com/classes/foo.jar\n \n\n Note that if this CodeSource has a null location and a null\n certificate chain, then it implies every other CodeSource."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this CodeSource, telling its\n URL and certificates."
                }
              ]
            }
          ]
        },
        {
          "name": "DigestException",
          "methods": [
            {
              "name": "DigestException",
              "overloads": [
                {
                  "signature": "public DigestException()",
                  "description": "Constructs a DigestException with no detail message.  (A\n detail message is a String that describes this particular\n exception.)"
                },
                {
                  "signature": "public DigestException(String msg)",
                  "description": "Constructs a DigestException with the specified detail\n message.  (A detail message is a String that describes this\n particular exception.)"
                },
                {
                  "signature": "public DigestException(String message, Throwable cause)",
                  "description": "Creates a DigestException with the specified\n detail message and cause."
                },
                {
                  "signature": "public DigestException(Throwable cause)",
                  "description": "Creates a DigestException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "DigestInputStream",
          "methods": [
            {
              "name": "DigestInputStream",
              "overloads": [
                {
                  "signature": "public DigestInputStream(InputStream stream, MessageDigest digest)",
                  "description": "Creates a digest input stream, using the specified input stream\n and message digest."
                }
              ]
            },
            {
              "name": "getMessageDigest",
              "overloads": [
                {
                  "signature": "public MessageDigest getMessageDigest()",
                  "description": "Returns the message digest associated with this stream."
                }
              ]
            },
            {
              "name": "setMessageDigest",
              "overloads": [
                {
                  "signature": "public void setMessageDigest(MessageDigest digest)",
                  "description": "Associates the specified message digest with this stream."
                }
              ]
            },
            {
              "name": "read",
              "overloads": [
                {
                  "signature": "public int read() throws IOException",
                  "description": "Reads a byte, and updates the message digest (if the digest\n function is on).  That is, this method reads a byte from the\n input stream, blocking until the byte is actually read. If the\n digest function is on (see on), this method\n will then call update on the message digest associated\n with this stream, passing it the byte read."
                },
                {
                  "signature": "public int read(byte[] b, int off, int len) throws IOException",
                  "description": "Reads into a byte array, and updates the message digest (if the\n digest function is on).  That is, this method reads up to\n len bytes from the input stream into the array\n b, starting at offset off. This method\n blocks until the data is actually\n read. If the digest function is on (see\n on), this method will then call update\n on the message digest associated with this stream, passing it\n the data."
                }
              ]
            },
            {
              "name": "on",
              "overloads": [
                {
                  "signature": "public void on(boolean on)",
                  "description": "Turns the digest function on or off. The default is on.  When\n it is on, a call to one of the read methods results in an\n update on the message digest.  But when it is off, the message\n digest is not updated."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Prints a string representation of this digest input stream and\n its associated message digest object."
                }
              ]
            }
          ]
        },
        {
          "name": "DigestOutputStream",
          "methods": [
            {
              "name": "DigestOutputStream",
              "overloads": [
                {
                  "signature": "public DigestOutputStream(OutputStream stream, MessageDigest digest)",
                  "description": "Creates a digest output stream, using the specified output stream\n and message digest."
                }
              ]
            },
            {
              "name": "getMessageDigest",
              "overloads": [
                {
                  "signature": "public MessageDigest getMessageDigest()",
                  "description": "Returns the message digest associated with this stream."
                }
              ]
            },
            {
              "name": "setMessageDigest",
              "overloads": [
                {
                  "signature": "public void setMessageDigest(MessageDigest digest)",
                  "description": "Associates the specified message digest with this stream."
                }
              ]
            },
            {
              "name": "write",
              "overloads": [
                {
                  "signature": "public void write(int b) throws IOException",
                  "description": "Updates the message digest (if the digest function is on) using\n the specified byte, and in any case writes the byte\n to the output stream. That is, if the digest function is on\n (see on), this method calls\n update on the message digest associated with this\n stream, passing it the byte b. This method then\n writes the byte to the output stream, blocking until the byte\n is actually written."
                },
                {
                  "signature": "public void write(byte[] b, int off, int len) throws IOException",
                  "description": "Updates the message digest (if the digest function is on) using\n the specified subarray, and in any case writes the subarray to\n the output stream. That is, if the digest function is on (see\n on), this method calls update\n on the message digest associated with this stream, passing it\n the subarray specifications. This method then writes the subarray\n bytes to the output stream, blocking until the bytes are actually\n written."
                }
              ]
            },
            {
              "name": "on",
              "overloads": [
                {
                  "signature": "public void on(boolean on)",
                  "description": "Turns the digest function on or off. The default is on.  When\n it is on, a call to one of the write methods results in an\n update on the message digest.  But when it is off, the message\n digest is not updated."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Prints a string representation of this digest output stream and\n its associated message digest object."
                }
              ]
            }
          ]
        },
        {
          "name": "DomainCombiner",
          "methods": [
            {
              "name": "combine",
              "overloads": [
                {
                  "signature": "ProtectionDomain[] combine(ProtectionDomain[] currentDomains, ProtectionDomain[] assignedDomains)",
                  "description": "Modify or update the provided ProtectionDomains.\n ProtectionDomains may be added to or removed from the given\n ProtectionDomains.  The ProtectionDomains may be re-ordered.\n Individual ProtectionDomains may be modified (with a new\n set of Permissions, for example).",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "DomainLoadStoreParameter",
          "methods": [
            {
              "name": "DomainLoadStoreParameter",
              "overloads": [
                {
                  "signature": "public DomainLoadStoreParameter(URI configuration, Map<String,KeyStore.ProtectionParameter> protectionParams)",
                  "description": "Constructs a DomainLoadStoreParameter for a keystore domain with\n the parameters used to protect keystore data."
                }
              ]
            },
            {
              "name": "getConfiguration",
              "overloads": [
                {
                  "signature": "public URI getConfiguration()",
                  "description": "Gets the identifier for the domain configuration data."
                }
              ]
            },
            {
              "name": "getProtectionParams",
              "overloads": [
                {
                  "signature": "public Map<String,KeyStore.ProtectionParameter> getProtectionParams()",
                  "description": "Gets the keystore protection parameters for keystores in this\n domain."
                }
              ]
            },
            {
              "name": "getProtectionParameter",
              "overloads": [
                {
                  "signature": "public KeyStore.ProtectionParameter getProtectionParameter()",
                  "description": "Gets the keystore protection parameters for this domain.\n Keystore domains do not support a protection parameter."
                }
              ]
            }
          ]
        },
        {
          "name": "DrbgParameters",
          "methods": [
            {
              "name": "instantiation",
              "overloads": [
                {
                  "signature": "public static DrbgParameters.Instantiation instantiation(int strength, DrbgParameters.Capability capability, byte[] personalizationString)",
                  "description": "Generates a DrbgParameters.Instantiation object."
                }
              ]
            },
            {
              "name": "nextBytes",
              "overloads": [
                {
                  "signature": "public static DrbgParameters.NextBytes nextBytes(int strength, boolean predictionResistance, byte[] additionalInput)",
                  "description": "Generates a DrbgParameters.NextBytes object."
                }
              ]
            },
            {
              "name": "reseed",
              "overloads": [
                {
                  "signature": "public static DrbgParameters.Reseed reseed(boolean predictionResistance, byte[] additionalInput)",
                  "description": "Generates a DrbgParameters.Reseed object."
                }
              ]
            }
          ]
        },
        {
          "name": "DrbgParameters.Instantiation",
          "methods": [
            {
              "name": "getStrength",
              "overloads": [
                {
                  "signature": "public int getStrength()",
                  "description": "Returns the security strength in bits."
                }
              ]
            },
            {
              "name": "getCapability",
              "overloads": [
                {
                  "signature": "public DrbgParameters.Capability getCapability()",
                  "description": "Returns the capability."
                }
              ]
            },
            {
              "name": "getPersonalizationString",
              "overloads": [
                {
                  "signature": "public byte[] getPersonalizationString()",
                  "description": "Returns the personalization string as a byte array."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a Human-readable string representation of this\n Instantiation."
                }
              ]
            }
          ]
        },
        {
          "name": "DrbgParameters.NextBytes",
          "methods": [
            {
              "name": "getStrength",
              "overloads": [
                {
                  "signature": "public int getStrength()",
                  "description": "Returns the security strength requested in bits."
                }
              ]
            },
            {
              "name": "getPredictionResistance",
              "overloads": [
                {
                  "signature": "public boolean getPredictionResistance()",
                  "description": "Returns whether prediction resistance is requested."
                }
              ]
            },
            {
              "name": "getAdditionalInput",
              "overloads": [
                {
                  "signature": "public byte[] getAdditionalInput()",
                  "description": "Returns the requested additional input."
                }
              ]
            }
          ]
        },
        {
          "name": "DrbgParameters.Reseed",
          "methods": [
            {
              "name": "getPredictionResistance",
              "overloads": [
                {
                  "signature": "public boolean getPredictionResistance()",
                  "description": "Returns whether prediction resistance is requested."
                }
              ]
            },
            {
              "name": "getAdditionalInput",
              "overloads": [
                {
                  "signature": "public byte[] getAdditionalInput()",
                  "description": "Returns the requested additional input."
                }
              ]
            }
          ]
        },
        {
          "name": "GeneralSecurityException",
          "methods": [
            {
              "name": "GeneralSecurityException",
              "overloads": [
                {
                  "signature": "public GeneralSecurityException()",
                  "description": "Constructs a GeneralSecurityException with no detail message."
                },
                {
                  "signature": "public GeneralSecurityException(String msg)",
                  "description": "Constructs a GeneralSecurityException with the specified detail\n message.\n A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public GeneralSecurityException(String message, Throwable cause)",
                  "description": "Creates a GeneralSecurityException with the specified\n detail message and cause."
                },
                {
                  "signature": "public GeneralSecurityException(Throwable cause)",
                  "description": "Creates a GeneralSecurityException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "Guard",
          "methods": [
            {
              "name": "checkGuard",
              "overloads": [
                {
                  "signature": "void checkGuard(Object object) throws SecurityException",
                  "description": "Determines whether or not to allow access to the guarded object\n object. Returns silently if access is allowed.\n Otherwise, throws a SecurityException."
                }
              ]
            }
          ]
        },
        {
          "name": "GuardedObject",
          "methods": [
            {
              "name": "GuardedObject",
              "overloads": [
                {
                  "signature": "public GuardedObject(Object object, Guard guard)",
                  "description": "Constructs a GuardedObject using the specified object and guard.\n If the Guard object is null, then no restrictions will\n be placed on who can access the object."
                }
              ]
            },
            {
              "name": "getObject",
              "overloads": [
                {
                  "signature": "public Object getObject() throws SecurityException",
                  "description": "Retrieves the guarded object, or throws an exception if access\n to the guarded object is denied by the guard."
                }
              ]
            }
          ]
        },
        {
          "name": "Identity",
          "methods": [
            {
              "name": "Identity",
              "overloads": [
                {
                  "signature": "protected Identity()",
                  "description": "Constructor for serialization only.",
                  "deprecated": true
                },
                {
                  "signature": "public Identity(String name, IdentityScope scope) throws KeyManagementException",
                  "description": "Constructs an identity with the specified name and scope.",
                  "deprecated": true
                },
                {
                  "signature": "public Identity(String name)",
                  "description": "Constructs an identity with the specified name and no scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns this identity's name.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getScope",
              "overloads": [
                {
                  "signature": "public final IdentityScope getScope()",
                  "description": "Returns this identity's scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPublicKey",
              "overloads": [
                {
                  "signature": "public PublicKey getPublicKey()",
                  "description": "Returns this identity's public key.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPublicKey",
              "overloads": [
                {
                  "signature": "public void setPublicKey(PublicKey key) throws KeyManagementException",
                  "description": "Sets this identity's public key. The old key and all of this\n identity's certificates are removed by this operation.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"setIdentityPublicKey\"\n as its argument to see if it's ok to set the public key.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setInfo",
              "overloads": [
                {
                  "signature": "public void setInfo(String info)",
                  "description": "Specifies a general information string for this identity.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"setIdentityInfo\"\n as its argument to see if it's ok to specify the information string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getInfo",
              "overloads": [
                {
                  "signature": "public String getInfo()",
                  "description": "Returns general information previously specified for this identity.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "addCertificate",
              "overloads": [
                {
                  "signature": "public void addCertificate(Certificate certificate) throws KeyManagementException",
                  "description": "Adds a certificate for this identity. If the identity has a public\n key, the public key in the certificate must be the same, and if\n the identity does not have a public key, the identity's\n public key is set to be that specified in the certificate.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"addIdentityCertificate\"\n as its argument to see if it's ok to add a certificate.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "removeCertificate",
              "overloads": [
                {
                  "signature": "public void removeCertificate(Certificate certificate) throws KeyManagementException",
                  "description": "Removes a certificate from this identity.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"removeIdentityCertificate\"\n as its argument to see if it's ok to remove a certificate.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "certificates",
              "overloads": [
                {
                  "signature": "public Certificate[] certificates()",
                  "description": "Returns a copy of all the certificates for this identity.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public final boolean equals(Object identity)",
                  "description": "Tests for equality between the specified object and this identity.\n This first tests to see if the entities actually refer to the same\n object, in which case it returns true. Next, it checks to see if\n the entities have the same name and the same scope. If they do,\n the method returns true. Otherwise, it calls\n identityEquals, which subclasses should\n override.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "identityEquals",
              "overloads": [
                {
                  "signature": "protected boolean identityEquals(Identity identity)",
                  "description": "Tests for equality between the specified identity and this identity.\n This method should be overridden by subclasses to test for equality.\n The default behavior is to return true if the names and public keys\n are equal.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a short string describing this identity, telling its\n name and its scope (if any).\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"printIdentity\"\n as its argument to see if it's ok to return the string.",
                  "deprecated": true
                },
                {
                  "signature": "public String toString(boolean detailed)",
                  "description": "Returns a string representation of this identity, with\n optionally more details than that provided by the\n toString method without any arguments.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"printIdentity\"\n as its argument to see if it's ok to return the string.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns a hashcode for this identity.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "IdentityScope",
          "methods": [
            {
              "name": "IdentityScope",
              "overloads": [
                {
                  "signature": "protected IdentityScope()",
                  "description": "This constructor is used for serialization only and should not\n be used by subclasses.",
                  "deprecated": true
                },
                {
                  "signature": "public IdentityScope(String name)",
                  "description": "Constructs a new identity scope with the specified name.",
                  "deprecated": true
                },
                {
                  "signature": "public IdentityScope(String name, IdentityScope scope) throws KeyManagementException",
                  "description": "Constructs a new identity scope with the specified name and scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getSystemScope",
              "overloads": [
                {
                  "signature": "public static IdentityScope getSystemScope()",
                  "description": "Returns the system's identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setSystemScope",
              "overloads": [
                {
                  "signature": "protected static void setSystemScope(IdentityScope scope)",
                  "description": "Sets the system's identity scope.\n\n First, if there is a security manager, its\n checkSecurityAccess\n method is called with \"setSystemScope\"\n as its argument to see if it's ok to set the identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public abstract int size()",
                  "description": "Returns the number of identities within this identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getIdentity",
              "overloads": [
                {
                  "signature": "public abstract Identity getIdentity(String name)",
                  "description": "Returns the identity in this scope with the specified name (if any).",
                  "deprecated": true
                },
                {
                  "signature": "public Identity getIdentity(Principal principal)",
                  "description": "Retrieves the identity whose name is the same as that of the\n specified principal. (Note: Identity implements Principal.)",
                  "deprecated": true
                },
                {
                  "signature": "public abstract Identity getIdentity(PublicKey key)",
                  "description": "Retrieves the identity with the specified public key.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "addIdentity",
              "overloads": [
                {
                  "signature": "public abstract void addIdentity(Identity identity) throws KeyManagementException",
                  "description": "Adds an identity to this identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "removeIdentity",
              "overloads": [
                {
                  "signature": "public abstract void removeIdentity(Identity identity) throws KeyManagementException",
                  "description": "Removes an identity from this identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "identities",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<Identity> identities()",
                  "description": "Returns an enumeration of all identities in this identity scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this identity scope, including\n its name, its scope name, and the number of identities in this\n identity scope.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidAlgorithmParameterException",
          "methods": [
            {
              "name": "InvalidAlgorithmParameterException",
              "overloads": [
                {
                  "signature": "public InvalidAlgorithmParameterException()",
                  "description": "Constructs an InvalidAlgorithmParameterException with no detail\n message.\n A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public InvalidAlgorithmParameterException(String msg)",
                  "description": "Constructs an InvalidAlgorithmParameterException with the specified\n detail message.\n A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public InvalidAlgorithmParameterException(String message, Throwable cause)",
                  "description": "Creates an InvalidAlgorithmParameterException with the\n specified detail message and cause."
                },
                {
                  "signature": "public InvalidAlgorithmParameterException(Throwable cause)",
                  "description": "Creates an InvalidAlgorithmParameterException with the\n specified cause and a detail message of\n (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidKeyException",
          "methods": [
            {
              "name": "InvalidKeyException",
              "overloads": [
                {
                  "signature": "public InvalidKeyException()",
                  "description": "Constructs an InvalidKeyException with no detail message. A\n detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public InvalidKeyException(String msg)",
                  "description": "Constructs an InvalidKeyException with the specified detail\n message. A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public InvalidKeyException(String message, Throwable cause)",
                  "description": "Creates an InvalidKeyException with the specified\n detail message and cause."
                },
                {
                  "signature": "public InvalidKeyException(Throwable cause)",
                  "description": "Creates an InvalidKeyException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "InvalidParameterException",
          "methods": [
            {
              "name": "InvalidParameterException",
              "overloads": [
                {
                  "signature": "public InvalidParameterException()",
                  "description": "Constructs an InvalidParameterException with no detail message.\n A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public InvalidParameterException(String msg)",
                  "description": "Constructs an InvalidParameterException with the specified\n detail message.  A detail message is a String that describes\n this particular exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Key",
          "methods": [
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "String getAlgorithm()",
                  "description": "Returns the standard algorithm name for this key. For\n example, \"DSA\" would indicate that this key is a DSA key.\n See the key related sections (KeyFactory, KeyGenerator,\n KeyPairGenerator, and SecretKeyFactory) in the \n Java Security Standard Algorithm Names Specification\n for information about standard key algorithm names."
                }
              ]
            },
            {
              "name": "getFormat",
              "overloads": [
                {
                  "signature": "String getFormat()",
                  "description": "Returns the name of the primary encoding format of this key,\n or null if this key does not support encoding.\n The primary encoding format is\n named in terms of the appropriate ASN.1 data format, if an\n ASN.1 specification for this key exists.\n For example, the name of the ASN.1 data format for public\n keys is SubjectPublicKeyInfo, as\n defined by the X.509 standard; in this case, the returned format is\n \"X.509\". Similarly,\n the name of the ASN.1 data format for private keys is\n PrivateKeyInfo,\n as defined by the PKCS #8 standard; in this case, the returned format is\n \"PKCS#8\"."
                }
              ]
            },
            {
              "name": "getEncoded",
              "overloads": [
                {
                  "signature": "byte[] getEncoded()",
                  "description": "Returns the key in its primary encoding format, or null\n if this key does not support encoding."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyException",
          "methods": [
            {
              "name": "KeyException",
              "overloads": [
                {
                  "signature": "public KeyException()",
                  "description": "Constructs a KeyException with no detail message. A detail\n message is a String that describes this particular exception."
                },
                {
                  "signature": "public KeyException(String msg)",
                  "description": "Constructs a KeyException with the specified detail message.\n A detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public KeyException(String message, Throwable cause)",
                  "description": "Creates a KeyException with the specified\n detail message and cause."
                },
                {
                  "signature": "public KeyException(Throwable cause)",
                  "description": "Creates a KeyException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyFactory",
          "methods": [
            {
              "name": "KeyFactory",
              "overloads": [
                {
                  "signature": "protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider, String algorithm)",
                  "description": "Creates a KeyFactory object."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static KeyFactory getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new KeyFactory object encapsulating the\n KeyFactorySpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyFactory getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.\n\n  A new KeyFactory object encapsulating the\n KeyFactorySpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyFactory getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.\n\n  A new KeyFactory object encapsulating the\n KeyFactorySpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this key factory object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Gets the name of the algorithm\n associated with this KeyFactory."
                }
              ]
            },
            {
              "name": "generatePublic",
              "overloads": [
                {
                  "signature": "public final PublicKey generatePublic(KeySpec keySpec) throws InvalidKeySpecException",
                  "description": "Generates a public key object from the provided key specification\n (key material)."
                }
              ]
            },
            {
              "name": "generatePrivate",
              "overloads": [
                {
                  "signature": "public final PrivateKey generatePrivate(KeySpec keySpec) throws InvalidKeySpecException",
                  "description": "Generates a private key object from the provided key specification\n (key material)."
                }
              ]
            },
            {
              "name": "getKeySpec",
              "overloads": [
                {
                  "signature": "public final <T extends KeySpec> T getKeySpec(Key key, Class<T> keySpec) throws InvalidKeySpecException",
                  "description": "Returns a specification (key material) of the given key object.\n keySpec identifies the specification class in which\n the key material should be returned. It could, for example, be\n DSAPublicKeySpec.class, to indicate that the\n key material should be returned in an instance of the\n DSAPublicKeySpec class."
                }
              ]
            },
            {
              "name": "translateKey",
              "overloads": [
                {
                  "signature": "public final Key translateKey(Key key) throws InvalidKeyException",
                  "description": "Translates a key object, whose provider may be unknown or potentially\n untrusted, into a corresponding key object of this key factory."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyFactorySpi",
          "methods": [
            {
              "name": "KeyFactorySpi",
              "overloads": [
                {
                  "signature": "public KeyFactorySpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineGeneratePublic",
              "overloads": [
                {
                  "signature": "protected abstract PublicKey engineGeneratePublic(KeySpec keySpec) throws InvalidKeySpecException",
                  "description": "Generates a public key object from the provided key\n specification (key material)."
                }
              ]
            },
            {
              "name": "engineGeneratePrivate",
              "overloads": [
                {
                  "signature": "protected abstract PrivateKey engineGeneratePrivate(KeySpec keySpec) throws InvalidKeySpecException",
                  "description": "Generates a private key object from the provided key\n specification (key material)."
                }
              ]
            },
            {
              "name": "engineGetKeySpec",
              "overloads": [
                {
                  "signature": "protected abstract <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec) throws InvalidKeySpecException",
                  "description": "Returns a specification (key material) of the given key\n object.\n keySpec identifies the specification class in which\n the key material should be returned. It could, for example, be\n DSAPublicKeySpec.class, to indicate that the\n key material should be returned in an instance of the\n DSAPublicKeySpec class."
                }
              ]
            },
            {
              "name": "engineTranslateKey",
              "overloads": [
                {
                  "signature": "protected abstract Key engineTranslateKey(Key key) throws InvalidKeyException",
                  "description": "Translates a key object, whose provider may be unknown or\n potentially untrusted, into a corresponding key object of this key\n factory."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyManagementException",
          "methods": [
            {
              "name": "KeyManagementException",
              "overloads": [
                {
                  "signature": "public KeyManagementException()",
                  "description": "Constructs a KeyManagementException with no detail message. A\n detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public KeyManagementException(String msg)",
                  "description": "Constructs a KeyManagementException with the specified detail\n message. A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public KeyManagementException(String message, Throwable cause)",
                  "description": "Creates a KeyManagementException with the specified\n detail message and cause."
                },
                {
                  "signature": "public KeyManagementException(Throwable cause)",
                  "description": "Creates a KeyManagementException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyPair",
          "methods": [
            {
              "name": "KeyPair",
              "overloads": [
                {
                  "signature": "public KeyPair(PublicKey publicKey, PrivateKey privateKey)",
                  "description": "Constructs a key pair from the given public key and private key.\n\n Note that this constructor only stores references to the public\n and private key components in the generated key pair. This is safe,\n because Key objects are immutable."
                }
              ]
            },
            {
              "name": "getPublic",
              "overloads": [
                {
                  "signature": "public PublicKey getPublic()",
                  "description": "Returns a reference to the public key component of this key pair."
                }
              ]
            },
            {
              "name": "getPrivate",
              "overloads": [
                {
                  "signature": "public PrivateKey getPrivate()",
                  "description": "Returns a reference to the private key component of this key pair."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyPairGenerator",
          "methods": [
            {
              "name": "KeyPairGenerator",
              "overloads": [
                {
                  "signature": "protected KeyPairGenerator(String algorithm)",
                  "description": "Creates a KeyPairGenerator object for the specified algorithm."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public String getAlgorithm()",
                  "description": "Returns the standard name of the algorithm for this key pair generator.\n See the KeyPairGenerator section in the \n Java Security Standard Algorithm Names Specification\n for information about standard algorithm names."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static KeyPairGenerator getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a KeyPairGenerator object that generates public/private\n key pairs for the specified algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new KeyPairGenerator object encapsulating the\n KeyPairGeneratorSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyPairGenerator getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a KeyPairGenerator object that generates public/private\n key pairs for the specified algorithm.\n\n  A new KeyPairGenerator object encapsulating the\n KeyPairGeneratorSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyPairGenerator getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a KeyPairGenerator object that generates public/private\n key pairs for the specified algorithm.\n\n  A new KeyPairGenerator object encapsulating the\n KeyPairGeneratorSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this key pair generator object."
                }
              ]
            },
            {
              "name": "initialize",
              "overloads": [
                {
                  "signature": "public void initialize(int keysize)",
                  "description": "Initializes the key pair generator for a certain keysize using\n a default parameter set and the SecureRandom\n implementation of the highest-priority installed provider as the source\n of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)"
                },
                {
                  "signature": "public void initialize(int keysize, SecureRandom random)",
                  "description": "Initializes the key pair generator for a certain keysize with\n the given source of randomness (and a default parameter set)."
                },
                {
                  "signature": "public void initialize(AlgorithmParameterSpec params) throws InvalidAlgorithmParameterException",
                  "description": "Initializes the key pair generator using the specified parameter\n set and the SecureRandom\n implementation of the highest-priority installed provider as the source\n of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness is\n used.)\n\n This concrete method has been added to this previously-defined\n abstract class.\n This method calls the KeyPairGeneratorSpi\n initialize method,\n passing it params and a source of randomness (obtained\n from the highest-priority installed provider or system-provided if none\n of the installed providers supply one).\n That initialize method always throws an\n UnsupportedOperationException if it is not overridden by the provider."
                },
                {
                  "signature": "public void initialize(AlgorithmParameterSpec params, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes the key pair generator with the given parameter\n set and source of randomness.\n\n This concrete method has been added to this previously-defined\n abstract class.\n This method calls the KeyPairGeneratorSpi initialize method,\n passing it params and random.\n That initialize\n method always throws an\n UnsupportedOperationException if it is not overridden by the provider."
                }
              ]
            },
            {
              "name": "genKeyPair",
              "overloads": [
                {
                  "signature": "public final KeyPair genKeyPair()",
                  "description": "Generates a key pair.\n\n If this KeyPairGenerator has not been initialized explicitly,\n provider-specific defaults will be used for the size and other\n (algorithm-specific) values of the generated keys.\n\n This will generate a new key pair every time it is called.\n\n This method is functionally equivalent to\n generateKeyPair."
                }
              ]
            },
            {
              "name": "generateKeyPair",
              "overloads": [
                {
                  "signature": "public KeyPair generateKeyPair()",
                  "description": "Generates a key pair.\n\n If this KeyPairGenerator has not been initialized explicitly,\n provider-specific defaults will be used for the size and other\n (algorithm-specific) values of the generated keys.\n\n This will generate a new key pair every time it is called.\n\n This method is functionally equivalent to\n genKeyPair."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyPairGeneratorSpi",
          "methods": [
            {
              "name": "KeyPairGeneratorSpi",
              "overloads": [
                {
                  "signature": "public KeyPairGeneratorSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "initialize",
              "overloads": [
                {
                  "signature": "public abstract void initialize(int keysize, SecureRandom random)",
                  "description": "Initializes the key pair generator for a certain keysize, using\n the default parameter set."
                },
                {
                  "signature": "public void initialize(AlgorithmParameterSpec params, SecureRandom random) throws InvalidAlgorithmParameterException",
                  "description": "Initializes the key pair generator using the specified parameter\n set and user-provided source of randomness.\n\n This concrete method has been added to this previously-defined\n abstract class. (For backwards compatibility, it cannot be abstract.)\n It may be overridden by a provider to initialize the key pair\n generator. Such an override\n is expected to throw an InvalidAlgorithmParameterException if\n a parameter is inappropriate for this key pair generator.\n If this method is not overridden, it always throws an\n UnsupportedOperationException."
                }
              ]
            },
            {
              "name": "generateKeyPair",
              "overloads": [
                {
                  "signature": "public abstract KeyPair generateKeyPair()",
                  "description": "Generates a key pair. Unless an initialization method is called\n using a KeyPairGenerator interface, algorithm-specific defaults\n will be used. This will generate a new key pair every time it\n is called."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyRep",
          "methods": [
            {
              "name": "KeyRep",
              "overloads": [
                {
                  "signature": "public KeyRep(KeyRep.Type type, String algorithm, String format, byte[] encoded)",
                  "description": "Construct the alternate Key class."
                }
              ]
            },
            {
              "name": "readResolve",
              "overloads": [
                {
                  "signature": "protected Object readResolve() throws ObjectStreamException",
                  "description": "Resolve the Key object.\n\n  This method supports three Type/format combinations:\n \n  Type.SECRET/\"RAW\" - returns a SecretKeySpec object\n constructed using encoded key bytes and algorithm\n  Type.PUBLIC/\"X.509\" - gets a KeyFactory instance for\n the key algorithm, constructs an X509EncodedKeySpec with the\n encoded key bytes, and generates a public key from the spec\n  Type.PRIVATE/\"PKCS#8\" - gets a KeyFactory instance for\n the key algorithm, constructs a PKCS8EncodedKeySpec with the\n encoded key bytes, and generates a private key from the spec"
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore",
          "methods": [
            {
              "name": "KeyStore",
              "overloads": [
                {
                  "signature": "protected KeyStore(KeyStoreSpi keyStoreSpi, Provider provider, String type)",
                  "description": "Creates a KeyStore object of the given type, and encapsulates the given\n provider implementation (SPI object) in it."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static KeyStore getInstance(String type) throws KeyStoreException",
                  "description": "Returns a keystore object of the specified type.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new KeyStore object encapsulating the\n KeyStoreSpi implementation from the first\n Provider that supports the specified type is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyStore getInstance(String type, String provider) throws KeyStoreException, NoSuchProviderException",
                  "description": "Returns a keystore object of the specified type.\n\n  A new KeyStore object encapsulating the\n KeyStoreSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static KeyStore getInstance(String type, Provider provider) throws KeyStoreException",
                  "description": "Returns a keystore object of the specified type.\n\n  A new KeyStore object encapsulating the\n KeyStoreSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                },
                {
                  "signature": "public static final KeyStore getInstance(File file, char[] password) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Returns a loaded keystore object of the appropriate keystore type.\n First the keystore type is determined by probing the specified file.\n Then a keystore object is instantiated and loaded using the data from\n that file.\n\n \n A password may be given to unlock the keystore\n (e.g. the keystore resides on a hardware token device),\n or to check the integrity of the keystore data.\n If a password is not given for integrity checking,\n then integrity checking is not performed.\n\n \n This method traverses the list of registered security\n providers, starting with the most\n preferred Provider.\n For each KeyStoreSpi implementation supported by a\n Provider, it invokes the engineProbe method to\n determine if it supports the specified keystore.\n A new KeyStore object is returned that encapsulates the KeyStoreSpi\n implementation from the first Provider that supports the specified file.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static final KeyStore getInstance(File file, KeyStore.LoadStoreParameter param) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Returns a loaded keystore object of the appropriate keystore type.\n First the keystore type is determined by probing the specified file.\n Then a keystore object is instantiated and loaded using the data from\n that file.\n A LoadStoreParameter may be supplied which specifies how to\n unlock the keystore data or perform an integrity check.\n\n \n This method traverses the list of registered security providers, starting with the most preferred Provider.\n For each KeyStoreSpi implementation supported by a\n Provider, it invokes the engineProbe method to\n determine if it supports the specified keystore.\n A new KeyStore object is returned that encapsulates the KeyStoreSpi\n implementation from the first Provider that supports the specified file.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                }
              ]
            },
            {
              "name": "getDefaultType",
              "overloads": [
                {
                  "signature": "public static final String getDefaultType()",
                  "description": "Returns the default keystore type as specified by the\n keystore.type security property, or the string\n \"jks\" (acronym for \"Java keystore\")\n if no such property exists.\n\n The default keystore type can be used by applications that do not\n want to use a hard-coded keystore type when calling one of the\n getInstance methods, and want to provide a default keystore\n type in case a user does not specify its own.\n\n The default keystore type can be changed by setting the value of the\n keystore.type security property to the desired keystore type."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this keystore."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public final String getType()",
                  "description": "Returns the type of this keystore."
                }
              ]
            },
            {
              "name": "getKey",
              "overloads": [
                {
                  "signature": "public final Key getKey(String alias, char[] password) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException",
                  "description": "Returns the key associated with the given alias, using the given\n password to recover it.  The key must have been associated with\n the alias by a call to setKeyEntry,\n or by a call to setEntry with a\n PrivateKeyEntry or SecretKeyEntry."
                }
              ]
            },
            {
              "name": "getCertificateChain",
              "overloads": [
                {
                  "signature": "public final Certificate[] getCertificateChain(String alias) throws KeyStoreException",
                  "description": "Returns the certificate chain associated with the given alias.\n The certificate chain must have been associated with the alias\n by a call to setKeyEntry,\n or by a call to setEntry with a\n PrivateKeyEntry."
                }
              ]
            },
            {
              "name": "getCertificate",
              "overloads": [
                {
                  "signature": "public final Certificate getCertificate(String alias) throws KeyStoreException",
                  "description": "Returns the certificate associated with the given alias.\n\n  If the given alias name identifies an entry\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n then the trusted certificate contained in that entry is returned.\n\n  If the given alias name identifies an entry\n created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry,\n then the first element of the certificate chain in that entry\n is returned."
                }
              ]
            },
            {
              "name": "getCreationDate",
              "overloads": [
                {
                  "signature": "public final Date getCreationDate(String alias) throws KeyStoreException",
                  "description": "Returns the creation date of the entry identified by the given alias."
                }
              ]
            },
            {
              "name": "setKeyEntry",
              "overloads": [
                {
                  "signature": "public final void setKeyEntry(String alias, Key key, char[] password, Certificate[] chain) throws KeyStoreException",
                  "description": "Assigns the given key to the given alias, protecting it with the given\n password.\n\n If the given key is of type java.security.PrivateKey,\n it must be accompanied by a certificate chain certifying the\n corresponding public key.\n\n If the given alias already exists, the keystore information\n associated with it is overridden by the given key (and possibly\n certificate chain)."
                },
                {
                  "signature": "public final void setKeyEntry(String alias, byte[] key, Certificate[] chain) throws KeyStoreException",
                  "description": "Assigns the given key (that has already been protected) to the given\n alias.\n\n If the protected key is of type\n java.security.PrivateKey, it must be accompanied by a\n certificate chain certifying the corresponding public key. If the\n underlying keystore implementation is of type jks,\n key must be encoded as an\n EncryptedPrivateKeyInfo as defined in the PKCS #8 standard.\n\n If the given alias already exists, the keystore information\n associated with it is overridden by the given key (and possibly\n certificate chain)."
                }
              ]
            },
            {
              "name": "setCertificateEntry",
              "overloads": [
                {
                  "signature": "public final void setCertificateEntry(String alias, Certificate cert) throws KeyStoreException",
                  "description": "Assigns the given trusted certificate to the given alias.\n\n  If the given alias identifies an existing entry\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n the trusted certificate in the existing entry\n is overridden by the given certificate."
                }
              ]
            },
            {
              "name": "deleteEntry",
              "overloads": [
                {
                  "signature": "public final void deleteEntry(String alias) throws KeyStoreException",
                  "description": "Deletes the entry identified by the given alias from this keystore."
                }
              ]
            },
            {
              "name": "aliases",
              "overloads": [
                {
                  "signature": "public final Enumeration<String> aliases() throws KeyStoreException",
                  "description": "Lists all the alias names of this keystore."
                }
              ]
            },
            {
              "name": "containsAlias",
              "overloads": [
                {
                  "signature": "public final boolean containsAlias(String alias) throws KeyStoreException",
                  "description": "Checks if the given alias exists in this keystore."
                }
              ]
            },
            {
              "name": "size",
              "overloads": [
                {
                  "signature": "public final int size() throws KeyStoreException",
                  "description": "Retrieves the number of entries in this keystore."
                }
              ]
            },
            {
              "name": "isKeyEntry",
              "overloads": [
                {
                  "signature": "public final boolean isKeyEntry(String alias) throws KeyStoreException",
                  "description": "Returns true if the entry identified by the given alias\n was created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry or a SecretKeyEntry."
                }
              ]
            },
            {
              "name": "isCertificateEntry",
              "overloads": [
                {
                  "signature": "public final boolean isCertificateEntry(String alias) throws KeyStoreException",
                  "description": "Returns true if the entry identified by the given alias\n was created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry."
                }
              ]
            },
            {
              "name": "getCertificateAlias",
              "overloads": [
                {
                  "signature": "public final String getCertificateAlias(Certificate cert) throws KeyStoreException",
                  "description": "Returns the (alias) name of the first keystore entry whose certificate\n matches the given certificate.\n\n  This method attempts to match the given certificate with each\n keystore entry. If the entry being considered was\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n then the given certificate is compared to that entry's certificate.\n\n  If the entry being considered was\n created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry,\n then the given certificate is compared to the first\n element of that entry's certificate chain."
                }
              ]
            },
            {
              "name": "store",
              "overloads": [
                {
                  "signature": "public final void store(OutputStream stream, char[] password) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Stores this keystore to the given output stream, and protects its\n integrity with the given password."
                },
                {
                  "signature": "public final void store(KeyStore.LoadStoreParameter param) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Stores this keystore using the given LoadStoreParameter."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public final void load(InputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Loads this KeyStore from the given input stream.\n\n A password may be given to unlock the keystore\n (e.g. the keystore resides on a hardware token device),\n or to check the integrity of the keystore data.\n If a password is not given for integrity checking,\n then integrity checking is not performed.\n\n In order to create an empty keystore, or if the keystore cannot\n be initialized from a stream, pass null\n as the stream argument.\n\n  Note that if this keystore has already been loaded, it is\n reinitialized and loaded again from the given input stream."
                },
                {
                  "signature": "public final void load(KeyStore.LoadStoreParameter param) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Loads this keystore using the given LoadStoreParameter.\n\n  Note that if this KeyStore has already been loaded, it is\n reinitialized and loaded again from the given parameter."
                }
              ]
            },
            {
              "name": "getEntry",
              "overloads": [
                {
                  "signature": "public final KeyStore.Entry getEntry(String alias, KeyStore.ProtectionParameter protParam) throws NoSuchAlgorithmException, UnrecoverableEntryException, KeyStoreException",
                  "description": "Gets a keystore Entry for the specified alias\n with the specified protection parameter."
                }
              ]
            },
            {
              "name": "setEntry",
              "overloads": [
                {
                  "signature": "public final void setEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException",
                  "description": "Saves a keystore Entry under the specified alias.\n The protection parameter is used to protect the\n Entry.\n\n  If an entry already exists for the specified alias,\n it is overridden."
                }
              ]
            },
            {
              "name": "entryInstanceOf",
              "overloads": [
                {
                  "signature": "public final boolean entryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) throws KeyStoreException",
                  "description": "Determines if the keystore Entry for the specified\n alias is an instance or subclass of the specified\n entryClass."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.Builder",
          "methods": [
            {
              "name": "Builder",
              "overloads": [
                {
                  "signature": "protected Builder()",
                  "description": "Construct a new Builder."
                }
              ]
            },
            {
              "name": "getKeyStore",
              "overloads": [
                {
                  "signature": "public abstract KeyStore getKeyStore() throws KeyStoreException",
                  "description": "Returns the KeyStore described by this object."
                }
              ]
            },
            {
              "name": "getProtectionParameter",
              "overloads": [
                {
                  "signature": "public abstract KeyStore.ProtectionParameter getProtectionParameter(String alias) throws KeyStoreException",
                  "description": "Returns the ProtectionParameters that should be used to obtain\n the Entry with the given alias.\n The getKeyStore method must be invoked before this\n method may be called."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "public static KeyStore.Builder newInstance(KeyStore keyStore, KeyStore.ProtectionParameter protectionParameter)",
                  "description": "Returns a new Builder that encapsulates the given KeyStore.\n The getKeyStore() method of the returned object\n will return keyStore, the getProtectionParameter() method will\n return protectionParameters.\n\n  This is useful if an existing KeyStore object needs to be\n used with Builder-based APIs."
                },
                {
                  "signature": "public static KeyStore.Builder newInstance(String type, Provider provider, File file, KeyStore.ProtectionParameter protection)",
                  "description": "Returns a new Builder object.\n\n The first call to the getKeyStore() method on the returned\n builder will create a KeyStore of type type and call\n its load() method.\n The inputStream argument is constructed from\n file.\n If protection is a\n PasswordProtection, the password is obtained by\n calling the getPassword method.\n Otherwise, if protection is a\n CallbackHandlerProtection, the password is obtained\n by invoking the CallbackHandler.\n\n Subsequent calls to getKeyStore() return the same object\n as the initial call. If the initial call failed with a\n KeyStoreException, subsequent calls also throw a\n KeyStoreException.\n\n The KeyStore is instantiated from provider if\n non-null. Otherwise, all installed providers are searched.\n\n Calls to getProtectionParameter()\n will return a PasswordProtection\n object encapsulating the password that was used to invoke the\n load method.\n\n Note that the getKeyStore() method is executed\n within the AccessControlContext of the code invoking this\n method."
                },
                {
                  "signature": "public static KeyStore.Builder newInstance(File file, KeyStore.ProtectionParameter protection)",
                  "description": "Returns a new Builder object.\n\n The first call to the getKeyStore() method on the returned\n builder will create a KeyStore using file to detect the\n keystore type and then call its load() method.\n It uses the same algorithm to determine the keystore type as\n described in KeyStore.getInstance(File, LoadStoreParameter).\n The inputStream argument is constructed from file.\n If protection is a PasswordProtection, the password\n is obtained by calling the getPassword method.\n Otherwise, if protection is a\n CallbackHandlerProtection,\n the password is obtained by invoking the CallbackHandler.\n\n Subsequent calls to getKeyStore() return the same object\n as the initial call. If the initial call failed with a\n KeyStoreException, subsequent calls also throw a KeyStoreException.\n\n Calls to getProtectionParameter()\n will return a PasswordProtection\n object encapsulating the password that was used to invoke the\n load method.\n\n Note that the getKeyStore() method is executed\n within the AccessControlContext of the code invoking this\n method."
                },
                {
                  "signature": "public static KeyStore.Builder newInstance(String type, Provider provider, KeyStore.ProtectionParameter protection)",
                  "description": "Returns a new Builder object.\n\n Each call to the getKeyStore() method on the returned\n builder will return a new KeyStore object of type type.\n Its load()\n method is invoked using a\n LoadStoreParameter that encapsulates\n protection.\n\n The KeyStore is instantiated from provider if\n non-null. Otherwise, all installed providers are searched.\n\n Calls to getProtectionParameter()\n will return protection.\n\n Note that the getKeyStore() method is executed\n within the AccessControlContext of the code invoking this\n method."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.CallbackHandlerProtection",
          "methods": [
            {
              "name": "CallbackHandlerProtection",
              "overloads": [
                {
                  "signature": "public CallbackHandlerProtection(CallbackHandler handler)",
                  "description": "Constructs a new CallbackHandlerProtection from a\n CallbackHandler."
                }
              ]
            },
            {
              "name": "getCallbackHandler",
              "overloads": [
                {
                  "signature": "public CallbackHandler getCallbackHandler()",
                  "description": "Returns the CallbackHandler."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.Entry",
          "methods": [
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "default Set<KeyStore.Entry.Attribute> getAttributes()",
                  "description": "Retrieves the attributes associated with an entry."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.Entry.Attribute",
          "methods": [
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "String getName()",
                  "description": "Returns the attribute's name."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "String getValue()",
                  "description": "Returns the attribute's value.\n Multi-valued attributes encode their values as a single string."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.LoadStoreParameter",
          "methods": [
            {
              "name": "getProtectionParameter",
              "overloads": [
                {
                  "signature": "KeyStore.ProtectionParameter getProtectionParameter()",
                  "description": "Gets the parameter used to protect keystore data."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.PasswordProtection",
          "methods": [
            {
              "name": "PasswordProtection",
              "overloads": [
                {
                  "signature": "public PasswordProtection(char[] password)",
                  "description": "Creates a password parameter.\n\n  The specified password is cloned before it is stored\n in the new PasswordProtection object."
                },
                {
                  "signature": "public PasswordProtection(char[] password, String protectionAlgorithm, AlgorithmParameterSpec protectionParameters)",
                  "description": "Creates a password parameter and specifies the protection algorithm\n and associated parameters to use when encrypting a keystore entry.\n \n The specified password is cloned before it is stored in the\n new PasswordProtection object."
                }
              ]
            },
            {
              "name": "getProtectionAlgorithm",
              "overloads": [
                {
                  "signature": "public String getProtectionAlgorithm()",
                  "description": "Gets the name of the protection algorithm.\n If none was set then the keystore provider will use its default\n protection algorithm."
                }
              ]
            },
            {
              "name": "getProtectionParameters",
              "overloads": [
                {
                  "signature": "public AlgorithmParameterSpec getProtectionParameters()",
                  "description": "Gets the parameters supplied for the protection algorithm."
                }
              ]
            },
            {
              "name": "getPassword",
              "overloads": [
                {
                  "signature": "public char[] getPassword()",
                  "description": "Gets the password.\n\n Note that this method returns a reference to the password.\n If a clone of the array is created it is the caller's\n responsibility to zero out the password information\n after it is no longer needed."
                }
              ]
            },
            {
              "name": "destroy",
              "overloads": [
                {
                  "signature": "public void destroy() throws DestroyFailedException",
                  "description": "Clears the password."
                }
              ]
            },
            {
              "name": "isDestroyed",
              "overloads": [
                {
                  "signature": "public boolean isDestroyed()",
                  "description": "Determines if password has been cleared."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.PrivateKeyEntry",
          "methods": [
            {
              "name": "PrivateKeyEntry",
              "overloads": [
                {
                  "signature": "public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain)",
                  "description": "Constructs a PrivateKeyEntry with a\n PrivateKey and corresponding certificate chain.\n\n  The specified chain is cloned before it is stored\n in the new PrivateKeyEntry object."
                },
                {
                  "signature": "public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain, Set<KeyStore.Entry.Attribute> attributes)",
                  "description": "Constructs a PrivateKeyEntry with a PrivateKey and\n corresponding certificate chain and associated entry attributes.\n\n  The specified chain and attributes are cloned\n before they are stored in the new PrivateKeyEntry object."
                }
              ]
            },
            {
              "name": "getPrivateKey",
              "overloads": [
                {
                  "signature": "public PrivateKey getPrivateKey()",
                  "description": "Gets the PrivateKey from this entry."
                }
              ]
            },
            {
              "name": "getCertificateChain",
              "overloads": [
                {
                  "signature": "public Certificate[] getCertificateChain()",
                  "description": "Gets the Certificate chain from this entry.\n\n  The stored chain is cloned before being returned."
                }
              ]
            },
            {
              "name": "getCertificate",
              "overloads": [
                {
                  "signature": "public Certificate getCertificate()",
                  "description": "Gets the end entity Certificate\n from the certificate chain in this entry."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "public Set<KeyStore.Entry.Attribute> getAttributes()",
                  "description": "Retrieves the attributes associated with an entry."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this PrivateKeyEntry."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.ProtectionParameter",
          "methods": []
        },
        {
          "name": "KeyStore.SecretKeyEntry",
          "methods": [
            {
              "name": "SecretKeyEntry",
              "overloads": [
                {
                  "signature": "public SecretKeyEntry(SecretKey secretKey)",
                  "description": "Constructs a SecretKeyEntry with a\n SecretKey."
                },
                {
                  "signature": "public SecretKeyEntry(SecretKey secretKey, Set<KeyStore.Entry.Attribute> attributes)",
                  "description": "Constructs a SecretKeyEntry with a SecretKey and\n associated entry attributes.\n\n  The specified attributes is cloned before it is stored\n in the new SecretKeyEntry object."
                }
              ]
            },
            {
              "name": "getSecretKey",
              "overloads": [
                {
                  "signature": "public SecretKey getSecretKey()",
                  "description": "Gets the SecretKey from this entry."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "public Set<KeyStore.Entry.Attribute> getAttributes()",
                  "description": "Retrieves the attributes associated with an entry."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this SecretKeyEntry."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStore.TrustedCertificateEntry",
          "methods": [
            {
              "name": "TrustedCertificateEntry",
              "overloads": [
                {
                  "signature": "public TrustedCertificateEntry(Certificate trustedCert)",
                  "description": "Constructs a TrustedCertificateEntry with a\n trusted Certificate."
                },
                {
                  "signature": "public TrustedCertificateEntry(Certificate trustedCert, Set<KeyStore.Entry.Attribute> attributes)",
                  "description": "Constructs a TrustedCertificateEntry with a\n trusted Certificate and associated entry attributes.\n\n  The specified attributes is cloned before it is stored\n in the new TrustedCertificateEntry object."
                }
              ]
            },
            {
              "name": "getTrustedCertificate",
              "overloads": [
                {
                  "signature": "public Certificate getTrustedCertificate()",
                  "description": "Gets the trusted Certficate from this entry."
                }
              ]
            },
            {
              "name": "getAttributes",
              "overloads": [
                {
                  "signature": "public Set<KeyStore.Entry.Attribute> getAttributes()",
                  "description": "Retrieves the attributes associated with an entry."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this TrustedCertificateEntry."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStoreException",
          "methods": [
            {
              "name": "KeyStoreException",
              "overloads": [
                {
                  "signature": "public KeyStoreException()",
                  "description": "Constructs a KeyStoreException with no detail message.  (A\n detail message is a String that describes this particular\n exception.)"
                },
                {
                  "signature": "public KeyStoreException(String msg)",
                  "description": "Constructs a KeyStoreException with the specified detail\n message.  (A detail message is a String that describes this\n particular exception.)"
                },
                {
                  "signature": "public KeyStoreException(String message, Throwable cause)",
                  "description": "Creates a KeyStoreException with the specified\n detail message and cause."
                },
                {
                  "signature": "public KeyStoreException(Throwable cause)",
                  "description": "Creates a KeyStoreException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "KeyStoreSpi",
          "methods": [
            {
              "name": "KeyStoreSpi",
              "overloads": [
                {
                  "signature": "public KeyStoreSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineGetKey",
              "overloads": [
                {
                  "signature": "public abstract Key engineGetKey(String alias, char[] password) throws NoSuchAlgorithmException, UnrecoverableKeyException",
                  "description": "Returns the key associated with the given alias, using the given\n password to recover it.  The key must have been associated with\n the alias by a call to setKeyEntry,\n or by a call to setEntry with a\n PrivateKeyEntry or SecretKeyEntry."
                }
              ]
            },
            {
              "name": "engineGetCertificateChain",
              "overloads": [
                {
                  "signature": "public abstract Certificate[] engineGetCertificateChain(String alias)",
                  "description": "Returns the certificate chain associated with the given alias.\n The certificate chain must have been associated with the alias\n by a call to setKeyEntry,\n or by a call to setEntry with a\n PrivateKeyEntry."
                }
              ]
            },
            {
              "name": "engineGetCertificate",
              "overloads": [
                {
                  "signature": "public abstract Certificate engineGetCertificate(String alias)",
                  "description": "Returns the certificate associated with the given alias.\n\n  If the given alias name identifies an entry\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n then the trusted certificate contained in that entry is returned.\n\n  If the given alias name identifies an entry\n created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry,\n then the first element of the certificate chain in that entry\n (if a chain exists) is returned."
                }
              ]
            },
            {
              "name": "engineGetCreationDate",
              "overloads": [
                {
                  "signature": "public abstract Date engineGetCreationDate(String alias)",
                  "description": "Returns the creation date of the entry identified by the given alias."
                }
              ]
            },
            {
              "name": "engineSetKeyEntry",
              "overloads": [
                {
                  "signature": "public abstract void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) throws KeyStoreException",
                  "description": "Assigns the given key to the given alias, protecting it with the given\n password.\n\n If the given key is of type java.security.PrivateKey,\n it must be accompanied by a certificate chain certifying the\n corresponding public key.\n\n If the given alias already exists, the keystore information\n associated with it is overridden by the given key (and possibly\n certificate chain)."
                },
                {
                  "signature": "public abstract void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) throws KeyStoreException",
                  "description": "Assigns the given key (that has already been protected) to the given\n alias.\n\n If the protected key is of type\n java.security.PrivateKey,\n it must be accompanied by a certificate chain certifying the\n corresponding public key.\n\n If the given alias already exists, the keystore information\n associated with it is overridden by the given key (and possibly\n certificate chain)."
                }
              ]
            },
            {
              "name": "engineSetCertificateEntry",
              "overloads": [
                {
                  "signature": "public abstract void engineSetCertificateEntry(String alias, Certificate cert) throws KeyStoreException",
                  "description": "Assigns the given certificate to the given alias.\n\n  If the given alias identifies an existing entry\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n the trusted certificate in the existing entry\n is overridden by the given certificate."
                }
              ]
            },
            {
              "name": "engineDeleteEntry",
              "overloads": [
                {
                  "signature": "public abstract void engineDeleteEntry(String alias) throws KeyStoreException",
                  "description": "Deletes the entry identified by the given alias from this keystore."
                }
              ]
            },
            {
              "name": "engineAliases",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<String> engineAliases()",
                  "description": "Lists all the alias names of this keystore."
                }
              ]
            },
            {
              "name": "engineContainsAlias",
              "overloads": [
                {
                  "signature": "public abstract boolean engineContainsAlias(String alias)",
                  "description": "Checks if the given alias exists in this keystore."
                }
              ]
            },
            {
              "name": "engineSize",
              "overloads": [
                {
                  "signature": "public abstract int engineSize()",
                  "description": "Retrieves the number of entries in this keystore."
                }
              ]
            },
            {
              "name": "engineIsKeyEntry",
              "overloads": [
                {
                  "signature": "public abstract boolean engineIsKeyEntry(String alias)",
                  "description": "Returns true if the entry identified by the given alias\n was created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry or a SecretKeyEntry."
                }
              ]
            },
            {
              "name": "engineIsCertificateEntry",
              "overloads": [
                {
                  "signature": "public abstract boolean engineIsCertificateEntry(String alias)",
                  "description": "Returns true if the entry identified by the given alias\n was created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry."
                }
              ]
            },
            {
              "name": "engineGetCertificateAlias",
              "overloads": [
                {
                  "signature": "public abstract String engineGetCertificateAlias(Certificate cert)",
                  "description": "Returns the (alias) name of the first keystore entry whose certificate\n matches the given certificate.\n\n This method attempts to match the given certificate with each\n keystore entry. If the entry being considered was\n created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry,\n then the given certificate is compared to that entry's certificate.\n\n  If the entry being considered was\n created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry,\n then the given certificate is compared to the first\n element of that entry's certificate chain."
                }
              ]
            },
            {
              "name": "engineStore",
              "overloads": [
                {
                  "signature": "public abstract void engineStore(OutputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Stores this keystore to the given output stream, and protects its\n integrity with the given password."
                },
                {
                  "signature": "public void engineStore(KeyStore.LoadStoreParameter param) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Stores this keystore using the given\n KeyStore.LoadStoreParameter."
                }
              ]
            },
            {
              "name": "engineLoad",
              "overloads": [
                {
                  "signature": "public abstract void engineLoad(InputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Loads the keystore from the given input stream.\n\n A password may be given to unlock the keystore\n (e.g. the keystore resides on a hardware token device),\n or to check the integrity of the keystore data.\n If a password is not given for integrity checking,\n then integrity checking is not performed."
                },
                {
                  "signature": "public void engineLoad(KeyStore.LoadStoreParameter param) throws IOException, NoSuchAlgorithmException, CertificateException",
                  "description": "Loads the keystore using the given\n KeyStore.LoadStoreParameter.\n\n  Note that if this KeyStore has already been loaded, it is\n reinitialized and loaded again from the given parameter."
                }
              ]
            },
            {
              "name": "engineGetEntry",
              "overloads": [
                {
                  "signature": "public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException",
                  "description": "Gets a KeyStore.Entry for the specified alias\n with the specified protection parameter."
                }
              ]
            },
            {
              "name": "engineSetEntry",
              "overloads": [
                {
                  "signature": "public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException",
                  "description": "Saves a KeyStore.Entry under the specified alias.\n The specified protection parameter is used to protect the\n Entry.\n\n  If an entry already exists for the specified alias,\n it is overridden."
                }
              ]
            },
            {
              "name": "engineEntryInstanceOf",
              "overloads": [
                {
                  "signature": "public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass)",
                  "description": "Determines if the keystore Entry for the specified\n alias is an instance or subclass of the specified\n entryClass."
                }
              ]
            },
            {
              "name": "engineProbe",
              "overloads": [
                {
                  "signature": "public boolean engineProbe(InputStream stream) throws IOException",
                  "description": "Probes the specified input stream to determine whether it contains a\n keystore that is supported by this implementation, or not."
                }
              ]
            }
          ]
        },
        {
          "name": "MessageDigest",
          "methods": [
            {
              "name": "MessageDigest",
              "overloads": [
                {
                  "signature": "protected MessageDigest(String algorithm)",
                  "description": "Creates a message digest with the specified algorithm name."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static MessageDigest getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a MessageDigest object that implements the specified digest\n algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new MessageDigest object encapsulating the\n MessageDigestSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static MessageDigest getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a MessageDigest object that implements the specified digest\n algorithm.\n\n  A new MessageDigest object encapsulating the\n MessageDigestSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static MessageDigest getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a MessageDigest object that implements the specified digest\n algorithm.\n\n  A new MessageDigest object encapsulating the\n MessageDigestSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this message digest object."
                }
              ]
            },
            {
              "name": "update",
              "overloads": [
                {
                  "signature": "public void update(byte input)",
                  "description": "Updates the digest using the specified byte."
                },
                {
                  "signature": "public void update(byte[] input, int offset, int len)",
                  "description": "Updates the digest using the specified array of bytes, starting\n at the specified offset."
                },
                {
                  "signature": "public void update(byte[] input)",
                  "description": "Updates the digest using the specified array of bytes."
                },
                {
                  "signature": "public final void update(ByteBuffer input)",
                  "description": "Update the digest using the specified ByteBuffer. The digest is\n updated using the input.remaining() bytes starting\n at input.position().\n Upon return, the buffer's position will be equal to its limit;\n its limit will not have changed."
                }
              ]
            },
            {
              "name": "digest",
              "overloads": [
                {
                  "signature": "public byte[] digest()",
                  "description": "Completes the hash computation by performing final operations\n such as padding. The digest is reset after this call is made."
                },
                {
                  "signature": "public int digest(byte[] buf, int offset, int len) throws DigestException",
                  "description": "Completes the hash computation by performing final operations\n such as padding. The digest is reset after this call is made."
                },
                {
                  "signature": "public byte[] digest(byte[] input)",
                  "description": "Performs a final update on the digest using the specified array\n of bytes, then completes the digest computation. That is, this\n method first calls update(input),\n passing the input array to the update method,\n then calls digest()."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this message digest object."
                }
              ]
            },
            {
              "name": "isEqual",
              "overloads": [
                {
                  "signature": "public static boolean isEqual(byte[] digesta, byte[] digestb)",
                  "description": "Compares two digests for equality. Two digests are equal if they have\n the same length and all bytes at corresponding positions are equal."
                }
              ]
            },
            {
              "name": "reset",
              "overloads": [
                {
                  "signature": "public void reset()",
                  "description": "Resets the digest for further use."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns a string that identifies the algorithm, independent of\n implementation details. The name should be a standard\n Java Security name (such as \"SHA-256\").\n See the MessageDigest section in the \n Java Security Standard Algorithm Names Specification\n for information about standard algorithm names."
                }
              ]
            },
            {
              "name": "getDigestLength",
              "overloads": [
                {
                  "signature": "public final int getDigestLength()",
                  "description": "Returns the length of the digest in bytes, or 0 if this operation is\n not supported by the provider and the implementation is not cloneable."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone() throws CloneNotSupportedException",
                  "description": "Returns a clone if the implementation is cloneable."
                }
              ]
            }
          ]
        },
        {
          "name": "MessageDigestSpi",
          "methods": [
            {
              "name": "MessageDigestSpi",
              "overloads": [
                {
                  "signature": "public MessageDigestSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineGetDigestLength",
              "overloads": [
                {
                  "signature": "protected int engineGetDigestLength()",
                  "description": "Returns the digest length in bytes.\n\n This concrete method has been added to this previously-defined\n abstract class. (For backwards compatibility, it cannot be abstract.)\n\n The default behavior is to return 0.\n\n This method may be overridden by a provider to return the digest\n length."
                }
              ]
            },
            {
              "name": "engineUpdate",
              "overloads": [
                {
                  "signature": "protected abstract void engineUpdate(byte input)",
                  "description": "Updates the digest using the specified byte."
                },
                {
                  "signature": "protected abstract void engineUpdate(byte[] input, int offset, int len)",
                  "description": "Updates the digest using the specified array of bytes,\n starting at the specified offset."
                },
                {
                  "signature": "protected void engineUpdate(ByteBuffer input)",
                  "description": "Update the digest using the specified ByteBuffer. The digest is\n updated using the input.remaining() bytes starting\n at input.position().\n Upon return, the buffer's position will be equal to its limit;\n its limit will not have changed."
                }
              ]
            },
            {
              "name": "engineDigest",
              "overloads": [
                {
                  "signature": "protected abstract byte[] engineDigest()",
                  "description": "Completes the hash computation by performing final\n operations such as padding. Once engineDigest has\n been called, the engine should be reset (see\n engineReset).\n Resetting is the responsibility of the\n engine implementor."
                },
                {
                  "signature": "protected int engineDigest(byte[] buf, int offset, int len) throws DigestException",
                  "description": "Completes the hash computation by performing final\n operations such as padding. Once engineDigest has\n been called, the engine should be reset (see\n engineReset).\n Resetting is the responsibility of the\n engine implementor.\n\n This method should be abstract, but we leave it concrete for\n binary compatibility.  Knowledgeable providers should override this\n method."
                }
              ]
            },
            {
              "name": "engineReset",
              "overloads": [
                {
                  "signature": "protected abstract void engineReset()",
                  "description": "Resets the digest for further use."
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone() throws CloneNotSupportedException",
                  "description": "Returns a clone if the implementation is cloneable."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchAlgorithmException",
          "methods": [
            {
              "name": "NoSuchAlgorithmException",
              "overloads": [
                {
                  "signature": "public NoSuchAlgorithmException()",
                  "description": "Constructs a NoSuchAlgorithmException with no detail\n message. A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public NoSuchAlgorithmException(String msg)",
                  "description": "Constructs a NoSuchAlgorithmException with the specified\n detail message. A detail message is a String that describes\n this particular exception, which may, for example, specify which\n algorithm is not available."
                },
                {
                  "signature": "public NoSuchAlgorithmException(String message, Throwable cause)",
                  "description": "Creates a NoSuchAlgorithmException with the specified\n detail message and cause."
                },
                {
                  "signature": "public NoSuchAlgorithmException(Throwable cause)",
                  "description": "Creates a NoSuchAlgorithmException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "NoSuchProviderException",
          "methods": [
            {
              "name": "NoSuchProviderException",
              "overloads": [
                {
                  "signature": "public NoSuchProviderException()",
                  "description": "Constructs a NoSuchProviderException with no detail message. A\n detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public NoSuchProviderException(String msg)",
                  "description": "Constructs a NoSuchProviderException with the specified detail\n message. A detail message is a String that describes this\n particular exception."
                }
              ]
            }
          ]
        },
        {
          "name": "Permission",
          "methods": [
            {
              "name": "Permission",
              "overloads": [
                {
                  "signature": "public Permission(String name)",
                  "description": "Constructs a permission with the specified name."
                }
              ]
            },
            {
              "name": "checkGuard",
              "overloads": [
                {
                  "signature": "public void checkGuard(Object object) throws SecurityException",
                  "description": "Implements the guard interface for a permission. The\n SecurityManager.checkPermission method is called,\n passing this permission object as the permission to check.\n Returns silently if access is granted. Otherwise, throws\n a SecurityException."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public abstract boolean implies(Permission permission)",
                  "description": "Checks if the specified permission's actions are \"implied by\"\n this object's actions.\n \n This must be implemented by subclasses of Permission, as they are the\n only ones that can impose semantics on a Permission object.\n\n The implies method is used by the AccessController to determine\n whether or not a requested permission is implied by another permission that\n is known to be valid in the current execution context."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public abstract boolean equals(Object obj)",
                  "description": "Checks two Permission objects for equality.\n \n Do not use the equals method for making access control\n decisions; use the implies method."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public abstract int hashCode()",
                  "description": "Returns the hash code value for this Permission object.\n \n The required hashCode behavior for Permission Objects is\n the following:\n \n Whenever it is invoked on the same Permission object more than\n     once during an execution of a Java application, the\n     hashCode method\n     must consistently return the same integer. This integer need not\n     remain consistent from one execution of an application to another\n     execution of the same application.\n If two Permission objects are equal according to the\n     equals\n     method, then calling the hashCode method on each of the\n     two Permission objects must produce the same integer result."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public final String getName()",
                  "description": "Returns the name of this Permission.\n For example, in the case of a java.io.FilePermission,\n the name will be a pathname."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public abstract String getActions()",
                  "description": "Returns the actions as a String. This is abstract\n so subclasses can defer creating a String representation until\n one is needed. Subclasses should always return actions in what they\n consider to be their\n canonical form. For example, two FilePermission objects created via\n the following:\n\n    perm1 = new FilePermission(p1,\"read,write\");\n   perm2 = new FilePermission(p2,\"write,read\");\n \n\n both return\n \"read,write\" when the getActions method is invoked."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns an empty PermissionCollection for a given Permission object, or null if\n one is not defined. Subclasses of class Permission should\n override this if they need to store their permissions in a particular\n PermissionCollection object in order to provide the correct semantics\n when the PermissionCollection.implies method is called.\n If null is returned,\n then the caller of this method is free to store permissions of this\n type in any PermissionCollection they choose (one that uses a Hashtable,\n one that uses a Vector, etc)."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this Permission.  The convention is to\n specify the class name, the permission name, and the actions in\n the following format: '(\"ClassName\" \"name\" \"actions\")', or\n '(\"ClassName\" \"name\")' if actions list is null or empty."
                }
              ]
            }
          ]
        },
        {
          "name": "PermissionCollection",
          "methods": [
            {
              "name": "PermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public abstract void add(Permission permission)",
                  "description": "Adds a permission object to the current collection of permission objects."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public abstract boolean implies(Permission permission)",
                  "description": "Checks to see if the specified permission is implied by\n the collection of Permission objects held in this PermissionCollection."
                }
              ]
            },
            {
              "name": "elements",
              "overloads": [
                {
                  "signature": "public abstract Enumeration<Permission> elements()",
                  "description": "Returns an enumeration of all the Permission objects in the collection."
                }
              ]
            },
            {
              "name": "elementsAsStream",
              "overloads": [
                {
                  "signature": "public Stream<Permission> elementsAsStream()",
                  "description": "Returns a stream of all the Permission objects in the collection.\n\n  The collection should not be modified (see add(java.security.Permission)) during the\n execution of the terminal stream operation. Otherwise, the result of the\n terminal stream operation is undefined."
                }
              ]
            },
            {
              "name": "setReadOnly",
              "overloads": [
                {
                  "signature": "public void setReadOnly()",
                  "description": "Marks this PermissionCollection object as \"readonly\". After\n a PermissionCollection object\n is marked as readonly, no new Permission objects can be added to it\n using add."
                }
              ]
            },
            {
              "name": "isReadOnly",
              "overloads": [
                {
                  "signature": "public boolean isReadOnly()",
                  "description": "Returns true if this PermissionCollection object is marked as readonly.\n If it is readonly, no new Permission objects can be added to it\n using add.\n\n By default, the object is not readonly. It can be set to\n readonly by a call to setReadOnly."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this PermissionCollection object,\n providing information about all the permissions it contains.\n The format is:\n  super.toString() (\n   // enumerate all the Permission\n   // objects and call toString() on them,\n   // one per line..\n )\n\n super.toString is a call to the toString\n method of this\n object's superclass, which is Object. The result is\n this PermissionCollection's type name followed by this object's\n hashcode, thus enabling clients to differentiate different\n PermissionCollections object, even if they contain the same permissions."
                }
              ]
            }
          ]
        },
        {
          "name": "Permissions",
          "methods": [
            {
              "name": "Permissions",
              "overloads": [
                {
                  "signature": "public Permissions()",
                  "description": "Creates a new Permissions object containing no PermissionCollections."
                }
              ]
            },
            {
              "name": "add",
              "overloads": [
                {
                  "signature": "public void add(Permission permission)",
                  "description": "Adds a permission object to the PermissionCollection for the class the\n permission belongs to. For example, if permission is a\n FilePermission, it is added to the FilePermissionCollection stored\n in this Permissions object.\n\n This method creates\n a new PermissionCollection object (and adds the permission to it)\n if an appropriate collection does not yet exist."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission permission)",
                  "description": "Checks to see if this object's PermissionCollection for permissions of\n the specified permission's class implies the permissions\n expressed in the permission object. Returns true if the\n combination of permissions in the appropriate PermissionCollection\n (e.g., a FilePermissionCollection for a FilePermission) together\n imply the specified permission.\n\n For example, suppose there is a FilePermissionCollection in this\n Permissions object, and it contains one FilePermission that specifies\n \"read\" access for  all files in all subdirectories of the \"/tmp\"\n directory, and another FilePermission that specifies \"write\" access\n for all files in the \"/tmp/scratch/foo\" directory.\n Then if the implies method\n is called with a permission specifying both \"read\" and \"write\" access\n to files in the \"/tmp/scratch/foo\" directory, true is\n returned.\n\n Additionally, if this PermissionCollection contains the\n AllPermission, this method will always return true."
                }
              ]
            },
            {
              "name": "elements",
              "overloads": [
                {
                  "signature": "public Enumeration<Permission> elements()",
                  "description": "Returns an enumeration of all the Permission objects in all the\n PermissionCollections in this Permissions object."
                }
              ]
            }
          ]
        },
        {
          "name": "PKCS12Attribute",
          "methods": [
            {
              "name": "PKCS12Attribute",
              "overloads": [
                {
                  "signature": "public PKCS12Attribute(String name, String value)",
                  "description": "Constructs a PKCS12 attribute from its name and value.\n The name is an ASN.1 Object Identifier represented as a list of\n dot-separated integers.\n A string value is represented as the string itself.\n A binary value is represented as a string of colon-separated\n pairs of hexadecimal digits.\n Multi-valued attributes are represented as a comma-separated\n list of values, enclosed in square brackets. See\n Arrays.toString(java.lang.Object[]).\n \n A string value will be DER-encoded as an ASN.1 UTF8String and a\n binary value will be DER-encoded as an ASN.1 Octet String."
                },
                {
                  "signature": "public PKCS12Attribute(byte[] encoded)",
                  "description": "Constructs a PKCS12 attribute from its ASN.1 DER encoding.\n The DER encoding is specified by the following ASN.1 definition:\n \n Attribute ::= SEQUENCE {\n     type   AttributeType,\n     values SET OF AttributeValue\n }\n AttributeType ::= OBJECT IDENTIFIER\n AttributeValue ::= ANY defined by type"
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the attribute's ASN.1 Object Identifier represented as a\n list of dot-separated integers."
                }
              ]
            },
            {
              "name": "getValue",
              "overloads": [
                {
                  "signature": "public String getValue()",
                  "description": "Returns the attribute's ASN.1 DER-encoded value as a string.\n An ASN.1 DER-encoded value is returned in one of the following\n String formats:\n \n  the DER encoding of a basic ASN.1 type that has a natural\n      string representation is returned as the string itself.\n      Such types are currently limited to BOOLEAN, INTEGER,\n      OBJECT IDENTIFIER, UTCTime, GeneralizedTime and the\n      following six ASN.1 string types: UTF8String,\n      PrintableString, T61String, IA5String, BMPString and\n      GeneralString.\n  the DER encoding of any other ASN.1 type is not decoded but\n      returned as a binary string of colon-separated pairs of\n      hexadecimal digits.\n \n Multi-valued attributes are represented as a comma-separated\n list of values, enclosed in square brackets. See\n Arrays.toString(java.lang.Object[])."
                }
              ]
            },
            {
              "name": "getEncoded",
              "overloads": [
                {
                  "signature": "public byte[] getEncoded()",
                  "description": "Returns the attribute's ASN.1 DER encoding."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Compares this PKCS12Attribute and a specified object for\n equality."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hashcode for this PKCS12Attribute.\n The hash code is computed from its DER encoding."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this PKCS12Attribute."
                }
              ]
            }
          ]
        },
        {
          "name": "Policy",
          "methods": [
            {
              "name": "Policy",
              "overloads": [
                {
                  "signature": "public Policy()",
                  "description": "Constructor for subclasses to call.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPolicy",
              "overloads": [
                {
                  "signature": "public static Policy getPolicy()",
                  "description": "Returns the installed Policy object. This value should not be cached,\n as it may be changed by a call to setPolicy.\n This method first calls\n SecurityManager.checkPermission with a\n SecurityPermission(\"getPolicy\") permission\n to ensure it's ok to get the Policy object.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setPolicy",
              "overloads": [
                {
                  "signature": "public static void setPolicy(Policy p)",
                  "description": "Sets the system-wide Policy object. This method first calls\n SecurityManager.checkPermission with a\n SecurityPermission(\"setPolicy\")\n permission to ensure it's ok to set the Policy.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Policy getInstance(String type, Policy.Parameters params) throws NoSuchAlgorithmException",
                  "description": "Returns a Policy object of the specified type.\n\n  This method traverses the list of registered security providers,\n starting with the most preferred Provider.\n A new Policy object encapsulating the\n PolicySpi implementation from the first\n Provider that supports the specified type is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.",
                  "deprecated": true
                },
                {
                  "signature": "public static Policy getInstance(String type, Policy.Parameters params, String provider) throws NoSuchProviderException, NoSuchAlgorithmException",
                  "description": "Returns a Policy object of the specified type.\n\n  A new Policy object encapsulating the\n PolicySpi implementation from the specified provider\n is returned.   The specified provider must be registered\n in the provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.",
                  "deprecated": true
                },
                {
                  "signature": "public static Policy getInstance(String type, Policy.Parameters params, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a Policy object of the specified type.\n\n  A new Policy object encapsulating the\n PolicySpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public Provider getProvider()",
                  "description": "Return the Provider of this Policy.\n\n  This Policy instance will only have a Provider if it\n was obtained via a call to Policy.getInstance.\n Otherwise this method returns null.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public String getType()",
                  "description": "Return the type of this Policy.\n\n  This Policy instance will only have a type if it\n was obtained via a call to Policy.getInstance.\n Otherwise this method returns null.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getParameters",
              "overloads": [
                {
                  "signature": "public Policy.Parameters getParameters()",
                  "description": "Return Policy parameters.\n\n  This Policy instance will only have parameters if it\n was obtained via a call to Policy.getInstance.\n Otherwise this method returns null.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPermissions",
              "overloads": [
                {
                  "signature": "public PermissionCollection getPermissions(CodeSource codesource)",
                  "description": "Return a PermissionCollection object containing the set of\n permissions granted to the specified CodeSource.\n\n  Applications are discouraged from calling this method\n since this operation may not be supported by all policy implementations.\n Applications should solely rely on the implies method\n to perform policy checks.  If an application absolutely must call\n a getPermissions method, it should call\n getPermissions(ProtectionDomain).\n\n  The default implementation of this method returns\n Policy.UNSUPPORTED_EMPTY_COLLECTION.  This method can be\n overridden if the policy implementation can return a set of\n permissions granted to a CodeSource.",
                  "deprecated": true
                },
                {
                  "signature": "public PermissionCollection getPermissions(ProtectionDomain domain)",
                  "description": "Return a PermissionCollection object containing the set of\n permissions granted to the specified ProtectionDomain.\n\n  Applications are discouraged from calling this method\n since this operation may not be supported by all policy implementations.\n Applications should rely on the implies method\n to perform policy checks.\n\n  The default implementation of this method first retrieves\n the permissions returned via getPermissions(CodeSource)\n (the CodeSource is taken from the specified ProtectionDomain),\n as well as the permissions located inside the specified ProtectionDomain.\n All of these permissions are then combined and returned in a new\n PermissionCollection object.  If getPermissions(CodeSource)\n returns Policy.UNSUPPORTED_EMPTY_COLLECTION, then this method\n returns the permissions contained inside the specified ProtectionDomain\n in a new PermissionCollection object.\n\n  This method can be overridden if the policy implementation\n supports returning a set of permissions granted to a ProtectionDomain.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(ProtectionDomain domain, Permission permission)",
                  "description": "Evaluates the global policy for the permissions granted to\n the ProtectionDomain and tests whether the permission is\n granted.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "refresh",
              "overloads": [
                {
                  "signature": "public void refresh()",
                  "description": "Refreshes/reloads the policy configuration. The behavior of this method\n depends on the implementation. For example, calling refresh\n on a file-based policy will cause the file to be re-read.\n\n  The default implementation of this method does nothing.\n This method should be overridden if a refresh operation is supported\n by the policy implementation.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Policy.Parameters",
          "methods": []
        },
        {
          "name": "PolicySpi",
          "methods": [
            {
              "name": "PolicySpi",
              "overloads": [
                {
                  "signature": "public PolicySpi()",
                  "description": "Constructor for subclasses to call.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "engineImplies",
              "overloads": [
                {
                  "signature": "protected abstract boolean engineImplies(ProtectionDomain domain, Permission permission)",
                  "description": "Check whether the policy has granted a Permission to a ProtectionDomain.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "engineRefresh",
              "overloads": [
                {
                  "signature": "protected void engineRefresh()",
                  "description": "Refreshes/reloads the policy configuration. The behavior of this method\n depends on the implementation. For example, calling refresh\n on a file-based policy will cause the file to be re-read.\n\n  The default implementation of this method does nothing.\n This method should be overridden if a refresh operation is supported\n by the policy implementation.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "engineGetPermissions",
              "overloads": [
                {
                  "signature": "protected PermissionCollection engineGetPermissions(CodeSource codesource)",
                  "description": "Return a PermissionCollection object containing the set of\n permissions granted to the specified CodeSource.\n\n  The default implementation of this method returns\n Policy.UNSUPPORTED_EMPTY_COLLECTION object.  This method can be\n overridden if the policy implementation can return a set of\n permissions granted to a CodeSource.",
                  "deprecated": true
                },
                {
                  "signature": "protected PermissionCollection engineGetPermissions(ProtectionDomain domain)",
                  "description": "Return a PermissionCollection object containing the set of\n permissions granted to the specified ProtectionDomain.\n\n  The default implementation of this method returns\n Policy.UNSUPPORTED_EMPTY_COLLECTION object.  This method can be\n overridden if the policy implementation can return a set of\n permissions granted to a ProtectionDomain.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Principal",
          "methods": [
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "boolean equals(Object another)",
                  "description": "Compares this principal to the specified object.  Returns true\n if the object passed in matches the principal represented by\n the implementation of this interface."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "String toString()",
                  "description": "Returns a string representation of this principal."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "int hashCode()",
                  "description": "Returns a hashcode for this principal."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "String getName()",
                  "description": "Returns the name of this principal."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "default boolean implies(Subject subject)",
                  "description": "Returns true if the specified subject is implied by this principal."
                }
              ]
            }
          ]
        },
        {
          "name": "PrivateKey",
          "methods": []
        },
        {
          "name": "PrivilegedAction<T>",
          "methods": [
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "T run()",
                  "description": "Performs the computation.  This method will be called by\n AccessController.doPrivileged after enabling privileges."
                }
              ]
            }
          ]
        },
        {
          "name": "PrivilegedActionException",
          "methods": [
            {
              "name": "PrivilegedActionException",
              "overloads": [
                {
                  "signature": "public PrivilegedActionException(Exception exception)",
                  "description": "Constructs a new PrivilegedActionException \"wrapping\"\n the specific Exception."
                }
              ]
            },
            {
              "name": "getException",
              "overloads": [
                {
                  "signature": "public Exception getException()",
                  "description": "Returns the exception thrown by the privileged computation that\n resulted in this PrivilegedActionException."
                }
              ]
            }
          ]
        },
        {
          "name": "PrivilegedExceptionAction<T>",
          "methods": [
            {
              "name": "run",
              "overloads": [
                {
                  "signature": "T run() throws Exception",
                  "description": "Performs the computation.  This method will be called by\n AccessController.doPrivileged after enabling privileges."
                }
              ]
            }
          ]
        },
        {
          "name": "ProtectionDomain",
          "methods": [
            {
              "name": "ProtectionDomain",
              "overloads": [
                {
                  "signature": "public ProtectionDomain(CodeSource codesource, PermissionCollection permissions)",
                  "description": "Creates a new ProtectionDomain with the given CodeSource and\n Permissions. If the permissions object is not null, then\n  setReadOnly() will be called on the passed in\n Permissions object.\n \n The permissions granted to this domain are static, i.e.\n invoking the staticPermissionsOnly() method returns true.\n They contain only the ones passed to this constructor and\n the current Policy will not be consulted."
                },
                {
                  "signature": "public ProtectionDomain(CodeSource codesource, PermissionCollection permissions, ClassLoader classloader, Principal[] principals)",
                  "description": "Creates a new ProtectionDomain qualified by the given CodeSource,\n Permissions, ClassLoader and array of Principals. If the\n permissions object is not null, then setReadOnly()\n will be called on the passed in Permissions object.\n \n The permissions granted to this domain are dynamic, i.e.\n invoking the staticPermissionsOnly() method returns false.\n They include both the static permissions passed to this constructor,\n and any permissions granted to this domain by the current Policy at the\n time a permission is checked.\n \n This constructor is typically used by\n ClassLoaders\n and DomainCombiners which delegate to\n Policy to actively associate the permissions granted to\n this domain. This constructor affords the\n Policy provider the opportunity to augment the supplied\n PermissionCollection to reflect policy changes."
                }
              ]
            },
            {
              "name": "getCodeSource",
              "overloads": [
                {
                  "signature": "public final CodeSource getCodeSource()",
                  "description": "Returns the CodeSource of this domain."
                }
              ]
            },
            {
              "name": "getClassLoader",
              "overloads": [
                {
                  "signature": "public final ClassLoader getClassLoader()",
                  "description": "Returns the ClassLoader of this domain."
                }
              ]
            },
            {
              "name": "getPrincipals",
              "overloads": [
                {
                  "signature": "public final Principal[] getPrincipals()",
                  "description": "Returns an array of principals for this domain."
                }
              ]
            },
            {
              "name": "getPermissions",
              "overloads": [
                {
                  "signature": "public final PermissionCollection getPermissions()",
                  "description": "Returns the static permissions granted to this domain."
                }
              ]
            },
            {
              "name": "staticPermissionsOnly",
              "overloads": [
                {
                  "signature": "public final boolean staticPermissionsOnly()",
                  "description": "Returns true if this domain contains only static permissions\n and does not check the current Policy at the time of\n permission checking."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission perm)",
                  "description": "Check and see if this ProtectionDomain implies the permissions\n expressed in the Permission object.\n \n The set of permissions evaluated is a function of whether the\n ProtectionDomain was constructed with a static set of permissions\n or it was bound to a dynamically mapped set of permissions.\n \n If the staticPermissionsOnly() method returns\n true, then the permission will only be checked against the\n PermissionCollection supplied at construction.\n \n Otherwise, the permission will be checked against the combination\n of the PermissionCollection supplied at construction and\n the current Policy binding."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Convert a ProtectionDomain to a String."
                }
              ]
            }
          ]
        },
        {
          "name": "Provider",
          "methods": [
            {
              "name": "Provider",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") protected Provider(String name, double version, String info)",
                  "description": "Constructs a provider with the specified name, version number,\n and information. Calling this constructor is equivalent to call the\n Provider(String, String, String) with name\n name, Double.toString(version), and info.",
                  "deprecated": true
                },
                {
                  "signature": "protected Provider(String name, String versionStr, String info)",
                  "description": "Constructs a provider with the specified name, version string,\n and information.\n\n The version string contains a version number optionally followed\n by other information separated by one of the characters of '+', '-'.\n\n The format for the version number is:\n\n      ^[0-9]+(\\.[0-9]+)*\n \n\n In order to return the version number in a double, when there are\n more than two components (separated by '.' as defined above), only\n the first two components are retained. The resulting string is then\n passed to Double.valueOf(String) to generate version number,\n i.e. getVersion().\n If the conversion failed, value 0 will be used."
                }
              ]
            },
            {
              "name": "configure",
              "overloads": [
                {
                  "signature": "public Provider configure(String configArg)",
                  "description": "Apply the supplied configuration argument to this provider instance\n and return the configured provider. Note that if this provider cannot\n be configured in-place, a new provider will be created and returned.\n Therefore, callers should always use the returned provider."
                }
              ]
            },
            {
              "name": "isConfigured",
              "overloads": [
                {
                  "signature": "public boolean isConfigured()",
                  "description": "Check if this provider instance has been configured."
                }
              ]
            },
            {
              "name": "getName",
              "overloads": [
                {
                  "signature": "public String getName()",
                  "description": "Returns the name of this provider."
                }
              ]
            },
            {
              "name": "getVersion",
              "overloads": [
                {
                  "signature": "@Deprecated(since=\"9\") public double getVersion()",
                  "description": "Returns the version number for this provider.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getVersionStr",
              "overloads": [
                {
                  "signature": "public String getVersionStr()",
                  "description": "Returns the version string for this provider."
                }
              ]
            },
            {
              "name": "getInfo",
              "overloads": [
                {
                  "signature": "public String getInfo()",
                  "description": "Returns a human-readable description of the provider and its\n services.  This may return an HTML page, with relevant links."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string with the name and the version string\n of this provider."
                }
              ]
            },
            {
              "name": "clear",
              "overloads": [
                {
                  "signature": "public void clear()",
                  "description": "Clears this provider so that it no longer contains the properties\n used to look up facilities implemented by the provider.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"clearProviderProperties.\"+name\n (where name is the provider name) to see if it's ok to clear\n this provider."
                }
              ]
            },
            {
              "name": "load",
              "overloads": [
                {
                  "signature": "public void load(InputStream inStream) throws IOException",
                  "description": "Reads a property list (key and element pairs) from the input stream."
                }
              ]
            },
            {
              "name": "putAll",
              "overloads": [
                {
                  "signature": "public void putAll(Map<?,?> t)",
                  "description": "Copies all of the mappings from the specified Map to this provider.\n These mappings will replace any properties that this provider had\n for any of the keys currently in the specified Map."
                }
              ]
            },
            {
              "name": "entrySet",
              "overloads": [
                {
                  "signature": "public Set<Map.Entry<Object,Object>> entrySet()",
                  "description": "Returns an unmodifiable Set view of the property entries contained\n in this Provider."
                }
              ]
            },
            {
              "name": "keySet",
              "overloads": [
                {
                  "signature": "public Set<Object> keySet()",
                  "description": "Returns an unmodifiable Set view of the property keys contained in\n this provider."
                }
              ]
            },
            {
              "name": "values",
              "overloads": [
                {
                  "signature": "public Collection<Object> values()",
                  "description": "Returns an unmodifiable Collection view of the property values\n contained in this provider."
                }
              ]
            },
            {
              "name": "put",
              "overloads": [
                {
                  "signature": "public Object put(Object key, Object value)",
                  "description": "Sets the key property to have the specified\n value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "putIfAbsent",
              "overloads": [
                {
                  "signature": "public Object putIfAbsent(Object key, Object value)",
                  "description": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "remove",
              "overloads": [
                {
                  "signature": "public Object remove(Object key)",
                  "description": "Removes the key property (and its corresponding\n value).\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"removeProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to remove this\n provider's properties."
                },
                {
                  "signature": "public boolean remove(Object key, Object value)",
                  "description": "Removes the entry for the specified key only if it is currently\n mapped to the specified value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"removeProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to remove this\n provider's properties."
                }
              ]
            },
            {
              "name": "replace",
              "overloads": [
                {
                  "signature": "public boolean replace(Object key, Object oldValue, Object newValue)",
                  "description": "Replaces the entry for the specified key only if currently\n mapped to the specified value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                },
                {
                  "signature": "public Object replace(Object key, Object value)",
                  "description": "Replaces the entry for the specified key only if it is\n currently mapped to some value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "replaceAll",
              "overloads": [
                {
                  "signature": "public void replaceAll(BiFunction<? super Object,? super Object,? extends Object> function)",
                  "description": "Replaces each entry's value with the result of invoking the given\n function on that entry, in the order entries are returned by an entry\n set iterator, until all entries have been processed or the function\n throws an exception.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the string \"putProviderProperty.\"+name,\n where name is the provider name, to see if it's ok to set this\n provider's property values."
                }
              ]
            },
            {
              "name": "compute",
              "overloads": [
                {
                  "signature": "public Object compute(Object key, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "Attempts to compute a mapping for the specified key and its\n current mapped value (or null if there is no current\n mapping).\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "computeIfAbsent",
              "overloads": [
                {
                  "signature": "public Object computeIfAbsent(Object key, Function<? super Object,? extends Object> mappingFunction)",
                  "description": "If the specified key is not already associated with a value (or\n is mapped to null), attempts to compute its value using\n the given mapping function and enters it into this map unless\n null.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "computeIfPresent",
              "overloads": [
                {
                  "signature": "public Object computeIfPresent(Object key, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "merge",
              "overloads": [
                {
                  "signature": "public Object merge(Object key, Object value, BiFunction<? super Object,? super Object,? extends Object> remappingFunction)",
                  "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given value. Otherwise,\n replaces the value with the results of the given remapping function,\n or removes if the result is null. This method may be of use when\n combining multiple mapped values for a key.\n\n If a security manager is enabled, its checkSecurityAccess\n method is called with the strings \"putProviderProperty.\"+name\n and \"removeProviderProperty.\"+name, where name is the\n provider name, to see if it's ok to set this provider's property values\n and remove this provider's properties."
                }
              ]
            },
            {
              "name": "getOrDefault",
              "overloads": [
                {
                  "signature": "public Object getOrDefault(Object key, Object defaultValue)",
                  "description": "Description copied from interface:Map"
                }
              ]
            },
            {
              "name": "forEach",
              "overloads": [
                {
                  "signature": "public void forEach(BiConsumer<? super Object,? super Object> action)",
                  "description": "Description copied from interface:Map"
                }
              ]
            },
            {
              "name": "getService",
              "overloads": [
                {
                  "signature": "public Provider.Service getService(String type, String algorithm)",
                  "description": "Get the service describing this Provider's implementation of the\n specified type of this algorithm or alias. If no such\n implementation exists, this method returns null. If there are two\n matching services, one added to this provider using\n putService() and one added via put(),\n the service added via putService() is returned."
                }
              ]
            },
            {
              "name": "getServices",
              "overloads": [
                {
                  "signature": "public Set<Provider.Service> getServices()",
                  "description": "Get an unmodifiable Set of all services supported by\n this Provider."
                }
              ]
            },
            {
              "name": "putService",
              "overloads": [
                {
                  "signature": "protected void putService(Provider.Service s)",
                  "description": "Add a service. If a service of the same type with the same algorithm\n name exists and it was added using putService(),\n it is replaced by the new service.\n This method also places information about this service\n in the provider's Hashtable values in the format described in the\n Java Cryptography Architecture (JCA) Reference Guide.\n\n Also, if there is a security manager, its\n checkSecurityAccess method is called with the string\n \"putProviderProperty.\"+name, where name is\n the provider name, to see if it's ok to set this provider's property\n values. If the default implementation of checkSecurityAccess\n is used (that is, that method is not overridden), then this results in\n a call to the security manager's checkPermission method with\n a SecurityPermission(\"putProviderProperty.\"+name)\n permission."
                }
              ]
            },
            {
              "name": "removeService",
              "overloads": [
                {
                  "signature": "protected void removeService(Provider.Service s)",
                  "description": "Remove a service previously added using\n putService(). The specified service is removed from\n this provider. It will no longer be returned by\n getService() and its information will be removed\n from this provider's Hashtable.\n\n Also, if there is a security manager, its\n checkSecurityAccess method is called with the string\n \"removeProviderProperty.\"+name, where name is\n the provider name, to see if it's ok to remove this provider's\n properties. If the default implementation of\n checkSecurityAccess is used (that is, that method is not\n overridden), then this results in a call to the security manager's\n checkPermission method with a\n SecurityPermission(\"removeProviderProperty.\"+name)\n permission."
                }
              ]
            }
          ]
        },
        {
          "name": "Provider.Service",
          "methods": [
            {
              "name": "Service",
              "overloads": [
                {
                  "signature": "public Service(Provider provider, String type, String algorithm, String className, List<String> aliases, Map<String,String> attributes)",
                  "description": "Construct a new service."
                }
              ]
            },
            {
              "name": "getType",
              "overloads": [
                {
                  "signature": "public final String getType()",
                  "description": "Get the type of this service. For example, MessageDigest."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Return the name of the algorithm of this service. For example,\n SHA-1."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Return the Provider of this service."
                }
              ]
            },
            {
              "name": "getClassName",
              "overloads": [
                {
                  "signature": "public final String getClassName()",
                  "description": "Return the name of the class implementing this service."
                }
              ]
            },
            {
              "name": "getAttribute",
              "overloads": [
                {
                  "signature": "public final String getAttribute(String name)",
                  "description": "Return the value of the specified attribute or null if this\n attribute is not set for this Service."
                }
              ]
            },
            {
              "name": "newInstance",
              "overloads": [
                {
                  "signature": "public Object newInstance(Object constructorParameter) throws NoSuchAlgorithmException",
                  "description": "Return a new instance of the implementation described by this\n service. The security provider framework uses this method to\n construct implementations. Applications will typically not need\n to call it.\n\n The default implementation uses reflection to invoke the\n standard constructor for this type of service.\n Security providers can override this method to implement\n instantiation in a different way.\n For details and the values of constructorParameter that are\n valid for the various types of services see the\n Java Cryptography Architecture (JCA) Reference Guide."
                }
              ]
            },
            {
              "name": "supportsParameter",
              "overloads": [
                {
                  "signature": "public boolean supportsParameter(Object parameter)",
                  "description": "Test whether this Service can use the specified parameter.\n Returns false if this service cannot use the parameter. Returns\n true if this service can use the parameter, if a fast test is\n infeasible, or if the status is unknown.\n\n The security provider framework uses this method with\n some types of services to quickly exclude non-matching\n implementations for consideration.\n Applications will typically not need to call it.\n\n For details and the values of parameter that are valid for the\n various types of services see the top of this class and the\n Java Cryptography Architecture (JCA) Reference Guide.\n Security providers can override it to implement their own test."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Return a String representation of this service."
                }
              ]
            }
          ]
        },
        {
          "name": "ProviderException",
          "methods": [
            {
              "name": "ProviderException",
              "overloads": [
                {
                  "signature": "public ProviderException()",
                  "description": "Constructs a ProviderException with no detail message. A\n detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public ProviderException(String s)",
                  "description": "Constructs a ProviderException with the specified detail\n message. A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public ProviderException(String message, Throwable cause)",
                  "description": "Creates a ProviderException with the specified\n detail message and cause."
                },
                {
                  "signature": "public ProviderException(Throwable cause)",
                  "description": "Creates a ProviderException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "PublicKey",
          "methods": []
        },
        {
          "name": "SecureClassLoader",
          "methods": [
            {
              "name": "SecureClassLoader",
              "overloads": [
                {
                  "signature": "protected SecureClassLoader(ClassLoader parent)",
                  "description": "Creates a new SecureClassLoader using the specified parent\n class loader for delegation.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader\n method  to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "protected SecureClassLoader()",
                  "description": "Creates a new SecureClassLoader using the default parent class\n loader for delegation.\n\n If there is a security manager, this method first\n calls the security manager's checkCreateClassLoader\n method  to ensure creation of a class loader is allowed."
                },
                {
                  "signature": "protected SecureClassLoader(String name, ClassLoader parent)",
                  "description": "Creates a new SecureClassLoader of the specified name and\n using the specified parent class loader for delegation."
                }
              ]
            },
            {
              "name": "defineClass",
              "overloads": [
                {
                  "signature": "protected final Class<?> defineClass(String name, byte[] b, int off, int len, CodeSource cs)",
                  "description": "Converts an array of bytes into an instance of class Class,\n with an optional CodeSource. Before the\n class can be used it must be resolved.\n \n If a non-null CodeSource is supplied a ProtectionDomain is\n constructed and associated with the class being defined."
                },
                {
                  "signature": "protected final Class<?> defineClass(String name, ByteBuffer b, CodeSource cs)",
                  "description": "Converts a ByteBuffer\n into an instance of class Class, with an optional CodeSource.\n Before the class can be used it must be resolved.\n \n If a non-null CodeSource is supplied a ProtectionDomain is\n constructed and associated with the class being defined."
                }
              ]
            },
            {
              "name": "getPermissions",
              "overloads": [
                {
                  "signature": "protected PermissionCollection getPermissions(CodeSource codesource)",
                  "description": "Returns the permissions for the given CodeSource object.\n \n This method is invoked by the defineClass method which takes\n a CodeSource as an argument when it is constructing the\n ProtectionDomain for the class being defined."
                }
              ]
            }
          ]
        },
        {
          "name": "SecureRandom",
          "methods": [
            {
              "name": "SecureRandom",
              "overloads": [
                {
                  "signature": "public SecureRandom()",
                  "description": "Constructs a secure random number generator (RNG) implementing the\n default random number algorithm.\n\n  This constructor traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the first\n Provider that supports a SecureRandom (RNG) algorithm is returned.\n If none of the Providers support a RNG algorithm,\n then an implementation-specific default is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n  See the SecureRandom section in the \n Java Security Standard Algorithm Names Specification\n for information about standard RNG algorithm names."
                },
                {
                  "signature": "public SecureRandom(byte[] seed)",
                  "description": "Constructs a secure random number generator (RNG) implementing the\n default random number algorithm.\n The SecureRandom instance is seeded with the specified seed bytes.\n\n  This constructor traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the first\n Provider that supports a SecureRandom (RNG) algorithm is returned.\n If none of the Providers support a RNG algorithm,\n then an implementation-specific default is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method.\n\n  See the SecureRandom section in the \n Java Security Standard Algorithm Names Specification\n for information about standard RNG algorithm names."
                },
                {
                  "signature": "protected SecureRandom(SecureRandomSpi secureRandomSpi, Provider provider)",
                  "description": "Creates a SecureRandom object."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static SecureRandom getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static SecureRandom getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.\n\n  A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static SecureRandom getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.\n\n  A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                },
                {
                  "signature": "public static SecureRandom getInstance(String algorithm, SecureRandomParameters params) throws NoSuchAlgorithmException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm and supports the specified\n SecureRandomParameters request.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the first\n Provider that supports the specified algorithm and the specified\n SecureRandomParameters is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static SecureRandom getInstance(String algorithm, SecureRandomParameters params, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm and supports the specified\n SecureRandomParameters request.\n\n  A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static SecureRandom getInstance(String algorithm, SecureRandomParameters params, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm and supports the specified\n SecureRandomParameters request.\n\n  A new SecureRandom object encapsulating the\n SecureRandomSpi implementation from the specified\n Provider object is returned.  Note that the specified\n Provider object does not have to be registered in the\n provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this SecureRandom object."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public String getAlgorithm()",
                  "description": "Returns the name of the algorithm implemented by this\n SecureRandom object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a Human-readable string representation of this\n SecureRandom."
                }
              ]
            },
            {
              "name": "getParameters",
              "overloads": [
                {
                  "signature": "public SecureRandomParameters getParameters()",
                  "description": "Returns the effective SecureRandomParameters for this\n SecureRandom instance.\n \n The returned value can be different from the\n SecureRandomParameters object passed into a getInstance\n method, but it cannot change during the lifetime of this\n SecureRandom object.\n \n A caller can use the returned value to find out what features this\n SecureRandom supports."
                }
              ]
            },
            {
              "name": "setSeed",
              "overloads": [
                {
                  "signature": "public void setSeed(byte[] seed)",
                  "description": "Reseeds this random object with the given seed. The seed supplements,\n rather than replaces, the existing seed. Thus, repeated calls are\n guaranteed never to reduce randomness.\n \n A PRNG SecureRandom will not seed itself automatically if\n setSeed is called before any nextBytes or reseed\n calls. The caller should make sure that the seed argument\n contains enough entropy for the security of this SecureRandom."
                },
                {
                  "signature": "public void setSeed(long seed)",
                  "description": "Reseeds this random object, using the eight bytes contained\n in the given long seed. The given seed supplements,\n rather than replaces, the existing seed. Thus, repeated calls\n are guaranteed never to reduce randomness.\n\n This method is defined for compatibility with\n java.util.Random."
                }
              ]
            },
            {
              "name": "nextBytes",
              "overloads": [
                {
                  "signature": "public void nextBytes(byte[] bytes)",
                  "description": "Generates a user-specified number of random bytes."
                },
                {
                  "signature": "public void nextBytes(byte[] bytes, SecureRandomParameters params)",
                  "description": "Generates a user-specified number of random bytes with\n additional parameters."
                }
              ]
            },
            {
              "name": "next",
              "overloads": [
                {
                  "signature": "protected final int next(int numBits)",
                  "description": "Generates an integer containing the user-specified number of\n pseudo-random bits (right justified, with leading zeros).  This\n method overrides a java.util.Random method, and serves\n to provide a source of random bits to all of the methods inherited\n from that class (for example, nextInt,\n nextLong, and nextFloat)."
                }
              ]
            },
            {
              "name": "getSeed",
              "overloads": [
                {
                  "signature": "public static byte[] getSeed(int numBytes)",
                  "description": "Returns the given number of seed bytes, computed using the seed\n generation algorithm that this class uses to seed itself.  This\n call may be used to seed other random number generators.\n\n This method is only included for backwards compatibility.\n The caller is encouraged to use one of the alternative\n getInstance methods to obtain a SecureRandom object, and\n then call the generateSeed method to obtain seed bytes\n from that object."
                }
              ]
            },
            {
              "name": "generateSeed",
              "overloads": [
                {
                  "signature": "public byte[] generateSeed(int numBytes)",
                  "description": "Returns the given number of seed bytes, computed using the seed\n generation algorithm that this class uses to seed itself.  This\n call may be used to seed other random number generators."
                }
              ]
            },
            {
              "name": "getInstanceStrong",
              "overloads": [
                {
                  "signature": "public static SecureRandom getInstanceStrong() throws NoSuchAlgorithmException",
                  "description": "Returns a SecureRandom object that was selected by using\n the algorithms/providers specified in the \n securerandom.strongAlgorithms Security property.\n \n Some situations require strong random values, such as when\n creating high-value/long-lived secrets like RSA public/private\n keys.  To help guide applications in selecting a suitable strong\n SecureRandom implementation, Java distributions\n include a list of known strong SecureRandom\n implementations in the securerandom.strongAlgorithms\n Security property.\n \n Every implementation of the Java platform is required to\n support at least one strong SecureRandom implementation."
                }
              ]
            },
            {
              "name": "reseed",
              "overloads": [
                {
                  "signature": "public void reseed()",
                  "description": "Reseeds this SecureRandom with entropy input read from its\n entropy source."
                },
                {
                  "signature": "public void reseed(SecureRandomParameters params)",
                  "description": "Reseeds this SecureRandom with entropy input read from its\n entropy source with additional parameters.\n \n Note that entropy is obtained from an entropy source. While\n some data in params may contain entropy, its main usage is to\n provide diversity."
                }
              ]
            }
          ]
        },
        {
          "name": "SecureRandomParameters",
          "methods": []
        },
        {
          "name": "SecureRandomSpi",
          "methods": [
            {
              "name": "SecureRandomSpi",
              "overloads": [
                {
                  "signature": "public SecureRandomSpi()",
                  "description": "Constructor without a parameter."
                },
                {
                  "signature": "protected SecureRandomSpi(SecureRandomParameters params)",
                  "description": "Constructor with a parameter."
                }
              ]
            },
            {
              "name": "engineSetSeed",
              "overloads": [
                {
                  "signature": "protected abstract void engineSetSeed(byte[] seed)",
                  "description": "Reseeds this random object with the given seed. The seed supplements,\n rather than replaces, the existing seed. Thus, repeated calls\n are guaranteed never to reduce randomness."
                }
              ]
            },
            {
              "name": "engineNextBytes",
              "overloads": [
                {
                  "signature": "protected abstract void engineNextBytes(byte[] bytes)",
                  "description": "Generates a user-specified number of random bytes.\n \n Some random number generators can only generate a limited amount\n of random bytes per invocation. If the size of bytes\n is greater than this limit, the implementation should invoke\n its generation process multiple times to completely fill the\n buffer before returning from this method."
                },
                {
                  "signature": "protected void engineNextBytes(byte[] bytes, SecureRandomParameters params)",
                  "description": "Generates a user-specified number of random bytes with\n additional parameters.\n \n Some random number generators can only generate a limited amount\n of random bytes per invocation. If the size of bytes\n is greater than this limit, the implementation should invoke\n its generation process multiple times to completely fill the\n buffer before returning from this method."
                }
              ]
            },
            {
              "name": "engineGenerateSeed",
              "overloads": [
                {
                  "signature": "protected abstract byte[] engineGenerateSeed(int numBytes)",
                  "description": "Returns the given number of seed bytes.  This call may be used to\n seed other random number generators."
                }
              ]
            },
            {
              "name": "engineReseed",
              "overloads": [
                {
                  "signature": "protected void engineReseed(SecureRandomParameters params)",
                  "description": "Reseeds this random object with entropy input read from its\n entropy source with additional parameters.\n \n If this method is called by SecureRandom.reseed(),\n params will be null.\n \n Do not override this method if the implementation does not\n support reseeding."
                }
              ]
            },
            {
              "name": "engineGetParameters",
              "overloads": [
                {
                  "signature": "protected SecureRandomParameters engineGetParameters()",
                  "description": "Returns the effective SecureRandomParameters for this\n SecureRandom instance."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a Human-readable string representation of this\n SecureRandom."
                }
              ]
            }
          ]
        },
        {
          "name": "Security",
          "methods": [
            {
              "name": "getAlgorithmProperty",
              "overloads": [
                {
                  "signature": "@Deprecated public static String getAlgorithmProperty(String algName, String propName)",
                  "description": "Gets a specified property for an algorithm. The algorithm name\n should be a standard name. See the \n Java Security Standard Algorithm Names Specification\n for information about standard algorithm names.\n\n One possible use is by specialized algorithm parsers, which may map\n classes to algorithms which they understand (much like Key parsers\n do).",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "insertProviderAt",
              "overloads": [
                {
                  "signature": "public static int insertProviderAt(Provider provider, int position)",
                  "description": "Adds a new provider, at a specified position. The position is\n the preference order in which providers are searched for\n requested algorithms.  The position is 1-based, that is,\n 1 is most preferred, followed by 2, and so on.\n\n If the given provider is installed at the requested position,\n the provider that used to be at that position, and all providers\n with a position greater than position, are shifted up\n one position (towards the end of the list of installed providers).\n\n A provider cannot be added if it is already installed.\n\n If there is a security manager, the\n SecurityManager.checkSecurityAccess(java.lang.String) method is called\n with the \"insertProvider\" permission target name to see if\n it's ok to add a new provider. If this permission check is denied,\n checkSecurityAccess is called again with the\n \"insertProvider.\"+provider.getName() permission target name. If\n both checks are denied, a SecurityException is thrown."
                }
              ]
            },
            {
              "name": "addProvider",
              "overloads": [
                {
                  "signature": "public static int addProvider(Provider provider)",
                  "description": "Adds a provider to the next position available.\n\n If there is a security manager, the\n SecurityManager.checkSecurityAccess(java.lang.String) method is called\n with the \"insertProvider\" permission target name to see if\n it's ok to add a new provider. If this permission check is denied,\n checkSecurityAccess is called again with the\n \"insertProvider.\"+provider.getName() permission target name. If\n both checks are denied, a SecurityException is thrown."
                }
              ]
            },
            {
              "name": "removeProvider",
              "overloads": [
                {
                  "signature": "public static void removeProvider(String name)",
                  "description": "Removes the provider with the specified name.\n\n When the specified provider is removed, all providers located\n at a position greater than where the specified provider was are shifted\n down one position (towards the head of the list of installed\n providers).\n\n This method returns silently if the provider is not installed or\n if name is null.\n\n First, if there is a security manager, its\n checkSecurityAccess\n method is called with the string \"removeProvider.\"+name\n to see if it's ok to remove the provider.\n If the default implementation of checkSecurityAccess\n is used (i.e., that method is not overridden), then this will result in\n a call to the security manager's checkPermission method\n with a SecurityPermission(\"removeProvider.\"+name)\n permission."
                }
              ]
            },
            {
              "name": "getProviders",
              "overloads": [
                {
                  "signature": "public static Provider[] getProviders()",
                  "description": "Returns an array containing all the installed providers. The order of\n the providers in the array is their preference order."
                },
                {
                  "signature": "public static Provider[] getProviders(String filter)",
                  "description": "Returns an array containing all installed providers that satisfy the\n specified selection criterion, or null if no such providers have been\n installed. The returned providers are ordered\n according to their\n preference order.\n\n  A cryptographic service is always associated with a particular\n algorithm or type. For example, a digital signature service is\n always associated with a particular algorithm (e.g., DSA),\n and a CertificateFactory service is always associated with\n a particular certificate type (e.g., X.509).\n\n The selection criterion must be specified in one of the following two\n formats:\n \n  <crypto_service>.<algorithm_or_type>\n  The cryptographic service name must not contain any dots.\n  A\n provider satisfies the specified selection criterion iff the provider\n implements the\n specified algorithm or type for the specified cryptographic service.\n  For example, \"CertificateFactory.X.509\"\n would be satisfied by any provider that supplied\n a CertificateFactory implementation for X.509 certificates.\n  <crypto_service>.<algorithm_or_type>\n <attribute_name>:<attribute_value>\n  The cryptographic service name must not contain any dots. There\n must be one or more space characters between the\n <algorithm_or_type> and the\n <attribute_name>.\n   A provider satisfies this selection criterion iff the\n provider implements the specified algorithm or type for the specified\n cryptographic service and its implementation meets the\n constraint expressed by the specified attribute name/value pair.\n  For example, \"Signature.SHA1withDSA KeySize:1024\" would be\n satisfied by any provider that implemented\n the SHA1withDSA signature algorithm with a keysize of 1024 (or larger).\n\n \n\n  See the \n Java Security Standard Algorithm Names Specification\n for information about standard cryptographic service names, standard\n algorithm names and standard attribute names."
                },
                {
                  "signature": "public static Provider[] getProviders(Map<String,String> filter)",
                  "description": "Returns an array containing all installed providers that satisfy the\n specified selection criteria, or null if no such providers have been\n installed. The returned providers are ordered\n according to their\n preference order.\n\n The selection criteria are represented by a map.\n Each map entry represents a selection criterion.\n A provider is selected iff it satisfies all selection\n criteria. The key for any entry in such a map must be in one of the\n following two formats:\n \n  <crypto_service>.<algorithm_or_type>\n  The cryptographic service name must not contain any dots.\n  The value associated with the key must be an empty string.\n  A provider\n satisfies this selection criterion iff the provider implements the\n specified algorithm or type for the specified cryptographic service.\n   <crypto_service>.\n <algorithm_or_type> <attribute_name>\n  The cryptographic service name must not contain any dots. There\n must be one or more space characters between the\n <algorithm_or_type>\n and the <attribute_name>.\n  The value associated with the key must be a non-empty string.\n A provider satisfies this selection criterion iff the\n provider implements the specified algorithm or type for the specified\n cryptographic service and its implementation meets the\n constraint expressed by the specified attribute name/value pair.\n \n\n  See the \n Java Security Standard Algorithm Names Specification\n for information about standard cryptographic service names, standard\n algorithm names and standard attribute names."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public static Provider getProvider(String name)",
                  "description": "Returns the provider installed with the specified name, if\n any. Returns null if no provider with the specified name is\n installed or if name is null."
                }
              ]
            },
            {
              "name": "getProperty",
              "overloads": [
                {
                  "signature": "public static String getProperty(String key)",
                  "description": "Gets a security property value.\n\n First, if there is a security manager, its\n checkPermission  method is called with a\n java.security.SecurityPermission(\"getProperty.\"+key)\n permission to see if it's ok to retrieve the specified\n security property value.."
                }
              ]
            },
            {
              "name": "setProperty",
              "overloads": [
                {
                  "signature": "public static void setProperty(String key, String datum)",
                  "description": "Sets a security property value.\n\n First, if there is a security manager, its\n checkPermission method is called with a\n java.security.SecurityPermission(\"setProperty.\"+key)\n permission to see if it's ok to set the specified\n security property value."
                }
              ]
            },
            {
              "name": "getAlgorithms",
              "overloads": [
                {
                  "signature": "public static Set<String> getAlgorithms(String serviceName)",
                  "description": "Returns a Set of Strings containing the names of all available\n algorithms or types for the specified Java cryptographic service\n (e.g., Signature, MessageDigest, Cipher, Mac, KeyStore). Returns\n an empty Set if there is no provider that supports the\n specified service or if serviceName is null. For a complete list\n of Java cryptographic services, please see the\n Java Cryptography Architecture (JCA) Reference Guide.\n Note: the returned set is immutable."
                }
              ]
            }
          ]
        },
        {
          "name": "SecurityPermission",
          "methods": [
            {
              "name": "SecurityPermission",
              "overloads": [
                {
                  "signature": "public SecurityPermission(String name)",
                  "description": "Creates a new SecurityPermission with the specified name.\n The name is the symbolic name of the SecurityPermission. An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match."
                },
                {
                  "signature": "public SecurityPermission(String name, String actions)",
                  "description": "Creates a new SecurityPermission object with the specified name.\n The name is the symbolic name of the SecurityPermission, and the\n actions String is currently unused and should be null."
                }
              ]
            }
          ]
        },
        {
          "name": "Signature",
          "methods": [
            {
              "name": "Signature",
              "overloads": [
                {
                  "signature": "protected Signature(String algorithm)",
                  "description": "Creates a Signature object for the specified algorithm."
                }
              ]
            },
            {
              "name": "getInstance",
              "overloads": [
                {
                  "signature": "public static Signature getInstance(String algorithm) throws NoSuchAlgorithmException",
                  "description": "Returns a Signature object that implements the specified signature\n algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new Signature object encapsulating the\n SignatureSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static Signature getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException",
                  "description": "Returns a Signature object that implements the specified signature\n algorithm.\n\n  A new Signature object encapsulating the\n SignatureSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."
                },
                {
                  "signature": "public static Signature getInstance(String algorithm, Provider provider) throws NoSuchAlgorithmException",
                  "description": "Returns a Signature object that implements the specified\n signature algorithm.\n\n  A new Signature object encapsulating the\n SignatureSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."
                }
              ]
            },
            {
              "name": "getProvider",
              "overloads": [
                {
                  "signature": "public final Provider getProvider()",
                  "description": "Returns the provider of this signature object."
                }
              ]
            },
            {
              "name": "initVerify",
              "overloads": [
                {
                  "signature": "public final void initVerify(PublicKey publicKey) throws InvalidKeyException",
                  "description": "Initializes this object for verification. If this method is called\n again with a different argument, it negates the effect\n of this call."
                },
                {
                  "signature": "public final void initVerify(Certificate certificate) throws InvalidKeyException",
                  "description": "Initializes this object for verification, using the public key from\n the given certificate.\n If the certificate is of type X.509 and has a key usage\n extension field marked as critical, and the value of the key usage\n extension field implies that the public key in\n the certificate and its corresponding private key are not\n supposed to be used for digital signatures, an\n InvalidKeyException is thrown."
                }
              ]
            },
            {
              "name": "initSign",
              "overloads": [
                {
                  "signature": "public final void initSign(PrivateKey privateKey) throws InvalidKeyException",
                  "description": "Initialize this object for signing. If this method is called\n again with a different argument, it negates the effect\n of this call."
                },
                {
                  "signature": "public final void initSign(PrivateKey privateKey, SecureRandom random) throws InvalidKeyException",
                  "description": "Initialize this object for signing. If this method is called\n again with a different argument, it negates the effect\n of this call."
                }
              ]
            },
            {
              "name": "sign",
              "overloads": [
                {
                  "signature": "public final byte[] sign() throws SignatureException",
                  "description": "Returns the signature bytes of all the data updated.\n The format of the signature depends on the underlying\n signature scheme.\n\n A call to this method resets this signature object to the state\n it was in when previously initialized for signing via a\n call to initSign(PrivateKey). That is, the object is\n reset and available to generate another signature from the same\n signer, if desired, via new calls to update and\n sign."
                },
                {
                  "signature": "public final int sign(byte[] outbuf, int offset, int len) throws SignatureException",
                  "description": "Finishes the signature operation and stores the resulting signature\n bytes in the provided buffer outbuf, starting at\n offset.\n The format of the signature depends on the underlying\n signature scheme.\n\n This signature object is reset to its initial state (the state it\n was in after a call to one of the initSign methods) and\n can be reused to generate further signatures with the same private key."
                }
              ]
            },
            {
              "name": "verify",
              "overloads": [
                {
                  "signature": "public final boolean verify(byte[] signature) throws SignatureException",
                  "description": "Verifies the passed-in signature.\n\n A call to this method resets this signature object to the state\n it was in when previously initialized for verification via a\n call to initVerify(PublicKey). That is, the object is\n reset and available to verify another signature from the identity\n whose public key was specified in the call to initVerify."
                },
                {
                  "signature": "public final boolean verify(byte[] signature, int offset, int length) throws SignatureException",
                  "description": "Verifies the passed-in signature in the specified array\n of bytes, starting at the specified offset.\n\n A call to this method resets this signature object to the state\n it was in when previously initialized for verification via a\n call to initVerify(PublicKey). That is, the object is\n reset and available to verify another signature from the identity\n whose public key was specified in the call to initVerify."
                }
              ]
            },
            {
              "name": "update",
              "overloads": [
                {
                  "signature": "public final void update(byte b) throws SignatureException",
                  "description": "Updates the data to be signed or verified by a byte."
                },
                {
                  "signature": "public final void update(byte[] data) throws SignatureException",
                  "description": "Updates the data to be signed or verified, using the specified\n array of bytes."
                },
                {
                  "signature": "public final void update(byte[] data, int off, int len) throws SignatureException",
                  "description": "Updates the data to be signed or verified, using the specified\n array of bytes, starting at the specified offset."
                },
                {
                  "signature": "public final void update(ByteBuffer data) throws SignatureException",
                  "description": "Updates the data to be signed or verified using the specified\n ByteBuffer. Processes the data.remaining() bytes\n starting at data.position().\n Upon return, the buffer's position will be equal to its limit;\n its limit will not have changed."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public final String getAlgorithm()",
                  "description": "Returns the name of the algorithm for this signature object."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string representation of this signature object,\n providing information that includes the state of the object\n and the name of the algorithm used."
                }
              ]
            },
            {
              "name": "setParameter",
              "overloads": [
                {
                  "signature": "@Deprecated public final void setParameter(String param, Object value) throws InvalidParameterException",
                  "description": "Sets the specified algorithm parameter to the specified value.\n This method supplies a general-purpose mechanism through\n which it is possible to set the various parameters of this object.\n A parameter may be any settable parameter for the algorithm, such as\n a parameter size, or a source of random bits for signature generation\n (if appropriate), or an indication of whether or not to perform\n a specific but optional computation. A uniform algorithm-specific\n naming scheme for each parameter is desirable but left unspecified\n at this time.",
                  "deprecated": true
                },
                {
                  "signature": "public final void setParameter(AlgorithmParameterSpec params) throws InvalidAlgorithmParameterException",
                  "description": "Initializes this signature engine with the specified parameter set."
                }
              ]
            },
            {
              "name": "getParameters",
              "overloads": [
                {
                  "signature": "public final AlgorithmParameters getParameters()",
                  "description": "Returns the parameters used with this signature object.\n\n  If this signature has been initialized with parameters\n (by calling setParameter(AlgorithmParameterSpec) or\n setParameter(String, Object)) and the underlying signature\n implementation supports returning the parameters as\n AlgorithmParameters, this method returns the same parameters.\n If the parameters were not set, this method may return a combination\n of default and randomly generated parameter values if the\n underlying signature implementation supports it and can successfully\n generate them. Otherwise, null is returned."
                }
              ]
            },
            {
              "name": "getParameter",
              "overloads": [
                {
                  "signature": "@Deprecated public final Object getParameter(String param) throws InvalidParameterException",
                  "description": "Gets the value of the specified algorithm parameter. This method\n supplies a general-purpose mechanism through which it is possible to\n get the various parameters of this object. A parameter may be any\n settable parameter for the algorithm, such as a parameter size, or\n a source of random bits for signature generation (if appropriate),\n or an indication of whether or not to perform a specific but optional\n computation. A uniform algorithm-specific naming scheme for each\n parameter is desirable but left unspecified at this time.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone() throws CloneNotSupportedException",
                  "description": "Returns a clone if the implementation is cloneable."
                }
              ]
            }
          ]
        },
        {
          "name": "SignatureException",
          "methods": [
            {
              "name": "SignatureException",
              "overloads": [
                {
                  "signature": "public SignatureException()",
                  "description": "Constructs a SignatureException with no detail message. A\n detail message is a String that describes this particular\n exception."
                },
                {
                  "signature": "public SignatureException(String msg)",
                  "description": "Constructs a SignatureException with the specified detail\n message.  A detail message is a String that describes this\n particular exception."
                },
                {
                  "signature": "public SignatureException(String message, Throwable cause)",
                  "description": "Creates a SignatureException with the specified\n detail message and cause."
                },
                {
                  "signature": "public SignatureException(Throwable cause)",
                  "description": "Creates a SignatureException with the specified cause\n and a detail message of (cause==null ? null : cause.toString())\n (which typically contains the class and detail message of\n cause)."
                }
              ]
            }
          ]
        },
        {
          "name": "SignatureSpi",
          "methods": [
            {
              "name": "SignatureSpi",
              "overloads": [
                {
                  "signature": "public SignatureSpi()",
                  "description": "Constructor for subclasses to call."
                }
              ]
            },
            {
              "name": "engineInitVerify",
              "overloads": [
                {
                  "signature": "protected abstract void engineInitVerify(PublicKey publicKey) throws InvalidKeyException",
                  "description": "Initializes this signature object with the specified\n public key for verification operations."
                }
              ]
            },
            {
              "name": "engineInitSign",
              "overloads": [
                {
                  "signature": "protected abstract void engineInitSign(PrivateKey privateKey) throws InvalidKeyException",
                  "description": "Initializes this signature object with the specified\n private key for signing operations."
                },
                {
                  "signature": "protected void engineInitSign(PrivateKey privateKey, SecureRandom random) throws InvalidKeyException",
                  "description": "Initializes this signature object with the specified\n private key and source of randomness for signing operations.\n\n This concrete method has been added to this previously-defined\n abstract class. (For backwards compatibility, it cannot be abstract.)"
                }
              ]
            },
            {
              "name": "engineUpdate",
              "overloads": [
                {
                  "signature": "protected abstract void engineUpdate(byte b) throws SignatureException",
                  "description": "Updates the data to be signed or verified\n using the specified byte."
                },
                {
                  "signature": "protected abstract void engineUpdate(byte[] b, int off, int len) throws SignatureException",
                  "description": "Updates the data to be signed or verified, using the\n specified array of bytes, starting at the specified offset."
                },
                {
                  "signature": "protected void engineUpdate(ByteBuffer input)",
                  "description": "Updates the data to be signed or verified using the specified\n ByteBuffer. Processes the data.remaining() bytes\n starting at data.position().\n Upon return, the buffer's position will be equal to its limit;\n its limit will not have changed."
                }
              ]
            },
            {
              "name": "engineSign",
              "overloads": [
                {
                  "signature": "protected abstract byte[] engineSign() throws SignatureException",
                  "description": "Returns the signature bytes of all the data\n updated so far.\n The format of the signature depends on the underlying\n signature scheme."
                },
                {
                  "signature": "protected int engineSign(byte[] outbuf, int offset, int len) throws SignatureException",
                  "description": "Finishes this signature operation and stores the resulting signature\n bytes in the provided buffer outbuf, starting at\n offset.\n The format of the signature depends on the underlying\n signature scheme.\n\n The signature implementation is reset to its initial state\n (the state it was in after a call to one of the\n engineInitSign methods)\n and can be reused to generate further signatures with the same private\n key.\n\n This method should be abstract, but we leave it concrete for\n binary compatibility.  Knowledgeable providers should override this\n method."
                }
              ]
            },
            {
              "name": "engineVerify",
              "overloads": [
                {
                  "signature": "protected abstract boolean engineVerify(byte[] sigBytes) throws SignatureException",
                  "description": "Verifies the passed-in signature."
                },
                {
                  "signature": "protected boolean engineVerify(byte[] sigBytes, int offset, int length) throws SignatureException",
                  "description": "Verifies the passed-in signature in the specified array\n of bytes, starting at the specified offset.\n\n  Note: Subclasses should overwrite the default implementation."
                }
              ]
            },
            {
              "name": "engineSetParameter",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract void engineSetParameter(String param, Object value) throws InvalidParameterException",
                  "description": "Sets the specified algorithm parameter to the specified\n value. This method supplies a general-purpose mechanism through\n which it is possible to set the various parameters of this object.\n A parameter may be any settable parameter for the algorithm, such as\n a parameter size, or a source of random bits for signature generation\n (if appropriate), or an indication of whether or not to perform\n a specific but optional computation. A uniform algorithm-specific\n naming scheme for each parameter is desirable but left unspecified\n at this time.",
                  "deprecated": true
                },
                {
                  "signature": "protected void engineSetParameter(AlgorithmParameterSpec params) throws InvalidAlgorithmParameterException",
                  "description": "This method is overridden by providers to initialize\n this signature engine with the specified parameter set."
                }
              ]
            },
            {
              "name": "engineGetParameters",
              "overloads": [
                {
                  "signature": "protected AlgorithmParameters engineGetParameters()",
                  "description": "This method is overridden by providers to return the parameters\n used with this signature engine.\n\n  If this signature engine has been initialized with parameters\n (by calling engineSetParameter(AlgorithmParameterSpec) or\n engineSetParameter(String, Object)) and the underlying signature\n implementation supports returning the parameters as\n AlgorithmParameters, this method returns the same parameters.\n If the parameters were not set, this method may return a combination\n of default and randomly generated parameter values if the\n underlying signature implementation supports it and can successfully\n generate them. Otherwise, null is returned."
                }
              ]
            },
            {
              "name": "engineGetParameter",
              "overloads": [
                {
                  "signature": "@Deprecated protected abstract Object engineGetParameter(String param) throws InvalidParameterException",
                  "description": "Gets the value of the specified algorithm parameter.\n This method supplies a general-purpose mechanism through which it\n is possible to get the various parameters of this object. A parameter\n may be any settable parameter for the algorithm, such as a parameter\n size, or  a source of random bits for signature generation (if\n appropriate), or an indication of whether or not to perform a\n specific but optional computation. A uniform algorithm-specific\n naming scheme for each parameter is desirable but left unspecified\n at this time.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "clone",
              "overloads": [
                {
                  "signature": "public Object clone() throws CloneNotSupportedException",
                  "description": "Returns a clone if the implementation is cloneable."
                }
              ]
            }
          ]
        },
        {
          "name": "SignedObject",
          "methods": [
            {
              "name": "SignedObject",
              "overloads": [
                {
                  "signature": "public SignedObject(Serializable object, PrivateKey signingKey, Signature signingEngine) throws IOException, InvalidKeyException, SignatureException",
                  "description": "Constructs a SignedObject from any Serializable object.\n The given object is signed with the given signing key, using the\n designated signature engine."
                }
              ]
            },
            {
              "name": "getObject",
              "overloads": [
                {
                  "signature": "public Object getObject() throws IOException, ClassNotFoundException",
                  "description": "Retrieves the encapsulated object.\n The encapsulated object is de-serialized before it is returned."
                }
              ]
            },
            {
              "name": "getSignature",
              "overloads": [
                {
                  "signature": "public byte[] getSignature()",
                  "description": "Retrieves the signature on the signed object, in the form of a\n byte array."
                }
              ]
            },
            {
              "name": "getAlgorithm",
              "overloads": [
                {
                  "signature": "public String getAlgorithm()",
                  "description": "Retrieves the name of the signature algorithm."
                }
              ]
            },
            {
              "name": "verify",
              "overloads": [
                {
                  "signature": "public boolean verify(PublicKey verificationKey, Signature verificationEngine) throws InvalidKeyException, SignatureException",
                  "description": "Verifies that the signature in this SignedObject is the valid\n signature for the object stored inside, with the given\n verification key, using the designated verification engine."
                }
              ]
            }
          ]
        },
        {
          "name": "Signer",
          "methods": [
            {
              "name": "Signer",
              "overloads": [
                {
                  "signature": "protected Signer()",
                  "description": "Creates a signer. This constructor should only be used for\n serialization.",
                  "deprecated": true
                },
                {
                  "signature": "public Signer(String name)",
                  "description": "Creates a signer with the specified identity name.",
                  "deprecated": true
                },
                {
                  "signature": "public Signer(String name, IdentityScope scope) throws KeyManagementException",
                  "description": "Creates a signer with the specified identity name and scope.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "getPrivateKey",
              "overloads": [
                {
                  "signature": "public PrivateKey getPrivateKey()",
                  "description": "Returns this signer's private key.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"getSignerPrivateKey\"\n as its argument to see if it's ok to return the private key.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "setKeyPair",
              "overloads": [
                {
                  "signature": "public final void setKeyPair(KeyPair pair) throws InvalidParameterException, KeyException",
                  "description": "Sets the key pair (public key and private key) for this signer.\n\n First, if there is a security manager, its checkSecurityAccess\n method is called with \"setSignerKeyPair\"\n as its argument to see if it's ok to set the key pair.",
                  "deprecated": true
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string of information about the signer.",
                  "deprecated": true
                }
              ]
            }
          ]
        },
        {
          "name": "Timestamp",
          "methods": [
            {
              "name": "Timestamp",
              "overloads": [
                {
                  "signature": "public Timestamp(Date timestamp, CertPath signerCertPath)",
                  "description": "Constructs a Timestamp."
                }
              ]
            },
            {
              "name": "getTimestamp",
              "overloads": [
                {
                  "signature": "public Date getTimestamp()",
                  "description": "Returns the date and time when the timestamp was generated."
                }
              ]
            },
            {
              "name": "getSignerCertPath",
              "overloads": [
                {
                  "signature": "public CertPath getSignerCertPath()",
                  "description": "Returns the certificate path for the Timestamping Authority."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this timestamp.\n The hash code is generated using the date and time of the timestamp\n and the TSA's certificate path."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Tests for equality between the specified object and this\n timestamp. Two timestamps are considered equal if the date and time of\n their timestamp's and their signer's certificate paths are equal."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this timestamp."
                }
              ]
            }
          ]
        },
        {
          "name": "UnrecoverableEntryException",
          "methods": [
            {
              "name": "UnrecoverableEntryException",
              "overloads": [
                {
                  "signature": "public UnrecoverableEntryException()",
                  "description": "Constructs an UnrecoverableEntryException with no detail message."
                },
                {
                  "signature": "public UnrecoverableEntryException(String msg)",
                  "description": "Constructs an UnrecoverableEntryException with the specified detail\n message, which provides more information about why this exception\n has been thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "UnrecoverableKeyException",
          "methods": [
            {
              "name": "UnrecoverableKeyException",
              "overloads": [
                {
                  "signature": "public UnrecoverableKeyException()",
                  "description": "Constructs an UnrecoverableKeyException with no detail message."
                },
                {
                  "signature": "public UnrecoverableKeyException(String msg)",
                  "description": "Constructs an UnrecoverableKeyException with the specified detail\n message, which provides more information about why this exception\n has been thrown."
                }
              ]
            }
          ]
        },
        {
          "name": "UnresolvedPermission",
          "methods": [
            {
              "name": "UnresolvedPermission",
              "overloads": [
                {
                  "signature": "public UnresolvedPermission(String type, String name, String actions, Certificate[] certs)",
                  "description": "Creates a new UnresolvedPermission containing the permission\n information needed later to actually create a Permission of the\n specified class, when the permission is resolved."
                }
              ]
            },
            {
              "name": "implies",
              "overloads": [
                {
                  "signature": "public boolean implies(Permission p)",
                  "description": "This method always returns false for unresolved permissions.\n That is, an UnresolvedPermission is never considered to\n imply another permission."
                }
              ]
            },
            {
              "name": "equals",
              "overloads": [
                {
                  "signature": "public boolean equals(Object obj)",
                  "description": "Checks two UnresolvedPermission objects for equality.\n Checks that obj is an UnresolvedPermission, and has\n the same type (class) name, permission name, actions, and\n certificates as this object.\n\n  To determine certificate equality, this method only compares\n actual signer certificates.  Supporting certificate chains\n are not taken into consideration by this method."
                }
              ]
            },
            {
              "name": "hashCode",
              "overloads": [
                {
                  "signature": "public int hashCode()",
                  "description": "Returns the hash code value for this object."
                }
              ]
            },
            {
              "name": "getActions",
              "overloads": [
                {
                  "signature": "public String getActions()",
                  "description": "Returns the canonical string representation of the actions,\n which currently is the empty string \"\", since there are no actions for\n an UnresolvedPermission. That is, the actions for the\n permission that will be created when this UnresolvedPermission\n is resolved may be non-null, but an UnresolvedPermission\n itself is never considered to have any actions."
                }
              ]
            },
            {
              "name": "getUnresolvedType",
              "overloads": [
                {
                  "signature": "public String getUnresolvedType()",
                  "description": "Get the type (class name) of the underlying permission that\n has not been resolved."
                }
              ]
            },
            {
              "name": "getUnresolvedName",
              "overloads": [
                {
                  "signature": "public String getUnresolvedName()",
                  "description": "Get the target name of the underlying permission that\n has not been resolved."
                }
              ]
            },
            {
              "name": "getUnresolvedActions",
              "overloads": [
                {
                  "signature": "public String getUnresolvedActions()",
                  "description": "Get the actions for the underlying permission that\n has not been resolved."
                }
              ]
            },
            {
              "name": "getUnresolvedCerts",
              "overloads": [
                {
                  "signature": "public Certificate[] getUnresolvedCerts()",
                  "description": "Get the signer certificates (without any supporting chain)\n for the underlying permission that has not been resolved."
                }
              ]
            },
            {
              "name": "toString",
              "overloads": [
                {
                  "signature": "public String toString()",
                  "description": "Returns a string describing this UnresolvedPermission.  The convention\n is to specify the class name, the permission name, and the actions, in\n the following format: '(unresolved \"ClassName\" \"name\" \"actions\")'."
                }
              ]
            },
            {
              "name": "newPermissionCollection",
              "overloads": [
                {
                  "signature": "public PermissionCollection newPermissionCollection()",
                  "description": "Returns a new PermissionCollection object for storing\n UnresolvedPermission  objects."
                }
              ]
            }
          ]
        },
        {
          "name": "URIParameter",
          "methods": [
            {
              "name": "URIParameter",
              "overloads": [
                {
                  "signature": "public URIParameter(URI uri)",
                  "description": "Constructs a URIParameter with the URI pointing to\n data intended for an SPI implementation."
                }
              ]
            },
            {
              "name": "getURI",
              "overloads": [
                {
                  "signature": "public URI getURI()",
                  "description": "Returns the URI."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}